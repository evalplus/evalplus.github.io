{"date": "2024-10-19 16:27", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 76.26393608564656, "dps_norm": 75.16850711244093, "pass@1": 83.71186440677967}, "eval": {"HumanEval/9": {"dps": 63.09148264984227, "dps_norm": 55.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')  # Initialize with negative infinity\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')  # Initialize with negative infinity\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')  # Initialize with negative infinity\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')  # Initialize with negative infinity\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')  # Initialize with negative infinity\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')  # Initialize with negative infinity\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    current_max = numbers[0]\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}]}, "HumanEval/4": {"dps": 90.75949367088607, "dps_norm": 96.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list to avoid ZeroDivisionError\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    n = len(numbers)\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list to avoid ZeroDivisionError\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad\nnumbers = [1.0, 2.0, 3.0, 4.0]\nmad = mean_absolute_deviation(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle empty list to avoid ZeroDivisionError\n\n    n = len(numbers)\n    mean = sum(numbers) / n\n    mad = sum(abs(x - mean) for x in numbers) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad\nnumbers = [1.0, 2.0, 3.0, 4.0]\nmad = mean_absolute_deviation(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list case\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list to avoid ZeroDivisionError\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    n = len(numbers)\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Handle empty list to avoid ZeroDivisionError\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 26.511627906976745, "dps_norm": 41.111111111111114, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string:\n        seen.add(char.lower())\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string:\n        seen.add(char.lower())\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    seen = set()\n    for char in string.lower():\n        seen.add(char)\n    return len(seen)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 3}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to efficiently find closest elements\n\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()  # Sort the list to easily find adjacent elements\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find adjacent elements\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find closest elements\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find closest elements\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find closest elements\n\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n\n    numbers.sort()  # Sort the list to easily find adjacent elements\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find closest elements\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find adjacent closest numbers\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to facilitate comparison\n\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the numbers to easily find closest pairs\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find closest elements\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find adjacent elements\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i+1] - numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the numbers to easily find closest pairs\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find closest elements\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n\n    numbers.sort()  # Sort the numbers to easily find closest pairs\n\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    numbers.sort()  # Sort the list to easily find adjacent closest numbers\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 93.46938775510205, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return 1  # Handle cases where n is 1 or less\n\n    for i in range(n // 2, 0, -1):  # Iterate downwards from n/2 to 1\n        if n % i == 0:\n            return i\n    return 1  # Should technically never reach here for n>1, but good practice for edge cases", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    # raises an error since 1 has no divisors smaller than itself\n    \"\"\"\n    if n == 1:\n        raise ValueError(\"1 has no divisors smaller than itself.\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(1)\n    1 # Special Case.  Definition allows 1 to divide itself\n    >>> largest_divisor(3456732)\n    1728366\n    \"\"\"\n\n    if n == 1:  # Special case to handle n=1\n        return 1\n\n    for i in range(n // 2, 0, -1):  # Iterate downwards from n/2 for efficiency\n        if n % i == 0:\n            return i\n\n    return 1  # Should not be reached unless n=1, which is handled above", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return -1  # Or raise an exception, depending on desired behavior for invalid input\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n\n    return -1  # Should never reach here for n > 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):  # Iterate from n/2 down to 1\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found (for prime numbers other than 2), return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    1 # Technically incorrect, should raise an Exception as per problem constraints. Handling this below.\n    >>> largest_divisor(24)\n    12\n    >>> largest_divisor(173)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input n must be greater than 1.\")  # Handling the n<=1 case\n\n    for i in range(n // 2, 0, -1):  # Optimize by starting from n//2 and going down\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If n is prime and > 2, the largest divisor is 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(25)\n    5\n    >>> largest_divisor(1)\n    -1 # Special case as 1 has no divisors smaller than itself.\n    >>> largest_divisor(1738492) # Large prime number should also return 1\n    1\n    \"\"\"\n    if n == 1:\n        return -1\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n\n    return 1  # If no divisor is found (prime numbers other than 1), return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Should only happen if n is 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(25)\n    5\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(1)\n    1 # Special case, documented here for clarity.  Mathematically undefined. \n    >>> largest_divisor(2)\n    1\n    \"\"\"\n    for i in range(n // 2, 0, -1):  # Iterate from n//2 down to 1\n        if n % i == 0:\n            return i\n    return 1  # Return 1 if no other divisor is found (for prime numbers or 1)", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):  # Iterate from n/2 down to 1\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found (should only happen for n=1, as 1 divides every number)", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(25)\n    5\n    >>> largest_divisor(1) # Returns 1 for n=1\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):  # Iterate from n/2 down to 1\n        if n % i == 0:\n            return i\n    return 1 # Should theoretically never reach here for n > 1 as 1 is always a divisor", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):  # Iterate from n/2 down to 1\n        if n % i == 0:\n            return i\n    return 1 # Shouldn't reach here unless n is 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):  # Iterate from n//2 down to 1\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found (for prime numbers > 2), return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(25)\n    5\n\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):  # Iterate from n/2 down to 1\n        if n % i == 0:\n            return i\n    return None  # Should never reach here for n > 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(12)\n    6\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    1 # Special Case - Returns 1 as instructed\n    >>> largest_divisor(2)\n    1\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    if n == 1:  # Handle the special case where n is 1.\n        return 1\n\n    for i in range(n // 2, 0, -1): # Iterate from n/2 downwards\n        if n % i == 0:\n            return i\n    return 1 # If no divisor is found other than 1 (for prime numbers).", "matching_cluster_idx": 4}]}, "HumanEval/26": {"dps": 31.4, "dps_norm": 73.75, "pass@1": 92.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n        else:\n            continue  # Skip duplicates\n\n        counts = numbers.count(number)\n        if counts == 1:  # Only include the element if it appears once\n            result.append(number)\n\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n            result.append(number)\n        else:\n            if number in result:\n                result.remove(number)\n\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 1\n            result.append(num)\n        else:\n            counts[num] += 1\n\n    final_result = []\n    for num in result:\n        if counts[num] == 1:\n            final_result.append(num)\n    return final_result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 0\n        counts[number] += 1\n\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 2}]}, "HumanEval/31": {"dps": 95.12658227848101, "dps_norm": 86.875, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 86.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    n = len(l)\n    third_vals = []\n    for i in range(n):\n        if (i % 3) == 0:\n            third_vals.append(l[i])\n    \n    third_vals.sort()\n\n    result = []\n    third_index = 0\n    for i in range(n):\n        if (i % 3) == 0:\n            result.append(third_vals[third_index])\n            third_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    n = len(l)\n    divisible_by_three = []\n    for i in range(0, n, 3):\n        if i < n:\n            divisible_by_three.append(l[i])\n    \n    divisible_by_three.sort()\n    \n    result = []\n    div_three_index = 0\n    for i in range(n):\n        if i % 3 == 0:\n            result.append(divisible_by_three[div_three_index])\n            div_three_index += 1\n        else:\n            result.append(l[i])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    thirds = []\n    result = []\n    for i, val in enumerate(l):\n        if i % 3 == 0:\n            thirds.append(val)\n        result.append(val)\n\n    thirds.sort()\n\n    j = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = thirds[j]\n            j += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    thirds = []\n    result = []\n    for i, val in enumerate(l):\n        if i % 3 == 0:\n            thirds.append(val)\n        result.append(val)\n\n    thirds.sort()\n\n    j = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = thirds[j]\n            j += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    third_values = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            third_values.append(l[i])\n    third_values.sort()\n    result = []\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(third_values[third_index])\n            third_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    divisible_by_three = []\n    result = []\n\n    for i in range(len(l)):\n        if i % 3 == 0:\n            divisible_by_three.append(l[i])\n\n    divisible_by_three.sort()\n\n    index_divisible = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(divisible_by_three[index_divisible])\n            index_divisible += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    n = len(l)\n    third_values = []\n    for i in range(n):\n        if (i % 3 == 0):\n            third_values.append(l[i])\n    \n    third_values.sort()\n    \n    result = []\n    third_index = 0\n    for i in range(n):\n        if (i % 3 == 0):\n            result.append(third_values[third_index])\n            third_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if not l:\n        return []\n\n    thirds = []\n    result = []\n    for i, val in enumerate(l):\n        if i % 3 == 0:\n            thirds.append(val)\n        result.append(None)  # Placeholder\n\n    thirds.sort()\n\n    thirds_index = 0\n    for i, val in enumerate(l):\n        if i % 3 == 0:\n            result[i] = thirds[thirds_index]\n            thirds_index += 1\n        else:\n            result[i] = l[i]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    divisible_by_three = []\n    result = []\n\n    for i in range(len(l)):\n        if i % 3 == 0:\n            divisible_by_three.append(l[i])\n\n    divisible_by_three.sort()\n\n    index_divisible = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(divisible_by_three[index_divisible])\n            index_divisible += 1\n        else:\n            result.append(l[i])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if not l:\n        return []\n\n    thirds = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            thirds.append(l[i])\n    \n    thirds.sort()\n\n    result = []\n    thirds_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(thirds[thirds_index])\n            thirds_index += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    n = len(l)\n    thirds = []\n    for i in range(n):\n        if i % 3 == 0:\n            thirds.append(l[i])\n    \n    thirds.sort()\n\n    result = []\n    thirds_index = 0\n    for i in range(n):\n        if i % 3 == 0:\n            result.append(thirds[thirds_index])\n            thirds_index += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    third_values = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            third_values.append(l[i])\n\n    third_values.sort()\n\n    new_list = []\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            new_list.append(third_values[third_index])\n            third_index += 1\n        else:\n            new_list.append(l[i])\n\n    return new_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    n = len(l)\n    divisible_by_three = []\n    for i in range(n):\n        if i % 3 == 0:\n            divisible_by_three.append(l[i])\n\n    divisible_by_three.sort()\n\n    result = []\n    j = 0\n    for i in range(n):\n        if i % 3 == 0:\n            result.append(divisible_by_three[j])\n            j += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if not l:\n        return []\n\n    thirds = []\n    result = []\n    for i, val in enumerate(l):\n        if i % 3 == 0:\n            thirds.append(val)\n        result.append(None)  # Placeholder\n\n    thirds.sort()\n\n    thirds_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = thirds[thirds_index]\n            thirds_index += 1\n        else:\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    third_values = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            third_values.append(l[i])\n    third_values.sort()\n\n    result = []\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(third_values[third_index])\n            third_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if not l:\n        return []\n\n    third_values = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            third_values.append(l[i])\n    \n    third_values.sort()\n\n    new_list = []\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            new_list.append(third_values[third_index])\n            third_index += 1\n        else:\n            new_list.append(l[i])\n    \n    return new_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n\n    n = len(l)\n    third_values = []\n    for i in range(n):\n        if i % 3 == 0:\n            third_values.append(l[i])\n\n    third_values.sort()\n\n    result = []\n    third_index = 0\n    for i in range(n):\n        if i % 3 == 0:\n            result.append(third_values[third_index])\n            third_index += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n\n    divisible_by_three = []\n    result = []\n\n    for i in range(len(l)):\n        if (i % 3 == 0):\n            divisible_by_three.append(l[i])\n\n    divisible_by_three.sort()\n\n    j = 0\n    for i in range(len(l)):\n        if (i % 3 == 0):\n            result.append(divisible_by_three[j])\n            j += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    n = len(l)\n    third_values = []\n    for i in range(n):\n        if i % 3 == 0:\n            third_values.append(l[i])\n    third_values.sort()\n    result = []\n    third_index = 0\n    for i in range(n):\n        if i % 3 == 0:\n            result.append(third_values[third_index])\n            third_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [3, 6, 2, 4, 8, 9, 5]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2, 1, 7, 10, 11, 0])\n    [0, 6, 3, 4, 8, 9, 2, 1, 5, 10, 11, 7]\n\n    \"\"\"\n    n = len(l)\n    divisible_by_three = []\n    for i in range(n):\n        if i % 3 == 0:\n            divisible_by_three.append(l[i])\n\n    divisible_by_three.sort()\n    \n    new_list = []\n    j = 0\n    for i in range(n):\n        if i % 3 == 0:\n            new_list.append(divisible_by_three[j])\n            j += 1\n        else:\n            new_list.append(l[i])\n    return new_list", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 95.28301886792453, "dps_norm": 97.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    seen = set()\n    result = []\n    for item in l:\n        if item not in seen:\n            result.append(item)\n            seen.add(item)\n    result.sort()\n    return result", "matching_cluster_idx": 1}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0) or (i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0) or (i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0) or (i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n    \n    even_values.sort()\n    \n    new_list = l[:] # Create a copy to avoid modifying the original list\n    \n    for i, val in zip(even_indices, even_values):\n        new_list[i] = val\n        \n    return new_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if not l:\n        return []\n\n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = list(l)  # Create a copy to avoid modifying the original list\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n\n    even_indices = []\n    even_values = []\n\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n    \n    even_values.sort()\n    \n    result = l[:]  # Create a copy to avoid modifying the original list\n\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n    \n    even_values.sort()\n\n    result = l[:] # Create a copy to avoid modifying the original list\n\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = [0] * len(l)\n    for i in range(len(even_indices)):\n        result[even_indices[i]] = even_values[i]\n\n    for i in range(1, len(l), 2):\n        result[i] = l[i]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = list(l)  # Create a copy to avoid modifying the original list\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if not l:\n        return []\n\n    even_indices = []\n    even_values = []\n    result = []\n\n    for i, val in enumerate(l):\n        if i % 2 == 0:\n            even_indices.append(i)\n            even_values.append(val)\n        else:\n            result.append(val)\n\n\n    even_values.sort()\n\n    result_with_evens = []\n    even_idx = 0\n    odd_idx = 0\n    for i in range(len(l)):\n      if i % 2 == 0:\n        result_with_evens.append(even_values[even_idx])\n        even_idx+=1\n      else:\n          if odd_idx < len(result):\n            result_with_evens.append(result[odd_idx])\n            odd_idx +=1\n          \n\n\n    return result_with_evens", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n    \n    even_values.sort()\n    \n    result = l[:]  # Create a copy to avoid modifying the original list\n    \n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n\n    even_indices = []\n    even_values = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            even_indices.append(i)\n            even_values.append(l[i])\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if not l:\n        return []\n\n    even_indices = []\n    even_values = []\n    for i, val in enumerate(l):\n        if i % 2 == 0:\n            even_indices.append(i)\n            even_values.append(val)\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n\n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n\n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if not l:\n        return []\n\n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = list(l)  # Create a copy to avoid modifying the original list\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n\n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n\n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n\n    result = l[:]  # Create a copy to avoid modifying the original list\n\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if len(l) <= 1:\n        return l\n    \n    even_indices = []\n    even_values = []\n    for i in range(0, len(l), 2):\n        even_indices.append(i)\n        even_values.append(l[i])\n\n    even_values.sort()\n    \n    result = l.copy()\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n        \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": null, "dps_norm": null, "pass@1": 3.0, "profiled": []}, "HumanEval/58": {"dps": 77.08661417322834, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)  # Efficiently find common elements using set intersection\n    return sorted(list(common_elements)) # Convert back to list and sort", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = list(set1.intersection(set2))\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = list(set1.intersection(set2))\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide n by 2 until n is odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers from 3 up to the square root of n\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n\n    # If n is still greater than 1, it means n is a prime number itself (since we've divided out all smaller factors)\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n\n    if n > largest_factor:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 1\n\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n\n    if n > largest_factor:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide n by 2 as many times as possible\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers from 3 to sqrt(n)\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n\n    # If n is still greater than 1, it's prime\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide n by 2 as many times as possible\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers from 3 up to the square root of n\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n\n    # If n is still greater than 1, it's the last prime factor\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide out all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n\n    # If n is still greater than 1, it must be prime itself\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide n by 2 repeatedly until it's odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers starting from 3 up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n\n    # If n is still greater than 2 after the loop, it's prime itself\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide n by 2 as many times as possible\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers from 3 up to the square root of n\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n\n    # If n is still greater than 1 after the loop, it's prime\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide n by 2 until it's odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers from 3 up to sqrt(n)\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n\n    # If n is still greater than 1, it's prime\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            while n % i == 0:\n                n //= i\n        i += 1\n    \n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide n by 2 until it's odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check odd factors starting from 3\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n\n    # If n is still greater than 1, it's prime\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide n by 2 repeatedly until it's odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers from 3 up to sqrt(n)\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n\n    # If n is still greater than 1, it's the largest prime factor\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide out all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers up to sqrt(n)\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n\n    # If n is still greater than 1, it's the largest prime factor\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i  # Divide n by i to reduce it and find larger factors\n            while n % i == 0:  # Handle cases where a prime factor appears multiple times\n                n //= i\n        i += 1\n\n    if n > 1:  # If n is still greater than 1 after the loop, it's the largest prime factor\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide n by 2 as many times as possible\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Iterate through odd numbers from 3 up to sqrt(n)\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n        i += 2\n\n    # If n is still greater than 1, it's a prime factor\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor\n\n    # Example usage (for testing)\n    print(largest_prime_factor(13195))  # Output: 29\n    print(largest_prime_factor(2048))  # Output: 2\n    print(largest_prime_factor(600851475143))", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n\n    if n > largest_factor:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 51.1038961038961, "dps_norm": 51.25, "pass@1": 100.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for i, char in enumerate(s.lower()):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for i in range(len(s)):\n        char = s[i].lower()\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith(\"y\"):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the given word.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for i in range(len(s)):\n        char = s[i].lower()\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for i, char in enumerate(s.lower()):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for i in range(len(s)):\n        char = s[i].lower()\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for i, char in enumerate(s.lower()):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 95.02475247524752, "dps_norm": 64.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 3, 5]) ==> 0\n        add([2, 4, 6, 8]) ==> 4 + 8 = 12\n        add([1, 2, 3, 4, 5, 6]) == 2 + 4 + 6 = 12\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the element is even\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5, 6]) ==> 2 + 6 = 8\n        add([1, 3, 5, 7]) ==> 0\n        add([2, 4, 6, 8]) ==> 4 + 8 = 12\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_even_at_odd = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:\n            sum_even_at_odd += lst[i]\n    return sum_even_at_odd", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4]) ==> 2\n        add([1, 3, 5, 7]) ==> 0\n        add([2, 4, 6, 8]) ==> 4 + 8 = 12\n        add([1, 2, 3, 4, 5, 6]) ==> 2 + 4 + 6 = 12\n    \"\"\"\n    sum_of_evens_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:\n            sum_of_evens_at_odd_indices += lst[i]\n    return sum_of_evens_at_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 3, 5, 7, 9]) == 0\n        add([2, 4, 6, 8]) == 4 + 8 = 12\n        add([1, 2, 3, 4, 5, 6]) == 2 + 4 + 6 = 12\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the current index is even\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 3, 5]) == 0\n        add([2, 4, 6]) == 4\n        add([1, 2, 3, 4, 5, 6]) == 6\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the current index is even\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5, 6]) ==> 2 + 6 = 8\n        add([1, 3, 5, 7]) ==> 0\n        add([2, 4, 6, 8]) ==> 4 + 8 = 12\n        add([2]) ==> 0\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5, 6]) ==> 2 + 6 = 8\n        add([1, 3, 5, 7]) ==> 0\n        add([2, 4, 6, 8]) ==> 4 + 8 = 12\n        add([1, 0, 1, 0]) ==> 0 + 0 = 0\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:        # Check if the element is even\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4]) == 2\n        add([1, 3, 5, 7]) == 0\n        add([2, 4, 6, 8]) == 4 + 8 = 12\n        add([10]) == 0\n\n\n    \"\"\"\n    sum_of_evens_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:\n            sum_of_evens_at_odd_indices += lst[i]\n    return sum_of_evens_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 2, 3, 4, 5, 6]) ==> 2 + 6 = 8\n        add([1, 3, 5]) ==> 0\n        add([2, 4, 6]) ==> 4\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5, 6]) ==> 2 + 6 = 8\n        add([1, 3, 5]) == 0\n        add([2, 4, 6]) == 4\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the current index is even\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4]) == 2\n        add([1, 3, 5, 7]) == 0\n        add([2, 4, 6, 8]) == 4 + 8 = 12\n        add([2]) == 0\n    \"\"\"\n    sum_even_at_odd = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:\n            sum_even_at_odd += lst[i]\n    return sum_even_at_odd", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5, 6]) ==> 2 + 6 = 8\n        add([1, 3, 5, 7]) ==> 0\n        add([2, 4, 6, 8]) == > 4 + 8 = 12\n\n    \"\"\"\n    sum_of_evens_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the current index is even\n            sum_of_evens_at_odd_indices += lst[i]\n    return sum_of_evens_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4]) ==> 2\n        add([2, 4, 6, 8]) ===> 4 + 8 = 12\n        add([1, 3, 5, 7]) ==> 0\n        add([2]) ==> 0\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the current index is even\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4]) ==> 2\n        add([1, 3, 5, 4, 2]) ==> 2\n        add([2, 4, 6, 8]) ==> 4 + 8 = 12\n        add([1, 2, 3, 4, 5, 6]) ==> 2 + 4 + 6 = 12\n    \"\"\"\n    sum_even_at_odd = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:        # Check if the element is even\n            sum_even_at_odd += lst[i]\n    return sum_even_at_odd", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4, 5, 6]) ==> 2 + 6 = 8\n        add([1, 3, 5, 7]) ==> 0\n        add([2, 4, 6, 8]) ==> 4 + 8 = 12\n        add([2]) ==> 0\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the current index is even\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:  # Check if the element is even\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 2, 3, 4]) == 2\n        add([1, 3, 5, 7]) == 0\n        add([2, 4, 6, 8]) == 4 + 8 == 12\n        add([10, 12, 14, 16]) == 12 + 16 == 28\n    \"\"\"\n    sum_even_at_odd_indices = 0\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:\n            sum_even_at_odd_indices += lst[i]\n    return sum_even_at_odd_indices", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "HumanEval/87": {"dps": 64.43804034582132, "dps_norm": 51.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        row_coords = []\n        for col_index, val in enumerate(row):\n            if val == x:\n                row_coords.append((row_index, col_index))\n        \n        row_coords.sort(key=lambda coord: coord[1], reverse=True)  # Sort by column descending\n        result.extend(row_coords)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        temp_indices = []\n        for col_index, val in enumerate(row):\n            if val == x:\n                temp_indices.append(col_index)\n        \n        for col_index in reversed(temp_indices):\n            result.append((row_index, col_index))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        temp = []\n        for col_index, val in enumerate(row):\n            if val == x:\n                temp.append((row_index, col_index))\n        temp.sort(key=lambda item: item[1], reverse=True)\n        result.extend(temp)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        temp = []\n        for j, val in enumerate(row):\n            if val == x:\n                temp.append((i, j))\n        temp.sort(key=lambda coord: coord[1], reverse=True)  # Sort columns in descending order\n        result.extend(temp)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        temp = []\n        for j, val in enumerate(row):\n            if val == x:\n                temp.append((i, j))\n        temp.sort(key=lambda item: item[1], reverse=True)\n        result.extend(temp)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        indices = []\n        for col_index, value in enumerate(row):\n            if value == x:\n                indices.append(col_index)\n        \n        for col_index in sorted(indices, reverse=True):\n            result.append((row_index, col_index))\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        indices = []\n        for col_index, element in enumerate(row):\n            if element == x:\n                indices.append(col_index)\n        \n        for col_index in sorted(indices, reverse=True):\n            result.append((row_index, col_index))\n            \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        row_indices = []\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                row_indices.append(j)\n        row_indices.sort(reverse=True)\n        for j in row_indices:\n            result.append((i, j))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        temp = []\n        for col_index, element in enumerate(row):\n            if element == x:\n                temp.append((row_index, col_index))\n        temp.sort(key=lambda item: item[1], reverse=True)\n        result.extend(temp)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        row_indices = []\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                row_indices.append(j)\n        \n        row_indices.sort(reverse=True)\n        for j in row_indices:\n            result.append((i, j))\n            \n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        temp = []\n        for j, val in enumerate(row):\n            if val == x:\n                temp.append((i, j))\n        temp.sort(key=lambda coord: coord[1], reverse=True)  # Sort columns in descending order\n        result.extend(temp)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        row_coords = []\n        for col_index, value in enumerate(row):\n            if value == x:\n                row_coords.append((row_index, col_index))\n        row_coords.sort(key=lambda coord: coord[1], reverse=True)  # Sort by column descending\n        result.extend(row_coords)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        row_indices = []\n        for j, val in enumerate(row):\n            if val == x:\n                row_indices.append(j)\n        \n        for j in sorted(row_indices, reverse=True):\n            result.append((i, j))\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        row_coords = []\n        for col_index, val in enumerate(row):\n            if val == x:\n                row_coords.append((row_index, col_index))\n        row_coords.sort(key=lambda coord: coord[1], reverse=True)  # Sort columns descending\n        result.extend(row_coords)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        row_indices = []\n        for j, val in enumerate(row):\n            if val == x:\n                row_indices.append(j)\n        \n        for j in sorted(row_indices, reverse=True):\n            result.append((i, j))\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        temp = []\n        for col_index, val in enumerate(row):\n            if val == x:\n                temp.append((row_index, col_index))\n        temp.sort(key=lambda item: item[1], reverse=True)\n        result.extend(temp)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        row_indices = []\n        for j, val in enumerate(row):\n            if val == x:\n                row_indices.append(j)\n        row_indices.sort(reverse=True)\n        for j in row_indices:\n            result.append((i, j))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        row_indices = []\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                row_indices.append(j)\n        row_indices.sort(reverse=True)\n        for j in row_indices:\n            result.append((i, j))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        row_indices = []\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                row_indices.append(j)\n        row_indices.sort(reverse=True)\n        for j in row_indices:\n            result.append((i, j))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        row_indices = []\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                row_indices.append(j)\n        row_indices.sort(reverse=True)\n        for j in row_indices:\n            result.append((i, j))\n    return result", "matching_cluster_idx": 2}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted_string += shifted_char\n        else:\n             encrypted_string += char # Handle non-lowercase letters\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            start = ord('a')\n            shifted_char = chr(((ord(char) - start + 4) % 26) + start)\n        elif 'A' <= char <= 'Z':\n            start = ord('A')\n            shifted_char = chr(((ord(char) - start + 4) % 26) + start)\n        else:\n            shifted_char = char  # Keep non-alphabetic characters unchanged\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted_string += shifted_char\n        else:\n            encrypted_string += char  # Handle non-lowercase letters\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            start = ord('a')\n            shifted_char = chr(start + (ord(char) - start + 4) % 26)\n        elif 'A' <= char <= 'Z':\n            start = ord('A')\n            shifted_char = chr(start + (ord(char) - start + 4) % 26)\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))  # Shift by 4 (2*2)\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))  # Shift by 4 (2*2)\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted_string += shifted_char\n        else:\n            encrypted_string += char  # Handle non-lowercase letters (optional)\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            shifted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            shifted_char = char  # Keep non-alphabetic characters as they are\n        encrypted_string += shifted_char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            rotated_char_ord = ord(char) + 4  # 2 * 2 = 4\n            if rotated_char_ord > ord('z'):\n                rotated_char_ord -= 26\n            encrypted_string += chr(rotated_char_ord)\n        else:\n            encrypted_string += char  # Handle non-alphabetic characters\n\n    return encrypted_string", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 51.750972762645915, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_sorted_lst = sorted(list(set(lst)))\n\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    return unique_sorted_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))\n\n    if len(unique_lst) < 2:\n        return None\n    \n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_sorted = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_sorted) < 2:\n        return None\n\n    return unique_sorted[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_sorted_lst = sorted(list(set(lst)))\n\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    return unique_sorted_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n    \n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(list(set(lst)))  # Remove duplicates and sort\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 5}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        result.append(\"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        result.append(\"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        output_string = \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        new_string = \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\"\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        result.append(\"the number of odd elements \" + str(count) + \"n the str\" + str(count) + \"ng \" + str(count) + \" of the \" + str(count) + \"nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        result.append(\"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        new_string = \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\"\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n\n        new_string = \"the number of odd elements \" + str(count) + \"n the str\" + str(count) + \"ng \" + str(count) + \" of the \" + str(count) + \"nput.\"\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        new_string = \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\"\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        new_string = \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\"\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        result.append(f\"the number of odd elements {count_str}n the str{count_str}ng {count_str} of the {count_str}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        result.append(f\"the number of odd elements {count_str}n the str{count_str}ng {count_str} of the {count_str}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        output_string = \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for char in s:\n            if int(char) % 2 != 0:\n                count += 1\n        \n        output_string = \"the number of odd elements \" + str(count) + \"n the str\" + str(count) + \"ng \" + str(count) + \" of the \" + str(count) + \"nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n        count_str = str(count)\n        result.append(\"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = 0\n        for digit in s:\n            if int(digit) % 2 != 0:\n                count += 1\n\n        output_string = \"the number of odd elements \" + str(count) + \"n the str\" + str(count) + \"ng \" + str(count) + \" of the \" + str(count) + \"nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 25.58139534883721, "dps_norm": 84.0, "pass@1": 100.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    \n    if is_balanced(s2 + s1):\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n\n    if is_balanced(s2 + s1):\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    elif is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    elif is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    elif is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    elif is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    elif is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n\n    if is_balanced(s2 + s1):\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    elif is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    elif is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    elif is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}]}, "HumanEval/120": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 30.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(arr)[-k:] if k else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()  # Sort the array in ascending order\n    return arr[-k:] if k > 0 else []  # Return the last k elements (largest)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()  # Sort the array in ascending order\n    return arr[len(arr) - k:]  # Return the last k elements (largest)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[len(arr) - k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:] if k > 0 else []", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted as described.\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort by length, then alphabetically for strings with the same length\n    even_length_strings.sort(key=lambda s: (len(s), s))\n\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted as described.\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted as described.\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda s: (len(s), s))  # Sort by length, then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted as described.\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths, \n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    assert sorted_list_sum([\"aba\", \"aa\", \"aaa\", \"a\", \"cccc\"]) == [\"aa\", \"cccc\"]\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths, \n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    filtered_list.sort(key=lambda s: (len(s), s))  # Sort by length then alphabetically\n    return filtered_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the remaining strings by length then alphabetically\n    even_length_strings.sort(key=lambda s: (len(s), s))\n\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted as described.\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings, removes odd-length strings, \n    and returns a sorted list based on length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    even_length_strings.sort(key=lambda x: (len(x), x))  # Sort by length, then alphabetically\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted as described.\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings sorted by length then alphabetically.\n\n    Args:\n        lst: A list of strings.\n\n    Returns:\n        A list of strings sorted by length then alphabetically.\n    \"\"\"\n\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    return sorted(even_length_strings, key=lambda s: (len(s), s))", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 85.46610169491525, "dps_norm": 91.875, "pass@1": 100.0, "profiled": [{"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        num: An integer.\n\n    Returns:\n        True if num is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n\n    # Optimization: Check divisibility only up to the square root of num\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return True\n\n    return False", "matching_cluster_idx": 4}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n\n    # Check for divisibility by 2 and 3\n    if num % 2 == 0 or num % 3 == 0:\n        return True\n\n    # Optimized primality test using 6k \u00b1 1 optimization.\n    # All prime numbers greater than 3 can be expressed in the form 6k \u00b1 1.\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False  # 2 and 3 are prime\n    if num % 2 == 0 or num % 3 == 0:\n        return True  # Divisible by 2 or 3\n\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is NOT prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n\n    # Optimization: Check divisibility only up to the square root of num\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return True  # Found a divisor, so it's not prime\n    return False  # No divisors found, so it's prime", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        num: An integer.\n\n    Returns:\n        True if num is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n    if num % 2 == 0 or num % 3 == 0:\n        return True # Divisible by 2 or 3, not prime\n\n    # Optimized primality test using 6k \u00b1 1 optimization\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n    if num % 2 == 0 or num % 3 == 0:\n        return True # Divisible by 2 or 3\n\n    # Optimized primality test: Check divisibility only for 6k \u00b1 1 up to sqrt(num)\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(n):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        n: The number to check.\n\n    Returns:\n        True if n is not a prime number (including 0, 1, and negative numbers), False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime\n\n    if n <= 3:\n        return False # 2 and 3 are prime\n\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n\n    # Optimized primality test.  Check divisibility only by 6k \u00b1 1\n    for i in range(5, int(math.sqrt(n)) + 1, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n        Returns True for num <= 1 as well.\n    \"\"\"\n    if num <= 1:\n        return True\n\n    # Optimization: Check divisibility only up to the square root of num\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n\n    # Optimize by only checking up to the square root of num\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return True  # Found a divisor, so not prime\n\n    return False  # No divisors found, so it's prime", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      num: The number to check.\n\n    Returns:\n      True if the number is not prime, False otherwise.\n    \"\"\"\n\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n\n    if num <= 3:\n        return False  # 2 and 3 are prime\n\n    if num % 2 == 0 or num % 3 == 0:\n        return True  # Divisible by 2 or 3\n\n    # Optimized primality test using 6k \u00b1 1 optimization\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n    if num % 2 == 0:\n        return True # Even numbers greater than 2 are not prime\n\n    # Optimized primality test: Check divisibility only up to the square root of num\n    # and only for odd numbers.\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n    if num % 2 == 0:\n        return True # Even numbers greater than 2 are not prime\n\n    # Iterate only through odd numbers up to the square root of num\n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n\n    # Check for divisibility by 2 and 3 explicitly for efficiency\n    if num % 2 == 0 or num % 3 == 0:\n        return True\n\n    # Iterate from 5 up to the square root of num with a step of 6\n    # (6k \u00b1 1 optimization)\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n    if num % 2 == 0 or num % 3 == 0:\n        return True\n\n    # Optimized primality test.  Check divisibility only by 6k \u00b1 1 up to sqrt(n)\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        num: An integer.\n\n    Returns:\n        True if num is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n    if num % 2 == 0 or num % 3 == 0:\n        return True\n\n    # Optimized primality test: Iterate only up to the square root of num\n    # and check divisibility by 6k \u00b1 1. This is because all primes greater\n    # than 3 can be expressed in the form 6k \u00b1 1.\n\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        num: An integer.\n\n    Returns:\n        True if num is not a prime number, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False # 2 and 3 are prime\n\n    # Optimization: Check divisibility only up to the square root of num\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return True  # Found a divisor, so it's not prime\n\n    return False  # No divisors found, so it's prime", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n\n    if num <= 3:\n        return False # 2 and 3 are prime\n\n    if num % 2 == 0 or num % 3 == 0:\n        return True  # Divisible by 2 or 3\n\n    # Optimized primality test using 6k \u00b1 1 optimization\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n        Returns True for numbers less than 2.\n    \"\"\"\n    if num < 2:\n        return True  # Numbers less than 2 are not prime\n\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n      num: The number to check.\n\n    Returns:\n      True if the number is not prime, False otherwise.\n    \"\"\"\n\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n\n    if num <= 3:\n        return False # 2 and 3 are prime\n\n    if num % 2 == 0 or num % 3 == 0:\n        return True  # Divisible by 2 or 3\n\n    # Optimized primality test, check divisibility only for 6k \u00b1 1\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is NOT a prime number.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if num <= 3:\n        return False  # 2 and 3 are prime\n    if num % 2 == 0 or num % 3 == 0:\n        return True  # Divisible by 2 or 3\n\n    # Optimized primality test, checking divisibility only up to the square root of num\n    # and incrementing by 6 (6k \u00b1 1 optimization). This is because all primes greater than 3\n    # can be expressed in the form 6k \u00b1 1.\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 76.70648464163823, "dps_norm": 81.25, "pass@1": 91.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a heap queue.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n        Returns an empty list if n is 0 or nums is empty.\n        Returns the sorted nums in descending order if n is greater than or equal to the length of nums.\n    \"\"\"\n    if not nums or n == 0:\n        return []\n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a heap queue.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n        Returns an empty list if n is 0 or negative or if the input list is empty.\n    \"\"\"\n\n    if n <= 0 or not nums:\n        return []\n    \n    return heapq.nlargest(n, nums, key=lambda x: x)", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a list using a min-heap.\n\n    Args:\n        nums: The input list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)\nn = 3", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a min-heap.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n        Returns an empty list if n is zero or negative.\n        Returns the sorted input list if n is larger than or equal to the length of the input list.\n    \"\"\"\n\n    if n <= 0:\n        return []\n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n\n    # Use a min-heap to efficiently track the n largest elements\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using heapq.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n        Returns an empty list if n is 0 or nums is empty.\n    \"\"\"\n    if not nums or n == 0:\n        return []\n\n    return heapq.nlargest(n, nums, key=None)", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n    return sorted(heapq.nlargest(n, nums), reverse=True)\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a heap queue.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a min-heap.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n        Returns an empty list if n is zero or negative, or if the input list is empty.\n    \"\"\"\n\n    if n <= 0 or not nums:\n        return []\n\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n        Returns an empty list if n is 0 or nums is empty.\n    \"\"\"\n    if not nums or n == 0:\n        return []\n    \n    return heapq.nlargest(n, nums, key=lambda x: x)", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a min-heap.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []  # Handle edge case of n being zero or negative\n    if n >= len(nums):\n        return sorted(nums, reverse=True)  # Handle edge case where n is greater than or equal to the list length\n\n    min_heap = []\n    for num in nums:\n        if len(min_heap) < n:\n            heapq.heappush(min_heap, num)\n        else:\n            if num > min_heap[0]:\n                heapq.heapreplace(min_heap, num)  # More efficient than heappushpop\n\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a min-heap.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n        Returns an empty list if n is 0 or nums is empty.\n    \"\"\"\n    if not nums or n == 0:\n        return []\n\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a min-heap.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n\n    if n <= 0:\n        return []\n\n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n\n    min_heap = []\n    for num in nums:\n        if len(min_heap) < n:\n            heapq.heappush(min_heap, num)\n        elif num > min_heap[0]:  # If current number is greater than the smallest in the heap\n            heapq.heapreplace(min_heap, num) # Replace smallest with current number\n\n    return sorted(min_heap, reverse=True)  # Sort the heap (which contains the n largest) in descending order", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a heap queue.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a heap queue.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n    \"\"\"\n\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers using a min-heap.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to find.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    min_heap = nums[:n]\n    heapq.heapify(min_heap)\n\n    for num in nums[n:]:\n        if num > min_heap[0]:\n            heapq.heapreplace(min_heap, num)\n\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 52.72108843537415, "dps_norm": 51.0, "pass@1": 98.0, "profiled": [{"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):  # Iterate through possible rotations from 1 to n\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == s:\n            return i\n    return -1  # No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations.  Returns the length of the string if no shorter rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):  # Iterate through possible rotations from 1 to n\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):  # Iterate through possible rotation lengths\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return -1  # No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):  # Iterate through possible rotations\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == s:\n            return i\n    return n  # Return n if no rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):  # Iterate through possible rotation lengths\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return -1  # No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        str1: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(str1) if no shorter rotation exists.\n    \"\"\"\n    n = len(str1)\n    for i in range(1, n):\n        rotated = str1[i:] + str1[:i]\n        if rotated == str1:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return -1  # No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):  # Iterate through possible rotation lengths\n        if n % i == 0:  # Only check rotations that are divisors of the string length\n            rotated = s[i:] + s[:i]\n            if rotated == s:\n                return i\n    return -1  # No rotation found", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == s:\n            return i\n    return n  # Return n if no rotation produces the same string.", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # Return n if no rotation produces the original string.", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no rotation produces the same string.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # Return n if no rotation produces the original string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # Return n if no rotation produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # Return n if no rotation within n produces the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no smaller rotation works.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # If no shorter rotation works", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no rotation produces the original string.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n  # No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):  # Iterate through rotations from 1 to n\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == s:\n            return i\n    return -1  # No rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or len(s) if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations, or -1 if no such rotation exists.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return -1", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/12": {"dps": 91.42857142857143, "dps_norm": 99.375, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows in ascending order.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order based on the sum of its rows.\"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows in ascending order.\"\"\"\n\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows.\"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows in ascending order.\"\"\"\n\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows.\"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the ascending order of row sums.\"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows in ascending order.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n\n    return sorted(matrix, key=sum)\nmatrix = [[10, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the ascending order of its row sums.\"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows in ascending order.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix based on the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 95.2439024390244, "dps_norm": 98.125, "pass@1": 84.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase sequences joined by underscores\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string contains sequences of lowercase letters joined with underscores, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more sequences of lowercase letters followed by underscores, ending with lowercase letters\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains only sequences of lowercase letters joined by underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more sequences of lowercase letters followed by underscores, ending with lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains only sequences of lowercase letters joined by underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Corrected regex\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains only sequences of lowercase letters joined by underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more lowercase sequences joined by underscores.\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string contains sequences of lowercase letters joined with underscores, \n        False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains only sequences of lowercase letters joined by underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"  # Matches one or more lowercase sequences joined by underscores\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string contains sequences of lowercase letters joined by underscores, \n        False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches one or more sequences of lowercase letters followed by an underscore, optionally ending with another sequence of lowercase letters.\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"  # Matches one or more sequences of lowercase letters joined by underscores\n    match = re.fullmatch(pattern, text)\n    return bool(match)", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains only sequences of lowercase letters joined by underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Corrected regex\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains only sequences of lowercase letters joined by underscores.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r\"^([a-z]+_)*[a-z]+$\"  # Matches sequences of lowercase letters joined by underscores\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"  # Matches one or more sequences of lowercase letters joined by underscores.\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 6}]}, "Mbpp/19": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array contains duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array contains duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array contains duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for element in arr:\n        if element in seen:\n            return True\n        seen.add(element)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}]}, "Mbpp/62": {"dps": 31.5, "dps_norm": 36.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n        Raises TypeError if any element in the list is not an int or a float.\n\n    Examples:\n        smallest_num([10, 20, 1, 45, 99]) == 1\n        smallest_num([10.5, 20.2, 1.1, 45.7, 99.9]) == 1.1\n        smallest_num([]) == None\n    \"\"\"\n    if not nums:\n        return None\n\n    for num in nums:\n        if not isinstance(num, (int, float)):\n            raise TypeError(\"List elements must be numbers (int or float)\")\n\n\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n        Raises TypeError if input is not a list or if the list contains non-numeric values.\n    \"\"\"\n\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    if not numbers:\n        return None  # Handle empty list case\n\n    for num in numbers:\n        if not isinstance(num,(int,float)):\n             raise TypeError(\"List elements must be numeric\")\n\n\n    smallest = numbers[0]  # Initialize with the first element\n\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n    \"\"\"\n    if not nums:\n        return None\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n        Raises TypeError if the list contains non-numeric values.\n    \"\"\"\n\n    if not numbers:\n        return None\n\n    smallest = numbers[0]\n    for num in numbers:\n        if not isinstance(num, (int, float)):  # Check for non-numeric values\n            raise TypeError(\"List must contain only numbers.\")\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list of numbers.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list. \n        Returns None if the list is empty.\n        Raises TypeError if any element in the list is not an int or a float.\n    \"\"\"\n    if not nums:\n        return None\n\n    smallest = nums[0]\n    for num in nums:\n        if not isinstance(num, (int, float)):\n            raise TypeError(\"List elements must be numbers (int or float)\")\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n\n    Raises:\n        TypeError: if input is not a list or contains non-numeric values.\n    \"\"\"\n\n    if not isinstance(nums, list):\n        raise TypeError(\"Input must be a list.\")\n    if not nums:\n        return None\n    if not all(isinstance(num, (int, float)) for num in nums):\n        raise TypeError(\"List must contain only numbers.\")\n\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n        Raises TypeError if the list contains non-numeric values.\n    \"\"\"\n    if not numbers:\n        return None\n\n    for num in numbers:\n        if not isinstance(num, (int, float)):\n            raise TypeError(\"List must contain only numbers.\")\n\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty or contains non-numeric elements.\n    \"\"\"\n    if not numbers:\n        return None\n    \n    smallest = numbers[0]\n    for num in numbers:\n        if not isinstance(num,(int,float)): # Handle potential non-numeric input\n            return None\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n    \"\"\"\n    if not nums:\n        return None\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty or None.\n    \"\"\"\n    if not nums:  # Check for empty or None list\n        return None\n\n    smallest = nums[0]  # Initialize with the first element\n\n    for num in nums:\n        if num < smallest:\n            smallest = num\n\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n        Raises TypeError if any element in the list is not an int or a float.\n    \"\"\"\n    if not nums:\n        return None\n\n    smallest = nums[0]\n    for num in nums:\n        if not isinstance(num, (int, float)):\n            raise TypeError(\"List elements must be numbers (int or float)\")\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n        Raises TypeError if the list contains non-numeric values.\n\n    \"\"\"\n\n    if not nums:\n        return None\n\n    smallest = nums[0]\n    for num in nums:\n        if not isinstance(num, (int, float)):\n            raise TypeError(\"List elements must be numbers\")  # Improved error handling\n        if num < smallest:\n            smallest = num\n\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n    \"\"\"\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The smallest number in the list.  Returns float('inf') if the list is empty.\n    \"\"\"\n    if not nums:\n        return float('inf')  # Handle empty list case\n\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n    \"\"\"\n\n    if not nums:\n        return None\n\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Raises ValueError if the list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"List cannot be empty\")\n    \n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n        Raises TypeError if any element in the list is not an int or a float.\n    \"\"\"\n    if not nums:\n        return None\n\n    smallest = nums[0]\n    for num in nums:\n        if not isinstance(num, (int, float)):\n            raise TypeError(\"List elements must be numbers.\")  # Added type checking\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Raises ValueError if the list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List cannot be empty\")\n    \n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty or contains non-numeric values.\n    \"\"\"\n    if not nums:\n        return None\n\n    smallest = nums[0]\n    for num in nums:\n        if not isinstance(num, (int, float)):\n            return None  # Handle non-numeric values\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": -1}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n        Returns None if the list is empty.\n    \"\"\"\n    if not nums:\n        return None\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 95.71428571428572, "dps_norm": 91.66666666666666, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples with all elements divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n        tuples_list: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements in each tuple are divisible by k.\n    \"\"\"\n\n    result = []\n    for tup in tuples_list:\n        is_divisible = True\n        for element in tup:\n            if element % k != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_tuples(list_of_tuples: List[Tuple[int, ...]], k: int) -> List[Tuple[int, ...]]:\n    \"\"\"\n    Finds tuples in which all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples of integers.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for num in tup:\n            if num % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 8}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples satisfying the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples satisfying the condition.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 8}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples satisfying the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples satisfying the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        divisible = True\n        for element in tup:\n            if element % k != 0:\n                divisible = False\n                break\n        if divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples satisfying the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements in each tuple are divisible by k.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_tuples(list_of_tuples: List[Tuple[int, ...]], k: int) -> List[Tuple[int, ...]]:\n    \"\"\"\n    Finds tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 8}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples with all elements divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples satisfying the condition.\n    \"\"\"\n\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples that satisfy the condition.\n    \"\"\"\n    result = []\n    for tup in list_of_tuples:\n        all_divisible = True\n        for element in tup:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    return result", "matching_cluster_idx": 7}]}, "Mbpp/88": {"dps": 49.75490196078431, "dps_norm": 68.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    freq_dict = defaultdict(int)  # Use defaultdict to avoid KeyError\n    for item in input_list:\n        freq_dict[item] += 1\n    return dict(freq_dict)  # Convert back to regular dict for consistent return type", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of elements in a list.\n\n    Args:\n        input_list: The input list.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    freq_dict = defaultdict(int)  # Use defaultdict to avoid KeyError\n    for element in input_list:\n        freq_dict[element] += 1\n    return dict(freq_dict)  # Convert back to regular dict for consistency", "matching_cluster_idx": 3}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list and returns a dictionary.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in input_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    freq_dict = defaultdict(int)  # Use defaultdict to simplify counting\n    for item in input_list:\n        freq_dict[item] += 1\n    return dict(freq_dict) # Convert back to regular dict for assertion", "matching_cluster_idx": 3}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of elements in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in input_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n\n    freq_dict = defaultdict(int)  # Use defaultdict to avoid KeyError\n    for item in input_list:\n        freq_dict[item] += 1\n    return dict(freq_dict)  # Convert back to regular dict for consistency with assert statement", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n\n    freq_dict = defaultdict(int)  # Using defaultdict to simplify counting\n    for element in input_list:\n        freq_dict[element] += 1\n    return dict(freq_dict) # Convert back to a regular dict for compatibility with assert", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef freq_count(data):\n    \"\"\"\n    Calculates the frequency of elements in a list.\n\n    Args:\n        data: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    return dict(Counter(data))", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    frequency = defaultdict(int)  # Initialize a dictionary with default value 0\n    for item in input_list:\n        frequency[item] += 1\n    return dict(frequency)  # Convert back to a regular dict for assertion", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    freq_dict = defaultdict(int)  # Using defaultdict to handle unseen elements\n    for item in input_list:\n        freq_dict[item] += 1\n    return dict(freq_dict)  # Convert back to a regular dictionary", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: The input list.\n\n    Returns:\n        A dictionary where keys are the elements of the list and values are their frequencies.\n    \"\"\"\n\n    freq_dict = defaultdict(int)  # Use defaultdict to simplify counting\n    for item in input_list:\n        freq_dict[item] += 1\n    return dict(freq_dict) # Convert back to regular dict for assertion", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    freq_dict = defaultdict(int)\n    for element in input_list:\n        freq_dict[element] += 1\n    return dict(freq_dict)  # Convert back to a regular dict for the assertion", "matching_cluster_idx": 3}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in input_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the unique elements in the list and values are their frequencies.\n    \"\"\"\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n\n    frequency = {}\n    for item in input_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements in the list and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for item in input_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n\n    freq_dict = defaultdict(int)  # Initialize a dictionary with default value 0\n    for item in input_list:\n        freq_dict[item] += 1\n    return dict(freq_dict) # Convert back to regular dict for stricter assertion", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    frequency = defaultdict(int)  # Use defaultdict to simplify counting\n    for item in input_list:\n        frequency[item] += 1\n    return dict(frequency)  # Convert back to a regular dictionary", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef freq_count(data):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        data: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    freq = defaultdict(int)\n    for item in data:\n        freq[item] += 1\n    return dict(freq)  # Convert back to regular dict for consistent assertion", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef freq_count(input_list):\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        input_list: The input list.\n\n    Returns:\n        A dictionary where keys are the elements of the list and values are their frequencies.\n    \"\"\"\n    frequency = defaultdict(int)\n    for item in input_list:\n        frequency[item] += 1\n    return dict(frequency)  # Convert defaultdict to a regular dict for assertion", "matching_cluster_idx": 3}]}, "Mbpp/90": {"dps": 17.73170731707317, "dps_norm": 52.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n    \"\"\"\n    max_len = 0\n    for word in words:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n        Returns 0 if the list is empty or contains any non-string elements.\n    \"\"\"\n    if not words:\n        return 0\n\n    max_len = 0\n    for word in words:\n        if not isinstance(word, str):\n            return 0  # Handle cases where non-string elements exist\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n    \"\"\"\n    max_len = 0\n    for word in words:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list. Returns 0 if the list is empty or None.\n    \"\"\"\n    if not words:\n        return 0\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n        Returns 0 if the list is empty or contains only empty strings.\n    \"\"\"\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n        Returns 0 if the list is empty or contains only empty strings.\n    \"\"\"\n    if not words:\n        return 0\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n        Returns 0 if the input list is empty or contains non-string elements.\n    \"\"\"\n    if not words or not all(isinstance(word, str) for word in words):\n        return 0\n\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n    \"\"\"\n    max_len = 0\n    for word in words:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest string in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0  # Handle empty list case\n\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0  # Handle empty list case\n\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n    \"\"\"\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0  # Handle empty list case\n\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 3}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n        Returns 0 if the list is empty or contains non-string elements.\n    \"\"\"\n    if not words or not all(isinstance(word, str) for word in words):\n      return 0\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n        Returns 0 if the list is empty or contains non-string elements.\n    \"\"\"\n    if not words:\n        return 0\n    max_len = 0\n    for word in words:\n        if isinstance(word, str):\n            max_len = max(max_len, len(word))\n        else: #Handles cases where the list contains non-string elements gracefully\n            return 0\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n    \"\"\"\n\n    if not words:\n        return 0  # Handle empty list\n\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word in the list.\n    \"\"\"\n    max_len = 0\n    for word in words:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of strings.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    max_len = 0\n    for word in words:\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 2}]}, "Mbpp/94": {"dps": 83.39939024390245, "dps_norm": 73.0, "pass@1": 56.0, "profiled": [{"solution": "def index_minimum(tuples):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples:\n        return None  # Handle empty list case\n\n    min_value = float('inf')\n    min_index = None\n\n    for i in range(len(tuples)):\n        if tuples[i][1] < min_value:\n            min_value = tuples[i][1]\n            min_index = i\n\n    if min_index is not None:\n        return tuples[min_index][0]\n    else:\n        return None  # Handle case where all second values are infinity", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples:\n        return None  # Handle empty list case\n\n    min_tuple = tuples[0]\n    for current_tuple in tuples:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value. \n        Returns None if the input list is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_tuple = tuples[0]\n    for tup in tuples:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples where each tuple contains two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.\n        Returns None if the input list is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_tuple = tuples[0]\n    for tup in tuples:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n        Returns None if the input list is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_value = float('inf')\n    min_index = None\n\n    for i in range(len(tuples)):\n        if tuples[i][1] < min_value:\n            min_value = tuples[i][1]\n            min_index = i\n\n    if min_index is not None:\n        return tuples[min_index][0]\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples:\n        return None  # Handle empty list case\n\n    min_value = float('inf')\n    min_index = None\n\n    for i in range(len(tuples)):\n        if tuples[i][1] < min_value:\n            min_value = tuples[i][1]\n            min_index = i\n    \n    if min_index is not None:\n        return tuples[min_index][0]\n    else:\n        return None  # Should not happen unless the second elements are not comparable", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n        Returns None if the input list is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_tuple = tuples[0]\n    for current_tuple in tuples:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n    \"\"\"\n\n    if not tuples:\n        return None  # Handle empty list case\n\n    min_tuple = tuples[0]\n    for tup in tuples:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples:\n        return None  # Handle empty list case\n\n    min_tuple = tuples[0]\n    for tup in tuples:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"Returns the first value of the tuple with the smallest second value.\"\"\"\n    if not tuples:\n        return None  # Handle empty list case\n\n    min_tuple = tuples[0]\n    for tup in tuples:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples_list:\n        return None  # Handle empty list case\n\n    min_tuple = tuples_list[0]\n    for current_tuple in tuples_list:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n        Returns None if the list of tuples is empty.\n    \"\"\"\n\n    if not tuples:\n        return None\n\n    min_tuple = tuples[0]\n    for tup in tuples:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n        Returns None if the input list is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_index = 0\n    for i in range(1, len(tuples)):\n        if tuples[i][1] < tuples[min_index][1]:\n            min_index = i\n    return tuples[min_index][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n        Returns None if the input list is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_value = float('inf')\n    min_index = None\n\n    for i in range(len(tuples)):\n        if tuples[i][1] < min_value:\n            min_value = tuples[i][1]\n            min_index = i\n\n    if min_index is not None:\n        return tuples[min_index][0]\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n        Returns None if the list is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_value = float('inf')\n    min_index = None\n\n    for i in range(len(tuples)):\n        if tuples[i][1] < min_value:\n            min_value = tuples[i][1]\n            min_index = i\n\n    if min_index is not None:\n        return tuples[min_index][0]\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples:\n        return None  # Handle empty list case\n\n    min_tuple = tuples[0]\n    for tup in tuples:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n        Returns None if the input list is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_tuple = tuples[0]\n    for t in tuples:\n        if t[1] < min_tuple[1]:\n            min_tuple = t\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples where each tuple contains two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.\n        Returns None if the input list is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_value = float('inf')\n    min_index = None\n\n    for i in range(len(tuples)):\n        if tuples[i][1] < min_value:\n            min_value = tuples[i][1]\n            min_index = i\n\n    return tuples[min_index][0] if min_index is not None else None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples:\n        return None  # Handle empty list case\n\n    min_tuple = tuples[0]\n    for tup in tuples:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples where each tuple contains two elements.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n        Returns None if the list of tuples is empty.\n    \"\"\"\n    if not tuples:\n        return None\n\n    min_tuple = tuples[0]\n    for t in tuples:\n        if t[1] < min_tuple[1]:\n            min_tuple = t\n\n    return min_tuple[0]", "matching_cluster_idx": 3}]}, "Mbpp/96": {"dps": 92.49999999999999, "dps_norm": 93.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Handle non-positive input\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i * i != n else 1  # Optimization: count pairs of divisors\n\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer n.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Handle non-positive inputs\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i * i != n else 1  # Optimization for perfect squares\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Optimized to check up to the square root\n        if n % i == 0:\n            count += 2  # Account for both i and n/i as divisors\n    if int(n**0.5)**2 == n:  # If n is a perfect square, adjust count (avoid double counting)\n        count -= 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n < 0:\n        n = -n  # Handle negative numbers\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2  # Account for both i and n/i\n    if int(n**0.5) * int(n**0.5) == n:  # Correct for perfect squares\n        count -= 1\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Handle non-positive inputs\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Optimization: Check up to the square root\n        if n % i == 0:\n            count += 2 if i * i != n else 1 # Add 2 if i is a divisor (and n/i is different), else add 1 if i*i=n\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Or raise an exception for non-positive input\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Optimization: Iterate only up to the square root\n        if n % i == 0:\n            count += 2  # Add 2 because both i and n/i are divisors\n\n    if int(n**0.5) * int(n**0.5) == n:  # If n is a perfect square, adjust count\n        count -= 1\n\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n < 0:\n        n = -n  # Handle negative integers\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2  # Count both i and n/i\n\n    if int(n**0.5) * int(n**0.5) == n: # If n is a perfect square, adjust count\n      count -= 1\n\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Or raise an exception, depending on desired behavior\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Optimization: Iterate only up to the square root\n        if n % i == 0:\n            count += 2  # If i is a divisor, n/i is also a divisor\n\n    if int(n**0.5) * int(n**0.5) == n:  # Correct for perfect squares\n        count -= 1    # Perfect squares have their square root counted twice\n\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer n.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Handle non-positive input\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2  # Account for both i and n/i\n    if int(n**0.5) * int(n**0.5) == n:  # Adjust for perfect squares\n        count -= 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i * i != n else 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n    if n < 0:\n        n = -n  # Handle negative numbers by taking their absolute value\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Optimize by iterating only up to the square root\n        if n % i == 0:\n            count += 2 if i * i != n else 1  # Count both divisors (i and n/i) unless they are the same (perfect square)\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n == 0:\n        return 0  # Or raise an exception, depending on how you want to handle 0.\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i * i != n else 1  # Optimization: Count both divisors at once if not a perfect square\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer n.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Or raise an exception for non-positive input\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Optimize by iterating up to the square root\n        if n % i == 0:\n            count += 2  # Add both i and n/i as divisors\n    \n    if int(n**0.5)**2 == n: # if n is a perfect square, we've counted the square root twice.\n        count -= 1\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer.\n\n    Args:\n      n: The integer for which to find the number of divisors.\n\n    Returns:\n      The number of divisors of n.\n    \"\"\"\n\n    if n < 0:\n        n = -n  # Handle negative numbers\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2  # Add both i and n/i as divisors\n    \n    if int(n**0.5) * int(n**0.5) == n:  # Adjust for perfect squares\n        count -= 1\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Handle non-positive inputs\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Optimize by only checking up to the square root\n        if n % i == 0:\n            count += 2  # Add 2 because both i and n/i are divisors\n\n    if int(n**0.5)**2 == n: # Correct for perfect squares (avoid double counting the square root)\n        count -= 1\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer n.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Handle non-positive input\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i * i != n else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n < 0:\n        n = -n  # Handle negative numbers\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i * i != n else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Handle non-positive inputs\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i * i != n else 1  # Account for perfect squares\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n < 0:\n        n = -n  # Handle negative numbers by taking the absolute value\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):  # Optimization: Iterate up to the square root\n        if n % i == 0:\n            count += 2  # If i is a divisor, n/i is also a divisor\n    if int(n**0.5) * int(n**0.5) == n:  # Correct for perfect squares\n        count -= 1  # Perfect squares have a duplicate divisor (the square root)\n\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    if n <= 0:\n        return 0  # Handle non-positive inputs\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2  # Count both i and n/i as divisors\n            if i * i == n: # if it's a perfect square, correct the overcounting\n                count -= 1\n\n    return count", "matching_cluster_idx": 6}]}, "Mbpp/97": {"dps": 99.93162393162393, "dps_norm": 97.5, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n\n    flat_list = []\n    for lst in list_of_lists:\n        flat_list.extend(lst)\n\n    return dict(Counter(flat_list))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for lst in list_of_lists:\n        flattened_list.extend(lst)\n    \n    return dict(Counter(flattened_list))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = Counter(flattened_list)  # Use Counter for efficient counting\n    return dict(frequency)", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = Counter(flattened_list) # Uses Counter for efficiency\n    return dict(frequency)  # Convert Counter object to a standard dictionary", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = Counter(flattened_list)  # Use Counter for efficient counting\n    return dict(frequency)", "matching_cluster_idx": 7}, {"solution": "from collections import defaultdict\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n    frequency = defaultdict(int)\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n      list_of_lists: A list of lists containing elements.\n\n    Returns:\n      A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n    frequency = defaultdict(int)\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing integers.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n    \n    return dict(Counter(flattened_list))", "matching_cluster_idx": 7}, {"solution": "from collections import defaultdict\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n    freq_dict = defaultdict(int)  # Using defaultdict to handle new elements efficiently\n    for sublist in list_of_lists:\n        for element in sublist:\n            freq_dict[element] += 1\n    return dict(freq_dict)  # Convert defaultdict back to a regular dictionary", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    flat_list = []\n    for lst in list_of_lists:\n        flat_list.extend(lst)\n    \n    return dict(Counter(flat_list))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n\n    flat_list = []\n    for sublist in list_of_lists:\n        flat_list.extend(sublist)\n\n    return dict(Counter(flat_list))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    frequency = Counter(flattened_list)  # Use Counter for efficient frequency counting\n    return dict(frequency)", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flat_list = []\n    for sublist in list_of_lists:\n        flat_list.extend(sublist)\n\n    return dict(Counter(flat_list))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n    \n    frequency = Counter(flattened_list)  # Use Counter for efficient frequency counting\n    return dict(frequency) # converts back to a dictionary as specified\nlist_of_lists = [[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]\nfrequency = frequency_lists(list_of_lists)", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    flattened_list = []\n    for lst in list_of_lists:\n        flattened_list.extend(lst)\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n    flat_list = []\n    for sublist in list_of_lists:\n        flat_list.extend(sublist)\n    \n    return dict(Counter(flat_list))", "matching_cluster_idx": 7}, {"solution": "from collections import defaultdict\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n    frequency = defaultdict(int)\n    for sub_list in list_of_lists:\n        for num in sub_list:\n            frequency[num] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists containing elements.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n    flattened_list = []\n    for lst in list_of_lists:\n        flattened_list.extend(lst)\n    \n    return dict(Counter(flattened_list))", "matching_cluster_idx": 7}]}, "Mbpp/106": {"dps": 43.44155844155844, "dps_norm": 77.5, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        lst: The list to append.\n        tpl: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple and returns a new tuple.\n\n    Args:\n        lst: The list to append.\n        tpl: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple and returns the combined tuple.\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_add, original_tuple):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to append.\n        original_tuple: The original tuple.\n\n    Returns:\n        A new tuple with the list's elements appended to the original tuple.\n    \"\"\"\n    return original_tuple + tuple(list_to_add)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple and returns the combined tuple.\"\"\"\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        lst: The list to append.\n        tpl: The tuple to append to.\n\n    Returns:\n        A new tuple with the list's elements appended to the original tuple.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        lst: The list to append.\n        tpl: The tuple to append to.\n\n    Returns:\n        A new tuple with the elements of the tuple followed by the elements of the list.\n    \"\"\"\n\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple and returns the result as a tuple.\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        lst: The list to append.\n        tpl: The tuple to which the list is appended.\n\n    Returns:\n        A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple and returns a new tuple.\"\"\"\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        lst: The list to append.\n        tpl: The tuple to append to.\n\n    Returns:\n        A new tuple with the list's elements appended.\n    \"\"\"\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        lst: The list to append.\n        tpl: The tuple to append to.\n\n    Returns:\n        A new tuple with the list elements added to the end of the tuple.\n    \"\"\"\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple and returns the combined tuple.\"\"\"\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list_to_add, tuple_to_extend):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        list_to_add: The list to be appended.\n        tuple_to_extend: The tuple to be extended.\n\n    Returns:\n        A new tuple containing elements of the original tuple followed by elements of the list.\n    \"\"\"\n    return tuple_to_extend + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n        lst: The list to append.\n        tpl: The tuple to append to.\n\n    Returns:\n        A new tuple with the list appended.\n    \"\"\"\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple, returning a new tuple.\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, input_tuple):\n    \"\"\"Appends a list to a tuple and returns the combined tuple.\n\n    Args:\n        list_to_add: The list to append.\n        input_tuple: The tuple to which the list will be appended.\n\n    Returns:\n        A new tuple containing the elements of the original tuple followed by \n        the elements of the list.\n    \"\"\"\n\n    return input_tuple + tuple(list_to_add)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple and returns a new tuple.\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_add, input_tuple):\n    \"\"\"Appends a list to a tuple and returns the result as a new tuple.\n\n    Args:\n        list_to_add: The list to append.\n        input_tuple: The tuple to append to.\n\n    Returns:\n        A new tuple containing the elements of the original tuple followed by the\n        elements of the list.\n    \"\"\"\n    new_tuple = input_tuple + tuple(list_to_add)\n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple and returns a new tuple.\n\n    Args:\n        lst: The list to append.\n        tpl: The tuple to append to.\n\n    Returns:\n        A new tuple containing the elements of the tuple followed by the elements of the list.\n    \"\"\"\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()  # Sorts the merged list in-place\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]\nmerged_list = merge_sorted_list(list1, list2, list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()  # Sorts the combined list in-place\n    return merged_list\nlist1 = [25, 24, 15, 4, 5, 29, 110]\nlist2 = [19, 20, 11, 56, 25, 233, 154]\nlist3 = [24, 26, 54, 48]", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 90.64615384615385, "dps_norm": 85.625, "pass@1": 100.0, "profiled": [{"solution": "from functools import reduce\ndef common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists.\n\n    Returns:\n        A list containing the elements that are present in all the input lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the lists to sets for efficient intersection\n    sets = [set(lst) for lst in nested_lists]\n\n    # Use reduce to find the intersection of all sets\n    common_elements = list(reduce(lambda x, y: x.intersection(y), sets))\n\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of integers representing the common elements.\n    \"\"\"\n\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection operations.\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and update the common elements set.\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of integers that are common to all the input lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of integers that are common to all lists.\n    \"\"\"\n\n    if not nested_lists:\n        return []\n    \n    # Convert lists to sets for efficient intersection\n    sets = [set(lst) for lst in nested_lists]\n\n    # Find the intersection of all sets\n    common_elements = sets[0].intersection(*sets[1:])\n\n    return list(common_elements)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n      nested_lists: A list of lists of integers.\n\n    Returns:\n      A list of integers that are common to all the nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in a list of nested lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of integers that are common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set for efficient lookups\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists\n    for lst in nested_lists[1:]:\n        # Update common_elements with the intersection of the current list and common_elements\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in a list of nested lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of integers representing the common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of integers containing the common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list containing the common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of nested lists.\n\n    Args:\n        nested_lists: A list of lists.\n\n    Returns:\n        A list containing the common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and update the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of integers containing the common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)  # More efficient than &=\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of nested lists.\n\n    Args:\n        nested_lists: A list of lists.\n\n    Returns:\n        A list containing the common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining nested lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)  # Efficiently finds the intersection\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of nested lists.\n\n    Args:\n        nested_lists: A list of lists.\n\n    Returns:\n        A list containing the elements that are present in all nested lists.\n    \"\"\"\n\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and update the common elements\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of integers representing the common elements.\n    \"\"\"\n\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of nested lists.\n\n    Args:\n        nested_lists: A list of lists.\n\n    Returns:\n        A list containing the elements that are present in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection operations\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and update the common elements set\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in a list of nested lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list containing the common elements.\n    \"\"\"\n\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection operations\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and update the common_elements set\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of integers representing the common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set for efficient intersection\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in a list of nested lists.\n\n    Args:\n      nested_lists: A list of lists of integers.\n\n    Returns:\n      A list of integers that are common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection operations\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in a list of lists.\n\n    Args:\n        nested_lists: A list of lists.\n\n    Returns:\n        A list containing the elements that are present in all sublists.\n    \"\"\"\n\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection operations\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and update the common elements set\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists of integers.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 84.0, "profiled": [{"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:  # Avoid double-counting for square roots\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    sum_amicable = 0\n    amicable_nums = set()  # Use a set to avoid double counting amicable pairs\n\n    for num in range(2, limit + 1):\n        if num not in amicable_nums:  # Check if already part of an amicable pair\n            sum_div_num = sum_proper_divisors(num)\n            sum_div_other = sum_proper_divisors(sum_div_num)\n            if num == sum_div_other and num != sum_div_num:  # Amicable pair found\n                sum_amicable += num\n                if sum_div_num <= limit:  # Check if the other number is within the limit\n                    sum_amicable += sum_div_num\n                amicable_nums.add(num)\n                amicable_nums.add(sum_div_num)\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double counting and including n itself\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a given limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Keep track of checked numbers to avoid redundant calculations\n\n    for num in range(2, limit + 1):\n        if num in checked:\n            continue\n\n        div_sum = sum_proper_divisors(num)\n        div_sum2 = sum_proper_divisors(div_sum)\n\n        if num == div_sum2 and num != div_sum:  # Amicable numbers are not equal to their divisor sum\n            amicable_sum += num\n            if div_sum <= limit: # Ensure both amicable numbers are within the limit.\n                amicable_sum += div_sum\n            checked.add(num)  # Add the discovered amicable pair to avoid recalculations\n            checked.add(div_sum)\n\n    return amicable_sum\nlimit = 10000", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Keep track of checked numbers to avoid double counting\n    for num in range(2, limit + 1):\n        if num in checked:\n            continue\n        sum1 = sum_of_divisors(num)\n        sum2 = sum_of_divisors(sum1)\n\n        if num == sum2 and num != sum1:  # Amicable numbers and not perfect numbers\n            amicable_sum += num\n            if sum1 <= limit:  # Only add the pair if both are within the limit\n                amicable_sum += sum1\n            checked.add(num)\n            checked.add(sum1)\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n:  # Avoid adding the same divisor twice for perfect squares\n                total += n // i\n    return total - n  # Subtract the number itself to get the sum of proper divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculate the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Keep track of checked numbers to avoid double counting\n\n    for num in range(1, limit + 1):\n        if num in checked:\n            continue\n\n        sum1 = sum_divisors(num)\n        sum2 = sum_divisors(sum1)\n\n        if num == sum2 and num != sum1:  # Amicable numbers and not perfect numbers\n            amicable_sum += num\n            if sum1 <= limit:  # Add the other amicable pair only if it is within the limit\n                amicable_sum += sum1\n\n        checked.add(num)  # Mark both numbers as checked (as they form a pair or one is not amicable)\n        if sum1 <= limit and sum1 != num: # Avoids unnecessary rechecking of higher numbers later\n            checked.add(sum1)\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double counting and including the number itself\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a given limit.\"\"\"\n    amicable_sum = 0\n    checked = set() # Optimization: Keep track of checked numbers to avoid redundant calculations\n\n    for num in range(1, limit + 1):\n        if num not in checked:\n            sum1 = sum_of_divisors(num)\n            sum2 = sum_of_divisors(sum1)\n\n            if num == sum2 and num != sum1: # Amicable numbers are different but their divisor sums match\n                amicable_sum += num\n                if sum1 <= limit: # Only add sum1 if it's within the limit\n                    amicable_sum += sum1\n\n            checked.add(num)\n            checked.add(sum1)\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid adding the number itself and double-counting the square root\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Keep track of checked numbers to avoid double-counting\n\n    for num in range(1, limit + 1):\n        if num not in checked:\n            sum1 = sum_proper_divisors(num)\n            sum2 = sum_proper_divisors(sum1)\n\n            if num == sum2 and num != sum1:  # Amicable numbers are different but have matching divisor sums\n                amicable_sum += num\n                if sum1 <= limit: # Only add sum1 if it's within the limit\n                    amicable_sum += sum1\n\n            checked.add(num)\n            checked.add(sum1)  # Add sum1 to avoid redundant checks\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    sum_divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i * i != n and i != 1:  # Avoid double counting and including the number itself\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a given limit.\"\"\"\n    amicable_sum = 0\n    amicable_found = set() # Keep track of amicable pairs to avoid double counting\n\n    for num in range(1, limit + 1):\n        if num in amicable_found:\n            continue  # Skip numbers that are already part of an amicable pair\n\n        sum_div_num = sum_proper_divisors(num)\n        sum_div_other = sum_proper_divisors(sum_div_num)\n\n        if num == sum_div_other and num != sum_div_num: # Amicable and not perfect numbers\n            amicable_sum += num\n            amicable_found.add(num)\n            if sum_div_num <= limit: # only add the other amicable number if it's within the limit\n                amicable_sum += sum_div_num\n                amicable_found.add(sum_div_num)\n\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double counting and adding the number itself\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers under a given limit.\"\"\"\n    amicable_sum = 0\n    checked = set() # Keep track of checked numbers to avoid redundant calculations\n    for num in range(1, limit + 1):\n        if num not in checked:\n            sum1 = sum_of_proper_divisors(num)\n            sum2 = sum_of_proper_divisors(sum1)\n\n            if num == sum2 and num != sum1:  # Amicable numbers and not perfect numbers\n                amicable_sum += num\n                if sum1 < limit: # Only add sum1 if it's within the limit\n                  amicable_sum += sum1\n                checked.add(num)\n                checked.add(sum1)\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double counting and exclude the number itself\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Keep track of checked numbers to avoid redundant calculations and double counting\n\n    for num in range(2, limit + 1):\n        if num not in checked:\n            sum1 = sum_divisors(num)\n            sum2 = sum_divisors(sum1)\n\n            if num == sum2 and num != sum1:  # Amicable numbers are not equal to themselves\n                amicable_sum += num\n                if sum1 <= limit:  # Only add sum1 if it's within the limit\n                    amicable_sum += sum1\n\n            checked.add(num)  # Add num to checked regardless of whether it is amicable or not\n            checked.add(sum1)  # Mark the other paired number\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double counting and including the number itself\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        sum1 = sum_of_divisors(num)\n        sum2 = sum_of_divisors(sum1)\n        if sum2 == num and sum1 != num:  # Ensure they are amicable and not perfect numbers\n            amicable_sum += num  # Only add once to prevent double counting since amicable pairs will be found twice\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if n // i != i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    sum_amicable = 0\n    checked = set()  # Keep track of checked numbers to avoid duplicates\n    for num1 in range(2, limit + 1):\n        if num1 not in checked:\n            num2 = sum_proper_divisors(num1)\n            if num1 != num2 and num2 <= limit and sum_proper_divisors(num2) == num1:\n                sum_amicable += num1 + num2\n                checked.add(num1)\n                checked.add(num2)\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n:\n                total += n // i\n    return total - n  # Exclude the number itself\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculate the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Keep track of checked numbers to avoid double counting\n\n    for num in range(1, limit + 1):\n        if num in checked:\n            continue\n\n        sum1 = sum_of_divisors(num)\n        sum2 = sum_of_divisors(sum1)\n\n        if num == sum2 and num != sum1:  # Amicable pair found\n            amicable_sum += num\n            if sum1 <= limit:\n                amicable_sum += sum1\n            checked.add(num)\n            checked.add(sum1)\n\n    return amicable_sum\nlimit = 2000", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid adding the number itself and double-counting perfect squares\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Use a set to avoid double-counting amicable pairs\n    for num in range(1, limit + 1):\n        if num not in checked:\n            sum_div_num = sum_proper_divisors(num)\n            sum_div_pair = sum_proper_divisors(sum_div_num)\n            if num == sum_div_pair and num != sum_div_num:  # Check for amicable pair and avoid perfect numbers\n                amicable_sum += num + sum_div_num\n                checked.add(num)\n                checked.add(sum_div_num)  # Add both numbers to the checked set\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i and i != 1:  # Avoid double counting and including the number itself\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    checked = set() # Keep track of checked numbers to avoid redundant calculations\n\n    for num in range(2, limit + 1):\n        if num in checked:\n            continue\n\n        sum1 = sum_divisors(num)\n        sum2 = sum_divisors(sum1)\n\n        if num == sum2 and num != sum1:  # Amicable numbers and not perfect numbers\n            amicable_sum += num\n            if sum1 <= limit: # only add sum1 if its within the limit.\n                amicable_sum += sum1\n\n        checked.add(num)\n        checked.add(sum1)\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double counting and include 1\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a given limit.\"\"\"\n    amicable_sum = 0\n    checked = set() # Keep track of already checked pairs\n\n    for num1 in range(1, limit + 1):\n        if num1 in checked:\n            continue\n\n        num2 = sum_divisors(num1)\n        if num1 != num2 and sum_divisors(num2) == num1:\n            if num2 <= limit: # Make sure both numbers are within the limit\n                amicable_sum += num1 + num2\n                checked.add(num1)\n                checked.add(num2)\n            elif num1 <= limit:  # Handle the case when num2 is greater than the limit\n                amicable_sum += num1\n                checked.add(num1)\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double-counting and exclude the number itself\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        sum1 = sum_divisors(num)\n        sum2 = sum_divisors(sum1)\n        if sum2 == num and sum1 != num:  # Check for amicable pair and avoid perfect numbers\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n:  # Avoid double counting for perfect squares\n                total += n // i\n    return total - n  # Exclude the number itself\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a given limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Keep track of checked numbers to avoid duplicates\n\n    for a in range(1, limit + 1):\n        if a not in checked:\n            b = sum_of_divisors(a)\n            if b != a and sum_of_divisors(b) == a:  # Check for amicable pair\n                amicable_sum += a\n                if b <= limit:  # Add b only if within the limit\n                    amicable_sum += b\n                checked.add(a)\n                checked.add(b)\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double-counting and include 1 only once.\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Use a set to avoid checking pairs twice\n\n    for num in range(1, limit + 1):\n        if num not in checked:\n            sum1 = sum_of_divisors(num)\n            sum2 = sum_of_divisors(sum1)\n\n            if sum2 == num and sum1 != num:  # Check for amicable pair and avoid perfect numbers\n                amicable_sum += num\n                if sum1 <= limit: # Only include sum1 if within the limit\n                    amicable_sum += sum1\n                checked.add(num)\n                checked.add(sum1)\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double counting and include 1 only if n is 1\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculates the sum of all amicable numbers up to a given limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        sum1 = sum_proper_divisors(num)\n        sum2 = sum_proper_divisors(sum1)\n        if sum2 == num and sum1 != num:  # Check for amicable pair and avoid self-amicable numbers\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number.\"\"\"\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i * i != n and i != 1:  # Avoid double counting and include 1 only if n==1\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculate the sum of all amicable numbers up to a limit.\"\"\"\n    amicable_sum = 0\n    checked = set()  # Keep track of checked numbers to avoid redundant calculations\n\n    for num in range(2, limit + 1): # Start from 2, as 1 is not considered amicable\n        if num not in checked:\n            sum1 = sum_divisors(num)\n            sum2 = sum_divisors(sum1)\n\n            if num == sum2 and num != sum1:  # Amicable numbers are not equal to themselves\n                amicable_sum += num\n                if sum1 <= limit: # Only add if within limit\n                    amicable_sum += sum1\n                checked.add(num)\n                checked.add(sum1)\n\n    return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, str):\n    \"\"\"\n    Finds words longer than n characters in a given string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = str.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str1: The input string containing words.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = str1.split()\n    long_word_list = []\n    for word in words:\n        if len(word) > n:\n            long_word_list.append(word)\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef long_words(n, str):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str: The input string containing words.\n\n    Returns:\n        A list of words longer than n characters.\n\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    >>> long_words(4, \"the quick brown fox jumps over the lazy dog\")\n    ['quick', 'brown', 'jumps']\n    >>> long_words(5, \"hello world\")\n    ['hello', 'world']\n    >>> long_words(6, \"hello world\")\n    []\n    >>> long_words(0, \"\")\n    []\n    \"\"\"\n    words = str.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words that are longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be returned.\n        sentence: A string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n.\n    \"\"\"\n    words = sentence.split()\n    long_word_list = []\n    for word in words:\n        if len(word) > n:\n            long_word_list.append(word)\n    return long_word_list\nsentence = \"this is a test sentence with some long and short words\"\nn = 4", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Finds words longer than n characters in a given text.\n\n    Args:\n        n: The minimum length of words to be returned.\n        text: The input text string.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = text.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list\ntext = \"This is a sample sentence with some words.\"\nn = 4", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str1: The input string containing words.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    word_list = str1.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = str.split()\n    long_word_list = []\n    for word in words:\n        if len(word) > n:\n            long_word_list.append(word)\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str_words):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str_words: The string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n.\n    \"\"\"\n    words = str_words.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = str.split()\n    long_word_list = []\n    for word in words:\n        if len(word) > n:\n            long_word_list.append(word)\n    return long_word_list\nn = 3", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    \"\"\"\n    Finds words longer than n characters in a given string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str1: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words from the input string that are longer than n characters.\n    \"\"\"\n    word_list = []\n    words = str1.split()\n    for word in words:\n        if len(word) > n:\n            word_list.append(word)\n    return word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str: The input string containing words.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = str.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    \"\"\"\n    Finds words longer than n characters in a given string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str1: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words from the input string that are longer than n characters.\n    \"\"\"\n    word_list = str1.split()\n    long_word_list = []\n    for word in word_list:\n        if len(word) > n:\n            long_word_list.append(word)\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    \"\"\"\n    Finds words longer than n characters in a given string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str1: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words from the input string that are longer than n characters.\n    \"\"\"\n    word_list = []\n    words = str1.split()\n    for word in words:\n        if len(word) > n:\n            word_list.append(word)\n    return word_list", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef long_words(n, str1):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str1: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words from str1 that are longer than n characters.\n\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    >>> long_words(4, \"the quick brown fox jumps over the lazy dog\")\n    ['quick', 'brown', 'jumps']\n    >>> long_words(5, \"hello world test\")\n    ['hello', 'world']\n    >>> long_words(0, \"\")\n    []\n    \"\"\"\n    word_list = str1.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    \"\"\"\n    Finds words longer than n characters in a given string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str1: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = str1.split()\n    long_word_list = []\n    for word in words:\n        if len(word) > n:\n            long_word_list.append(word)\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = str.split()\n    long_word_list = []\n    for word in words:\n        if len(word) > n:\n            long_word_list.append(word)\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = str.split()\n    result = [word for word in words if len(word) > n]\n    return result\nn = 4", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef long_words(n, str):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str: The input string containing words separated by spaces.\n\n    Returns:\n        A list of words longer than n.\n\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    >>> long_words(4, \"the quick brown fox jumps over the lazy dog\")\n    ['quick', 'brown', 'jumps']\n    >>> long_words(5, \"hello world\")\n    ['hello', 'world']\n    >>> long_words(6, \"short words only\")\n    []\n    \"\"\"\n    words = str.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    \"\"\"\n    Finds words longer than n characters in a string.\n\n    Args:\n        n: The minimum length of words to be returned.\n        str: The input string containing words.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = str.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef long_words(n, str):\n    \"\"\"\n    Returns a list of words longer than n from a given string.\n\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    >>> long_words(4, \"the quick brown fox jumps over the lazy dog\")\n    ['quick', 'brown', 'jumps']\n    >>> long_words(5, \"one two three four five six\")\n    ['three']\n    >>> long_words(0, \"\")\n    []\n    >>> long_words(2, \"a bc def\")\n    ['def']\n\n    \"\"\"\n    words = str.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 79.6938775510204, "dps_norm": 97.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    A magic square is a square matrix of numbers where the sum of the numbers in each row, each column, and both main diagonals is the same.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):  # Check if it's a square matrix\n        return False\n\n    magic_sum = sum(matrix[0])  # Calculate the magic sum from the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    # Check if the matrix is square\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the magic sum (from the first row)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False\n\n    # Calculate the magic sum from the first row\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic sum (sum of the first row)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check secondary diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    # Calculate the magic sum from the first row\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n    for row in matrix:\n        if len(row) != n:\n            return False # Not a square matrix\n\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    # Calculate the magic sum from the first row\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False  # Not a square matrix\n\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    magic_sum = sum(matrix[0]) # Calculate the sum of the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check secondary diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    # Calculate the magic constant (sum of first row)\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diag1_sum = 0\n    diag2_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n        diag2_sum += matrix[i][n - 1 - i]\n\n    if diag1_sum != magic_constant or diag2_sum != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of each row, each column, and both main diagonals are equal.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    for row in matrix:\n        if len(row) != n:\n            return False  # Not a square matrix\n\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    # Calculate the magic sum from the first row\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False\n\n    # Calculate the magic sum from the first row\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic sum (sum of the first row)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check secondary diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check secondary diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix is not a magic square\n\n    # Calculate the magic sum from the first row\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal\n    diag_sum1 = 0\n    for i in range(n):\n        diag_sum1 += matrix[i][i]\n    if diag_sum1 != magic_sum:\n        return False\n\n    # Check anti-diagonal\n    diag_sum2 = 0\n    for i in range(n):\n        diag_sum2 += matrix[i][n - 1 - i]\n    if diag_sum2 != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 99.10313901345292, "dps_norm": 83.33333333333333, "pass@1": 99.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(items):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        items: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not items:\n        return None  # Handle empty list case\n\n    counts = Counter(items)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_item = None\n    max_count = 0\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(items):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        items: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not items:\n        return None  # Handle empty list case\n\n    counts = Counter(items)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"Finds the item with maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_item = None\n    max_count = 0\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"Finds the item with maximum frequency in a given list.\n\n    Args:\n      data: A list of items.\n\n    Returns:\n      The item with the maximum frequency.  If there are multiple items\n      with the same maximum frequency, the function returns the first \n      one encountered.\n    \"\"\"\n    if not data:\n        return None\n\n    counts = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(items):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Args:\n        items: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not items:\n        return None  # Handle empty list\n\n    counts = Counter(items)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_item = None\n    max_count = 0\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_item = None\n    max_count = 0\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(items):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        items: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not items:\n        return None  # Handle empty list case\n\n    counts = Counter(items)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not input_list:\n        return None  # Handle empty list case\n\n    count = Counter(input_list)\n    max_freq_item = None\n    max_freq = 0\n\n    for item, freq in count.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_freq_item = item\n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not data:\n        return None  # Handle empty list case\n\n    counts = Counter(data)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not input_list:\n        return None  # Handle empty list case\n\n    count = Counter(input_list)\n    max_count = 0\n    max_item = None\n\n    for item, freq in count.items():\n        if freq > max_count:\n            max_count = freq\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(items):\n    \"\"\"\n    Finds the item with the maximum frequency in a list.\n\n    Args:\n        items: A list of items.\n\n    Returns:\n        The item with the maximum frequency.\n    \"\"\"\n    if not items:\n        return None  # Handle empty list case\n\n    counts = Counter(items)\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 4}]}, "Mbpp/137": {"dps": 43.44086021505375, "dps_norm": 56.666666666666664, "pass@1": 15.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes as a float.  Returns 0.0 if the array is empty \n        or contains only zeroes. Returns float('inf') if the array contains no zeroes.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    if not arr:\n        return 0.0  # Handle empty array\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n\n    if non_zeroes == 0 and zeroes > 0:\n        return float('inf') # Handle case where there are only zeroes\n    elif non_zeroes == 0 and zeroes == 0:\n        return 0.0 # Handle empty list case consistently\n    elif zeroes == 0:\n        return 0.0  # Handle case where there are no zeroes\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes as a float.  \n        Returns 0.0 if the array is empty or contains only zeroes.\n        Returns float('inf') if the array contains no zeroes.\n\n\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n\n    if len(arr) == 0 or non_zeroes == 0:\n        if zeroes == 0:\n             return 0.0  # Handles empty or all-zero case to avoid ZeroDivisionError\n        else:\n            return float('inf') # Return infinity if there are no non-zero elements\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes, or 0 if the array is empty or contains only zeroes.\n        Returns float('inf') if there are no non-zero elements but there are zero elements.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    if not arr:\n        return 0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n\n    if non_zeroes == 0:\n        if zeroes > 0:\n            return float('inf')\n        else:\n            return 0  # Empty array case\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes, or 0 if the array is empty or contains only zeroes.\n        Returns float('inf') if the array contains no zeros but other elements.\n\n    Raises:\n        TypeError: If input is not a list or if any element in the list is not an integer.\n    \"\"\"\n\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    for num in arr:\n        if not isinstance(num, int):\n            raise TypeError(\"All elements in the list must be integers.\")\n\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n\n    if len(arr) == 0 or non_zeroes == 0:\n      if zeroes > 0:\n        return float('inf') # All elements are zero, so technically infinite ratio\n      else: # List is empty\n        return 0\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes as a float, or 0.0 if the array is empty or contains only zeroes.\n        Returns math.inf if the array contains no zeroes but other elements.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n\n    if not arr:\n        return 0.0  # Handle empty array\n    elif non_zeroes == 0:\n      if zeroes == 0:\n        return 0.0 # Handle array with only zeroes (avoid division by zero)\n      else:\n        return math.inf # Handle array with only zeros\n    else:\n      if zeroes == 0:\n          return 0.0\n      else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes, or 0 if the array is empty or contains only zeroes.\n        Returns float('inf') if there are no non-zero elements.\n\n    Raises:\n        TypeError: If input is not a list or any element in the list is not an integer.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    for element in arr:\n        if not isinstance(element, int):\n            raise TypeError(\"Elements in the list must be integers.\")\n\n    zero_c = arr.count(0)\n    non_zero_c = len(arr) - zero_c\n\n    if len(arr) == 0:\n        return 0\n    elif non_zero_c == 0:\n        return float('inf')  # Handle case where there are no non-zero elements\n    else:\n        return zero_c / non_zero_c", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeros to non-zeros in an integer array.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeros to non-zeros as a float. Returns 0.0 if the array is empty \n        or contains only zeros. Returns math.inf if the array contains no zeros.\n\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    if not arr:\n        return 0.0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    \n    if non_zeroes == 0:\n      if zeroes == 0:\n        return 0.0\n      else:\n        return math.inf\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes as a float. \n        Returns 0.0 if the array is empty or contains only zeroes.\n        Returns float('inf') if the array contains no zeroes.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    \n    if len(arr) == 0 or non_zeroes == 0:\n      if zeroes > 0:\n        return float('inf') # Technically correct, but might be better to handle differently depending on use case\n      else:\n        return 0.0 #  Handles empty list\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeros to non-zeros in an integer array.\n\n    Args:\n        arr: An array (list) of integers.\n\n    Returns:\n        The ratio of zeros to non-zeros, or 0 if the array is empty.\n        Returns float('inf') if the array contains no non-zero elements.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n\n    if non_zeroes == 0:\n        return float('inf')  # Handle the case where there are no non-zero elements.\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes as a float. \n        Returns 0.0 if the array is empty or contains only zeroes.\n        Returns float('inf') if the array contains no zeroes.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n\n    if len(arr) == 0 or non_zeroes == 0:\n        if zeroes > 0:\n            return float('inf')  # Infinite ratio if all elements are zeroes but the array is not empty\n        else:\n            return 0.0\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes as a float, or 0.0 if the array is empty or contains only zeroes.\n        Returns math.inf if the array contains no zeroes.\n    \"\"\"\n    if not arr:\n        return 0.0\n\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n\n    if non_zeroes == 0:\n      if zeroes == 0:\n        return 0.0\n      else:\n        return math.inf  # or raise ZeroDivisionError, depending on desired behavior\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeros to non-zeros in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeros to non-zeros, or 0 if the array is empty or contains only zeros.\n        Returns math.inf if there are no non-zero elements.\n    \"\"\"\n    if not arr:\n        return 0\n\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n\n    if non_zeroes == 0:\n       if zeroes == 0:\n           return 0\n       else:\n           return math.inf\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes as a float. Returns 0 if the array is empty or contains only zeros.\n        Returns float('inf') if the array contains no zeros.\n\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n\n    if len(arr) == 0 or non_zeroes == 0:\n       if zeroes > 0:\n           return float('inf')  # Infinite ratio if only zeros but not empty\n       else:\n           return 0 # Zero ratio if empty or all zeroes\n\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes, or 0 if the array is empty or contains only zeroes.\n        Returns float('inf') if the array contains no zeroes but other elements.\n\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    \n    if len(arr) == 0 or non_zeroes == 0:\n      if zeroes == 0:\n        return 0  # Empty array or all elements are non-zero. Should return 0 for consistency.\n      else:\n        # This accounts for edge case when only zeros exist; technically the ratio approaches infinity. \n        # Python's math.isclose() doesn't handle comparing to infinity directly.\n        return float('inf')\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeros to non-zeros in an integer array.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeros to non-zeros as a float. Returns 0.0 if the array is empty \n        or contains only zeros. Returns float('inf') if the array contains no zeros.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    if not arr:\n        return 0.0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    \n    if non_zeroes == 0:\n        if zeroes == 0:\n            return 0.0\n        else:\n            return float('inf') # Or raise an exception if infinite ratio is undesirable\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 3}]}, "Mbpp/140": {"dps": 8.416149068322982, "dps_norm": 51.875, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is an iterable of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n\n    result_set = set()\n    for inner_list in list_of_lists:\n        for number in inner_list:\n            result_set.add(number)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list containing lists or tuples of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input lists.\n    \"\"\"\n\n    result_set = set()\n    for inner_list in list_of_lists:\n        for item in inner_list:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) of numbers into a single list of numbers.\n\n    Args:\n        list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n        A list containing all the numbers from the input lists/tuples.\n    \"\"\"\n    result = []\n    for inner_list in list_of_lists:\n        for item in inner_list:\n            result.append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set.\n\n    Args:\n        list_of_lists: A list where each element is an iterable of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is an iterable of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n      list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n      A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for item in inner_list:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n      list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n      A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n\n    result_set = set()\n    for inner_list in list_of_lists:\n        for number in inner_list:\n            result_set.add(number)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of iterables (lists, tuples, etc.) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is an iterable of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of iterables.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for element in inner_list:\n            result_set.add(element)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is either a list or tuple of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) of numbers into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list containing lists or tuples of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n\n    result_set = set()\n    for inner_list in list_of_lists:\n        for item in inner_list:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is an iterable of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n\n    result_set = set()\n    for inner_list in list_of_lists:\n        for number in inner_list:\n            result_set.add(number)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) of numbers into a single set.\n\n    Args:\n        list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list of lists or tuples containing numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for number in inner_list:\n            result_set.add(number)\n    return result_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) of numbers into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is an iterable of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is a list or tuple of numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n\n    result_set = set()\n    for inner_list in list_of_lists:\n        for num in inner_list:\n            result_set.add(num)\n    return result_set", "matching_cluster_idx": 3}]}, "Mbpp/141": {"dps": 57.18820861678005, "dps_norm": 38.75, "pass@1": 60.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\"\"\"\n\n    def flip(arr, k):\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    for curr_size in range(n, 0, -1):\n        mi = arr.index(max(arr[:curr_size]))\n\n        if mi != curr_size - 1:\n            flip(arr, mi)\n            flip(arr, curr_size - 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of a list.\"\"\"\n        return arr[:k][::-1] + arr[k:]\n\n    n = len(arr)\n    for i in range(n - 1, -1, -1):\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        if max_index != i:\n            arr = flip(arr, max_index + 1)\n            arr = flip(arr, i + 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        arr[:k] = arr[:k][::-1]\n\n    for i in range(len(arr) - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Bring the maximum element to the beginning\n        flip(arr, max_index + 1)\n\n        # Bring the maximum element to its correct position\n        flip(arr, i + 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the order of elements in arr up to index k.\"\"\"\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    for i in range(n - 1, -1, -1):\n        # Find the index of the maximum element in arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Move the maximum element to the beginning of arr[0...i]\n        if max_index != 0:\n            flip(arr, max_index)\n\n        # Move the maximum element to its correct sorted position at the end of arr[0...i]\n        flip(arr, i)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the order of the first k elements in the list.\"\"\"\n        return arr[:k][::-1] + arr[k:]\n\n    n = len(arr)\n    for i in range(n - 1, -1, -1):\n        # Find the index of the maximum element in arr[:i+1]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Bring the maximum element to the beginning\n        arr = flip(arr, max_index + 1)\n\n        # Bring the maximum element to its correct position\n        arr = flip(arr, i + 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of a list.\"\"\"\n        return arr[:k][::-1] + arr[k:]\n\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Flip the array from 0 to max_index to bring the max element to the beginning\n        arr = flip(arr, max_index + 1)\n\n        # Flip the array from 0 to i to bring the max element to its correct position\n        arr = flip(arr, i + 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        arr[:k] = arr[:k][::-1]\n\n    n = len(arr)\n    for i in range(n - 1, -1, -1):\n        # Find the maximum element in arr[:i+1]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Move the maximum element to the beginning\n        if max_index != 0:\n            flip(arr, max_index + 1)\n\n        # Move the maximum element to its correct position\n        flip(arr, i + 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        mi = arr.index(max(arr[:curr_size]))\n\n        # Move the maximum element to the beginning\n        if mi != 0:\n            flip(arr, mi)\n\n        # Move the maximum element to its correct sorted position\n        flip(arr, curr_size - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list of elements using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        return arr[:k][::-1] + arr[k:]\n\n    def find_max(arr, n):\n        \"\"\"Finds the index of the maximum element in the first n elements.\"\"\"\n        mi = 0\n        for i in range(0, n):\n            if arr[i] > arr[mi]:\n                mi = i\n        return mi\n\n    n = len(arr)\n    while n > 1:\n        mi = find_max(arr, n)\n        if mi != n - 1:\n            arr = flip(arr, mi + 1)  # Bring max to the beginning\n            arr = flip(arr, n)  # Bring max to its correct position\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in \n        # arr[0..curr_size-1]\n        mi = arr.index(max(arr[:curr_size]))\n\n        # Move the maximum element to end of current size subarray\n        if mi != curr_size - 1:\n            # To move at the end, first move maximum number to beginning \n            flip(arr, mi)\n            # Now move the maximum number to end by reversing current array\n            flip(arr, curr_size - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    \"\"\"Reverses the first k elements of an array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, k):\n    \"\"\"Finds the index of the maximum element in the first k elements of an array.\"\"\"\n    max_index = 0\n    for i in range(1, k):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_index = find_max_index(arr, i)\n        if max_index != i - 1:\n            arr = flip(arr, max_index + 1)  # Bring max to the front\n            arr = flip(arr, i)  # Bring max to its correct position\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    for i in range(n - 1, -1, -1):\n        # Find the maximum element in arr[0...i]\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        # Move the maximum element to the end of the current subarray\n        if max_index != i:\n            flip(arr, max_index)\n            flip(arr, i)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    for i in range(n - 1, -1, -1):\n        max_index = 0\n        for j in range(i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        if max_index != i:\n            flip(arr, max_index)  # Flip to bring the max element to the front\n            flip(arr, i)         # Flip to put the max element at the current position\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the elements of the list up to index k.\"\"\"\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        mi = 0\n        for i in range(1, curr_size):\n            if arr[i] > arr[mi]:\n                mi = i\n\n        if mi != curr_size - 1:\n            flip(arr, mi)\n            flip(arr, curr_size - 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the order of the first k elements in the list.\"\"\"\n        arr[:k+1] = arr[:k+1][::-1]\n\n\n    n = len(arr)\n    for curr_size in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part\n        mi = arr.index(max(arr[:curr_size + 1]))\n\n        # Flip the elements from 0 to mi to bring the maximum element to the beginning\n        if mi != 0:\n            flip(arr, mi)\n\n        # Flip the elements from 0 to curr_size to bring the maximum element to its correct position\n        flip(arr, curr_size)\n\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Reverses the order of the first k elements in the list.\"\"\"\n        arr[:k+1] = arr[:k+1][::-1]\n\n    n = len(arr)\n    for i in range(n - 1, -1, -1):\n        max_index = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_index]:\n                max_index = j\n\n        if max_index != i:\n            flip(arr, max_index)\n            flip(arr, i)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the elements of the list up to index k.\"\"\"\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in sub-array of size curr_size\n        mi = arr.index(max(arr[0:curr_size]))\n\n        # Move the maximum element to end of current sub-array\n        if mi != curr_size - 1:\n            # Reverse from 0 to mi to put the max element at the beginning\n            flip(arr, mi)\n\n            # Reverse the whole current sub-array to put the max element at the end\n            flip(arr, curr_size - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\"\"\"\n    n = len(arr)\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        return arr[:k][::-1] + arr[k:]\n        \n    for curr_size in range(n, 1, -1):\n        mi = arr.index(max(arr[:curr_size]))\n        \n        if mi != curr_size - 1:\n            arr = flip(arr, mi + 1)\n            arr = flip(arr, curr_size)\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        left = 0\n        while left < k:\n            arr[left], arr[k] = arr[k], arr[left]\n            left += 1\n            k -= 1\n\n\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in \n        # arr[0..curr_size-1]\n        mi = arr.index(max(arr[:curr_size]))\n\n        # Move the maximum element to end of current range\n        # if it's not already at the end\n        if mi != curr_size - 1:\n            # To move at the end, first move maximum number to beginning \n            flip(arr, mi)\n            # Now move the maximum number to end by reversing current array\n            flip(arr, curr_size - 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, -1, -1):\n        max_idx = 0\n        for j in range(1, i + 1):\n            if arr[j] > arr[max_idx]:\n                max_idx = j\n\n        if max_idx != i:\n            arr[:max_idx + 1] = arr[:max_idx + 1][::-1]  # Flip to bring max to the beginning\n            arr[:i + 1] = arr[:i + 1][::-1]  # Flip to bring max to the correct position\n\n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "from itertools import combinations\ndef find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs in a list whose XOR is even.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs with an even XOR.\n    \"\"\"\n\n    count = 0\n    for a, b in combinations(nums, 2):\n        if (a ^ b) % 2 == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"Counts the number of pairs in a list whose XOR is even.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs whose XOR sum is even.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"Counts the number of pairs in a list whose XOR results in an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs with an even XOR.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that XOR to an even number.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 30.434782608695652, "dps_norm": 60.625, "pass@1": 100.0, "profiled": [{"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices (inclusive).\n\n    Args:\n        nums: The input list of numbers.\n        start_index: The starting index of the range.\n        end_index: The ending index of the range.\n\n    Returns:\n        The sum of the numbers within the specified range. Returns 0 if the list is empty or indices are invalid.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    if start_index < 0 or end_index >= n or start_index > end_index:\n        return 0  # Handle invalid indices\n\n    total_sum = 0\n    for i in range(start_index, end_index + 1):\n        total_sum += nums[i]\n\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices (inclusive).\n\n    Args:\n        nums: The list of numbers.\n        start_index: The starting index of the range (inclusive).\n        end_index: The ending index of the range (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.\n        Returns 0 if the list is empty or indices are out of range.\n    \"\"\"\n    if not nums:\n        return 0  # Handle empty list\n\n    if start_index < 0 or end_index < 0 or start_index >= len(nums) or end_index >= len(nums) or start_index > end_index:\n        return 0  # Handle invalid indices\n\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums: list, start_index: int, end_index: int) -> int:\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices.\n\n    Args:\n        nums: The list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of the numbers within the specified range.\n        Returns 0 if the list is empty or indices are invalid.\n    \"\"\"\n\n    if not nums:\n        return 0\n    \n    if start_index < 0 or end_index < 0 or start_index >= len(nums) or end_index >= len(nums) or start_index > end_index:\n        return 0\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range of indices (inclusive).\n\n    Args:\n        nums: The list of numbers.\n        start_index: The starting index of the range (inclusive).\n        end_index: The ending index of the range (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.\n        Returns 0 if the list is empty or if the indices are out of range.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    if start_index < 0 or end_index < 0 or start_index >= len(nums) or end_index >= len(nums) or start_index > end_index:\n        return 0\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers within a specified range of indices in a list.\n\n    Args:\n        nums: The list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range, or 0 if the list is empty or indices are invalid.\n    \"\"\"\n    if not nums:\n        return 0\n\n    if start_index < 0 or end_index < 0 or start_index >= len(nums) or end_index >= len(nums) or start_index > end_index:\n        return 0  # Handle invalid indices\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums: list, start_index: int, end_index: int) -> int:\n    \"\"\"\n    Calculates the sum of elements within a specified range in a list.\n\n    Args:\n        nums: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of elements within the specified range.\n        Returns 0 if the input list is empty or None.\n        Returns 0 if the start_index is out of bounds.\n        Returns the sum up to the end of the list if the end_index is out of bounds.\n\n    \"\"\"\n    if not nums:\n        return 0\n\n    if start_index < 0 or start_index >= len(nums):\n        return 0\n\n    end_index = min(end_index, len(nums) - 1)  # Handle out-of-bounds end_index\n    \n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of elements within a given range of indices in a list.\n\n    Args:\n        nums: The list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of elements within the specified range.\n        Returns 0 if the list is empty or if the indices are out of range or invalid.\n    \"\"\"\n    if not nums:\n        return 0\n\n    if not (0 <= start_index <= end_index < len(nums)):  # Check for valid indices\n        return 0\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"Calculates the sum of numbers within a specified range of indices in a list.\n\n    Args:\n        nums: A list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.\n        Returns 0 if the list is empty or indices are out of range.\n    \"\"\"\n    if not nums or start_index < 0 or end_index >= len(nums) or start_index > end_index:\n        return 0\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Calculates the sum of elements in a list within a specified range (inclusive).\n\n    Args:\n        nums: A list of numbers.\n        start: The starting index (inclusive).\n        end: The ending index (inclusive).\n\n    Returns:\n        The sum of elements within the specified range.\n        Returns 0 if the list is empty or indices are invalid.\n    \"\"\"\n    if not nums:\n        return 0\n    if start < 0 or end >= len(nums) or start > end:\n        return 0\n\n    total = 0\n    for i in range(start, end + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers within a specified range of indices in a list.\n\n    Args:\n        nums: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range, or 0 if the input is invalid.\n    \"\"\"\n\n    if not isinstance(nums, list) or not all(isinstance(num, (int, float)) for num in nums):\n        return 0  # Handle invalid input: not a list or contains non-numeric elements\n\n    if not (0 <= start_index <= end_index < len(nums)):\n        return 0  # Handle invalid indices\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n\n    return total", "matching_cluster_idx": 1}, {"solution": "def sum_range_list(nums: list, start_index: int, end_index: int) -> int:\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range (inclusive).\n\n    Args:\n        nums: The list of numbers.\n        start_index: The starting index of the range.\n        end_index: The ending index of the range.\n\n    Returns:\n        The sum of the numbers within the range.\n        Returns 0 if the input list is empty or None.\n        Returns 0 if the start or end indices are out of bounds.\n    \"\"\"\n    if not nums:\n        return 0\n\n    if start_index < 0 or end_index >= len(nums) or start_index > end_index:\n        return 0\n    \n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n        nums: The list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.\n        Returns 0 if the list is empty or indices are invalid.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if start_index < 0 or end_index < 0 or start_index >= n or end_index >= n or start_index > end_index:\n        return 0\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers within a given range of indices in a list.\n\n    Args:\n        nums: The list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range.\n        Returns 0 if the list is empty or indices are out of range.\n    \"\"\"\n    if not nums:\n        return 0\n    if start_index < 0 or end_index < 0 or start_index >= len(nums) or end_index >= len(nums) or start_index > end_index:\n        return 0\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"Calculates the sum of numbers in a list within a specified range of indices (inclusive).\n\n    Args:\n        nums: The list of numbers.\n        start_index: The starting index of the range (inclusive).\n        end_index: The ending index of the range (inclusive).\n\n    Returns:\n        The sum of the numbers within the specified range.\n        Returns 0 if the list is empty or indices are invalid.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    if not (0 <= start_index <= end_index < len(nums)):\n        return 0\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers within a specified range of indices in a list.\n\n    Args:\n        nums: A list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers within the specified range. Returns 0 if the list is empty \n        or if the indices are invalid.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if not (0 <= start_index <= end_index < n):\n        return 0\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of elements in a list within a specified range of indices (inclusive).\n\n    Args:\n        nums: The input list of numbers.\n        start_index: The starting index of the range (inclusive).\n        end_index: The ending index of the range (inclusive).\n\n    Returns:\n        The sum of elements within the specified range. \n        Returns 0 if the list is empty or indices are invalid.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if start_index < 0 or end_index < 0 or start_index >= n or end_index >= n or start_index > end_index:\n        return 0  # Handle invalid indices\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculates the sum of elements in a list within a specified range of indices.\n\n    Args:\n        lst: The input list of numbers.\n        start_index: The starting index (inclusive).\n        end_index: The ending index (inclusive).\n\n    Returns:\n        The sum of elements within the specified range.\n        Returns 0 if the list is empty or indices are invalid.\n    \"\"\"\n\n    if not lst:\n        return 0\n\n    n = len(lst)\n\n    if not (0 <= start_index < n and 0 <= end_index < n and start_index <= end_index):\n        return 0\n    \n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += lst[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of numbers within a specified range of a list.\n\n    Args:\n        nums: The input list of numbers.\n        start_index: The starting index (inclusive) of the range.\n        end_index: The ending index (inclusive) of the range.\n\n    Returns:\n        The sum of the numbers within the specified range. Returns 0 if the list is empty\n        or if the indices are out of bounds.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    if start_index < 0 or end_index >= len(nums) or start_index > end_index:\n        return 0\n    \n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculates the sum of elements within a specified range of a list.\n\n    Args:\n        nums: The input list of numbers.\n        start_index: The starting index (inclusive) for the sum.\n        end_index: The ending index (inclusive) for the sum.\n\n    Returns:\n        The sum of the elements within the specified range.\n        Returns 0 if the list is empty or if the indices are invalid.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if start_index < 0 or end_index < 0 or start_index >= n or end_index >= n or start_index > end_index:\n        return 0\n\n    total = 0\n    for i in range(start_index, end_index + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums: list[int], start: int, end: int) -> int:\n    \"\"\"\n    Calculates the sum of elements in a list within a specified range (inclusive).\n\n    Args:\n        nums: The input list of numbers.\n        start: The starting index (inclusive).\n        end: The ending index (inclusive).\n\n    Returns:\n        The sum of elements within the specified range.\n        Returns 0 if the list is empty or indices are out of bounds.\n    \"\"\"\n    if not nums or start < 0 or end < 0 or start >= len(nums) or end >= len(nums) or start > end:\n        return 0\n\n    total = 0\n    for i in range(start, end + 1):\n        total += nums[i]\n    return total", "matching_cluster_idx": 4}]}, "Mbpp/226": {"dps": 68.21705426356588, "dps_norm": 14.285714285714286, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result = result + str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n      str1: The input string.\n\n  Returns:\n      A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n        str1: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(str1)):\n        if i % 2 == 0:\n            result += str1[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n        str1: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(str1)):\n        if i % 2 == 0:\n            result += str1[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    The string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"Removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    The string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 95.95238095238095, "dps_norm": 98.125, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a specified character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        char: The character to replace spaces with.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces blank spaces in a string with a specified character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.\n    \"\"\"\n    modified_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            modified_string += replacement_char\n        else:\n            modified_string += char\n    return modified_string", "matching_cluster_idx": 4}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces blank spaces in a string with a specified character.\n\n    Args:\n      input_string: The string to modify.\n      replacement_char: The character to replace spaces with.\n\n    Returns:\n      The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n      input_string: The string to modify.\n      char: The character to replace spaces with.\n\n    Returns:\n      The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced by the character.\n    \"\"\"\n\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n      string: The input string.\n      char: The character to replace spaces with.\n\n    Returns:\n      The modified string with spaces replaced.\n    \"\"\"\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"Replaces spaces in a string with a given character.\n\n    Args:\n        input_string: The string to modify.\n        replacement_char: The character to replace spaces with.\n\n    Returns:\n        The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 71.55172413793103, "dps_norm": 75.0, "pass@1": 93.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization to store results of subproblems\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n        \n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n           count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for start_element in range(1, m + 1):\n        total_count += count_sequences(start_element, n - 1)\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization dictionary\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):  # Iterate through possible first elements\n        total_count += count_sequences(first_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for each element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization\n\n    def count_sequences(current_n, prev_val):\n        if current_n == n:\n            return 1\n\n        if (current_n, prev_val) in dp:\n            return dp[(current_n, prev_val)]\n\n        count = 0\n        for current_val in range(2 * prev_val, m + 1):\n            count += count_sequences(current_n + 1, current_val)\n\n        dp[(current_n, prev_val)] = count\n        return count\n    \n    total_count = 0\n    for start_val in range(1, m + 1):\n        total_count += count_sequences(1, start_val)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for sequence elements.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for sequence elements.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    count = 0\n\n    def backtrack(current_sequence):\n        nonlocal count\n\n        if len(current_sequence) == n:\n            count += 1\n            return\n\n        if not current_sequence:\n            for i in range(1, m + 1):\n                backtrack([i])\n        else:\n            last_element = current_sequence[-1]\n            for i in range(2 * last_element, m + 1):\n                backtrack(current_sequence + [i])\n\n    backtrack([])\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Given positive integers m and n, finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    For example:\n    get_total_number_of_sequences(10, 4) == 4\n    \"\"\"\n\n    dp = {}\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the sequence elements.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for start_element in range(1, m + 1):\n        total_count += count_sequences(start_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    count = 0\n\n    def backtrack(current_sequence):\n        nonlocal count\n        if len(current_sequence) == n:\n            count += 1\n            return\n\n        if not current_sequence:\n            for i in range(1, m + 1):\n                backtrack([i])\n        else:\n            last_element = current_sequence[-1]\n            for i in range(2 * last_element, m + 1):\n                backtrack(current_sequence + [i])\n\n    backtrack([])\n    return count", "matching_cluster_idx": 3}, {"solution": "from functools import lru_cache\ndef get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    count = 0\n\n    def find_sequences(current_sequence):\n        nonlocal count\n        if len(current_sequence) == n:\n            count += 1\n            return\n\n        if not current_sequence:\n            for i in range(1, m + 1):\n                find_sequences([i])\n        else:\n            last_element = current_sequence[-1]\n            for i in range(2 * last_element, m + 1):\n                find_sequences(current_sequence + [i])\n\n    find_sequences([])\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization\n\n    def count_sequences(current_index, previous_element):\n        if current_index == n:\n            return 1\n\n        if (current_index, previous_element) in dp:\n            return dp[(current_index, previous_element)]\n\n        count = 0\n        for current_element in range(2 * previous_element, m + 1):\n            count += count_sequences(current_index + 1, current_element)\n\n        dp[(current_index, previous_element)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(1, first_element)\n    \n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for sequence elements.\n        n: The length of the sequences.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization to store intermediate results\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n    \n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements.\n        n: The length of the sequences.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization to store intermediate results\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization to store results of subproblems\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):  # Iterate through possible first elements\n        total_count += count_sequences(first_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for each element.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}\n\n    def count_sequences(prev, length):\n        if length == 0:\n            return 1\n        \n        if (prev, length) in dp:\n            return dp[(prev, length)]\n\n        count = 0\n        for current in range(2 * prev, m + 1):\n            count += count_sequences(current, length - 1)\n        \n        dp[(prev, length)] = count\n        return count\n\n    total_count = 0\n    for start in range(1, m + 1):\n      if 2**(n-1) <= m:\n        total_count += count_sequences(start, n - 1)\n\n    return total_count", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for the elements in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization dictionary\n\n    def count_sequences(current_n, previous_element):\n        if current_n == n:\n            return 1\n\n        if (current_n, previous_element) in dp:\n            return dp[(current_n, previous_element)]\n\n        count = 0\n        for current_element in range(2 * previous_element, m + 1):\n            count += count_sequences(current_n + 1, current_element)\n\n        dp[(current_n, previous_element)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n      total_count += count_sequences(1, first_element)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for sequence elements.\n        n: The length of the sequences.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization dictionary\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n    \n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences of length n with elements <= m.\n\n    Args:\n        m: The upper bound for the elements in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization table\n\n    def count_sequences(current_element, length_remaining):\n        if length_remaining == 0:\n            return 1\n\n        if (current_element, length_remaining) in dp:\n            return dp[(current_element, length_remaining)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, length_remaining - 1)\n\n        dp[(current_element, length_remaining)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of valid sequences.\n\n    Args:\n        m: The upper bound for sequence elements.\n        n: The length of the sequences.\n\n    Returns:\n        The total number of valid sequences.\n    \"\"\"\n\n    dp = {}  # Memoization to store results\n\n    def count_sequences(current_element, remaining_length):\n        if remaining_length == 0:\n            return 1\n\n        if (current_element, remaining_length) in dp:\n            return dp[(current_element, remaining_length)]\n\n        count = 0\n        for next_element in range(2 * current_element, m + 1):\n            count += count_sequences(next_element, remaining_length - 1)\n\n        dp[(current_element, remaining_length)] = count\n        return count\n\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += count_sequences(first_element, n - 1)\n\n    return total_count\nm = 10\nn = 4", "matching_cluster_idx": 7}]}, "Mbpp/240": {"dps": 67.6219512195122, "dps_norm": 78.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n\n    if not list1:  # Handle empty list1\n        return list2\n    \n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n\n    list1.pop()  # Remove the last element\n    list1.extend(list2)  # Add the elements of list2\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n\n    list1.pop()  # Remove the last element\n    list1.extend(list2)  # Add the elements of list2\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    new_list = list1[:-1] + list2  # Create a new list to avoid modifying the original list1\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    new_list = list1[:-1]  # Create a new list excluding the last element of list1\n    new_list.extend(list2) # Extend the new list with the elements of list2\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n\n    list1.pop()  # Remove the last element\n    list1.extend(list2)  # Add the elements of list2\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of list1 replaced by list2.\n    \"\"\"\n\n    new_list = list1[:-1]  # Create a new list containing all elements of list1 except the last\n    new_list.extend(list2)  # Extend the new list with the elements of list2\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    list1_copy = list1[:-1]  # Create a copy up to the second to last element\n    list1_copy.extend(list2)  # Extend the copy with the elements of list2\n    return list1_copy\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n\n    new_list = list1[:-1]  # Create a new list with all elements of list1 except the last one\n    new_list.extend(list2)  # Extend the new list with the elements of list2\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    list1.pop()  # Remove the last element\n    list1.extend(list2)  # Add the elements of list2\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n\n    new_list = list1[:-1] + list2  # Create a new list to avoid modifying the original list1\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n\n    new_list = list1[:-1] + list2  # Slice list1 to exclude last element and concatenate with list2\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by list2.\n        Returns list1 if it is empty.\n    \"\"\"\n    if not list1:\n        return list1\n    \n    new_list = list1[:-1]  # Create a new list excluding the last element\n    new_list.extend(list2)  # Add the elements of list2\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of list1 replaced by list2.\n      Returns list1 if it's empty.\n    \"\"\"\n    if not list1:\n        return list1\n    \n    return list1[:-1] + list2\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [6, 7, 8]", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n\n    new_list = list1[:-1]  # Create a new list containing all elements of list1 except the last one\n    new_list.extend(list2)  # Extend the new list with the elements of list2\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by list2.\n        Returns list1 if it's empty.\n    \"\"\"\n\n    if not list1:\n        return list1\n    \n    new_list = list1[:-1] + list2\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\"\"\"\n\n    list1.pop()  # Remove the last element of list1\n    list1.extend(list2)  # Extend list1 with the elements of list2\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n\n    new_list = list1[:-1] + list2  # Create a new list to avoid modifying the original list1\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    new_list = list1[:-1] + list2\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by list2.\n    \"\"\"\n\n    new_list = list1[:-1] + list2  # Create a new list by slicing list1 up to (but not including) the last element, then concatenating list2\n    return new_list", "matching_cluster_idx": 5}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each existing element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list\nmy_list = ['Red', 'Green', 'Black']\nnew_list = insert_element(my_list, 'c')", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list\nmy_list = ['Red', 'Green', 'Black']\nnew_list = insert_element(my_list, 'c')", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 97.71689497716895, "dps_norm": 88.23529411764706, "pass@1": 99.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False  # 0 and 1 are not prime\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n    \n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n    \n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n\n    # Create a list of booleans, initially all True.\n    # Each index represents a number, and True indicates it's potentially prime.\n    primes = [True] * n\n    # 0 and 1 are not prime\n    primes[0] = primes[1] = False\n\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            # Mark multiples of i as not prime\n            for multiple in range(i*i, n, i):\n                primes[multiple] = False\n\n    # Count the number of True values remaining in the list\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False  # 0 and 1 are not prime\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for multiple in range(i*i, n, i):\n                primes[multiple] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    if n == 2:\n        return 0\n    if n == 3:\n        return 1\n\n    primes = [True] * n  # Initialize a list to store primality flags\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n    \n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n  # Initialize a list to store prime flags\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n                \n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    if n == 2:\n        return 0  # No primes less than 2\n    if n == 3:\n        return 1  # Only 2 is less than 3\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False  # 0 and 1 are not prime\n\n    for i in range(2, int(n**0.5) + 1):  # Optimization: Check divisibility only up to the square root of n\n        if primes[i]:\n            for j in range(i * i, n, i): # Start from i*i to avoid redundant checks\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    # Sieve of Eratosthenes\n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for multiple in range(i*i, n, i):\n                primes[multiple] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for multiple in range(i*i, n, i):\n                primes[multiple] = False\n    \n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n    if n == 2:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}]}, "Mbpp/265": {"dps": 70.93023255813954, "dps_norm": 83.33333333333333, "pass@1": 27.0, "profiled": [{"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The interval for splitting.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on every nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"Splits a list into sublists every nth element.\n\n    Args:\n        lst: The input list.\n        n: The interval for splitting.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"Splits a list into sublists based on the nth element.\n\n    Args:\n      lst: The input list.\n      n: The interval for splitting.\n\n    Returns:\n      A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    Args:\n        lst: The input list.\n        n: The split interval.\n\n    Returns:\n        A list of lists, where each inner list contains elements at intervals of n.\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    split_lists = [[] for _ in range(n)]  # Initialize n empty lists\n\n    for i, item in enumerate(lst):\n        split_lists[i % n].append(item)\n\n    return split_lists\nlst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"Splits a list into sublists every nth element.\n\n    Args:\n        lst: The input list.\n        n: The split interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists by taking every nth element.\n\n    Args:\n        lst: The input list.\n        n: The interval for splitting the list.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The interval for splitting.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on every nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on every nth element.\n\n    Args:\n        lst: The input list.\n        n: The interval for splitting.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on the nth element.\n\n    Args:\n        lst: The input list.\n        n: The splitting interval.\n\n    Returns:\n        A list of sublists.\n    \"\"\"\n\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.6, "dps_norm": 83.63636363636363, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"Checks if all elements in a list are unique.\n\n    Args:\n        lst: The input list.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: The list to check.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The input list.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n      lst: The list to check.\n\n    Returns:\n      True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Checks if all elements in a list are unique.\n\n    Args:\n        lst: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 96.41025641025641, "dps_norm": 98.33333333333333, "pass@1": 65.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    def merge_sort_and_count(left, right):\n        nonlocal inv_count  # Access the outer inv_count variable\n\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # Count inversions\n\n        result += left[i:]\n        result += right[j:]\n        return result\n\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)  # Recursively count inversions in left subarray\n    inv_count += get_Inv_Count(right)  # Recursively count inversions in right subarray\n    arr[:] = merge_sort_and_count(left, right) # Modify original array in place\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)\n    inv_count += get_Inv_Count(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i  # Count inversions\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    def merge_sort_and_count(left, right):\n        nonlocal inv_count\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # Count inversions\n\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n    \n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)\n    inv_count += get_Inv_Count(right)\n    \n    arr[:] = merge_sort_and_count(left,right) # Important to modify original array in-place\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)\n    inv_count += get_Inv_Count(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i  # Count inversions\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    def _merge_sort(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += _merge_sort(arr, temp_arr, left, mid)\n            inv_count += _merge_sort(arr, temp_arr, mid + 1, right)\n            inv_count += _merge(arr, temp_arr, left, mid, right)\n        return inv_count\n\n    def _merge(arr, temp_arr, left, mid, right):\n        i = left\n        j = mid + 1\n        k = left\n        inv_count = 0\n\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)  # Count inversions\n                j += 1\n            k += 1\n\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp_arr[loop_var]\n\n        return inv_count\n\n    temp_arr = [0] * n\n    return _merge_sort(arr, temp_arr, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    def merge_sort_and_count(arr):\n        n = len(arr)\n        if n <= 1:\n            return arr, 0\n\n        mid = n // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n\n        merged = []\n        inv_merged = inv_left + inv_right\n        i = j = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_merged += len(left) - i  # Count inversions\n\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged, inv_merged\n\n    _, inversions = merge_sort_and_count(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using merge sort.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: The input array.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    def merge_sort_and_count(arr, temp, left, right):\n        inv_count = 0\n\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp, left, mid)\n            inv_count += merge_sort_and_count(arr, temp, mid + 1, right)\n            inv_count += merge(arr, temp, left, mid, right)\n        return inv_count\n\n    def merge(arr, temp, left, mid, right):\n        i = left\n        j = mid + 1\n        k = left\n        inv_count = 0\n\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                i += 1\n            else:\n                temp[k] = arr[j]\n                inv_count += (mid - i + 1)  # Count inversions\n                j += 1\n            k += 1\n\n        while i <= mid:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n\n        while j <= right:\n            temp[k] = arr[j]\n            j += 1\n            k += 1\n\n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp[loop_var]\n\n        return inv_count\n\n    temp = [0] * n\n    return merge_sort_and_count(arr, temp, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)\n    inv_count += get_Inv_Count(right)\n    inv_count += merge_and_count(arr, left, right)\n\n    return inv_count\ndef merge_and_count(arr, left, right):\n    \"\"\"\n    Merges two sorted subarrays and counts inversions.\n\n    Args:\n        arr: The original array.\n        left: The left subarray.\n        right: The right subarray.\n\n    Returns:\n        The number of inversions during the merge.\n    \"\"\"\n    i = j = k = inv_count = 0\n    n_left = len(left)\n    n_right = len(right)\n\n    while i < n_left and j < n_right:\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += n_left - i  # Count inversions\n        k += 1\n\n    while i < n_left:\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < n_right:\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n    \n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count = get_Inv_Count(left) + get_Inv_Count(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i  # Count inversions\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    def merge_sort_and_count(arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort_and_count(arr, left, mid)\n            inv_count += merge_sort_and_count(arr, mid + 1, right)\n            inv_count += merge(arr, left, mid, right)\n        return inv_count\n\n    def merge(arr, left, mid, right):\n        i = left\n        j = mid + 1\n        k = 0\n        inv_count = 0\n        temp = [0] * (right - left + 1)\n\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                i += 1\n            else:\n                temp[k] = arr[j]\n                j += 1\n                inv_count += (mid - i + 1)  # Count inversions\n            k += 1\n\n        while i <= mid:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n\n        while j <= right:\n            temp[k] = arr[j]\n            j += 1\n            k += 1\n\n        for i in range(right - left + 1):\n            arr[left + i] = temp[i]\n        \n        return inv_count\n\n    return merge_sort_and_count(arr, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)\n    inv_count += get_Inv_Count(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i  # Count inversions\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inv_count\narr = [1, 20, 6, 4, 5]", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair of elements (arr[i], arr[j]) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The total number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)\n    inv_count += get_Inv_Count(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i  # Count inversions\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)\n    inv_count += get_Inv_Count(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i  # Count inversions\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n    \n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    def merge_sort_and_count(arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort_and_count(arr, left, mid)\n            inv_count += merge_sort_and_count(arr, mid + 1, right)\n            inv_count += merge(arr, left, mid, right)\n        return inv_count\n\n    def merge(arr, left, mid, right):\n        i = left\n        j = mid + 1\n        k = 0\n        temp = [0] * (right - left + 1)\n        inv_count = 0\n\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                temp[k] = arr[j]\n                inv_count += (mid - i + 1)  # Count inversions\n                k += 1\n                j += 1\n\n        while i <= mid:\n            temp[k] = arr[i]\n            k += 1\n            i += 1\n\n        while j <= right:\n            temp[k] = arr[j]\n            k += 1\n            j += 1\n\n        for idx in range(right - left + 1):\n            arr[left + idx] = temp[idx]\n\n        return inv_count\n\n    return merge_sort_and_count(arr, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)\n    inv_count += get_Inv_Count(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i  # Count inversions\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n    \n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using a modified merge sort.\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    def merge_sort_and_count(arr):\n        n = len(arr)\n        if n <= 1:\n            return arr, 0\n\n        mid = n // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n\n        merged_arr = []\n        inversions = inv_left + inv_right\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged_arr.append(left[i])\n                i += 1\n            else:\n                merged_arr.append(right[j])\n                inversions += len(left) - i  # Count inversions\n                j += 1\n\n        merged_arr.extend(left[i:])\n        merged_arr.extend(right[j:])\n        return merged_arr, inversions\n\n    _, inversions = merge_sort_and_count(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    inv_count = 0\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count += get_Inv_Count(left)\n    inv_count += get_Inv_Count(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i  # Count inversions\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    def _merge_sort_and_count(arr, temp, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += _merge_sort_and_count(arr, temp, left, mid)\n            inv_count += _merge_sort_and_count(arr, temp, mid + 1, right)\n            inv_count += merge_and_count(arr, temp, left, mid, right)\n        return inv_count\n\n    def merge_and_count(arr, temp, left, mid, right):\n        i = left\n        j = mid + 1\n        k = left\n        inv_count = 0\n\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                i += 1\n            else:\n                temp[k] = arr[j]\n                inv_count += (mid - i + 1)  # Count inversions\n                j += 1\n            k += 1\n\n        while i <= mid:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n\n        while j <= right:\n            temp[k] = arr[j]\n            j += 1\n            k += 1\n\n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp[loop_var]\n\n        return inv_count\n\n    temp = [0] * n\n    return _merge_sort_and_count(arr, temp, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using merge sort.\n\n    An inversion is a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count = get_Inv_Count(left) + get_Inv_Count(right)\n\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i  # Count inversions\n        k += 1\n\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inv_count\narr = [1, 20, 6, 4, 5]", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 77.72413793103449, "dps_norm": 61.66666666666667, "pass@1": 32.0, "profiled": [{"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.\n    \"\"\"\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n    \n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products.\n    \"\"\"\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n\n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products formed by multiplying elements from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists, selecting one factor from each.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products in descending order.\n    \"\"\"\n\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    products = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            products.append(list1[i] * list2[j])\n\n\n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, num_largest):\n    \"\"\"\n    Finds the specified number of largest products from two given lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        num_largest: The number of largest products to return.\n\n    Returns:\n        A list containing the 'num_largest' largest products, sorted in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or num_largest <= 0:\n        return []\n\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    min_heap = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            product = list1[i] * list2[j]\n            if len(min_heap) < num_largest:\n                heapq.heappush(min_heap, product)\n            elif product > min_heap[0]:\n                heapq.heapreplace(min_heap, product)\n\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 2}, {"solution": "import heapq\ndef large_product(list1, list2, k):\n    \"\"\"\n    Finds the k largest products from two lists, selecting one factor from each.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        k: The number of largest products to return.\n\n    Returns:\n        A list containing the k largest products, sorted in descending order.\n    \"\"\"\n\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n\n    return heapq.nlargest(k, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two given lists, selecting one factor from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    list1.sort(reverse=True)  # Sort in descending order for efficient product generation\n    list2.sort(reverse=True)\n\n    min_heap = []  # Use a min-heap to store the n largest products\n\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            product = list1[i] * list2[j]\n\n            if len(min_heap) < n:\n                heapq.heappush(min_heap, product)\n            elif product > min_heap[0]:\n                heapq.heapreplace(min_heap, product)\n\n    return sorted(min_heap, reverse=True)  # Return sorted list in descending order", "matching_cluster_idx": 2}, {"solution": "import heapq\ndef large_product(list1, list2, num_largest):\n    \"\"\"\n    Finds the specified number of largest products from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        num_largest: The number of largest products to return.\n\n    Returns:\n        A list containing the 'num_largest' largest products, sorted in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or num_largest <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    return heapq.nlargest(num_largest, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two given lists, selecting one factor from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    min_heap = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            product = list1[i] * list2[j]\n            if len(min_heap) < n:\n                heapq.heappush(min_heap, product)\n            elif product > min_heap[0]:\n                heapq.heapreplace(min_heap, product)\n\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the 'n' largest products from two lists, selecting one factor from each.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the 'n' largest products.\n    \"\"\"\n\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    products.sort(reverse=True)  # Sort in descending order\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, num_largest):\n    \"\"\"\n    Finds the specified number of largest products from two given lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        num_largest: The number of largest products to return.\n\n    Returns:\n        A list containing the 'num_largest' largest products, sorted in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or num_largest <= 0:\n        return []\n\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    min_heap = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            product = list1[i] * list2[j]\n            if len(min_heap) < num_largest:\n                heapq.heappush(min_heap, product)\n            elif product > min_heap[0]:\n                heapq.heapreplace(min_heap, product)\n\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 2}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists, selecting one factor from each.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.\n    \"\"\"\n\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    return sorted(heapq.nlargest(n, products), reverse=True)", "matching_cluster_idx": 3}, {"solution": "import heapq\nimport heapq\ndef large_product(list1, list2, num_largest):\n    \"\"\"\n    Finds the specified number of largest products from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        num_largest: The number of largest products to return.\n\n    Returns:\n        A list containing the 'num_largest' largest products, sorted in descending order.\n    \"\"\"\n    if not list1 or not list2 or num_largest <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    return heapq.nlargest(num_largest, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, num):\n    \"\"\"\n    Finds the specified number of largest products from two given lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        num: The number of largest products to return.\n\n    Returns:\n        A list containing the 'num' largest products, sorted in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or num <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    return heapq.nlargest(num, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, num_products):\n    \"\"\"\n    Finds the specified number of largest products from two given lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        num_products: The number of largest products to return.\n\n    Returns:\n        A list containing the 'num_products' largest products, sorted in descending order.\n    \"\"\"\n\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    products = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            products.append(list1[i] * list2[j])\n    \n    return heapq.nlargest(num_products, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n\n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists, selecting one factor from each.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n\n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products, sorted in descending order.\n    \"\"\"\n\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, num_largest):\n    \"\"\"\n    Finds the specified number of largest products from two given lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        num_largest: The number of largest products to return.\n\n    Returns:\n        A list containing the 'num_largest' largest products, sorted in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or num_largest <= 0:\n        return []\n\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    min_heap = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            product = list1[i] * list2[j]\n            if len(min_heap) < num_largest:\n                heapq.heappush(min_heap, product)\n            elif product > min_heap[0]:\n                heapq.heapreplace(min_heap, product)\n    \n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 2}, {"solution": "import heapq\ndef large_product(list1, list2, num_largest):\n    \"\"\"\n    Finds the specified number of largest products from two lists.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        num_largest: The number of largest products to return.\n\n    Returns:\n        A list containing the 'num_largest' largest products, sorted in descending order.\n    \"\"\"\n\n    if not list1 or not list2 or num_largest <= 0:\n        return []\n\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    min_heap = []\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            product = list1[i] * list2[j]\n            if len(min_heap) < num_largest:\n                heapq.heappush(min_heap, product)\n            elif product > min_heap[0]:\n                heapq.heapreplace(min_heap, product)\n    \n    result = sorted(min_heap, reverse=True)\n    return result", "matching_cluster_idx": 2}]}, "Mbpp/392": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 32.0, "profiled": [{"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n\n    memo = {}\n\n    def calculate_sum(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        sum_parts = calculate_sum(n // 2) + calculate_sum(n // 3) + calculate_sum(n // 4) + calculate_sum(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return calculate_sum(n)\nn = 60", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n    \"\"\"\n    memo = {}\n\n    def _get_max_sum(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        result = max(n, _get_max_sum(n // 2) + _get_max_sum(n // 3) + _get_max_sum(n // 4) + _get_max_sum(n // 5))\n        memo[n] = result\n        return result\n\n    return _get_max_sum(n)\nn = 60", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n\n    memo = {}\n\n    def helper(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        memo[n] = max(n, helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5))\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "import math\ndef get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum achievable.\n    \"\"\"\n\n    memo = {}\n\n    def solve(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        memo[n] = max(n, solve(n // 2) + solve(n // 3) + solve(n // 4) + solve(n // 5))\n        return memo[n]\n\n    return solve(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n\n    memo = {}\n\n    def calculate_sum(num):\n        if num == 0:\n            return 0\n        if num in memo:\n            return memo[num]\n\n        memo[num] = max(num, calculate_sum(num // 2) + calculate_sum(num // 3) + calculate_sum(num // 4) + calculate_sum(num // 5))\n        return memo[num]\n\n    return calculate_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n\n    memo = {}\n\n    def helper(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        \n        memo[n] = max(n, helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5))\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n\n    memo = {}\n\n    def helper(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        memo[n] = max(n, helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5))\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n\n    memo = {}\n\n    def solve(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        memo[n] = max(solve(n // 2) + solve(n // 3) + solve(n // 4) + solve(n // 5), n)\n        return memo[n]\n\n    return solve(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n\n    memo = {}\n\n    def solve(n):\n        if n in memo:\n            return memo[n]\n\n        if n == 0:\n            return 0\n\n        result = max(n, solve(n // 2) + solve(n // 3) + solve(n // 4) + solve(n // 5))\n        memo[n] = result\n        return result\n\n    return solve(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n    \"\"\"\n    memo = {}\n\n    def _get_max_sum(n):\n        if n in memo:\n            return memo[n]\n\n        if n == 0:\n            return 0\n\n        result = max(n, _get_max_sum(n // 2) + _get_max_sum(n // 3) + _get_max_sum(n // 4) + _get_max_sum(n // 5))\n        memo[n] = result\n        return result\n\n    return _get_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n\n    memo = {}  # Memoization dictionary to store results of subproblems\n\n    def solve(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        memo[n] = max(n, solve(n // 2) + solve(n // 3) + solve(n // 4) + solve(n // 5))\n        return memo[n]\n\n    return solve(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation and memoization.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n\n    memo = {}\n\n    def calculate_sum(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        memo[n] = max(n, calculate_sum(n // 2) + calculate_sum(n // 3) + calculate_sum(n // 4) + calculate_sum(n // 5))\n        return memo[n]\n\n    return calculate_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n    \"\"\"\n    memo = {}\n\n    def calculate_sum(num):\n        if num == 0:\n            return 0\n        if num in memo:\n            return memo[num]\n\n        sum_parts = calculate_sum(num // 2) + calculate_sum(num // 3) + calculate_sum(num // 4) + calculate_sum(num // 5)\n        memo[num] = max(sum_parts, num)\n        return memo[num]\n\n    return calculate_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation and memoization.\n    \"\"\"\n    memo = {}\n\n    def helper(num):\n        if num == 0:\n            return 0\n        if num in memo:\n            return memo[num]\n\n        result = max(num, helper(num // 2) + helper(num // 3) + helper(num // 4) + helper(num // 5))\n        memo[num] = result\n        return result\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum achievable.\n    \"\"\"\n\n    memo = {}\n\n    def _get_max_sum(n):\n        if n in memo:\n            return memo[n]\n\n        if n == 0:\n            return 0\n        \n        if n < 1: # Handle potential floating point results that dip below 1\n          return n\n\n\n        res = max(n, _get_max_sum(n // 2) + _get_max_sum(n // 3) + _get_max_sum(n // 4) + _get_max_sum(n // 5))\n        memo[n] = res\n        return res\n\n    return _get_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n\n    memo = {}  # Memoization dictionary to store results\n\n    def _get_max_sum(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        result = max(n, _get_max_sum(n // 2) + _get_max_sum(n // 3) + _get_max_sum(n // 4) + _get_max_sum(n // 5))\n        memo[n] = result\n        return result\n\n    return _get_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n\n    memo = {}\n\n    def _get_max_sum_recursive(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        memo[n] = max(n, _get_max_sum_recursive(n // 2) + _get_max_sum_recursive(n // 3) + _get_max_sum_recursive(n // 4) + _get_max_sum_recursive(n // 5))\n        return memo[n]\n\n    return _get_max_sum_recursive(n)\nn = 60", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n\n    memo = {}\n\n    def helper(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        memo[n] = max(n, helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5))\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation with memoization.\n    \"\"\"\n    memo = {}\n\n    def calculate_sum(num):\n        if num == 0:\n            return 0\n        if num in memo:\n            return memo[num]\n\n        sum_parts = calculate_sum(num // 2) + calculate_sum(num // 3) + calculate_sum(num // 4) + calculate_sum(num // 5)\n        memo[num] = max(sum_parts, num)\n        return memo[num]\n\n    return calculate_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum using the given recursive equation.\n\n    Args:\n        n: The input number.\n\n    Returns:\n        The maximum sum.\n    \"\"\"\n\n    memo = {}\n\n    def calculate_sum(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n\n        sum_parts = calculate_sum(n // 2) + calculate_sum(n // 3) + calculate_sum(n // 4) + calculate_sum(n // 5)\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return calculate_sum(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(s)\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(s)\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}  # Use a dictionary to store character counts\n\n    # Count occurrences of each character\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Find the first character with a count of 1\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # Return None if all characters are repeated", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(s)  # Count character occurrences\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}  # Use a dictionary to store character counts\n\n    # Iterate through the string to count character occurrences\n    for char in string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Iterate through the string again to find the first non-repeated character\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # Return None if all characters are repeated", "matching_cluster_idx": 5}, {"solution": "from collections import OrderedDict\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = OrderedDict()  # Use OrderedDict to maintain insertion order\n\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n\n    char_counts = Counter(string)\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import OrderedDict\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = OrderedDict()  # Use OrderedDict to preserve insertion order\n\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(string)\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n\n    char_counts = Counter(string)  # Efficiently count character occurrences\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(s)\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import OrderedDict\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = OrderedDict()  # Use OrderedDict to preserve insertion order\n\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(s)\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(string)  # Efficiently count character occurrences\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import OrderedDict\ndef first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n\n    char_counts = OrderedDict()  # Use OrderedDict to preserve insertion order\n\n    for char in string:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(string)\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(s)  # Count character occurrences efficiently\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = Counter(s)  # Count character occurrences efficiently\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}  # Use a dictionary to store character counts\n\n    # Count the occurrences of each character\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Find the first character with a count of 1\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # Return None if no non-repeated character is found", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_counts = {}  # Dictionary to store character counts\n\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuplex: The tuple to search.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      tuplex: The tuple to search.\n      element: The element to search for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      input_tuple: The tuple to search within.\n      element: The element to search for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuplex: The tuple to search.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuplex: The tuple to search.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"Checks if an element exists within a tuple.\n\n    Args:\n        tuplex: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, elem):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        test_tup: The tuple to search within.\n        elem: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return elem in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, elem):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        test_tup: The tuple to search.\n        elem: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return elem in test_tup", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 85.90062111801242, "dps_norm": 86.66666666666666, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any value in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    set1 = set(seq1)  # Convert to sets for efficient membership checking\n    set2 = set(seq2)\n    return bool(set1.intersection(set2)) # Returns True if the intersection isn't empty, False otherwise", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any value in seq1 is present in seq2, False otherwise.\n    \"\"\"\n\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Checks if any value in sequence1 exists in sequence2.\n\n    Args:\n        sequence1: The first sequence (list or tuple).\n        sequence2: The second sequence (list or tuple).\n\n    Returns:\n        True if any value in sequence1 is present in sequence2, False otherwise.\n    \"\"\"\n    for value in sequence1:\n        if value in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any value in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any value in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any value in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False\nseq1 = [1, 2, 3]\nseq2 = [4, 5, 6]", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element of seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Checks if any element in sequence1 exists in sequence2.\n\n    Args:\n        sequence1: The first sequence (list or tuple).\n        sequence2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in sequence1 is also in sequence2, False otherwise.\n    \"\"\"\n\n    for item in sequence1:\n        if item in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any element in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any element overlaps, False otherwise.\n    \"\"\"\n\n    # Efficient solution using set intersection:\n    return bool(set(seq1).intersection(seq2))\n\n    # Alternatively, a more explicit (but potentially slower) solution:\n    # for item in seq1:\n    #     if item in seq2:\n    #         return True\n    # return False", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence (list or tuple).\n        seq2: The second sequence (list or tuple).\n\n    Returns:\n        True if any value in seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 64.44444444444444, "dps_norm": 76.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates elements of a tuple with a delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The string to use as a delimiter. Defaults to \"-\".\n\n    Returns:\n        A string containing the concatenated elements.\n    \"\"\"\n    \n    string_elements = [str(element) for element in input_tuple]\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple):\n    \"\"\"\n    Concatenates each element of a tuple, converting each element to a string and joining them with a hyphen.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A string with all elements concatenated by hyphens.\n    \"\"\"\n    return \"-\".join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"Concatenates each element of a tuple using the specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The string used to separate the elements. Defaults to '-'.\n\n    Returns:\n        A string containing the concatenated elements.\n    \"\"\"\n\n    result = \"\"\n    for i, element in enumerate(input_tuple):\n        result += str(element)\n        if i < len(input_tuple) - 1:\n            result += delimiter\n    return result", "matching_cluster_idx": 1}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates elements of a tuple with a given delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The string to use as a delimiter.\n\n    Returns:\n        A string containing the concatenated elements.\n    \"\"\"\n\n    converted_elements = [str(element) for element in input_tuple]  # Convert all elements to strings\n    return delimiter.join(converted_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates tuple elements with a delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The delimiter to use (default is \"-\").\n\n    Returns:\n        A string with the concatenated elements.\n        Returns an empty string if the input is not a tuple or the tuple is empty.\n\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        return \"\"\n    if not input_tuple:\n        return \"\"\n    \n    string_elements = [str(element) for element in input_tuple]  # Convert all to string\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The string used to separate the elements. Defaults to \"-\".\n\n    Returns:\n        A string containing the concatenated elements.\n    \"\"\"\n    \n    converted_elements = [str(element) for element in input_tuple]  # Convert all elements to strings\n    return delimiter.join(converted_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates elements of a tuple with a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The string to use as a delimiter between elements.\n\n    Returns:\n        A string containing the concatenated elements.\n    \"\"\"\n\n    string_elements = [str(element) for element in input_tuple]\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates each element of a tuple with a delimiter.\n\n    Args:\n        input_tuple: The input tuple.\n        delimiter: The delimiter string. Defaults to \"-\".\n\n    Returns:\n        The concatenated string.\n    \"\"\"\n\n    string_list = [str(element) for element in input_tuple]  # Convert elements to strings\n    return delimiter.join(string_list)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates elements of a tuple with a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The string to use as a delimiter. Defaults to \"-\".\n\n    Returns:\n        A string with the concatenated elements.\n    \"\"\"\n\n    concatenated_string = \"\"\n    for i, element in enumerate(input_tuple):\n        concatenated_string += str(element)  # Convert elements to strings\n        if i < len(input_tuple) - 1:\n            concatenated_string += delimiter\n    return concatenated_string", "matching_cluster_idx": 1}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates elements of a tuple with a delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The delimiter to use between elements. Defaults to \"-\".\n\n    Returns:\n        A string containing the concatenated elements.\n    \"\"\"\n    \n    concatenated_string = delimiter.join(map(str, input_tuple))\n    return concatenated_string", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates elements of a tuple with a specified delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The string to use as a delimiter. Defaults to \"-\".\n\n    Returns:\n        A string with the concatenated elements.\n    \"\"\"\n    \n    concatenated_string = \"\"\n    for i, element in enumerate(input_tuple):\n        concatenated_string += str(element)\n        if i < len(input_tuple) - 1:\n            concatenated_string += delimiter\n    return concatenated_string", "matching_cluster_idx": 1}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple with a given delimiter.\n\n    Args:\n        input_tuple: The input tuple.\n        delimiter: The delimiter to use (default is \"-\").\n\n    Returns:\n        A string representing the concatenated tuple elements.\n    \"\"\"\n\n    converted_elements = [str(element) for element in input_tuple]  # Convert all elements to strings\n    return delimiter.join(converted_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates elements of a tuple using a delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The string to use as a delimiter between elements. Defaults to \"-\".\n\n    Returns:\n        A string containing the concatenated elements.\n    \"\"\"\n\n    converted_elements = [str(element) for element in input_tuple]\n    return delimiter.join(converted_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple with a specified delimiter.\n\n    Args:\n        input_tuple: The input tuple.\n        delimiter: The delimiter to use (default is \"-\").\n\n    Returns:\n        The concatenated string.\n    \"\"\"\n\n    string_elements = [str(element) for element in input_tuple]\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates elements of a tuple with a delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The delimiter to use. Defaults to \"-\".\n\n    Returns:\n        A string with the concatenated elements.\n    \"\"\"\n    \n    string_elements = [str(element) for element in input_tuple]  # Convert all elements to strings\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates elements of a tuple with a delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The string to use as a delimiter. Defaults to \"-\".\n\n    Returns:\n        A string with the concatenated elements.\n    \"\"\"\n\n    string_elements = [str(element) for element in input_tuple]  # Convert all elements to strings\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates each element of a tuple with a delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The delimiter to use. Defaults to \"-\".\n\n    Returns:\n        A string containing the concatenated elements.\n        Returns an empty string if the input tuple is empty.\n    \"\"\"\n    if not input_tuple:\n      return \"\"\n\n    result = str(input_tuple[0])\n    for i in range(1, len(input_tuple)):\n        result += delimiter + str(input_tuple[i])\n    return result", "matching_cluster_idx": 2}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple with a delimiter.\n\n    Args:\n        input_tuple: The input tuple.\n        delimiter: The delimiter string. Defaults to \"-\".\n\n    Returns:\n        A string with the concatenated elements.\n\n    Raises:\n        TypeError: If input_tuple is not a tuple.\n    \"\"\"\n\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    string_elements = [str(element) for element in input_tuple]\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates elements of a tuple with a delimiter.\n\n    Args:\n        input_tuple: The input tuple.\n        delimiter: The delimiter to use. Defaults to \"-\".\n\n    Returns:\n        The concatenated string, or an empty string if the tuple is empty.\n    \"\"\"\n\n    if not input_tuple:\n        return \"\"\n\n    # Convert all elements to strings\n    string_tuple = tuple(map(str, input_tuple))\n\n    return delimiter.join(string_tuple)", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates tuple elements with a delimiter.\n\n    Args:\n        input_tuple: The input tuple.\n        delimiter: The delimiter string. Defaults to \"-\".\n\n    Returns:\n        The concatenated string, or an empty string if the tuple is empty.\n    \"\"\"\n\n    if not input_tuple:\n        return \"\"\n\n    # Convert each element to a string before joining.\n    string_elements = [str(element) for element in input_tuple]\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 5.054151624548736, "dps_norm": 44.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-strings.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n            result.append(\"\") # Append empty string for empty string input\n\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n            result.append(\"\") # or raise an exception if needed.\n        # No 'else' needed.  Silently ignore non-string entries.\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-strings.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n            result.append(\"\") # or raise an error if that's the preferred behavior\n        elif not isinstance(item, str): # Handle non-string tuple entries, perhaps by skipping or raising error\n            continue # or raise TypeError(\"Tuple elements must be strings\")\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handles empty strings\n            continue # or append \"\" depending on desired behavior. Here, we skip empty strings.\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n            result.append(\"\") # Or raise an error if that's the desired behaviour.\n        \n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple. \n        Returns an empty list if the input tuple is empty or contains empty strings.\n    \"\"\"\n\n    result = []\n    for item in input_tuple:\n        if item:  # Check if the string is not empty\n            result.append(item[-1])\n    return result", "matching_cluster_idx": 2}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n            result.append(\"\") # Add empty string to the result for consistency\n        \n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains empty strings.\n    \"\"\"\n\n    result = []\n    for string in input_tuple:\n        if string:  # Check if the string is not empty\n            result.append(string[-1])\n    return result", "matching_cluster_idx": 2}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string. \n        Returns an empty list if the input tuple is empty or contains non-strings.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif not isinstance(item, str):\n            return [] # Handles cases where non-string elements are in the tuple\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: #Handle empty strings\n            result.append(\"\") # or raise an exception if preferred.  This version preserves indices.\n        \n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains empty strings.\n    \"\"\"\n    result = []\n    for string in input_tuple:\n        if string:  # Check if the string is not empty\n            result.append(string[-1])\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-strings.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif not isinstance(item, str):\n             return [] # Handles cases where tuple elements are not strings\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        strings_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple. \n        Returns an empty list if the input tuple is empty or contains non-string elements.\n    \"\"\"\n    result = []\n    for item in strings_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n             result.append(\"\") # Or raise an exception if desired behavior is different\n        else:\n             #Handle cases where tuple might contain non-string elements - return empty list to be consistent with test cases\n            return [] # Or raise a TypeError if that is desired behavior\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif not isinstance(item, str):\n            print(f\"Warning: Non-string element encountered: {item}. Skipping.\")\n        \n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n            result.append(\"\") # Or raise an error if that's the desired behavior\n        elif not isinstance(item, str): # Handle non-string elements silently \n           pass # or raise a TypeError  if needed like: raise TypeError(\"Tuple elements must be strings.\")\n        \n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n        strings: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty.\n        Returns a list containing None for any element in the tuple that is not a string,\n         or if a string is empty\n    \"\"\"\n    result = []\n    for s in strings:\n        if isinstance(s, str) and s:  # Check if it's a string and not empty\n            result.append(s[-1])\n        elif isinstance(s, str) and not s: # Check if the string is empty\n            result.append(None)\n        else: #If not string, append None\n            result.append(None)\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-strings.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n            result.append(\"\") # Or raise an exception if that's the desired behavior\n        elif not isinstance(item, str):\n            return [] # Or raise an exception if non-string types are not allowed\n\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-strings.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n            result.append(\"\") # or raise an exception if that's the desired behaviour\n        elif not isinstance(item, str): # skip invalid values. Alternatively raise exception\n            continue #  raise TypeError(\"Tuple must contain only strings.\")\n\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        strings: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-strings.\n    \"\"\"\n    result = []\n    for string in strings:\n        if isinstance(string, str):  # Check if the element is a string\n            if string:  # Check if the string is not empty\n                result.append(string[-1])\n        else:\n            return [] # Handle cases with non-string elements gracefully\n    return result", "matching_cluster_idx": 1}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        input_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n        Returns an empty list if the input tuple is empty or contains non-string elements.\n    \"\"\"\n    result = []\n    for item in input_tuple:\n        if isinstance(item, str) and item:  # Check if the item is a string and not empty\n            result.append(item[-1])\n        elif isinstance(item, str) and not item: # Handle empty strings\n            result.append(\"\")\n        \n    return result", "matching_cluster_idx": 1}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists within a list of lists that contain a specific element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for within the sublists.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists within a given list of lists that contain a specific element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for within the sublists.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists within a list of lists that contain a specific element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for within the sublists.\n\n    Returns:\n        The number of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists within a list of lists that contain a specific element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for within the sublists.\n\n    Returns:\n        The number of sublists containing the specified element.\n    \"\"\"\n\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists in a given list of lists that contain a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists within a list of lists that contain a specific element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for within the sublists.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count\nlist_of_lists = [[1, 2, 3], [4, 5, 6], [1, 7, 8], [9, 10, 1]]\nelement = 1\ncount = count_element_in_list(list_of_lists, element)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"Counts the number of sublists containing a given element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count\nlist_of_lists = [[1, 3], [5, 7], [1, 11], [1, 15, 7]]\nelement = 1\ncount = count_element_in_list(list_of_lists, element)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists within a list of lists that contain a specific element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for within the sublists.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"Counts the number of sublists in a given list that contain a specific element.\n\n    Args:\n        lst: The list of lists to search within.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count\nlist_of_lists = [[1, 3], [5, 7], [1, 11], [1, 15, 7]]\nelement_to_count = 1\ncount = count_element_in_list(list_of_lists, element_to_count)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists within a list of lists that contain a specific element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for within the sublists.\n\n    Returns:\n      The number of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists within a list of lists that contain a specified element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for within the sublists.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"Counts the number of sublists containing a specific element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 81.36363636363636, "dps_norm": 55.0, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell Sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts a list using the shell sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell Sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts a list using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Integer division ensures gap reduces correctly\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts a list using the Shell Sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell Sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the shell sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using the Shell Sort algorithm.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts a given array using the shell sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 66.64893617021276, "dps_norm": 81.0, "pass@1": 100.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The input array of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The input array of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The input array of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The input array of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the given number is greater than all elements in the array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the given number is greater than all elements of the array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:  # Check for less than or equal to handle edge cases\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the given number is greater than all elements in the array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The array to check against.\n        num: The number to compare.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n      arr: The input array of numbers.\n      num: The number to compare against.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the given number is greater than all elements in the array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare against.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the given number is greater than all elements in the array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare against.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in an array.\n\n    Args:\n        arr: The input array of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}]}, "Mbpp/437": {"dps": 70.58823529411765, "dps_norm": 20.0, "pass@1": 28.0, "profiled": [{"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result\ntest_string = \"programming\"\nresult = remove_odd(test_string)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check if the index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices (1, 3, 5, ...)\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check if the index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check if the index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check if the index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check if the index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check if the index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check if the index is odd\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"Removes characters at odd indices from a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(input_string)):\n        if i % 2 == 1:  # Check for odd indices\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}]}, "Mbpp/440": {"dps": 36.36363636363637, "dps_norm": 75.0, "pass@1": 20.0, "profiled": [{"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its positions in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\" \n    #  with optional punctuation immediately following\n    pattern = r\"\\b(\\w+ly)(\\W*)\"\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)  # Corrected to only encompass the adverb, not trailing punctuation\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\" (with potential punctuation)\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  # \\b for word boundary, \\W* for trailing punctuation\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence as a string.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\" (with optional punctuation)\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  # \\b for word boundary, capturing the adverb and following punctuation\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n\n    # Regular expression pattern to match adverbs ending in \"ly\"\n    # Includes handling for punctuation immediately following the adverb\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  \n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)  # Exclude punctuation from adverb itself\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its start and end positions in a given sentence.\n\n    Args:\n        sentence: The input sentence as a string.\n\n    Returns:\n        A tuple containing the start position, end position, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in -ly (with potential punctuation)\n    pattern = r\"\\b(\\w+ly)(\\W*)\"\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_pos = match.start(1)\n        end_pos = match.end(1)  # Exclude trailing punctuation from the adverb itself\n        adverb = match.group(1)\n        return start_pos, end_pos, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\" \n    # and handles potential punctuation immediately after the adverb.\n    pattern = r\"\\b(\\w+ly)(\\W*)\"\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its start and end positions in a sentence.\n\n    Args:\n        sentence: The input sentence as a string.\n\n    Returns:\n        A tuple containing the start position, end position, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n\n    # Regular expression pattern to match adverbs ending in \"ly\" \n    # and handle punctuation immediately following the adverb.\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  # \\b for word boundary, \\W* for trailing punctuation\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start = match.start(1)\n        end = match.end(1)\n        adverb = match.group(1)\n        return (start, end, adverb)\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n\n    # Regular expression pattern to match adverbs ending in \"ly\"\n    # Includes handling for double punctuation like \"clearly!!\"\n    pattern = r\"\\b(\\w+ly)(\\W*)\"\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\" (with potential punctuation).\n    pattern = r\"\\b(\\w+ly)(\\W*)\"\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself. \n        Returns None if no adverb is found.\n    \"\"\"\n\n    # Regular expression pattern to match adverbs ending in \"ly\" (with possible punctuation)\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  # \\b for word boundaries\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start = match.start(1)\n        end = match.end(1)\n        adverb = match.group(1)\n        return start, end, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself. \n        Returns None if no adverb is found.\n    \"\"\"\n    # Regex pattern to match adverbs ending in \"ly\" (with potential punctuation following).\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  # \\b for word boundary, \\W* for optional punctuation\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)  # Excludes punctuation\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its positions in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\" with optional punctuation\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  \n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\"\n    # It accounts for punctuation immediately after the adverb.\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  \n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its start and end positions in a sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start position, end position, and the adverb itself, \n        or None if no adverb is found.\n    \"\"\"\n\n    # Regular expression pattern to match adverbs ending in \"ly\" \n    # and handle potential punctuation immediately following the adverb.\n    pattern = r\"\\b(\\w+ly)([!.,;:\\-\\\"'?\\s]+)?\"  \n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start = match.start()\n        adverb = match.group(1)\n        end = start + len(adverb)\n        return start, end, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its positions in a given sentence.\n\n    Args:\n        sentence: The input sentence as a string.\n\n    Returns:\n        A tuple containing the start position, end position, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\"\n    # Includes handling for multiple exclamation marks or other punctuation\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  \n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_pos = match.start(1)\n        end_pos = match.end(1)\n        adverb = match.group(1)\n        return (start_pos, end_pos, adverb)\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself. \n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression to match adverbs ending in \"ly\" with optional punctuation\n    pattern = r\"\\b(\\w+ly)(\\W*)\"\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence as a string.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"-ly\" along with potential punctuation.\n    pattern = r\"\\b(\\w+ly)([!.,:;?]*)\"  # \\b ensures word boundaries\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence as a string.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\" \n    # (accounts for punctuation immediately following the adverb)\n    pattern = r\"\\b(\\w+ly)(\\W*)\"\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        adverb = match.group(1)\n        start_index = match.start()\n        end_index = match.end(1) # Only get the end index of the adverb, not including punctuation.\n        return (start_index, end_index, adverb)\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its position in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regex pattern to match adverbs ending in \"ly\" with optional punctuation\n    pattern = r\"\\b(\\w+ly)(\\W*)\"  # \\b for word boundary\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return start_index, end_index, adverb\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    Finds the first adverb and its positions in a given sentence.\n\n    Args:\n        sentence: The input sentence.\n\n    Returns:\n        A tuple containing the start index, end index, and the adverb itself.\n        Returns None if no adverb is found.\n    \"\"\"\n    # Regular expression pattern to match adverbs ending in \"ly\" with optional punctuation.\n    pattern = r\"\\b(\\w+ly)(\\W*)\"\n\n    match = re.search(pattern, sentence)\n\n    if match:\n        start_index = match.start(1)\n        end_index = match.end(1)\n        adverb = match.group(1)\n        return (start_index, end_index, adverb)\n    else:\n        return None", "matching_cluster_idx": 2}]}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 89.0, "profiled": [{"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"Counts occurrences of list elements within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        my_tuple: The tuple to search within.\n        my_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in my_list:\n        count += my_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        my_tuple: The tuple to search within.\n        my_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in my_list:\n        count += my_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        my_tuple: The tuple to search within.\n        my_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of elements from my_list in my_tuple.\n    \"\"\"\n\n    count = 0\n    for item in my_list:\n        count += my_tuple.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        my_tuple: The tuple to search within.\n        my_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of elements from my_list in my_tuple.\n    \"\"\"\n    count = 0\n    for item in my_list:\n        count += my_tuple.count(item)  # Use tuple's built-in count method\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        my_tuple: The tuple to search within.\n        my_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of elements from my_list in my_tuple.\n    \"\"\"\n\n    count = 0\n    for element in my_list:\n        count += my_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of elements from input_list within input_tuple.\n    \"\"\"\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of elements from the list in the tuple.\n    \"\"\"\n\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        my_tuple: The tuple to search within.\n        my_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n\n    count = 0\n    for item in my_list:\n        count += my_tuple.count(item)  # Efficiently counts using tuple's built-in method\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    \"\"\"Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        my_tuple: The tuple to search within.\n        my_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in my_list:\n        count += my_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        input_list: The list of elements to count.\n\n    Returns:\n        The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 83.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The string with all whitespace characters removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The string with all whitespace removed.\n    \"\"\"\n\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"Removes all whitespace characters from a string.\"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        A new string with all whitespaces removed.\n    \"\"\"\n\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in a list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string within a list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list\nmy_list = ['apple', 'banana', 'cherry']\nreversed_list = reverse_string_list(my_list)", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list with each string reversed.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list\nmy_list = ['apple', 'banana', 'cherry']\nreversed_list = reverse_string_list(my_list)", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A list with each string reversed.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string within a list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in a list of strings.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      A new list with each string reversed.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A list of reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A list with each string reversed.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in a list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in a list.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A list with each string reversed.\n    \"\"\"\n\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string within a list of strings.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])  # Efficient string reversal in Python\n    return reversed_list\nmy_list = ['apple', 'banana', 'cherry']\nreversed_list = reverse_string_list(my_list)", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string within a list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list\nmy_list = ['apple', 'banana', 'cherry']\nreversed_list = reverse_string_list(my_list)", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in a list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list with each string reversed.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string within a list of strings.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list\nmy_list = ['apple', 'banana', 'cherry']\nreversed_list = reverse_string_list(my_list)", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in a list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for s in string_list:\n        reversed_list.append(s[::-1])\n    return reversed_list\nmy_list = ['apple', 'banana', 'cherry']\nreversed_list = reverse_string_list(my_list)", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list\nmy_list = ['apple', 'banana', 'cherry']\nreversed_list = reverse_string_list(my_list)", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string within a list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list containing the reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list with each string reversed.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list\nmy_list = ['Red', 'Green', 'Blue', 'White', 'Black']\nreversed_list = reverse_string_list(my_list)", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 27.019230769230766, "dps_norm": 52.0, "pass@1": 99.0, "profiled": [{"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in a given list of lists.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains non-list elements.\n    \"\"\"\n    result = []\n    for item in lst:\n        if isinstance(item, list) and len(item) > 0:\n            result.append(item[0])\n    return result", "matching_cluster_idx": -1}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist within a given list.\n\n    Args:\n        lst: A list of sublists.\n\n    Returns:\n        A new list containing the first element of each sublist.\n        Returns an empty list if the input is empty or not a list of lists.\n    \"\"\"\n\n    result = []\n    if lst and all(isinstance(sub, list) for sub in lst):  # Check if it's a non-empty list of lists\n        for sublist in lst:\n            if sublist: # Guard against empty sublists\n                result.append(sublist[0])\n    return result", "matching_cluster_idx": 1}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist within a given list.\n\n    Args:\n        lst: A list of sublists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains non-list elements.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if isinstance(sublist, list) and len(sublist) > 0:\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": -1}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in a given list of lists.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or not a list of lists.\n    \"\"\"\n    result = []\n    if not lst:\n        return result  # Handle empty input list\n    if not all(isinstance(sublist, list) for sublist in lst):\n        return result # Handle if not all elements are lists\n\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 1}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in a given list of lists.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist within a given list.\n\n    Args:\n        lst: A list of sublists.\n\n    Returns:\n        A list containing the first elements of each sublist.\n        Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist.\n\n    Args:\n      lst: A list of lists.\n\n    Returns:\n      A list containing the first element of each sublist.\n      Returns an empty list if the input list is empty or contains non-list elements.\n    \"\"\"\n    result = []\n    for item in lst:\n        if isinstance(item, list) and len(item) > 0:\n            result.append(item[0])\n    return result", "matching_cluster_idx": -1}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in a given list of lists.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A new list containing the first element of each sublist.\n        Returns an empty list if the input is an empty list.\n        Raises TypeError if the input is not a list or if any sublist is not a list or is empty.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    if not lst:\n      return []\n\n    result = []\n    for sublist in lst:\n        if not isinstance(sublist, list):\n            raise TypeError(\"Sublists must be lists.\")\n        if not sublist:\n            raise TypeError(\"Sublists cannot be empty.\")\n        result.append(sublist[0])\n    return result", "matching_cluster_idx": 1}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist within the provided list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A new list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains non-list elements.\n    \"\"\"\n    result = []\n    for item in lst:\n        if isinstance(item, list) and len(item) > 0:  # Check if it's a non-empty list\n            result.append(item[0])\n    return result", "matching_cluster_idx": -1}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in a given list of lists.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in a given list of lists.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains any non-list elements.\n    \"\"\"\n    result = []\n    for item in lst:\n        if isinstance(item, list) and len(item) > 0:\n            result.append(item[0])\n        elif not isinstance(item, list):\n          return []  # Return empty list if any element is not a list\n    return result", "matching_cluster_idx": -1}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in a given list of lists.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input is not a list or if any sublist is empty.\n    \"\"\"\n    if not isinstance(lst, list):\n        return []\n\n    result = []\n    for sublist in lst:\n        if isinstance(sublist, list) and sublist:\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 1}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in a given list of lists.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist within a given list.\n\n    Args:\n        lst: A list of sublists.\n\n    Returns:\n        A new list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in a given list of lists.\n\n    Args:\n      lst: A list of lists.\n\n    Returns:\n      A new list containing the first element of each sublist. \n      Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in a given list of lists.\n\n    Args:\n      lst: A list of lists.\n\n    Returns:\n      A list containing the first element of each sublist.\n      Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist within a given list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A new list containing the first element of each sublist.\n        Returns an empty list if the input list is empty or contains empty sublists.\n    \"\"\"\n    result = []\n    for sublist in lst:\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 47.70731707317073, "dps_norm": 54.285714285714285, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in a string.\n\n    Args:\n        string: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if char == old_char:\n            new_string += new_char\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the given string.\n\n    Args:\n        string: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n\n    new_string = \"\"\n    for char in string:\n        if char == old_char:\n            new_string += new_char\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in text.\n\n    Args:\n        text: The input string.\n        old_char: The character to be replaced.\n        new_char: The replacement character.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the given text.\n\n    Args:\n        text: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n    new_text = \"\"\n    for char in text:\n        if char == old_char:\n            new_text += new_char\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 2}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the given string.\n\n    Args:\n        string: The string to modify.\n        old_char: The character to replace.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n\n    new_string = \"\"\n    for char in string:\n        if char == old_char:\n            new_string += new_char\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the input string.\n\n    Args:\n        text: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n\n    new_text = \"\"\n    for char in text:\n        if char == old_char:\n            new_text += new_char\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 2}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in input_string.\n\n    Args:\n        input_string: The string to modify.\n        old_char: The character to replace.\n        new_char: The character to replace with.\n\n    Returns:\n        A new string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in text.\"\"\"\n    new_text = \"\"\n    for char in text:\n        if char == old_char:\n            new_text += new_char\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 2}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in a string.\"\"\"\n    new_string = \"\"\n    for char in string:\n        if char == old_char:\n            new_string += new_char\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the given text.\n\n    Args:\n        text: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the given text.\n\n    Args:\n        text: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        The string with the characters replaced.\n    \"\"\"\n\n    new_text = \"\"\n    for char in text:\n        if char == old_char:\n            new_text += new_char\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 2}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        string: The input string.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n    new_string = \"\"\n    for char in string:\n        if char == char_to_replace:\n            new_string += replacement_char\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in text.\"\"\"\n    new_text = \"\"\n    for char in text:\n        if char == old_char:\n            new_text += new_char\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 2}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a specific character in a string with another character.\n\n    Args:\n        string: The input string.\n        char_to_replace: The character to be replaced.\n        replacement_char: The character to replace with.\n\n    Returns:\n        The modified string with the character replaced.\n    \"\"\"\n\n    new_string = \"\"\n    for char in string:\n        if char == char_to_replace:\n            new_string += replacement_char\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the given text.\n\n    Args:\n        text: The string to modify.\n        old_char: The character to replace.\n        new_char: The replacement character.\n\n    Returns:\n        The modified string with replacements made.\n    \"\"\"\n\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in a string.\"\"\"\n    new_string = \"\"\n    for char in string:\n        if char == old_char:\n            new_string += new_char\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the given text.\n\n    Args:\n        text: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n\n    new_text = \"\"\n    for char in text:\n        if char == old_char:\n            new_text += new_char\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 2}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in a string.\n\n    Args:\n        text: The string to modify.\n        old_char: The character to replace.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    new_text = \"\"\n    for char in text:\n        if char == old_char:\n            new_text += new_char\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 2}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in a string.\n\n    Args:\n        text: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    new_text = \"\"\n    for char in text:\n        if char == old_char:\n            new_text += new_char\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 2}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the given string.\n\n    Args:\n        string: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        The modified string with the characters replaced.\n    \"\"\"\n\n    new_string = \"\"\n    for char in string:\n        if char == old_char:\n            new_string += new_char\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 2}]}, "Mbpp/476": {"dps": 77.41610738255034, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "import sys\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements, or -sys.maxsize - 1 if the array is empty.\n    \"\"\"\n    if not arr:\n        return -sys.maxsize - 1  # Return negative infinity if the array is empty\n    min_val = sys.maxsize\n    max_val = -sys.maxsize - 1\n    for num in arr:\n        min_val = min(min_val, num)\n        max_val = max(max_val, num)\n    return min_val + max_val", "matching_cluster_idx": 0}, {"solution": "import sys\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest values in the array.\n        Returns negative infinity if the array is empty.\n    \"\"\"\n    if not arr:\n        return -sys.maxsize - 1  # Return negative infinity for empty array\n\n    min_val = arr[0]\n    max_val = arr[0]\n\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "import math\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns -math.inf if the array is empty.\n    \"\"\"\n\n    if not arr:\n        return -math.inf\n    \n    min_val = min(arr)\n    max_val = max(arr)\n    \n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "import sys\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements.\n        Returns negative infinity if the array is empty.\n    \"\"\"\n    if not arr:\n        return -sys.maxsize - 1  # Return negative infinity for empty array\n\n    min_val = arr[0]\n    max_val = arr[0]\n\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "import math\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements.\n        Returns negative infinity if the array is empty.\n    \"\"\"\n    if not arr:\n        return -math.inf  # Handle empty array case\n\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0  # Handle empty array case\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "import sys\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in a given array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest values in the array.\n        Returns 0 if the array is empty.  (Clarification added for empty array case)\n    \"\"\"\n    if not arr:\n        return 0  # Handle empty array case\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "import sys\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements.\n        Returns -1 if the array is empty.\n    \"\"\"\n    if not arr:\n        return -1\n\n    min_val = sys.maxsize  # Initialize with the maximum possible value\n    max_val = -sys.maxsize - 1 # Initialize with the minimum possible value\n\n    for num in arr:\n        min_val = min(min_val, num)\n        max_val = max(max_val, num)\n    \n    return min_val + max_val", "matching_cluster_idx": 0}, {"solution": "import sys\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns -sys.maxsize if the array is empty.\n    \"\"\"\n    if not arr:\n        return -sys.maxsize  # Handle empty array case\n\n    min_val = arr[0]\n    max_val = arr[0]\n\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0  # Handle empty array case\n\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "import math\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns negative infinity if the array is empty.\n    \"\"\"\n    if not arr:\n        return -math.inf  # Or raise an exception if an empty array is considered invalid\n\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "import math\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns negative infinity if the array is empty.\n    \"\"\"\n    if not arr:\n        return -math.inf  # Return negative infinity for an empty array\n\n    min_val = min(arr)\n    max_val = max(arr)\n\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "import sys\ndef big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns -sys.maxsize if the array is empty.\n    \"\"\"\n    if not arr:\n        return -sys.maxsize\n\n    min_val = arr[0]\n    max_val = arr[0]\n\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "import math\ndef big_sum(arr):\n    \"\"\"\n    Calculates the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns negative infinity if the array is empty.\n    \"\"\"\n\n    if not arr:\n        return -math.inf  # Return negative infinity for an empty array\n\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest elements in an array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest value in a given array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest elements in the array.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0  # Handle empty array case\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(input_string):\n    \"\"\"Converts the given string to lower case.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lower-cased string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts the given string to lowercase.\n\n    Args:\n      input_string: The string to convert.\n\n    Returns:\n      The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts the input string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts the given string to lower case.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lower case version of the string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts the given string to lower case.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lowercase version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"Converts the given string to lower case.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        The lower case version of the string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 82.81420765027323, "dps_norm": 81.36363636363636, "pass@1": 99.0, "profiled": [{"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values, or an empty list if no values are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values, or an empty list if no values are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found between double quotes.\n        Returns an empty list if no values are found or the input is invalid.\n    \"\"\"\n\n    try:\n        return re.findall(r'\"([^\"]*)\"', text)\n    except TypeError:\n        return []", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        A list of strings containing the extracted values, or an empty list if no values are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values, or an empty list if no values are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The string containing quoted values.\n\n    Returns:\n        A list of strings, where each string is a value extracted from\n        within double quotes. Returns an empty list if no quoted values are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found between double quotes.\n        Returns an empty list if no values are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found between double quotes.\n        Returns an empty list if no values are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found within double quotes. \n        Returns an empty list if no values are found or if the input is not a string.\n    \"\"\"\n    if not isinstance(text, str):\n        return []\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found between double quotes.\n        Returns an empty list if no values are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The string to extract values from.\n\n    Returns:\n        A list of strings containing the extracted values, or an empty list if no values are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found between double quotes.\n        Returns an empty list if no values are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found between double quotes.\n        Returns an empty list if no values are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values, or an empty list if no values are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found within double quotes.\n        Returns an empty list if no values are found.\n    \"\"\"\n    try:\n        return re.findall(r'\"([^\"]*)\"', text)\n    except TypeError:\n        return []", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values. \n        Returns an empty list if no values are found.\n    \"\"\"\n\n    try:\n        return re.findall(r'\"([^\"]*)\"', text)\n    except TypeError:\n        return []", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        input_string: The string to extract values from.\n\n    Returns:\n        A list of strings containing the extracted values, or an empty list if no values are found.\n    \"\"\"\n    try:\n        return re.findall(r'\"([^\"]*)\"', input_string)\n    except TypeError:  # Handle cases where input is not a string\n        return []", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found between double quotes.\n        Returns an empty list if no values are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        A list of strings, where each string is a value found between quotation marks.\n        Returns an empty list if no values are found.\n    \"\"\"\n\n    # Regular expression to find quoted strings. \n    # It handles escaped quotes within the string as well.\n    matches = re.findall(r'\"((?:[^\"\\\\]|\\\\.)*)\"', s)\n    return matches", "matching_cluster_idx": 7}]}, "Mbpp/572": {"dps": 90.74074074074075, "dps_norm": 88.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the numbers that appear exactly once in the input list, preserving their original order.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes numbers appearing more than once from a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the numbers that appeared exactly once in the input list.\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num, count in counts.items():\n        if count == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A list containing only the numbers that appeared once in the input list,\n        preserving their original order.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a list and returns a new list containing only the unique numbers.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the numbers that appear once in the input list.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a list and returns a new list containing only the unique elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the unique elements from the input list.\n    \"\"\"\n\n    counts = Counter(nums)\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list containing only the numbers that appeared once in the input list,\n        preserving their original order.\n    \"\"\"\n\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the numbers that appeared once in the input list,\n        preserving their original order.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"Removes duplicate numbers from a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the numbers that appear once in the input list.\n        The order of the elements in the returned list should match the order of their first occurrence in the input list.\n    \"\"\"\n\n    counts = Counter(nums)\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the numbers that appeared once in the input list, preserving their original order.\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the numbers that appeared once in the input list.\n        The order of the elements in the output list should maintain the original order \n        in which they appeared in the input list.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the unique numbers that appear only once in the input list.\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num, count in counts.items():\n        if count == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list and returns the unique numbers.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list containing only the numbers that appear once in the input list.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list containing only the numbers that appeared once in the input list, preserving their original order.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from a list and returns a new list containing only the unique numbers.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the numbers that appear once in the input list.\n    \"\"\"\n\n    counts = Counter(nums)\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A list containing only the numbers that appeared exactly once in the input list,\n        preserving their original order.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A new list containing only the numbers that appear exactly once in the input list.\n    \"\"\"\n\n    counts = Counter(nums)\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list, preserving order.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list containing only the numbers that appeared once in the input list,\n        preserving their original order.\n    \"\"\"\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n\n    unique_nums = []\n    for num in nums:\n        if counts[num] == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list containing only the numbers that appear once in the input list, preserving their original order.\n    \"\"\"\n\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list and returns the unique numbers.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list containing only the numbers that appear once in the input list.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in a list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A new list containing only the numbers that appear once in the input list, preserving original order.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 58.41269841269841, "dps_norm": 63.63636363636363, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Returns an empty list if the input lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        return []\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements of the input lists.\n        Returns an empty list if the input lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        return []\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements of the input lists.\n        Returns an empty list if the input lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        return []\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Returns an empty list if the input lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        return []\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Raises ValueError if the input lists are not of the same length.\n\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Raises ValueError if lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements of the input lists.\n        Raises ValueError if lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Raises ValueError if lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements of the input lists.\n        Raises ValueError if the input lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Raises ValueError if lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Returns an empty list if the input lists are not of the same length.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        return []\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef interleave_lists(list1: List, list2: List, list3: List) -> List:\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length.\")\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Lists must be of the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Raises ValueError if the lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Raises ValueError if the lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Raises ValueError if lists are not of the same length.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must be of the same length\")\n    \n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing the interleaved elements.\n        Raises ValueError if lists are not of the same length.\n    \"\"\"\n\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"Lists must have the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 84.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list.\n        Returns the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle out-of-bounds index\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and appends the first part to the end.\n\n    Args:\n        arr: The list to be split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list, or the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list, or the original list if n is invalid.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle invalid 'n' values\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The rearranged list.\n        Returns the original list if n is out of bounds (negative or greater than or equal to the length of the list).\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]\nn = 2", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list.\n        Returns the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle invalid 'n' values\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and appends the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list.\n        Returns the original list if n is out of bounds (negative or greater than/equal to the length of the list).\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list.\n        Returns the original list if n is invalid (out of range or not an integer).\n    \"\"\"\n    if not isinstance(n, int) or n < 0 or n >= len(arr):\n        return arr  # Handle invalid input\n    return arr[n:] + arr[:n]\nn = 2", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The rearranged list, or the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle out-of-bounds n\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input 'arr' must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"Input 'n' must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"Input 'n' must be within the range of the list's length.\")\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list, or the original list if n is invalid.\n    \"\"\"\n    if not isinstance(arr, list) or not isinstance(n, int) or n < 0 or n >= len(arr):\n      return arr  # Handle invalid input gracefully\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list with the first part appended to the end.\n        Returns the original list if n is out of bounds or if the list is empty.\n    \"\"\"\n\n    if not arr or n < 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index to split at.\n\n    Returns:\n        The modified list.  Returns the original list if n is invalid.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and appends the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list.  Returns the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle invalid 'n' values\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index to split at.\n\n    Returns:\n        The modified list.\n        Returns the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Handle out-of-bounds n\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list, or None if the input is invalid.\n    \"\"\"\n    if not isinstance(arr, list) or not isinstance(n, int) or n < 0 or n > len(arr):\n        return None\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list.\n        Returns the original list if n is out of bounds or if the list is empty.\n    \"\"\"\n\n    if not arr or n < 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The list to be split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list, or the original list if n is out of bounds.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # Return original list if n is invalid\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and appends the first part to the end.\n\n    Args:\n      arr: The list to be split.\n      n: The index at which to split the list.\n\n    Returns:\n      The modified list.\n      Returns the original list if n is out of bounds or not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        return arr\n    if n < 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]\nn = 2", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and appends the first part to the end.\n\n    Args:\n        arr: The list to split.\n        n: The index at which to split the list.\n\n    Returns:\n        The modified list.\n        Returns the original list if n is out of bounds or if the list is empty.\n    \"\"\"\n    if not arr or n < 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]\nn = 2", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 29.72972972972973, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list1: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n    list1: The input list.\n\n    Returns:\n    A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(my_list):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        my_list: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(my_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list1: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list1: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list1: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"\n    Converts a list to a tuple.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      list1: The input list.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(my_list):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        my_list: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n\n    return tuple(my_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(my_list):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        my_list: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(my_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(my_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        my_list: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(my_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list1: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      list1: The input list.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      list1: The list to convert.\n\n    Returns:\n      A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(my_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        my_list: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(my_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(my_list):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        my_list: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(my_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list1: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        list1: The input list.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n\n    return tuple(list1)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(my_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        my_list: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(my_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list1):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        list1: The list to convert.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(list1)", "matching_cluster_idx": 2}]}, "Mbpp/588": {"dps": 97.13302752293578, "dps_norm": 99.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a given list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a given list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest values in the list.\n      Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a given list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n    \"\"\"\n\n    if not nums:\n        return 0  # Handle empty list case\n\n    min_val = nums[0]\n    max_val = nums[0]\n\n    for num in nums:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n\n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0  # Handle empty list case\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return 0\n    \n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n        Returns 0 if the list is empty or contains only one element.\n    \"\"\"\n    if not nums or len(nums) == 1:  # Handle empty or single-element lists\n        return 0\n    \n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 37.93333333333334, "dps_norm": 40.0, "pass@1": 97.0, "profiled": [{"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n: An integer representing the upper limit of the binomial coefficient.\n\n    Returns:\n        The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n\n    total_sum = 0\n    for r in range(n + 1):\n        if r < n:  # Avoid index out of bounds when accessing nCr+1\n            nCr = math.comb(n, r)\n            nC_r_plus_1 = math.comb(n, r + 1)\n            total_sum += nCr * nC_r_plus_1\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n: An integer representing the upper limit of the binomial coefficient.\n\n    Returns:\n        The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input n must be a non-negative integer.\")\n    \n    total_sum = 0\n    for i in range(n + 1):\n        if i < n:\n            total_sum += comb(n, i) * comb(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"Calculates the binomial coefficient (n choose r).\"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n-r)\ndef sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients for a given n.\n  \"\"\"\n  sum_prod = 0\n  for r in range(n):\n      sum_prod += nCr(n, r) * nCr(n, r+1)\n  return sum_prod", "matching_cluster_idx": 1}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"Calculates the binomial coefficient (n choose r).\"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of the product of consecutive binomial coefficients.\"\"\"\n    sum_prod = 0\n    for r in range(n):\n        sum_prod += nCr(n, r) * nCr(n, r + 1)\n    return sum_prod\nn = 5", "matching_cluster_idx": 1}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"Calculates the binomial coefficient (n choose r).\"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n-r)\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of the product of consecutive binomial coefficients.\"\"\"\n    sum_prod = 0\n    for r in range(n):\n        sum_prod += nCr(n, r) * nCr(n, r + 1)\n    return sum_prod\nn = 6", "matching_cluster_idx": 1}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"Calculates nCr (n choose r) using the formula n! / (r! * (n-r)!)\"\"\"\n    if r < 0 or r > n:\n        return 0\n    return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n    \"\"\"\n    sum_prod = 0\n    for r in range(n + 1):\n        sum_prod += nCr(n, r) * nCr(n, r + 1)\n    return sum_prod", "matching_cluster_idx": 1}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"Calculate nCr (n choose r) using math.comb.\"\"\"\n    return math.comb(n, r)\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    sum_prod = 0\n    for r in range(n):\n      sum_prod += nCr(n,r) * nCr(n, r+1)\n    return sum_prod", "matching_cluster_idx": 5}, {"solution": "import math\ndef binomial_coefficient(n, k):\n    \"\"\"Calculates the binomial coefficient (n choose k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum\nn = 5", "matching_cluster_idx": 4}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"Calculates the binomial coefficient (n choose r).\"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n-r)\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    sum_prod = 0\n    for r in range(n):\n        sum_prod += nCr(n, r) * nCr(n, r + 1)\n    return sum_prod", "matching_cluster_idx": 1}, {"solution": "import math\ndef binomial_coefficient(n, k):\n    \"\"\"Calculates the binomial coefficient (n choose k).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    return math.comb(n, k)  # Use math.comb for efficiency and accuracy\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    Specifically, it computes:\n    \u03a3(k=0 to n-1) (nCk * nC(k+1)) \n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum\nn = 5", "matching_cluster_idx": 4}, {"solution": "import math\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n-r)\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n: An integer representing the upper limit of the binomial coefficient.\n\n    Returns:\n        The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n\n    total_sum = 0\n    for r in range(n):\n        total_sum += nCr(n, r) * nCr(n, r + 1)\n    return total_sum\nn = 3", "matching_cluster_idx": 1}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"Calculates the binomial coefficient (n choose r).\"\"\"\n    if 0 <= r <= n:\n        return math.comb(n, r)  # Efficiently computes binomial coefficient\n    else:\n        return 0  # Handles cases where r is out of bounds\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n    \"\"\"\n    total_sum = 0\n    for r in range(n + 1):\n        total_sum += nCr(n, r) * nCr(n, r + 1)\n    return total_sum\nn = 5", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n: An integer representing the upper limit of the binomial coefficient.\n\n    Returns:\n        The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input n must be a non-negative integer.\")\n\n    total_sum = 0\n    for i in range(n):\n        total_sum += comb(n, i) * comb(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef binomialCoeff(n, k):\n    \"\"\"Calculates the binomial coefficient (nCk).\"\"\"\n    res = 1\n    if k > n - k:\n        k = n - k\n    for i in range(k):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of products of consecutive binomial coefficients.\"\"\"\n    sum_prod = 0\n    for i in range(n + 1):\n        sum_prod += binomialCoeff(n, i) * binomialCoeff(n, i + 1) if i+1 <= n else 0\n    return sum_prod", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n: An integer representing the upper limit for the binomial coefficients.\n\n    Returns:\n        The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n + 1):\n        if k < n:\n            total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef binomial_coefficient(n, k):\n    \"\"\"Calculates the binomial coefficient (nCk).\"\"\"\n    if k < 0 or k > n:\n        return 0\n    return math.comb(n, k)  # Using math.comb for efficiency\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for k in range(n + 1):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"Calculates the binomial coefficient (n choose r).\"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n-r)\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n    \"\"\"\n    total_sum = 0\n    for r in range(n):\n        total_sum += nCr(n, r) * nCr(n, r + 1)\n    return total_sum", "matching_cluster_idx": 1}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n: An integer representing the upper limit of the binomial coefficient.\n\n    Returns:\n        The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n\n    total_sum = 0\n    for k in range(n + 1):\n        if k < n:\n            term1 = math.comb(n, k)\n            term2 = math.comb(n, k + 1)\n            total_sum += term1 * term2\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef nCr(n, r):\n    return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n: An integer representing the upper limit of the binomial coefficient.\n\n    Returns:\n        The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n\n    total_sum = 0\n    for r in range(0, n):\n        total_sum += nCr(n, r) * nCr(n, r + 1)\n    return total_sum\nn = 5", "matching_cluster_idx": 2}, {"solution": "import math\ndef nCr(n, r):\n    \"\"\"Calculates the binomial coefficient \"n choose r\".\"\"\"\n    if r > n:\n        return 0\n    f = math.factorial\n    return f(n) // f(r) // f(n-r)\ndef sum_Of_product(n):\n    \"\"\"Calculates the sum of the product of consecutive binomial coefficients.\"\"\"\n    sum_prod = 0\n    for r in range(n + 1):\n        sum_prod += nCr(n, r) * nCr(n, r + 1)\n    return sum_prod\nn = 3", "matching_cluster_idx": 1}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 90.0, "profiled": [{"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with words reversed.\n        Returns an empty string if the input is an empty string or contains only spaces.\n    \"\"\"\n    words = s.split()\n    if not words:  # Handle empty string or string with only spaces\n        return \"\"\n    return \" \".join(reversed(words))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string.\n\n    Args:\n        input_string: The string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed. Returns an empty string if the input is empty or contains only whitespace.\n    \"\"\"\n    words = input_string.split()\n    if not words:  # Handle empty or whitespace-only input\n        return \"\"\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string.\n\n    Args:\n        input_string: The string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed.\n        Returns an empty string if the input is empty or contains only spaces.\n    \"\"\"\n    words = input_string.split()\n    if not words:  # Handle empty or space-only input\n        return \"\"\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string separated by spaces.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with words reversed.\n        Returns an empty string if the input is an empty string or only contains whitespace.\n    \"\"\"\n    words = s.split()\n    if not words:  # Handle empty string or string with only whitespace\n        return \"\"\n    return \" \".join(reversed(words))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with words reversed.\n    \"\"\"\n    words = s.split()\n    return \" \".join(reversed(words))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"Reverses the order of words in a string.\n\n    Args:\n        input_string: The string to reverse.\n\n    Returns:\n        The string with words reversed.\n        Returns an empty string if the input is empty or consists only of whitespace.\n    \"\"\"\n\n    words = input_string.split()\n    if not words:  # Handle empty or whitespace-only input\n        return \"\"\n    \n    reversed_words = words[::-1]  # Reverse the list of words\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string separated by spaces.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with the words reversed.\n        Returns an empty string if the input is None or an empty string.\n    \"\"\"\n    if not s:  # Handles None and empty strings\n        return \"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"Reverses the order of words in a string separated by spaces.\n\n    Args:\n        input_string: The string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed.  Returns an empty string if the input is empty or contains only whitespace.\n    \"\"\"\n\n    words = input_string.split()\n    if not words:  # Handle empty or whitespace-only input\n        return \"\"\n    return \" \".join(reversed(words))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string separated by spaces.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with the words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]  # Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string.\n\n    Args:\n        input_string: The string containing words separated by spaces.\n\n    Returns:\n        A string with the words reversed.\n    \"\"\"\n    words = input_string.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses words separated by spaces in a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]  # Efficient way to reverse a list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with words reversed.\n    \"\"\"\n    words = s.split()\n    return \" \".join(reversed(words))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n    \"\"\"Reverses the order of words in a space-separated string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The string with words reversed.\n    \"\"\"\n    words = text.split()\n    reversed_words = words[::-1]  # Reverse the list of words\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n    \"\"\"\n    Reverses the order of words in a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The string with words reversed.\n    \"\"\"\n    words = text.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]  # Efficiently reverses the list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"Reverses the order of words in a string.\n\n    Args:\n        input_string: The string to reverse.\n\n    Returns:\n        The reversed string.\n    \"\"\"\n    words = input_string.split()\n    reversed_words = words[::-1]  # Efficient way to reverse a list\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a string.\n\n    Args:\n        input_string: The string containing words separated by spaces.\n\n    Returns:\n        The string with words reversed. Returns an empty string if the input is empty or contains only spaces.\n    \"\"\"\n    words = input_string.split()\n    if not words:  # Handle empty or space-only strings\n        return \"\"\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with words reversed.\n        Returns an empty string if the input is an empty string or contains only spaces.\n\n    \"\"\"\n    words = s.split()\n    if not words:  # Handle empty string or string with only spaces\n        return \"\"\n    return \" \".join(words[::-1])", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/611": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/631": {"dps": 31.597222222222218, "dps_norm": 33.75, "pass@1": 100.0, "profiled": [{"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and underscores with spaces in a string.\"\"\"\n\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice-versa in a string.\"\"\"\n\n    result = []\n    for char in input_string:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return \"\".join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and underscores with spaces in a string.\"\"\"\n    result = ''\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces whitespaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces whitespaces with underscores and vice versa in a string.\"\"\"\n\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The modified string with spaces and underscores swapped.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The string to modify.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    modified_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            modified_string += \"_\"\n        elif char == \"_\":\n            modified_string += \" \"\n        else:\n            modified_string += char\n    return modified_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice-versa in a string.\"\"\"\n\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and underscores with spaces in a string.\n\n    Args:\n        input_string: The string to modify.\n\n    Returns:\n        The modified string.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice-versa in a string.\n\n    Args:\n        input_string: The string to modify.\n\n    Returns:\n        The modified string with spaces replaced by underscores and vice-versa.\n    \"\"\"\n\n    modified_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            modified_string += \"_\"\n        elif char == \"_\":\n            modified_string += \" \"\n        else:\n            modified_string += char\n    return modified_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces whitespaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The string to modify.\n\n    Returns:\n        The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and underscores with spaces in a string.\"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice-versa in a string.\"\"\"\n\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The string with spaces replaced by underscores and vice versa.\n    \"\"\"\n\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and underscores with spaces in a string.\"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and underscores with spaces in a string.\n\n    Args:\n        input_string: The string to modify.\n\n    Returns:\n        The modified string.\n    \"\"\"\n\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice-versa in a string.\"\"\"\n\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\"\"\"\n\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replaces spaces with underscores and vice versa in a string.\"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 1}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(nums):\n    \"\"\"Moves all zeroes in a list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A new list with zeroes moved to the end.\n    \"\"\"\n\n    result = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n\n    result.extend([0] * zero_count)  # Efficiently add zeroes at the end\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes in a list to the end while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list with all zeroes moved to the end.\n    \"\"\"\n    if not nums:\n        return []\n\n    zero_count = 0\n    result = []\n\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n        else:\n            result.append(num)\n\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of a list while preserving the order of other elements.\n\n    Args:\n        lst: A list of numbers.\n\n    Returns:\n        A new list with zeroes moved to the end.\n    \"\"\"\n    result = []\n    zeros = []\n    for num in lst:\n        if num == 0:\n            zeros.append(0)\n        else:\n            result.append(num)\n    result.extend(zeros)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeros in a list to the end while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with zeros moved to the end.\n    \"\"\"\n\n    result = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n\n    result.extend([0] * zero_count)  # Efficiently adds the zeros at the end\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while maintaining the relative order of non-zero elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A list with all zeroes moved to the end.\n    \"\"\"\n\n    if not nums:\n        return []\n\n    non_zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index] = nums[i]\n            non_zero_index += 1\n\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n\n    return nums\nnums = [1, 0, 2, 0, 3, 4]", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeros in a list to the end while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list with all zeros moved to the end.\n    \"\"\"\n    \n    non_zero = []\n    zero_count = 0\n\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero.append(num)\n            \n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeros in a list to the end while maintaining the relative order of non-zero elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list with all zeros moved to the end.\n    \"\"\"\n\n    non_zero_index = 0  # Keeps track of the position to insert the next non-zero element\n\n    for num in nums:\n        if num != 0:\n            nums[non_zero_index] = num\n            non_zero_index += 1\n\n    # Fill the remaining elements with zeros\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeros in a list to the end while preserving the order of other elements.\n\n    Args:\n        nums: The input list of numbers.\n\n    Returns:\n        A new list with zeros moved to the end.\n    \"\"\"\n\n    result = []\n    zeros = 0\n    for num in nums:\n        if num == 0:\n            zeros += 1\n        else:\n            result.append(num)\n\n    result.extend([0] * zeros)  # Efficiently adds the required number of zeros\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeros to the end of the list while maintaining the order of other elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A list with all zeros moved to the end.\n    \"\"\"\n\n    non_zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index], nums[i] = nums[i], nums[non_zero_index]  # Swap\n            non_zero_index += 1\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeros in a list to the end while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A list with all zeros moved to the end.\n    \"\"\"\n    non_zero = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            non_zero.append(num)\n        else:\n            zero_count += 1\n\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the relative order of non-zero elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A list with all zeroes moved to the end.\n    \"\"\"\n\n    non_zero = []\n    zero_count = 0\n\n    for num in nums:\n        if num != 0:\n            non_zero.append(num)\n        else:\n            zero_count += 1\n            \n    return non_zero + [0] * zero_count\nnums = [1, 0, 2, 0, 3, 4]", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while maintaining the relative order of non-zero elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A list with all zeroes moved to the end.\n    \"\"\"\n\n    non_zero_index = 0  # Keeps track of the position to place the next non-zero element\n\n    for num in nums:\n        if num != 0:\n            nums[non_zero_index] = num\n            non_zero_index += 1\n\n    # Fill the remaining positions with zeroes\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeros in a list to the end while maintaining the relative order of non-zero elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with zeros moved to the end.\n    \"\"\"\n\n    result = []\n    zero_count = 0\n\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n\n    result.extend([0] * zero_count)  # Efficiently adds multiple zeros\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeros in a list to the end while maintaining the relative order of non-zero elements.\"\"\"\n    \n    non_zero = []\n    zero_count = 0\n    \n    for num in nums:\n        if num != 0:\n            non_zero.append(num)\n        else:\n            zero_count += 1\n            \n    result = non_zero + [0] * zero_count  # Efficiently add zeros to the end\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeroes in a list to the end while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    result = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeroes in a list to the end while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with zeroes moved to the end.\n    \"\"\"\n\n    result = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of a list while maintaining the relative order of non-zero elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with zeroes moved to the end.\n    \"\"\"\n    result = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n    result.extend([0] * zero_count)  # Efficiently add zeroes at the end\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeroes in a list to the end while preserving the order of other elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    result = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeroes to the end of the list while maintaining the order of other elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A list with all zeroes moved to the end.\n    \"\"\"\n\n    non_zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index] = nums[i]\n            non_zero_index += 1\n\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeros in a list to the end while maintaining the relative order of non-zero elements.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A new list with zeros moved to the end.\n    \"\"\"\n    result = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 98.0, "profiled": [{"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: The input list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs in a list.\n\n    Args:\n        arr: The list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    return total_xor_sum\nnumbers = [1, 2, 3, 4]\nn = len(numbers)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: The input list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: The list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs in a list.\n\n    Args:\n      arr: A list of integers.\n      n: The length of the list.\n\n    Returns:\n      The sum of XORs of all pairs in the list.\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs in a list.\n\n    Args:\n      arr: The input list of numbers.\n      n: The length of the list.\n\n    Returns:\n      The sum of XORs of all pairs.\n    \"\"\"\n\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: The list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: The input list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in the given list.\n\n    Args:\n      arr: The list of numbers.\n      n: The number of elements in the list.\n\n    Returns:\n      The sum of XORs of all pairs.\n    \"\"\"\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs in a list.\n\n    Args:\n        arr: The input list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: The list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs in a list.\n\n    Args:\n        arr: The input list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor\nnumbers = [1, 2, 3, 4]\nn = len(numbers)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: The list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n      arr: The input list of numbers.\n      n: The length of the list.\n\n    Returns:\n      The sum of XORs of all pairs.\n    \"\"\"\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += arr[i] ^ arr[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs in a list.\n\n    Args:\n        arr: The input list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: The list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs in a list.\n\n    Args:\n        arr: The input list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += arr[i] ^ arr[j]\n    return ans\narr = [1, 2, 3]\nn = len(arr)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: A list of integers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs of numbers in the list.\n    \"\"\"\n\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs of numbers in a list.\n\n    Args:\n        arr: The input list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XORs of all pairs in a list.\n\n    Args:\n        arr: The input list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XORs of all pairs.\n    \"\"\"\n\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 71.80851063829786, "dps_norm": 73.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which to reverse (exclusive).\n\n    Returns:\n        The array with the elements up to k reversed.\n        Returns the original array if k is invalid.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n\n    reversed_portion = arr[:k]\n    reversed_portion.reverse()\n    return reversed_portion + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        A new array with the elements up to k reversed.\n    \"\"\"\n\n    if k <= 0 or k > len(arr):\n        return arr  # Handle invalid k values\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n    remaining_part = arr[k:]\n\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which to reverse (0-indexed).\n\n    Returns:\n        The array with the first k elements reversed.\n    \"\"\"\n\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer.\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the bounds of the array.\")\n\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n    return reversed_part + arr[k:]\nk = 5", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which to reverse (0-indexed).\n\n    Returns:\n        The array with the elements up to k reversed.\n        Returns the original array if k is out of bounds or invalid. \n    \"\"\"\n    if not isinstance(arr, list) or not isinstance(k, int) or k < 0 or k > len(arr):\n        return arr  # Handle invalid input\n\n    reversed_portion = arr[:k]\n    reversed_portion.reverse()\n    return reversed_portion + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The reversed array.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        return arr  # Handle invalid k values\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k <= 0 or k > len(arr):\n        return arr  # Handle invalid k values\n\n    reversed_portion = arr[:k]\n    reversed_portion.reverse()\n    return reversed_portion + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The reversed array.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the bounds of the array\")\n    \n    reversed_part = arr[:k]\n    reversed_part.reverse()  # In-place reversal\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a given position k (exclusive).\n\n    Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n      A new array with the elements reversed up to position k.\n      Returns the original array if k is invalid (negative or greater than array length).\n    \"\"\"\n\n    if k < 0 or k > len(arr):\n        return arr  # Handle invalid k values\n\n    reversed_portion = arr[:k]\n    reversed_portion.reverse()\n\n    return reversed_portion + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The array with the first k elements reversed.\n    \"\"\"\n\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    if not isinstance(k, int) or k < 0 or k > len(arr):\n        raise ValueError(\"k must be a non-negative integer less than or equal to the length of the array.\")\n\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n      arr: The input array.\n      k: The position up to which to reverse (exclusive).\n\n    Returns:\n      The array with the first k elements reversed, or the original array if k is invalid.\n    \"\"\"\n    if not isinstance(arr, list) or not isinstance(k, int) or k < 0 or k > len(arr):\n        return arr  # Return original array for invalid input\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n    return reversed_part + arr[k:]\narr = [10, 20, 30, 40, 50]\nk = 3", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with the elements reversed up to position k.\n        Returns the original array if k is out of bounds (negative or greater than the array length).\n    \"\"\"\n\n    if k < 0 or k > len(arr):\n        return arr  # Handle out-of-bounds k\n\n    reversed_portion = arr[:k]\n    reversed_portion.reverse()\n\n    return reversed_portion + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The array with the first k elements reversed.\n    \"\"\"\n\n    if not isinstance(arr, list):\n        raise TypeError(\"Input 'arr' must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"Input 'k' must be an integer.\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"Input 'k' must be within the range of the array length.\")\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n    result = reversed_part + arr[k:]\n    return result", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        A new array with the elements up to k reversed.\n        Returns the original array if k is invalid.\n\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n\n    reversed_portion = arr[:k]\n    reversed_portion.reverse()\n    return reversed_portion + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        The reversed array.\n    \"\"\"\n\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the bounds of the array\")\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        A new array with the elements reversed up to position k.\n    \"\"\"\n\n    if not isinstance(arr, list):\n        raise TypeError(\"Input 'arr' must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"Input 'k' must be an integer.\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"Input 'k' must be within the bounds of the array.\")\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n    return reversed_part + arr[k:]\narr = [10, 20, 30, 40, 50]\nk = 3", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with the elements reversed up to position k.\n        Returns the original array if k is out of bounds.\n\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    reversed_part = arr[:k]\n    reversed_part.reverse()\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with the reversed elements up to position k.\n    \"\"\"\n\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the bounds of the array.\")\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        A new array with the elements reversed up to position k.\n        Returns the original array if k is invalid (e.g., negative, larger than array length).\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr  # Handle invalid k values\n\n    reversed_part = arr[:k]\n    reversed_part.reverse()\n    return reversed_part + arr[k:]\narr = [1, 2, 3, 4, 5, 6, 7, 8]\nk = 5", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a specified position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (0-indexed).\n\n    Returns:\n        A new array with the elements reversed up to position k.\n    \"\"\"\n\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be a valid index within the array.\")\n\n    reversed_part = arr[:k][::-1]  # Reverse the portion up to k\n    remaining_part = arr[k:]       # Keep the rest of the array as is\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k (exclusive).\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr) or k < 0:\n        raise ValueError(\"k must be within the bounds of the array\")\n    \n    reversed_portion = arr[:k]\n    reversed_portion.reverse()\n    \n    return reversed_portion + arr[k:]", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The original tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The original tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended to the end.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The original tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to add to.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to modify.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n      input_tuple: The tuple to which the dictionary will be added.\n      input_dict: The dictionary to be added.\n\n    Returns:\n      A new tuple with the dictionary appended to the end.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to the end of a tuple.\n\n    Args:\n      input_tuple: The original tuple.\n      input_dict: The dictionary to add.\n\n    Returns:\n      A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple: The tuple to which the dictionary will be added.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 85.02732240437157, "dps_norm": 80.625, "pass@1": 98.0, "profiled": [{"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings found within double quotes.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is the content within a pair of double quotes.\n        Returns an empty list if no quotes are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings found within double quotes.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values.\n        Returns an empty list if no quoted strings are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        A list of strings found between double quotes.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values, or an empty list if no quotes are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is the content within a pair of double quotes.\n        Returns an empty list if no quoted strings are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is the content within a pair of double quotes.\n        Returns an empty list if no quoted strings are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values. \n        Returns an empty list if no quoted strings are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is the content enclosed within a pair of double quotes.\n        Returns an empty list if no quotes are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values. \n        Returns an empty list if no quoted strings are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is the content within a pair of double quotes.\n        Returns an empty list if no quotes are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is the content enclosed within a pair of double quotes.\n        Returns an empty list if no quoted strings are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)\ntext = 'This is a \"test\" string with \"multiple\" quoted \"values\".'", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings containing the extracted values.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is the content within a pair of double quotes.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is the content within a pair of double quotes.\n        Returns an empty list if no quoted strings are found.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, where each string is the content enclosed within a pair of double quotes.\n        Returns an empty list if no quotes are found.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values enclosed within double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings, each representing a value found within quotes.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 20.07751937984496, "dps_norm": 48.0, "pass@1": 99.0, "profiled": [{"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    modified_string = \"\"\n    for char in input_string:\n        if char in (\" \", \",\", \".\"):\n            modified_string += \":\"\n        else:\n            modified_string += char\n    return modified_string", "matching_cluster_idx": 4}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    return re.sub(r\"[ ,.]\", \":\", text)", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char in (\" \", \",\", \".\"):\n            result += \":\"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 4}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    new_text = \"\"\n    for char in text:\n        if char == \" \" or char == \",\" or char == \".\":\n            new_text += \":\"\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 4}, {"solution": "import re\ndef replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    return re.sub(r'[ ,.]', ':', input_string)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    new_text = \"\"\n    for char in text:\n        if char in (\" \", \",\", \".\"):\n            new_text += \":\"\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    result = \"\"\n    for char in text:\n        if char == ' ' or char == ',' or char == '.':\n            result += ':'\n        else:\n            result += char\n    return result", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    result = \"\"\n    for char in input_string:\n        if char in (\" \", \",\", \".\"):\n            result += \":\"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char in [\" \", \",\", \".\"]:\n            output_string += \":\"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        input_string: The input string.\n\n    Returns:\n        The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char in (\" \", \",\", \".\"):\n            output_string += \":\"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 4}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    return re.sub(r\"[ ,.]\", \":\", text)", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons in a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The modified string with special characters replaced.\n    \"\"\"\n    new_text = \"\"\n    for char in text:\n        if char in (\" \", \",\", \".\"):\n            new_text += \":\"\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        input_string: The string to modify.\n\n    Returns:\n        The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char in (\" \", \",\", \".\"):\n            output_string += \":\"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 4}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons in a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The modified string with special characters replaced.\n    \"\"\"\n\n    new_text = \"\"\n    for char in text:\n        if char == \" \" or char == \",\" or char == \".\":\n            new_text += \":\"\n        else:\n            new_text += char\n    return new_text", "matching_cluster_idx": 4}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    return re.sub(r\"[ ,.]\", \":\", text)", "matching_cluster_idx": 4}, {"solution": "import re\ndef replace_specialchar(input_string):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    return re.sub(r\"[ ,.]\", \":\", input_string)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    return re.sub(r\"[ ,.]\", \":\", text)", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n    result = \"\"\n    for char in text:\n        if char in (\" \", \",\", \".\"):\n            result += \":\"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 4}]}, "Mbpp/740": {"dps": 83.63636363636364, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary where keys are elements at even indices and values are elements at odd indices.\n        Returns an empty dictionary if the tuple has an odd number of elements or is empty.\n    \"\"\"\n    if len(input_tuple) % 2 != 0 or not input_tuple:\n        return {}\n\n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i + 1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary where keys and values are taken from adjacent elements of the tuple.\n        Returns an empty dictionary if the tuple has an odd number of elements or is empty.\n    \"\"\"\n\n    if len(input_tuple) % 2 != 0 or not input_tuple:\n        return {}\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple has an odd number of elements.\n    \"\"\"\n\n    if len(input_tuple) % 2 != 0:\n        return {}  # Or raise an exception if preferred\n\n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple has an odd number of elements.\n        \n    Raises:\n        TypeError: if input is not a tuple\n    \"\"\"\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n\n    if len(input_tuple) % 2 != 0:\n        return {}\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple \n        has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  # Return empty dictionary for odd-length tuples\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple has an odd number of elements.\n    \"\"\"\n\n    if len(input_tuple) % 2 != 0:\n        return {}\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i + 1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple has an odd number of elements.\n    \"\"\"\n\n    if len(input_tuple) % 2 != 0:\n        return {}\n\n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i + 1]\n\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple \n        has an odd number of elements or is empty.\n    \"\"\"\n\n    if len(input_tuple) % 2 != 0 or not input_tuple:\n        return {}\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    return result_dict\ntest_tuple = (2, 4, 6, 8, 10, 12)\nresult_dict = tuple_to_dict(test_tuple)", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary where keys are elements at even indices and values are elements at odd indices.\n        Returns an empty dictionary if the tuple has an odd number of elements or is empty.\n    \"\"\"\n    if len(input_tuple) % 2 != 0 or not input_tuple:\n        return {}\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple \n        has an odd number of elements or is empty.\n    \"\"\"\n\n    if len(input_tuple) % 2 != 0 or not input_tuple:\n        return {}\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple has an odd number of elements.\n    \"\"\"\n\n    if len(input_tuple) % 2 != 0:\n        return {}  # Or raise an error if preferred\n\n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}  # Return empty dict for odd length tuples\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary where keys are elements at even indices and values are elements at odd indices.\n        Returns an empty dictionary if the tuple has an odd number of elements or is empty.\n    \"\"\"\n    if len(input_tuple) % 2 != 0 or not input_tuple:\n        return {}\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple \n        has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        return {}\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a key-value dictionary using adjacent elements.\"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements.\")\n\n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple \n        has an odd number of elements or is empty.\n    \"\"\"\n\n    if len(input_tuple) % 2 != 0 or not input_tuple:\n        return {}\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from the tuple, or an empty dictionary if the tuple \n        has an odd number of elements or is empty.\n    \"\"\"\n    if len(input_tuple) % 2 != 0 or not input_tuple:\n        return {}\n    \n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"Converts a tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary where keys are elements at even indices and values are elements at odd indices.\n        Returns an empty dictionary if the tuple has an odd number of elements or is empty.\n    \"\"\"\n    if len(input_tuple) % 2 != 0 or not input_tuple:\n        return {}\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n    return result_dict", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 76.02739726027397, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains None, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if the given tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains None, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains None, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"Checks if a tuple contains any None values.\"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple contains None, False otherwise.\n    \"\"\"\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}]}, "Mbpp/750": {"dps": 13.503401360544217, "dps_norm": 14.166666666666668, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to a list.\n\n    Args:\n        my_list: The list to which the tuple elements will be added.\n        my_tuple: The tuple containing the elements to be added.\n\n    Returns:\n        A new list containing the elements of the original list followed by the elements of the tuple.\n    \"\"\"\n\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n        my_list: The list to modify.\n        my_tuple: The tuple containing elements to add.\n\n    Returns:\n        The modified list with the tuple elements appended.\n    \"\"\"\n\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to a list.\n\n    Args:\n        my_list: The list to which elements will be added.\n        my_tuple: The tuple containing elements to be added.\n\n    Returns:\n        A new list with elements of the tuple appended to the original list.\n    \"\"\"\n\n    new_list = my_list[:] # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n        my_list: The list to modify.\n        my_tuple: The tuple whose elements will be added.\n\n    Returns:\n        The modified list with the tuple elements appended.\n    \"\"\"\n\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    new_list.extend(my_tuple)\n    return new_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n        my_list: The list to modify.\n        my_tuple: The tuple to add to the list.\n\n    Returns:\n        The modified list with the tuple elements appended.\n    \"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds elements of a tuple to the end of a list.\n\n    Args:\n        my_list: The list to which elements will be added.\n        my_tuple: The tuple containing elements to be added.\n\n    Returns:\n        A new list with the tuple elements appended.\n    \"\"\"\n\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list\nlist1 = [1, 2, 3]\ntuple1 = (4, 5)\nnew_list = add_tuple(list1, tuple1)", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n        my_list: The list to modify.\n        my_tuple: The tuple whose elements will be added.\n\n    Returns:\n        The modified list with the tuple elements appended.\n    \"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list in-place\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list\nmy_list = [1, 2, 3]\nmy_tuple = (4, 5)\nnew_list = add_tuple(my_list, my_tuple)", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n        my_list: The list to which the tuple elements will be added.\n        my_tuple: The tuple whose elements will be added to the list.\n\n    Returns:\n        A new list with the tuple elements added to the end of the original list.\n    \"\"\"\n    new_list = my_list[:] # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n      my_list: The list to modify.\n      my_tuple: The tuple whose elements are to be added.\n\n    Returns:\n      A new list with the tuple elements appended.\n    \"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    new_list.extend(my_tuple)\n    return new_list", "matching_cluster_idx": 2}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Args:\n        my_list: The list to modify.\n        my_tuple: The tuple containing elements to add.\n\n    Returns:\n        The modified list with the tuple elements appended.\n    \"\"\"\n    new_list = my_list.copy() # Important to copy to avoid modifying the original list\n    for item in my_tuple:\n      new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds elements of a tuple to the end of a list.\"\"\"\n\n    new_list = my_list[:] # Create a copy to avoid modifying the original list.\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to a list.\n\n    Args:\n      my_list: The list to which the tuple elements should be added.\n      my_tuple: The tuple containing elements to be added.\n\n    Returns:\n      A new list with the tuple elements appended to the original list.\n    \"\"\"\n\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to a list.\n\n    Args:\n        my_list: The list to modify.\n        my_tuple: The tuple containing the elements to add.\n\n    Returns:\n        The modified list with the tuple elements appended.\n    \"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds a tuple to the end of a list.\n\n    Args:\n        my_list: The list to modify.\n        my_tuple: The tuple to add.\n\n    Returns:\n        A new list with the tuple's elements appended.\n    \"\"\"\n\n    new_list = my_list[:]  # Create a copy to avoid modifying the original\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n        my_list: The list to modify.\n        my_tuple: The tuple whose elements are to be added.\n\n    Returns:\n        The modified list.\n    \"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original\n    new_list.extend(my_tuple)\n    return new_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n      my_list: The list to modify.\n      my_tuple: The tuple whose elements are to be added.\n\n    Returns:\n      The modified list with the tuple elements appended.\n    \"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    for item in my_tuple:\n        new_list.append(item)\n    return new_list\noriginal_list = [1, 2, 3]\nnew_list = add_tuple(original_list, (4, 5))", "matching_cluster_idx": -1}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n      my_list: The list to modify.\n      my_tuple: The tuple whose elements to add.\n\n    Returns:\n      A new list with the tuple's elements appended.\n    \"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    new_list.extend(my_tuple)\n    return new_list", "matching_cluster_idx": 2}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"Adds the elements of a tuple to the end of a list.\n\n    Args:\n        my_list: The list to modify.\n        my_tuple: The tuple whose elements are to be added.\n\n    Returns:\n        A new list with the tuple elements appended.\n    \"\"\"\n    new_list = my_list[:]  # Create a copy to avoid modifying the original list\n    new_list.extend(my_tuple)\n    return new_list", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": 31.333892617449663, "dps_norm": 57.8125, "pass@1": 16.0, "profiled": [{"solution": "import heapq\ndef min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple represents a record.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of k tuples representing the minimum records.\n    \"\"\"\n    if not records:\n        return []\n    \n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element (numerical value).\n\n    Args:\n        tuple_list: A list of tuples, where each tuple contains a string and a number.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of k tuples with the smallest numerical values, sorted in ascending order.\n        Returns an empty list if the input list is empty or k is 0.\n        Returns the entire sorted list if k is greater than the length of the input list. \n    \"\"\"\n    if not tuple_list or k == 0:\n        return []\n\n    sorted_tuples = sorted(tuple_list, key=lambda x: x[1])\n\n    return sorted_tuples[:k]", "matching_cluster_idx": 1}, {"solution": "import heapq\ndef min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element (numerical value).\n\n    Args:\n        records: A list of tuples, where each tuple contains a string and a numerical value.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of k tuples representing the minimum records.\n        Returns an empty list if the input list is empty or k is 0.\n        If k is larger than the length of records, returns all records sorted.\n    \"\"\"\n    if not records or k == 0:\n        return []\n\n    if k >= len(records):\n        return sorted(records, key=lambda x: x[1])\n\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple represents a record.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of the k records with the smallest values in the second element of each tuple.\n        Returns an empty list if the input list is empty or k is 0.  Handles cases where k > len(records) by returning all records.\n    \"\"\"\n    if not records or k == 0:\n        return []\n\n    sorted_records = sorted(records, key=lambda x: x[1])  # Sort based on the second element\n\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "import heapq\ndef min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n        records: A list of tuples.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of the k tuples with the smallest second elements.\n        Returns an empty list if records is empty or k is 0.\n        If k is greater than the length of records, returns all records sorted.\n    \"\"\"\n\n    if not records or k == 0:\n        return []\n\n    if k >= len(records):\n        return sorted(records, key=lambda x: x[1])\n\n\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "import heapq\ndef min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n        records: A list of tuples.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of k tuples with the smallest second elements.\n        Returns an empty list if records is empty or k is 0.\n        Returns all records if k is greater than the length of records.\n    \"\"\"\n\n    if not records or k == 0:\n        return []\n\n    if k >= len(records):\n        return sorted(records, key=lambda x: x[1])\n\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple contains a string and an integer.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of the k tuples with the smallest integer values, sorted in ascending order by integer value.\n    \"\"\"\n\n    if not records:\n        return []\n\n    sorted_records = sorted(records, key=lambda x: x[1])\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "import heapq\ndef min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple represents a record.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of k tuples representing the minimum records.\n        Returns an empty list if records is empty or k is 0.\n        Returns all records if k is greater than or equal to the length of records.\n    \"\"\"\n\n    if not records or k == 0:\n        return []\n    if k >= len(records):\n        return sorted(records, key=lambda x: x[1])\n\n\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element (numerical value).\n\n    Args:\n        tuples_list: A list of tuples, where each tuple contains a string and a numerical value.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of the k tuples with the smallest numerical values, sorted in ascending order by the numerical value.\n        Returns an empty list if the input list is empty or k is 0.\n        If k is greater than the length of tuples_list, returns all elements sorted.\n    \"\"\"\n    if not tuples_list or k == 0:\n        return []\n    \n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    return sorted_tuples[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples, where the second element of each tuple is used for comparison.\n\n    Args:\n        records: A list of tuples.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of k tuples with the smallest second elements, sorted in ascending order by the second element.\n        Returns an empty list if the input list is empty or k is 0.\n        Returns the entire sorted list if k is greater than or equal to the length of the input list.\n    \"\"\"\n    if not records or k == 0:\n        return []\n\n    if k >= len(records):\n        return sorted(records, key=lambda x: x[1])\n\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple represents a record.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of tuples containing the k records with the smallest values in the second element of each tuple.\n        Returns an empty list if the input list is empty or k is 0.\n        Returns the entire input list if k is greater than or equal to the length of the input list.\n\n    \"\"\"\n    if not records or k == 0:\n        return []\n    if k >= len(records):\n        return records\n\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple contains a string and an integer.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of tuples representing the minimum k records, sorted in ascending order based on the integer value.\n        Returns an empty list if the input list is empty or k is 0.\n    \"\"\"\n    if not records or k == 0:\n        return []\n\n    # Sort the records based on the integer value in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "import heapq\ndef min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple represents a record.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of k tuples representing the minimum records.\n        Returns an empty list if the input list is empty or k is 0.\n    \"\"\"\n\n    if not records or k == 0:\n        return []\n\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple represents a record \n                 and the second element of each tuple is the value to compare.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of the k records with the smallest values, sorted in ascending order.\n        Returns an empty list if the input list is empty or k is 0.\n        If k is larger than the number of records, returns all records sorted.\n    \"\"\"\n\n    if not records or k == 0:\n        return []\n\n    sorted_records = sorted(records, key=lambda x: x[1])  # Sort based on the second element of each tuple\n\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple represents a record \n                 and the second element of each tuple is a numerical value.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list containing the k records with the smallest numerical values, \n        sorted in ascending order based on the numerical value.\n        Returns an empty list if records is empty or k is 0.\n    \"\"\"\n    if not records or k == 0:\n        return []\n\n    sorted_records = sorted(records, key=lambda x: x[1])  # Sort based on the second element\n    return sorted_records[:k]\nrecords = [('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)]\nk = 2", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    Args:\n        records: A list of tuples, where each tuple contains a string and an integer.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of tuples representing the minimum k records, sorted in ascending order based on the integer value.\n        Returns an empty list if the input list is empty or k is 0.\n    \"\"\"\n\n    if not records or k == 0:\n        return []\n\n    sorted_records = sorted(records, key=lambda x: x[1])\n    return sorted_records[:k]", "matching_cluster_idx": 1}]}, "Mbpp/754": {"dps": 89.65517241379311, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list containing the common elements.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list containing the common elements.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] and l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list containing the common elements.\n    \"\"\"\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list containing the common elements.\n    \"\"\"\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list of common elements.\n    \"\"\"\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists at the same index.\n\n    Args:\n        l1: The first list.\n        l2: The second list.\n        l3: The third list.\n\n    Returns:\n        A list containing the common elements.\n    \"\"\"\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 96.95796460176992, "dps_norm": 98.95833333333333, "pass@1": 16.0, "profiled": [{"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than 2 unique elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  # Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than two unique elements.\n    \"\"\"\n\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n\n    if len(unique_numbers) < 2:\n        return None\n    \n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list \n        has fewer than two distinct elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  # Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.\n        Returns the smallest if the list has only one distinct element.\n        Returns None if the list is empty or has only one element.\n\n    \"\"\"\n    if not numbers or len(set(numbers)) < 2:  # Handle empty or single unique element lists\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "import heapq\ndef second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or the smallest if there is no second smallest.\n        Returns None if the list has less than 2 elements or contains only one unique element.\n\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n\n    if len(unique_numbers) < 2:\n        return None\n    \n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than two distinct elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    # Remove duplicates and sort the list\n    unique_numbers = sorted(list(set(numbers)))\n\n    if len(unique_numbers) < 2:\n        return None\n    \n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than two distinct elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  # Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "import heapq\ndef second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than 2 unique elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n\n    if len(unique_numbers) < 2:\n        return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than 2 unique elements.\n    \"\"\"\n\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  # Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than 2 unique elements.\n    \"\"\"\n    unique_nums = sorted(list(set(nums)))  # Remove duplicates and sort\n    if len(unique_nums) < 2:\n        return None\n    return unique_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than two distinct elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n\n    if len(unique_numbers) < 2:\n        return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than two distinct elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  # Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "import heapq\ndef second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than two unique elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  # Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than 2 unique elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  # Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None\n\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list has fewer than two distinct elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))\n\n    if len(unique_numbers) < 2:\n        return None\n    \n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list \n        has fewer than two distinct elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n\n    unique_numbers = sorted(list(set(numbers)))  # Remove duplicates and sort\n\n    if len(unique_numbers) < 2:\n        return None\n    \n    return unique_numbers[1]", "matching_cluster_idx": 5}]}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/758": {"dps": 70.85907335907335, "dps_norm": 78.125, "pass@1": 100.0, "profiled": [{"solution": "from collections import defaultdict\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of unique sublists (converted to tuples) within a list of lists.\n\n    Args:\n    list_of_lists: A list of lists.\n\n    Returns:\n    A dictionary where keys are tuples representing the unique sublists and values are their counts.\n    \"\"\"\n\n    counts = defaultdict(int)  # Use defaultdict to simplify counting\n\n    for sublist in list_of_lists:\n        counts[tuple(sublist)] += 1\n\n    return dict(counts)  # Convert back to a regular dict", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (representing unique sublists) and values\n        are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists within a list.\n\n    Args:\n        lst: A list containing sublists.\n\n    Returns:\n        A dictionary where keys are tuples representing unique sublists \n        and values are their counts within the original list.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        else:\n            counts[tuple_sublist] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: The input list containing sublists.\n\n    Returns:\n        A dictionary where keys are tuples representing unique sublists and values are their counts.\n    \"\"\"\n\n    tuple_list = [tuple(sublist) for sublist in lst]\n    return dict(Counter(tuple_list))", "matching_cluster_idx": 7}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing the unique sublists \n        and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)  # Use defaultdict for automatic initialization\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts) # Return a regular dict", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"Counts the occurrences of sublists (converted to tuples) within a list.\n\n    Args:\n        lst: The input list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing unique sublists and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples (converted from sublists) and values\n        are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing the sublists and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n      lst: A list of lists.\n\n    Returns:\n      A dictionary where keys are tuples representing the unique sublists and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: A list containing sublists.\n\n    Returns:\n        A dictionary where keys are tuples representing unique sublists and values are their counts.\n    \"\"\"\n\n    counts = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)  # Convert list to tuple for dictionary key\n        counts[tuple_sublist] = counts.get(tuple_sublist, 0) + 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing the unique sublists, \n        and values are their counts.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: The input list containing sublists.\n\n    Returns:\n        A dictionary where keys are tuples representing the unique sublists and values are their counts.\n    \"\"\"\n\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing the unique sublists, and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing the unique sublists and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: The input list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing the unique sublists and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: The input list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing the unique sublists \n        and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing the unique sublists and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing unique sublists and values are their counts.\n    \"\"\"\n\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(input_list):\n    \"\"\"Counts the occurrences of unique sublists within a list.\n\n    Args:\n        input_list: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing unique sublists \n        and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in input_list:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"Counts the occurrences of unique sublists (converted to tuples) within a list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing unique sublists and values are their counts.\n    \"\"\"\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}]}, "Mbpp/760": {"dps": 32.846715328467155, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n    first = nums[0]\n    for num in nums:\n        if num != first:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True  # Or False, depending on desired behavior for empty lists\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n    \n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True \n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n\n    if not nums:  # Handle empty list case\n        return True\n\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return False\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True \n\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        lst: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not lst:  # Handle empty list case\n        return False\n    \n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n    \n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True  # Or False, depending on your desired behavior for empty lists\n\n    first_element = nums[0]\n    for element in nums:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True  # Or False, depending on desired behavior for empty lists\n\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True\n\n    first_element = nums[0]\n    for element in nums:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    if not nums:  # Handle empty list case\n        return True  # Or False, depending on desired behavior for empty lists.\n\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"Counts the number of digits in a string.\"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The string to analyze.\n\n    Returns:\n      The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n\n    # Using regular expressions for efficiency\n    return len(re.findall(r'\\d', input_string))", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits in the string.\n    \"\"\"\n\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits in the string.\n    \"\"\"\n\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The number of digits found in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 55.14018691588785, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains consecutive pairs of items from the input list.\n    \"\"\"\n    if not data:\n        return []\n    \n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    \n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple represents a pair of consecutive items in the input list.\n\n    Args:\n      input_list: A list of items.\n\n    Returns:\n      A list of tuples.\n    \"\"\"\n    if not input_list:\n        return []\n    \n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of tuples, where each tuple represents a pair of consecutive items in the input list.\n    \"\"\"\n    if not data:\n        return []\n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \"\"\"\n    if not data:\n        return []\n    \n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple represents a pair of consecutive items.\n        Returns an empty list if the input list has fewer than two elements.\n    \"\"\"\n    if len(input_list) < 2:\n        return []\n\n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple represents a pair of consecutive items in the input list.\n    \"\"\"\n    if not input_list:\n        return []\n\n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        A list of tuples.\n    \"\"\"\n\n    if not data:\n        return []\n\n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \"\"\"\n    if not data:\n        return []\n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    if not data:\n        return []\n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \"\"\"\n    if not input_list:\n        return []\n    \n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \"\"\"\n    if not data:\n        return []\n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        lst: The input list.\n\n    Returns:\n        A list of tuples, where each tuple represents a pair of consecutive items.\n    \"\"\"\n    if not lst:\n        return []\n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple represents a pair of consecutive items from the input list.\n    \"\"\"\n    if not input_list:\n        return []\n    \n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"Returns a list of tuples representing all pairs of consecutive items in the input list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple contains a pair of consecutive items.\n        Returns an empty list if the input list has fewer than two elements.\n    \"\"\"\n    if len(data) < 2:\n        return []\n\n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple represents a pair of consecutive items.\n    \"\"\"\n    if not input_list:\n        return []\n\n    pairs = []\n    for i in range(len(input_list) - 1):\n        pairs.append((input_list[i], input_list[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple represents a pair of consecutive items.\n        Returns an empty list if the input list has fewer than two elements.\n    \"\"\"\n    if len(data) < 2:\n        return []\n    \n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(nums):\n    \"\"\"\n    Returns a list of tuples representing consecutive pairs of items in the input list.\n    \"\"\"\n    pairs = []\n    for i in range(len(nums) - 1):\n        pairs.append((nums[i], nums[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of tuples, where each tuple represents a pair of consecutive items in the input list.\n    \"\"\"\n    if not data:  # Handle empty list case\n        return []\n    \n    pairs = []\n    for i in range(len(data) - 1):\n        pairs.append((data[i], data[i+1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(data):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items in the input list.\n\n    Args:\n        data: A list of items.\n\n    Returns:\n        A list of tuples.\n    \"\"\"\n    if not data:\n        return []\n    result = []\n    for i in range(len(data) - 1):\n        result.append((data[i], data[i+1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    if not lst:  # Handle empty list case\n        return []\n    \n    pairs = []\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i+1]))\n    return pairs", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 94.39999999999999, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n        Returns True if the list is empty or has only one element (as there are no odd indices to check in these cases).\n    \"\"\"\n    if len(nums) <= 1:  # Handle empty or single-element lists\n        return True\n\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.\n      Returns True for an empty list.\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:  # Check if the element is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n    nums: A list of integers.\n\n    Returns:\n    True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:  # Check if the element is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks whether every odd index contains an odd number in a given list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index is an odd number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n    nums: A list of integers.\n\n    Returns:\n    True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        lst: The input list of numbers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:  # Check if the element is even\n            return False  # Return False if an even number is found at an odd index\n    return True  # Return True if all elements at odd indices are odd", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index is odd.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every element at an odd index in a list is an odd number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/781": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n == 0:\n      return True # Technically infinite divisors, but assuming True for this case to avoid ZeroDivisionError\n\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if n // i == i:  # perfect square divisor\n                count += 1\n            else:\n                count += 2  # i and n/i are both divisors\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False  # Handle non-positive input as needed\n\n\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # Count both i and n/i\n\n    if sqrt_n * sqrt_n == n:  # Correct for perfect squares\n        count -= 1\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n == 0:\n        return True  # Or raise an exception as 0 has infinite divisors\n    \n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n // i == i:  # Check for perfect squares\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: The number to check.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i * i != n:  # Avoid double counting for perfect squares\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: The number to check.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n\n    if n <= 0:\n      return False # Handle non-positive input as needed\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n // i == i:  # If divisors are equal (perfect square case), count once\n                count += 1\n            else:  # Otherwise, count both divisors\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n\n    if n <= 0:\n        return False # Or raise an exception, depending on desired behavior for non-positive input\n\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # Count both i and n/i as divisors\n    \n    # If n is a perfect square, we counted the square root twice. Correct for that.\n    if sqrt_n * sqrt_n == n:\n        count -= 1\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False # Handle non-positive inputs as needed\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n\n    if n <= 0:\n        return False  # Handle non-positive input\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n / i == i:  # If i is a perfect square root, count only once\n                count += 1\n            else:\n                count += 2\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n == 0:\n        return True # Technically has infinite divisors, but treating as an even case.\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 1\n            if i * i != n:  # Avoid double counting perfect squares\n                count += 1\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False  # Handle non-positive inputs appropriately\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 1 if i * i == n else 2  # Optimized counting\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i * i != n:  # Avoid double counting for perfect squares\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: A positive integer.\n\n    Returns:\n        True if the number of divisors is even, False otherwise.\n    \"\"\"\n\n    if n <= 0:\n      raise ValueError(\"Input n must be a positive integer.\")\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1  # If it's a perfect square, only count the square root once\n            else:\n                count += 2  # Count both i and n//i as divisors\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n == 0:  # Handle the case where n is 0 (infinite divisors)\n        return False\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n / i == i: # Handle perfect squares - only count the square root once.\n                count += 1\n            else:\n                count += 2 # Count both i and n/i\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the number of divisors is even, False otherwise.\n    \"\"\"\n\n    if n <= 0:\n        return False  # Handle non-positive inputs as needed\n\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i * i != n else 1  # Optimized counting\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: A positive integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n // i == i:  # Handle perfect squares\n                count += 1\n            else:\n                count += 2\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i * i != n:  # Avoid double counting if i is the square root\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if n // i == i:  # Handle perfect squares\n                count += 1\n            else:\n                count += 2\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False  # Handle non-positive inputs appropriately\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):  # Optimized to check up to the square root\n        if n % i == 0:\n            if n / i == i:  # If i is the square root, count it once\n                count += 1\n            else:  # Otherwise, count both i and n/i\n                count += 2\n\n    return count % 2 == 0 # Return True if count is even, False otherwise", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks if the number of divisors of n is even.\n\n    Args:\n      n: A positive integer.\n\n    Returns:\n      True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n // i == i:  # Check for perfect squares\n                count += 1\n            else:\n                count += 2  # Count both i and n/i\n    return count % 2 == 0", "matching_cluster_idx": 4}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 84.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to process.\n\n    Returns:\n        The string with all whitespace removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n      input_string: The input string.\n\n    Returns:\n      The string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespace from.\n\n    Returns:\n        The string with all whitespace removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        input_string: The string to remove whitespaces from.\n\n    Returns:\n        A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n      lists: A list of lists of numbers.\n\n    Returns:\n      The list with the highest sum, or None if the input list is empty or contains non-numeric elements.\n    \"\"\"\n    if not lists:\n        return None\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in lists:\n        try:\n            current_sum = sum(lst)\n            if current_sum > max_sum:\n                max_sum = current_sum\n                max_list = lst\n        except TypeError:\n            return None  # Handle non-numeric elements\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not list_of_lists:\n        return None  # Handle empty input\n\n    max_sum = float('-inf')  # Initialize with negative infinity\n    max_list = None\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return None  # Handle empty input\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        lists: A list of lists of numbers.\n\n    Returns:\n        The list with the maximum sum.\n        Returns an empty list if the input list is empty or if all sublists are empty.\n    \"\"\"\n    if not lists:\n        return []\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle negative numbers\n    max_list = []\n\n    for lst in lists:\n        if not lst:  #Handle empty sublists\n            current_sum = -float('inf')\n        else:\n            current_sum = sum(lst)\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"Returns the list with the maximum sum of elements.\"\"\"\n\n    if not list_of_lists:\n        return None  # Handle empty input\n\n    max_sum = -float('inf')  # Initialize with negative infinity for any number comparison\n    max_list = None\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = -float('inf')  # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return None  # Handle empty input\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = None\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return None  # Handle empty input\n\n    max_sum = float('-inf')  # Initialize with negative infinity\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = -float('inf')  # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return None  # Handle empty input\n\n    max_list = None\n    max_sum = float('-inf')  # Initialize with negative infinity\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not list_of_lists:\n        return None  # Handle empty input\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return None  # Handle empty input\n\n    max_sum = float('-inf')\n    max_list = None\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = -float('inf')  # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return None  # Handle empty input\n\n    max_sum = -float('inf') # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"Returns the list in a list of lists whose sum of elements is the highest.\"\"\"\n\n    if not lists:\n        return None  # Handle empty input\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = -float('inf')  # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the highest sum.\n    \"\"\"\n\n    max_sum = -float('inf')  # Initialize with negative infinity\n    max_list = None\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        lists: A list of lists of numbers.\n\n    Returns:\n        The list with the highest sum.\n    \"\"\"\n\n    if not lists:\n        return None  # Handle empty input\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle negative numbers\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return None  # Handle empty input\n\n    max_sum = -float('inf')  # Initialize with negative infinity to handle lists with negative numbers\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 72.28070175438596, "dps_norm": 93.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a tuple contains a specific value.\n\n    Args:\n        tup: The tuple to check.\n        k: The value to search for.\n\n    Returns:\n        True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(nums, k):\n    \"\"\"\n    Checks if a tuple contains a given value k.\n\n    Args:\n        nums: The tuple to search.\n        k: The value to search for.\n\n    Returns:\n        True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in nums", "matching_cluster_idx": 4}, {"solution": "def check_K(nums, k):\n    \"\"\"\n    Checks if the tuple nums contains the integer k.\n\n    Args:\n        nums: A tuple of integers.\n        k: The integer to search for.\n\n    Returns:\n        True if k is in nums, False otherwise.\n    \"\"\"\n    return k in nums", "matching_cluster_idx": 5}, {"solution": "def check_K(given_tuple, k):\n    \"\"\"\n    Checks if an integer k is present in a given tuple.\n\n    Args:\n        given_tuple: The tuple to search.\n        k: The integer to search for.\n\n    Returns:\n        True if k is in given_tuple, False otherwise.\n    \"\"\"\n    return k in given_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    Checks if a tuple contains a specific value.\n\n    Args:\n        t: The tuple to search.\n        k: The value to search for.\n\n    Returns:\n        True if the value is found in the tuple, False otherwise.\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(given_tuple, k):\n    \"\"\"\n    Checks if a tuple contains a given value.\n\n    Args:\n        given_tuple: The tuple to check.\n        k: The value to search for.\n\n    Returns:\n        True if k is present in the tuple, False otherwise.\n    \"\"\"\n    return k in given_tuple", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a tuple contains a specific value.\n\n    Args:\n        tup: The tuple to search.\n        k: The value to search for.\n\n    Returns:\n        True if the value is found, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(nums, k):\n    \"\"\"\n    Checks if a tuple contains a specific value k.\n\n    Args:\n        nums: The tuple of numbers.\n        k: The value to search for.\n\n    Returns:\n        True if k is present in the tuple, False otherwise.\n    \"\"\"\n    return k in nums", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a tuple contains a given value k.\n\n    Args:\n        tup: The tuple to check.\n        k: The value to search for.\n\n    Returns:\n        True if k is present in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a tuple contains a specific value k.\n\n    Args:\n        tup: The tuple to check.\n        k: The value to search for.\n\n    Returns:\n        True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(nums, k):\n    \"\"\"\n    Checks if a tuple contains a specific value.\n\n    Args:\n        nums: A tuple of numbers.\n        k: The value to search for.\n\n    Returns:\n        True if k is in nums, False otherwise.\n    \"\"\"\n    return k in nums", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a tuple contains a given value k.\n\n    Args:\n        tup: The tuple to check.\n        k: The value to search for.\n\n    Returns:\n        True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a tuple contains a specific element k.\n\n    Args:\n        tup: The tuple to check.\n        k: The element to search for.\n\n    Returns:\n        True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(nums, k):\n    \"\"\"\n    Checks if the given tuple contains the integer k.\n\n    Args:\n        nums: A tuple of integers.\n        k: The integer to search for.\n\n    Returns:\n        True if k is present in the tuple, False otherwise.\n    \"\"\"\n    return k in nums", "matching_cluster_idx": 5}, {"solution": "def check_K(nums, k):\n    \"\"\"\n    Checks if the given tuple contains the integer k.\n\n    Args:\n        nums: A tuple of integers.\n        k: An integer to search for.\n\n    Returns:\n        True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in nums", "matching_cluster_idx": 5}, {"solution": "def check_K(nums, k):\n    \"\"\"\n    Checks if a tuple contains a specific value.\n\n    Args:\n        nums: A tuple of numbers.\n        k: The value to search for.\n\n    Returns:\n        True if k is present in nums, False otherwise.\n    \"\"\"\n    return k in nums", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a tuple contains a specific value.\n\n    Args:\n      tup: The tuple to check.\n      k: The value to search for.\n\n    Returns:\n      True if the value k is present in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a tuple contains a specific value.\n\n    Args:\n        tup: The tuple to check.\n        k: The value to search for.\n\n    Returns:\n        True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(nums, k):\n    \"\"\"\n    Checks if a tuple contains a given value.\n\n    Args:\n        nums: A tuple of numbers.\n        k: The value to search for.\n\n    Returns:\n        True if k is present in the tuple, False otherwise.\n    \"\"\"\n    return k in nums", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a tuple contains a specific value k.\n\n    Args:\n        tup: The tuple to search.\n        k: The value to search for.\n\n    Returns:\n        True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}]}}}
