{"date": "2024-10-19 16:28", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 83.62957240263601, "dps_norm": 78.58003556526222, "pass@1": 69.83898305084746}, "eval": {"HumanEval/9": {"dps": 68.8801261829653, "dps_norm": 66.66666666666667, "pass@1": 70.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_num = None\n    output = []\n    for num in numbers:\n        if max_num is None or num > max_num:\n            max_num = num\n        output.append(max_num)\n    return output", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    rolling_max_nums = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        rolling_max_nums.append(current_max)\n    return rolling_max_nums", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_so_far = float('-inf')\n    rolling_max_list = []\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    result = [numbers[0]]\n    for i in range(1, len(numbers)):\n        result.append(max(result[-1], numbers[i]))\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_list = [max(numbers[:i+1]) for i in range(len(numbers))]\n    return max_list", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_list = [None]*len(numbers)\n    max_value = float('-inf')\n    for i in range(len(numbers)):\n        max_value = max(max_value, numbers[i])\n        max_list[i] = max_value\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_number = float('-inf')  # Set initial max_number as negative infinity\n    rolling_max_numbers = []  # Initialize the rolling max list\n\n    for num in numbers:\n        if num > max_number:  # If the current number is greater than max_number\n            max_number = num  # Update max_number\n        rolling_max_numbers.append(max_number)  # Append max_number to the rolling max list\n\n    return rolling_max_numbers", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_so_far = None\n    res = []\n    for num in numbers:\n        if max_so_far is None or num > max_so_far:\n            max_so_far = num\n        res.append(max_so_far)\n    return res", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_nums = []\n    max_num = float('-inf')\n    for num in numbers:\n        max_num = max(max_num, num)\n        rolling_max_nums.append(max_num)\n    return rolling_max_nums", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_num = numbers[0]\n    result = [max_num]\n\n    for num in numbers[1:]:\n        if num > max_num:\n            max_num = num\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max = [numbers[0]]\n    for num in numbers[1:]:\n        rolling_max.append(max(rolling_max[-1], num))\n\n    return rolling_max", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_val = float('-inf')\n    result = []\n    for num in numbers:\n        max_val = max(num, max_val)\n        result.append(max_val)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    for index, num in enumerate(numbers):\n        if index == 0:\n            rolling_max_list.append(num)\n        else:\n            rolling_max_list.append(max(rolling_max_list[-1], num))\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_so_far = float('-inf')\n    rolling_max_list = []\n    for number in numbers:\n        max_so_far = max(max_so_far, number)\n        rolling_max_list.append(max_so_far)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    maximums = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        maximums.append(current_max)\n    return maximums", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # Initialize an empty list to store the rolling maximums.\n    rolling_maxs = []\n\n    # Initialize a variable to keep track of the maximum number found so far.\n    max_so_far = float('-inf')\n\n    # Iterate through the input list.\n    for num in numbers:\n        # If the current number is greater than the maximum seen so far,\n        # update the maximum and append it to the rolling maximum list.\n        if num > max_so_far:\n            max_so_far = num\n        rolling_maxs.append(max_so_far)\n\n    # Return the list of rolling maximums.\n    return rolling_maxs", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    for i in range(1, len(numbers)):\n        result.append(max(result[-1], numbers[i]))\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_so_far = -float('inf')  # Initialize max_so_far to negative infinity\n    output = []  # Initialize output list\n\n    for num in numbers:\n        max_so_far = max(max_so_far, num)  # Update max_so_far to the maximum between max_so_far and current num\n        output.append(max_so_far)  # Append max_so_far to output\n\n    return output", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 69.01162790697674, "dps_norm": 72.14285714285714, "pass@1": 94.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the array to find neighbouring elements easily\n    numbers.sort()\n    \n    for i in range(len(numbers) - 1):\n        # Check if the difference between the two neighbouring elements is less than the threshold\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list in increasing order\n    numbers.sort()\n    \n    # Iterate over the sorted list\n    for i in range(len(numbers) - 1):\n        # Check if the difference between two adjacent numbers is less than threshold\n        if abs(numbers[i+1] - numbers[i]) < threshold:\n            # If so, there is a pair of close elements, return True\n            return True\n    # If no pair of close elements is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the numbers\n    numbers.sort()\n    \n    # Loop through the numbers to check for closeness\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no pair found closer than threshold\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if abs(numbers[i] - numbers[i - 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    sorted_nums = sorted(numbers)\n\n    for i in range(1, len(sorted_nums)):\n        if sorted_nums[i] - sorted_nums[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers)-1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers = sorted(numbers)\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers = sorted(numbers)  # sort the list of numbers\n    for i in range(len(numbers)-1):  # iterate through the sorted list\n        if numbers[i+1]-numbers[i] < threshold:  # check if the difference between current and next number is less than threshold\n            return True  # return True as soon as we find a pair of numbers that are closer than the threshold\n    return False  # if we don't find such a pair, return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n\n    # Loop over the numbers\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n\n            # Calculate the absolute difference between the current number and other numbers\n            difference = abs(numbers[i] - numbers[j])\n\n            # Check if the absolute difference is less than the threshold\n            if difference < threshold:\n                return True\n\n    # No close elements found\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers)-1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}]}, "HumanEval/4": {"dps": 83.38607594936708, "dps_norm": 88.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # calculate mean\n    mean = sum(numbers) / len(numbers)\n\n    # calculate absolute deviations from the mean\n    deviations = [abs(n - mean) for n in numbers]\n\n    # calculate and return mean of absolute deviations\n    return sum(deviations) / len(deviations)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(n - mean) for n in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(n - mean) for n in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    \n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    mean = sum(numbers) / len(numbers)\n    absolute_deviation = [abs(number - mean) for number in numbers]\n    mean_absolute_deviation = sum(absolute_deviation) / len(absolute_deviation)\n    return mean_absolute_deviation", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(num - mean) for num in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if len(numbers) == 0:\n        return 0.0\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(number - mean) for number in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean_of_numbers = sum(numbers) / len(numbers)\n    absolute_difference = [abs(number - mean_of_numbers) for number in numbers]\n    mean_absolute_deviation = sum(absolute_difference) / len(numbers)\n\n    return mean_absolute_deviation", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences\n    diffs = [abs(num - mean) for num in numbers]\n    \n    # Calculate and return the average\n    return sum(diffs) / len(diffs)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum([abs(x - mean) for x in numbers]) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_diffs = [abs(num - mean) for num in numbers]\n    mad = sum(absolute_diffs) / len(absolute_diffs)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # calculate mean\n    mean = sum(numbers) / len(numbers)\n    # calculate absolute deviation\n    abs_deviations = [abs(num - mean) for num in numbers]\n    # calculate and return mean absolute deviation\n    mad = sum(abs_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    deviation = [abs(n - mean) for n in numbers]\n    mad = sum(deviation) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(num - mean) for num in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(number - mean) for number in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(num - mean) for num in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n    mad = sum(abs(x - mean) for x in numbers) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    deviation = [abs(x - mean) for x in numbers]\n    mad = sum(deviation) / len(deviation)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(n - mean) for n in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(num - mean) for num in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 81.86046511627907, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    # First, convert the string to lowercase to treat characters in different cases equally\n    string = string.lower()\n\n    # Create an empty set to hold distinct characters\n    distinct_characters = set()\n\n    # Add each character to the set\n    for char in string:\n        distinct_characters.add(char)\n\n    # The length of the set will be the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    distinct_characters = set(string.lower())  # Convert the string to a set of distinct lower-case characters\n    return len(distinct_characters)  # Return the number of distinct characters", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    unique_characters = set(string.lower())\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # To handle case-insensitive comparison\n    string = string.lower()\n\n    # Creating a set to automatically remove duplicates\n    distinct_chars = set(string)\n    \n    # Count the number of characters in the set\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n\n    # Convert string to lower case to consider characters as case insensitive\n    string = string.lower()\n\n    # Store distinct characters in a set, because set automatically removes duplicates\n    distinct_characters = set(string)\n\n    # Return the count of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # convert string to lowercase to ensure the count is case-insensitive\n    lowered_string = string.lower()\n    # convert string to a set to remove duplicates\n    distinct_chars = set(lowered_string)\n    # return length of set to get the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # convert the string to lower case\n    string = string.lower()\n\n    # create an empty set to store unique characters\n    distinct_chars = set()\n    \n    # iterate over every character in the string\n    for char in string:\n        distinct_chars.add(char)\n        \n    # return the number of unique characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_characters = set()\n\n    for char in string.lower():\n        distinct_characters.add(char)\n\n    return len(distinct_characters)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    distinct_characters = set(string.lower())  # creates a set with unique characters in the string\n    return len(distinct_characters)  # returns the number of distinct characters", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to treat capital and small cases as the same character\n    string = string.lower()\n    # Use a set to automatically remove duplicates and count the unique characters\n    return len(set(string))", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase\n    string = string.lower()\n    # Use a set to eliminate duplicate characters\n    distinct_chars = set(string)\n    # The length of the set is the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    distinct_chars = set()  # use a set to automatically eliminate duplicates\n    for char in string.lower():  # convert to lowercase and iterate over characters\n        distinct_chars.add(char)  # add each character to the set\n    return len(distinct_chars)  # return the number of elements in the set", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))  # Converts the string to lower case and then to a set, which automatically removes duplicates", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 92.36077481840194, "dps_norm": 96.66666666666667, "pass@1": 89.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    smallest = sorted_numbers[0]\n    largest = sorted_numbers[1]\n\n    min_difference = largest - smallest\n\n    for i in range(len(sorted_numbers) - 1):\n        difference = sorted_numbers[i + 1] - sorted_numbers[i]\n\n        if difference < min_difference:\n            min_difference = difference\n            smallest = sorted_numbers[i]\n            largest = sorted_numbers[i + 1]\n\n    return smallest, largest", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    closest_pair = numbers[1] - numbers[0], numbers[0], numbers[1]\n\n    for i in range(2, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < closest_pair[0]:\n            closest_pair = diff, numbers[i - 1], numbers[i]\n\n    return closest_pair[1], closest_pair[2]", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()  # sort the numbers in ascending order\n    min_diff = float('inf')  # initialize minimum difference to positive infinity\n    closest_pair = (0, 0)  # initialize closest pair to (0, 0)\n    for i in range(len(numbers) - 1):  # iterate through the sorted numbers\n        diff = numbers[i + 1] - numbers[i]  # calculate the difference between current and next number\n        if diff < min_diff:  # if current difference is smaller than minimum difference\n            min_diff = diff  # update minimum difference\n            closest_pair = (numbers[i], numbers[i + 1])  # update closest pair\n    return closest_pair  # return the closest pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sorting the numbers\n    numbers.sort()\n    min_difference = float(\"inf\")\n    closest_pair = (0, 0)\n\n    for i in range(1, len(numbers)):\n        difference = numbers[i] - numbers[i-1]\n        if difference < min_difference:\n            min_difference = difference\n            closest_pair = (numbers[i-1], numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()\n    closest_pair = (numbers[0], numbers[1])\n    min_difference = abs(numbers[0] - numbers[1])\n\n    for i in range(1, len(numbers) - 1):\n        difference = abs(numbers[i] - numbers[i + 1])\n        if difference < min_difference:\n            min_difference = difference\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the list\n    numbers.sort()\n    \n    # Initialize variables\n    min_diff = float('inf')\n    result = ()\n\n    # Iterate through the list to find two closest numbers\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Check if list length is less than 2\n    if len(numbers) < 2:\n        raise ValueError(\"Input list should contain at least two elements\")\n\n    # Initialize min_diff and min_pair with first two elements\n    min_diff = abs(numbers[0] - numbers[1])\n    min_pair = (min(numbers[0], numbers[1]), max(numbers[0], numbers[1]))\n\n    # Traverse the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            # If diff is smaller than current min_diff, update min_diff and min_pair\n            if diff < min_diff:\n                min_diff = diff\n                min_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return min_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # sort the list\n    numbers.sort()\n\n    # initialize minimum difference and corresponding elements as first two elements of sorted list\n    min_diff = numbers[1] - numbers[0]\n    closest_elements = (numbers[0], numbers[1])\n\n    # iterate over list and compare difference between each number and its preceding number\n    for i in range(2, len(numbers)):\n        curr_diff = numbers[i] - numbers[i - 1]\n        if curr_diff < min_diff:\n            min_diff = curr_diff\n            closest_elements = (numbers[i - 1], numbers[i])\n\n    return closest_elements", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list in ascending order\n    numbers.sort()\n\n    # Initialize the minimum difference and result variables\n    min_diff = float('inf')\n    result = None\n\n    # Iterate over the list, skipping the first element (since it can't be compared with the previous one)\n    for i in range(1, len(numbers)):\n        # Calculate the difference between the current number and the previous one\n        diff = numbers[i] - numbers[i-1]\n\n        # If the difference is smaller than the current minimum difference, update the minimum difference and result\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0.0, 0.0)\n    \n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" \n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest = ()\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest = (numbers[i-1], numbers[i])\n\n    return closest", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sorting the numbers\n    numbers.sort()\n\n    # Initializing closest_diff as the absolute difference between the first two numbers\n    closest_diff = abs(numbers[1] - numbers[0])\n\n    # Initializing the closest_pair as the first two numbers\n    closest_pair = numbers[0], numbers[1]\n\n    # Looping over the list and updating the closest_pair and closest_diff as necessary\n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i+1] - numbers[i])\n        if diff < closest_diff:\n            closest_diff = diff\n            closest_pair = numbers[i], numbers[i+1]\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    for i in range(1, len(numbers)):\n        diff = abs(numbers[i] - numbers[i-1])\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    sorted_numbers = sorted(numbers)\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_elements = sorted_numbers[0], sorted_numbers[1]\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_elements = sorted_numbers[i], sorted_numbers[i + 1]\n    return closest_elements", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()  # sort numbers\n    min_diff = float('inf')  # initially assign minimum difference to infinity\n    min_pair = (0, 0)  # initialize minimum pair\n    for i in range(len(numbers) - 1):  # iterate through all pairs of numbers\n        diff = numbers[i + 1] - numbers[i]  # compute difference between current pair\n        if diff < min_diff:  # if smaller difference found\n            min_diff = diff  # replace minimum difference\n            min_pair = (numbers[i], numbers[i + 1])  # replace minimum pair\n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()  # sort the list in ascending order\n    min_diff = float('inf')  # initialize min_diff to infinity\n    closest_pair = ()  # initialize closest_pair to be empty\n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i + 1] - numbers[i])  # compute the difference between consecutive elements\n        if diff < min_diff:  # if the difference is less than min_diff, update min_diff and closest_pair\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_difference = float('inf')\n    closest_elements = (numbers[0], numbers[1])\n    \n    for i in range(1, len(numbers)):\n        difference = abs(numbers[i] - numbers[i - 1])\n        if difference < min_difference:\n            min_difference = difference\n            closest_elements = (numbers[i - 1], numbers[i])\n    \n    return closest_elements", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must have at least two elements.\")\n    \n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_difference = min(numbers[i+1] - numbers[i] for i in range(len(numbers)-1))\n    \n    for i in range(len(numbers)-1):\n        if numbers[i+1] - numbers[i] == min_difference:\n            return (numbers[i], numbers[i+1])", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    result = None\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 59.353741496598644, "dps_norm": 21.875, "pass@1": 80.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    i = n - 1\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):  # start from n-1, go to 1, step -1\n        if n % i == 0:  # if n is divisible by i\n            return i  # return i as largest divisor", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    if n <= 1:\n        return None  # as no positive integer less than n can divide 1\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n. \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    if n <= 1:\n        return \"Error: Number should be greater than 1\"\n\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            return i\n\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" \n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(48)\n    24\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input number must be a positive integer.\")\n    for divisor in range(n - 1, 1, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    i = n - 1\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    i = n - 1\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "import doctest\ndef largest_divisor(n: int) -> int:\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None\n    i = n // 2\n    while i >= 1:\n        if n % i == 0:\n            return i\n        i -= 1\n    return None", "matching_cluster_idx": 1}, {"solution": "import doctest\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    i = n - 1\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    i = n - 1\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    if n < 1:\n        raise ValueError(\"Input number should be greater than 0\")\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}]}, "HumanEval/26": {"dps": 43.0, "dps_norm": 43.75, "pass@1": 25.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n\n    unique_numbers = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            unique_numbers.append(num)\n    return unique_numbers", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    return [i for i in numbers if numbers.count(i) == 1]", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    unique = []\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            unique.append(num)\n\n    return unique", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    # Create a dictionary to track the count of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    # Append numbers that have count = 1 to the result\n    for num in numbers:\n        if count[num] == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    num_counts = {}\n    result = []\n\n    for num in numbers:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    for num in numbers:\n        if num_counts[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Use a dictionary to store the number of occurrences of each number\n    counts = {}\n    # Iterate through the list\n    for num in numbers:\n        # If number is in dictionary, increment its count, otherwise, add it to the dictionary\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    # Now, iterate through the list again\n    no_duplicates = []\n    for num in numbers:\n        # If number is in dictionary and its count is 1, add it to the result list\n        if num in counts and counts[num] == 1:\n            no_duplicates.append(num)\n    return no_duplicates", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    new_list = []\n    for num in numbers:\n        if numbers.count(num) == 1:  # count the occurrences of the number in the list\n            new_list.append(num)\n    return new_list", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    return [item for item in numbers if numbers.count(item) == 1]", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return [i for i in numbers if numbers.count(i) == 1]", "matching_cluster_idx": 0}]}, "HumanEval/31": {"dps": 76.39240506329114, "dps_norm": 81.875, "pass@1": 92.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\"\"\"\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n\n    If n is less than 2, it's not prime, therefore return False.\n    If n is 2, it's prime, so return True.\n    For all other numbers, we check if they have any divisors between 2 and the square root of n, if they do, return False.\n    If they don't, return True.\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:  # all numbers less than 2 are not prime\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # all other even numbers are not prime\n        return False\n    max_divisor = int(n ** 0.5) + 1  # we only need to check up to sqrt(n)\n    for d in range(3, max_divisor, 2):  # only check odd numbers\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:  # zero, one and negative numbers are not prime\n        return False\n    if n == 2:  # 2 is prime\n        return True\n    if n % 2 == 0:  # even numbers are not prime\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):  # try odd numbers up to square root of n\n        if n % i == 0:  # if n is divisible by i, it's not prime\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n ** 0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2: \n        return False  # 1 and numbers less than 2 are not prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False  # If n is divisible by any number up to its square root, it's not prime\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i:\n            i += 2\n        else:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:  # numbers less than 2 are not prime\n        return False\n    if n == 2:  # 2 is prime\n        return True\n    if n % 2 == 0:  # even numbers other than 2 are not prime\n        return False\n    max_divisor = int(n ** 0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:  # n is not a prime\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 55.601851851851855, "dps_norm": 72.72727272727272, "pass@1": 25.0, "profiled": [{"solution": "def sort_third(l):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    divisible_by_three = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(divisible_by_three.pop(0))\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    index = [i for i in range(len(l)) if i % 3 == 0]\n    sorted_value = sorted([l[i] for i in index])\n    res = l[:]\n    for idx, val in zip(index, sorted_value):\n        res[idx] = val\n    return res", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Identify all indices divisible by three\n    div_by_three = [i for i in range(len(l)) if i % 3 == 0]\n\n    # For each index divisible by three, we sort the list of values at those indices\n    sorted_values = sorted([l[i] for i in div_by_three])\n\n    # Create a new list where the values are sorted for the indices divisible by three\n    # and the rest of the values are kept as they are\n    l_prime = l.copy()\n    for idx, val in zip(div_by_three, sorted_values):\n        l_prime[idx] = val\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    divisible_by_three = sorted([l[i] for i in range(len(l)) if i%3 == 0])\n    divisible_by_three_indexes = sorted([i for i in range(len(l)) if i%3 == 0])\n    \n    sorted_l = [0]*len(l)\n    index = 0\n    divisible_index = 0\n\n    for i in range(len(l)):\n        if i%3 != 0:\n            sorted_l[i] = l[i]\n        else:\n            sorted_l[i] = divisible_by_three[divisible_index]\n            divisible_index += 1\n\n    return sorted_l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    divisible_indices = [i for i, x in enumerate(l) if i % 3 == 0]\n    divisible_values = [l[i] for i in divisible_indices]\n    divisible_values.sort()\n    \n    new_l = l.copy()\n    for i in divisible_indices:\n        new_l[i] = divisible_values.pop(0)\n    \n    return new_l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    divisible_by_three.sort()\n    result = l.copy()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = divisible_by_three.pop(0)\n    return result", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are \n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    third_elements = sorted([l[i] for i in range(0, len(l), 3)])\n    result = l.copy()\n    \n    for i in range(0, len(l), 3):\n        result[i] = third_elements.pop(0)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    indexes_to_sort = [i for i in range(len(l)) if i % 3 == 0]\n    values_to_sort = [l[i] for i in indexes_to_sort]\n    sorted_values = sorted(values_to_sort)\n    \n    for i in range(len(l)):\n        if i in indexes_to_sort:\n            l[i] = sorted_values.pop(0)\n    \n    return l", "matching_cluster_idx": 2}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Find values at indices divisible by 3\n    div_three_values = sorted([l[i] for i in range(0, len(l), 3)])\n\n    # Replace these values in the original list\n    for i in range(0, len(l), 3):\n        l[i] = div_three_values.pop(0)\n    \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    indices_divisible_by_three = [i for i in range(len(l)) if i % 3 == 0]\n    sorted_values = sorted([l[i] for i in indices_divisible_by_three])\n    \n    result = l.copy()\n    for i, val in enumerate(sorted_values):\n        result[indices_divisible_by_three[i]] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    index = [i for i, x in enumerate(l) if i % 3 == 0]\n    values = [l[i] for i in index]\n    values.sort()\n    for i, idx in enumerate(index):\n        l[idx] = values[i]\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # find the values at the indices divisible by 3\n    divisible_by_3 = [l[i] for i in range(len(l)) if i%3 == 0]\n    # sort the found values\n    divisible_by_3.sort()\n    # replace the values at the indices divisible by 3 with the sorted values\n    for i in range(len(l)):\n        if i%3 == 0:\n            l[i] = divisible_by_3.pop(0)\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    divisible_by_three = []\n    not_divisible_by_three = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            divisible_by_three.append(l[i])\n        else:\n            not_divisible_by_three.append(l[i])\n    divisible_by_three.sort()\n    l_prime = not_divisible_by_three\n    for i in range(len(divisible_by_three)):\n        l_prime.insert(i*3, divisible_by_three[i])\n    return l_prime", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    thirds = [l[i] for i in range(0, len(l), 3)]\n    thirds.sort()\n    thirds_i = 0\n    result = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(thirds[thirds_i])\n            thirds_i += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    sorted_values = sorted([l[i] for i in indices])\n    result = l.copy()\n    for i, value in zip(indices, sorted_values):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    divisible_by_three = [i for i in l[::3]]\n    divisible_by_three.sort()\n    i = 0\n    for j in range(0, len(l), 3):\n        l[j] = divisible_by_three[i]\n        i += 1\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    divisible_by_three_values = sorted([l[i] for i in range(len(l)) if i%3==0])\n    return [divisible_by_three_values.pop(0) if i%3==0 else l[i] for i in range(len(l))]", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    if not l:  # handle an empty list\n        return l\n\n    divisible_by_three_indices = [index for index in range(len(l)) if index % 3 == 0]\n    divisible_by_three_values = sorted([l[index] for index in divisible_by_three_indices])\n\n    for index in divisible_by_three_indices:\n        l[index] = divisible_by_three_values.pop(0)\n\n    return l", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    values = sorted([l[i] for i in indices])\n\n    for i in indices:\n        l[i] = values.pop(0)\n    \n    return l", "matching_cluster_idx": 7}, {"solution": "def sort_third(l):\n    # Define two empty lists to store the values at indices divisible by 3 and not divisible by 3\n    div_three = []\n    not_div_three = []\n\n    # Iterate through the list\n    for i in range(len(l)):\n        # If the index is divisible by 3, append the value to 'div_three'\n        if i % 3 == 0:\n            div_three.append(l[i])\n        # Otherwise, append the value to 'not_div_three'\n        else:\n            not_div_three.append(l[i])\n\n    # Sort 'div_three'\n    div_three.sort()\n    \n    # Construct a new list, 'new_l'\n    # Put elements from 'not_div_three' at indices divisible by 3\n    # Put elements from 'div_three' at other indices\n    new_l = [None] * len(l)\n    j, k = 0, 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            new_l[i] = div_three[j]\n            j += 1\n        else:\n            new_l[i] = not_div_three[k]\n            k += 1\n\n    return new_l", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 95.47169811320755, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(lst: list):\n    \"\"\"Return sorted unique elements in a list.\"\"\"\n    return sorted(list(set(lst)))", "matching_cluster_idx": 3}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Use set to remove duplicates\n    unique_list = list(set(l))\n\n    # Sort the list in ascending order\n    unique_list.sort()\n\n    return unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"\n    Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 87.98387096774192, "dps_norm": 67.85714285714286, "pass@1": 92.0, "profiled": [{"solution": "def count_sevens(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\ndef fizz_buzz(n: int):\n    return count_sevens(n)", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\")\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    # Initializing count\n    count = 0\n    \n    # Iterate from 0 to n\n    for i in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Count the number of times the digit 7 appears\n            count += str(i).count('7')\n            \n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\")\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    return sum(str(i).count('7') for i in range(n) if i % 11 == 0 or i % 13 == 0)", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: positive integer\n    :type n: int\n    :return: number of times 7 appears in the numbers less than n that are divisible by 11 or 13\n    :rtype: int\n    \n    :example:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    # Start by ensuring the given number is valid\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    \n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n            \n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\")\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    total = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            total += str(i).count('7')\n    return total", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    def digit_count(number, target_digit):\n        count = 0\n        while number > 0:\n            if number % 10 == target_digit:\n                count += 1\n            number = number // 10\n        return count\n\n    def divisible_by(number, divisor):\n        return number % divisor == 0\n\n    count = 0\n    for i in range(n):\n        if divisible_by(i, 11) or divisible_by(i, 13):\n            count += digit_count(i, 7)\n    return count", "matching_cluster_idx": 0}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def has_seven(num: int) -> bool:\n        return '7' in str(num)\n\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += sum(1 for digit in str(i) if digit == '7')\n    return count", "matching_cluster_idx": 3}]}, "HumanEval/37": {"dps": 95.18003273322422, "dps_norm": 90.5, "pass@1": 91.0, "profiled": [{"solution": "def sort_even(l: list):\n    # list of even indices\n    evens = [l[i] for i in range(0, len(l), 2)]\n    evens.sort()\n\n    # output list\n    l_sorted = l.copy()\n\n    # assign sorted evens to corresponding positions in the input list\n    j = 0\n    for i in range(0, len(l), 2):\n        l_sorted[i] = evens[j]\n        j += 1\n\n    return l_sorted", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_indicies = sorted([l[i] for i in range(0, len(l), 2)])\n    j = 0\n    for i in range(0, len(l), 2):\n        l[i] = even_indicies[j]\n        j += 1\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices values.\n    evens = [l[i] for i in range(0, len(l), 2)]\n    evens.sort()\n    # Insert sorted values in odd index positions.\n    for i in range(0, len(l), 2):\n        l[i] = evens.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    result = l[:]\n    result[::2] = even_elements\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are\n    equal to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Get even indexed items and sort\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    even_indices.sort()\n    \n    # Copy even indexed items from sorted list back into original list\n    new_l = l.copy()\n    for i in range(0, len(l), 2):\n        new_l[i] = even_indices.pop(0)\n    return new_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_index = sorted([value for index, value in enumerate(l) if index % 2 == 0])\n    result = []\n    even_iterator = iter(even_index)\n    for index in range(len(l)):\n        if index % 2 == 0:\n            result.append(next(even_iterator))\n        else:\n            result.append(l[index])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_values = sorted([l[i] for i in range(0, len(l), 2)])\n    result = [even_values.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are \n    equal to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_indicies = sorted(l[i] for i in range(0, len(l), 2))\n    result = l.copy()\n    for i in range(0, len(l), 2):\n        result[i] = even_indicies.pop(0)\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Get the values at even indices of l\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort them\n    even_values.sort()\n    \n    # Replace the values at even indices in l with sorted values\n    for i in range(0, len(l), 2):\n        l[i] = even_values.pop(0)\n        \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_indices = sorted(l[i] for i in range(0, len(l), 2))\n    return [(even_indices.pop(0) if i % 2 == 0 else l[i]) for i in range(len(l))]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    evens = [l[i] for i in range(0, len(l), 2)]\n    evens.sort()\n    j = 0\n    for i in range(0, len(l), 2):\n        l[i] = evens[j]\n        j += 1\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Separate out the values at even indices\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort these values\n    sorted_even_values = sorted(even_values)\n    \n    # Replace the values at even indices with the sorted ones\n    for i in range(0, len(l), 2):\n        l[i] = sorted_even_values.pop(0)\n    \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # get even indexed elements\n    evens = [l[i] for i in range(len(l)) if i % 2 == 0]\n    evens.sort()\n\n    # insert sorted evens at even indices\n    result = []\n    j = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(evens[j])\n            j += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    new_l = []\n    even_index = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            new_l.append(even_elements[even_index])\n            even_index += 1\n        else:\n            new_l.append(l[i])\n    \n    return new_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_numbers = sorted([l[i] for i in range(0, len(l), 2)])\n    result = [l[i] if i % 2 == 1 else even_numbers.pop(0) for i in range(len(l))]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indicies = [l[i] for i in range(0, len(l), 2)]\n    even_indicies.sort()\n    new_l = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            new_l.append(even_indicies[even_index])\n            even_index += 1\n        else:\n            new_l.append(l[i])\n    return new_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n\n    Args:\n        l (list): input list\n\n    Returns:\n        list: output list\n\n    Examples:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    evens = sorted(l[::2])\n    result = l[:]\n    result[::2] = evens\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_indexes = sorted([l[i] for i in range(0, len(l), 2)])\n    result = []\n    j = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indexes[j])\n            j += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_indexes = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    sorted_l = [None] * len(l)\n    for i in range(len(sorted_l)):\n        if i % 2 == 0:\n            sorted_l[i] = even_indexes.pop(0)\n        else:\n            sorted_l[i] = l[i]\n    return sorted_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    even_values.sort()\n    sorted_l = []\n    e = 0\n    for i in range(len(l)):\n        if i % 2 == 0:  # for even index\n            sorted_l.append(even_values[e])\n            e += 1\n        else:  # for odd index\n            sorted_l.append(l[i])\n    return sorted_l", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 78.58823529411765, "dps_norm": 93.0, "pass@1": 82.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    if n == 0:\n        return 1 % p\n    else:\n        return (2 ** n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n\n    :param n: Integer representing power of 2\n    :param p: Modulus to be applied\n    :return: Result of 2^n % p\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = 2 ** n % p\n    return result", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if p == 1:\n        return 0\n    else:\n        return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The base number.\n        p (int): The modulo number.\n    \n    Returns:\n        int: The result of (2^n) modulo p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return (2 ** n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    # Python uses modular exponentiation by default for power operations\n    return (2 ** n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    # Use Python's built-in function pow() to calculate 2^n mod p\n    # Note that pow() function is used instead of exponentiation operator\n    # because the operator has a different precedence than the modulus operator\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return 2 ** n % p", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return (2**n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return (2 ** n) % p", "matching_cluster_idx": 3}]}, "HumanEval/51": {"dps": 81.44927536231884, "dps_norm": 68.75, "pass@1": 99.0, "profiled": [{"solution": "def remove_vowels(text):\n    return ''.join(char for char in text if char.lower() not in 'aeiou')", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    return ''.join([i for i in text if i not in ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([ch for ch in text if ch not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join(c for c in text if c.lower() not in 'aeiou')", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define the set of vowels\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n\n    # Return the string without vowels\n    return ''.join(ch for ch in text if ch not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join(char for char in text if char not in 'aeiouAEIOU')", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join(letter for letter in text if letter.lower() not in \"aeiou\")", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join([char for char in text if char.lower() not in 'aeiou'])", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    for vowel in vowels:\n        text = text.replace(vowel, '')\n    return text", "matching_cluster_idx": 7}]}, "HumanEval/54": {"dps": 84.04255319148936, "dps_norm": 86.9047619047619, "pass@1": 12.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"Check if two words have the same characters.\"\"\"\n    # Converting both strings to sets\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Checking if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    # removing duplicate characters from the strings\n    s0 = ''.join(set(s0))\n    s1 = ''.join(set(s1))\n\n    # checking if both strings have the same characters\n    return sorted(s0) == sorted(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    # create a dictionary for each string counting the number of each letter\n    s0_dict = {}\n    for char in s0:\n        s0_dict[char] = s0_dict.get(char, 0) + 1\n    s1_dict = {}\n    for char in s1:\n        s1_dict[char] = s1_dict.get(char, 0) + 1\n\n    # check if both dictionaries have the same keys (letter counts are unimportant)\n    return s0_dict.keys() == s1_dict.keys()", "matching_cluster_idx": 0}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    # Convert both strings to sets to remove duplicates and change them to tuples\n    # for comparison.\n    return set(tuple(sorted(s0))) == set(tuple(sorted(s1)))", "matching_cluster_idx": 1}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # return sorted(s0) == sorted(s1)\n    return sorted(list(set(s0))) == sorted(list(set(s1)))", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 85.17716535433071, "dps_norm": 77.5, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    common_elements = list(set(l1) & set(l2))\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    # Convert the lists to sets, which can perform fast set operations\n    s1, s2 = set(l1), set(l2)\n    # Find the intersection of the sets, which gives us the common elements\n    common_set = s1.intersection(s2)\n    # Convert the resulting set back to a list\n    common_list = list(common_set)\n    # Sort the list in ascending order\n    common_list.sort()\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(list(set([value for value in l1 if value in l2])))", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set([i for i in l1 if i in l2])))", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection operation to find common elements\n    common_elements = list(set(l1) & set(l2))\n    # Return common elements sorted\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find common elements and then remove duplicates by converting to set\n    common_elements = set(l1).intersection(l2)\n    \n    # Convert the set back to a list and sort\n    sorted_common_elements = sorted(list(common_elements))\n    \n    return sorted_common_elements", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Returns the largest prime factor of n.\"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 89.82683982683983, "dps_norm": 65.27777777777777, "pass@1": 18.0, "profiled": [{"solution": "def vowels_count(s):\n    vowels = set(\"aeiouAEIOU\")\n    count = 0\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    for letter in s:\n        if letter in vowels:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    count = sum([s.lower().count(vowel) for vowel in \"aeiou\"])\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    vowels = 'aeiou'\n    count = sum(s.count(v) for v in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def vowels_count(s):\n    # We are using the set function to create a set of vowels\n    vowels = set(\"aeiouAEIOU\")\n\n    # Using list comprehension to find vowels in the string\n    count = sum(1 for letter in s if letter in vowels)\n\n    # If the last character in the string is 'Y' or 'y', count it\n    if s[-1:] == 'y' or s[-1:] == 'Y':\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = sum(1 for char in s if char in vowels)\n    \n    if s.endswith('y'):\n        count += 1\n        \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    This function counts the number of vowels in a given string, \n    including the 'y' at the end of the string.\n    \"\"\"\n    s = s.lower()  # convert the string to lowercase for easy comparison\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = sum(1 for char in s if char in vowels)\n    return count + (1 if s.endswith('y') else 0)", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Convert the string to lowercase to handle uppercase letters\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    # If the string ends with 'y', consider it a vowel\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    return sum(1 for char in s.lower() if char in vowels) + (\"y\" == s[-1:].lower())", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    s = s.lower()  # to handle cases like \"ACEDY\"\n    count = sum([1 for char in s if char in ['a', 'e', 'i', 'o', 'u']])\n    if s.endswith('y'):   # to check for 'y' at end of word\n        count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def vowels_count(s):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    s = s.lower()\n    return sum(1 for letter in s if letter in vowels) + (s.endswith('y') and s[-1] == 'y')", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = sum([1 for char in s if char in vowels])\n\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def vowels_count(s):\n    return sum(1 for c in s.lower() if c in 'aeiou') + (1 if s.lower().endswith('y') else 0)", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = sum(1 for letter in s if letter in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    count = 0\n    for char in s:\n        if char.lower() in 'aeiou':\n            count += 1\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = set(\"aeiou\")\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    s = s.lower()  # Ensure the search is case insensitive\n    # Use list comprehension to count the number of vowels\n    # and use the 'endswith' function to check if 'y' is at the end\n    # of the string. \n    return sum(1 for c in s if c in vowels) + ('y' in s[-1] if s else 0)", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for letter in s if letter in vowels)\n\n    if s.endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 76.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(word) for word in lst1)\n    total_chars2 = sum(len(word) for word in lst2)\n    return lst1 if total_chars1 <= total_chars2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    This function takes two lists of strings as input, calculates the total number of characters in each list, \n    and returns the list with fewer total characters.\n\n    If both lists have the same total number of characters, the function returns the first list.\n    '''\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n    \n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum([len(x) for x in lst1])\n    sum2 = sum([len(x) for x in lst2])\n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars1 = count_chars(lst1)\n    total_chars2 = count_chars(lst2)\n    \n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    \n    total_lst1 = sum(len(str) for str in lst1)\n    total_lst2 = sum(len(str) for str in lst2)\n\n    return lst1 if total_lst1 <= total_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum([len(i) for i in lst1])\n    sum_lst2 = sum([len(i) for i in lst2])\n    if sum_lst1 < sum_lst2:\n        return lst1\n    elif sum_lst2 < sum_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum(len(i) for i in lst1)\n    sum_lst2 = sum(len(i) for i in lst2)\n\n    if sum_lst1 <= sum_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(word) for word in lst1)\n    total2 = sum(len(word) for word in lst2)\n\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(word) for word in lst1)\n    total_chars2 = sum(len(word) for word in lst2)\n\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(str) for str in lst1)\n    total_chars_lst2 = sum(len(str) for str in lst2)\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_len_lst1 = sum(len(s) for s in lst1)\n    total_len_lst2 = sum(len(s) for s in lst2)\n    \n    if total_len_lst1 < total_len_lst2:\n        return lst1\n    elif total_len_lst1 > total_len_lst2:\n        return lst2\n    else: \n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    A function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n    '''\n    sum1 = sum(len(string) for string in lst1)\n    sum2 = sum(len(string) for string in lst2)\n\n    if sum1 < sum2:\n        return lst1\n    elif sum1 > sum2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    lst1_total = sum(len(i) for i in lst1)\n    lst2_total = sum(len(i) for i in lst2)\n\n    if lst1_total <= lst2_total:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(i) for i in lst1)\n    total_chars_lst2 = sum(len(i) for i in lst2)\n    \n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(i) for i in lst1)\n    sum2 = sum(len(i) for i in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Compute total chars in both lists\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer total chars\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum(len(s) for s in lst1)\n    sum_lst2 = sum(len(s) for s in lst2)\n\n    if sum_lst1 < sum_lst2:\n        return lst1\n    elif sum_lst1 > sum_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 91.68316831683168, "dps_norm": 60.0, "pass@1": 98.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\"\"\"\n\n    # Using list comprehension and enumerate for index\n    return sum(val for ind, val in enumerate(lst) if ind%2 and val%2==0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(i for idx, i in enumerate(lst) if i % 2 == 0 and idx % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices\"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, \n    add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(i for i in lst[1::2] if i % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n\n    # Initialize an empty list to store the sum of even elements at odd indices\n    sum_even_odd_indices = 0\n    \n    # Iterate through the list, skipping every 2nd element (the first element is at index 0)\n    for i in range(1, len(lst), 2):\n        # Check if the current element at the skipped index is even\n        if lst[i] % 2 == 0:\n            sum_even_odd_indices += lst[i]  # Add it to the sum\n\n    return sum_even_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n    add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    # Initialize sum variable\n    sum = 0\n    # Loop through list with an index starting from 1 (skipping the first index due to 0-based index)\n    for i in range(1, len(lst), 2):\n        # Check if the element at this index is even\n        if lst[i] % 2 == 0:\n            # If yes, add to the sum\n            sum += lst[i]\n    # return sum\n    return sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n    add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n\n    # start a counter\n    total = 0\n\n    # iterate over the list, adding the elements at odd indices to the counter\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            total += lst[i]\n\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(val for index, val in enumerate(lst) if index % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum([lst[i] for i in range(len(lst)) if i % 2 != 0 and lst[i] % 2 == 0])", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    if lst:\n        return sum(e for i, e in enumerate(lst) if i % 2 != 0 and e % 2 == 0)\n    else:\n        raise ValueError(\"List cannot be empty\")", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n\n    # define an empty list to hold even elements at odd indices\n    even_odds = []\n\n    # iterate over the list starting from index 0 to avoid counting twice\n    for i in range(len(lst)):\n\n        # check if index is odd and element is even\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            even_odds.append(lst[i])\n\n    # return the sum of even_odds list\n    return sum(even_odds)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}]}, "HumanEval/86": {"dps": 95.61224489795919, "dps_norm": 98.0, "pass@1": 50.0, "profiled": [{"solution": "def anti_shuffle(s):\n    # split the string into a list of words and spaces\n    words = s.split(' ')\n    # for each word in the list\n    for i in range(len(words)):\n        # sort the characters in the word and join them back together\n        words[i] = ''.join(sorted(words[i]))\n    # join the words together with spaces between them\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    res = []\n    for word in words:\n        sorted_chars = sorted(word, key=ord)\n        res.append(''.join(sorted_chars))\n    return ' '.join(res)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    result = []\n    for word in words:\n        letters = list(word)\n        sorted_letters = sorted(letters, key=lambda x: ord(x))\n        result.append(''.join(sorted_letters))\n    return ' '.join(result)", "matching_cluster_idx": 2}, {"solution": "def anti_shuffle(s):\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    return ' '.join([''.join(sorted(word)) for word in s.split(' ')])", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_words.append(''.join(sorted(word)))\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    result = ' '.join(ordered_words)\n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # split string into words\n    words = s.split(' ')\n\n    # sort each word's characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n\n    # combine sorted words and return\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    def sort_word(word):\n        return ''.join(sorted(word, key=ord))\n\n    return ' '.join(map(sort_word, s.split(' ')))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns an ordered version of a given string.\n    \"\"\"\n    words = s.split(' ')\n    for i in range(len(words)):\n        words[i] = \"\".join(sorted(words[i]))\n    return \" \".join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    return ' '.join([''.join(sorted(word)) for word in s.split(' ')])", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n\n    words = s.split(' ')  # split the string into words\n\n    for i in range(len(words)):\n        words[i] = ''.join(sorted(words[i]))  # sort each word and join the letters\n\n    return ' '.join(words)  # join the words back together with spaces", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    for i in range(len(words)):\n        words[i] = ''.join(sorted(words[i]))\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    for i in range(len(words)):\n        words[i] = ''.join(sorted(words[i]))\n    s = ' '.join(words)\n    return s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    words = [''.join(sorted(word)) for word in words]\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the string into a list of words (separated by space)\n    words = s.split(' ')\n    # Shuffle each word and convert it to a list of characters\n    shuffled_words = [''.join(sorted(word)) for word in words]\n    # Join the shuffled words together with spaces\n    result = ' '.join(shuffled_words)\n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    output = []\n    for word in words:\n        output.append(''.join(sorted(word)))\n\n    ordered_s = ' '.join(output)\n    return ordered_s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = ['']*len(words)\n    \n    for i, word in enumerate(words):\n        ordered_word = ''.join(sorted(word))\n        ordered_words[i] = ordered_word\n    \n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 75.50432276657061, "dps_norm": 53.57142857142857, "pass@1": 43.0, "profiled": [{"solution": "def get_row(lst, x):\n    result = []\n    for row in range(len(lst)):\n        for col in range(len(lst[row])):\n            if lst[row][col] == x:\n                result.append((row, col))\n    result.sort(key=lambda row_col: (row_col[0], -row_col[1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    \n    # loop through each row in list\n    for row_index, row in enumerate(lst):\n        # loop through each value in row\n        for value_index, value in enumerate(row):\n            # if the value is equal to x, add coordinate to result\n            if value == x:\n                result.append((row_index, value_index))\n    \n    # sort coordinates by rows in ascending order, and by columns in descending order\n    result.sort(key = lambda x: (x[0], -x[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Create a list to store our coordinates\n    coordinates = []\n\n    # Iterate over the rows\n    for i in range(len(lst)):\n        # Iterate over the columns\n        for j in range(len(lst[i])):\n            # If the current number matches our target, append the coordinate\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n\n    # Sort the coordinates first by the row in ascending order,\n    # then by the column in descending order\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the tuples\n    coordinates = []\n    # Iterate through each row\n    for i, row in enumerate(lst):\n        # Iterate through each column\n        for j, col in enumerate(row):\n            # If the value at the current position is equal to x, add a tuple (row index, column index) to the list\n            if col == x:\n                coordinates.append((i, j))\n    # Sort the list of tuples first by rows (first element of tuple) in ascending order, and then by columns (second element of tuple) in descending order\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # convert 2D list to a list of tuples where each tuple is a pair of coordinates: (row_index, column_index)\n    # filter out pairs where the value at that coordinate is not equal to x\n    # sort first by row_index in ascending order, then by column_index in descending order\n    coords = sorted(((i,j) for i,row in enumerate(lst) for j,el in enumerate(row) if el == x), \n                    key=lambda t:(t[0], -t[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coord = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                coord.append((i, j))\n\n    return sorted(coord, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, col in enumerate(row):\n            if col == x:\n                coords.append((row_idx, col_idx))\n    return sorted(coords, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"Returns coordinates of integer x in the 2D list sorted by rows and columns.\"\"\"\n    coords = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    return sorted(coords, key=lambda y: (y[0], -y[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coords.append((i, j))\n    return sorted(coords, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    return sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list for storing tuples.\n    coordinates = []\n\n    # Iterate over the rows in the list.\n    for row_num, row in enumerate(lst):\n        # Check each number in the row.\n        for col_num, num in enumerate(row):\n            # If the number is equal to x, add its coordinates to the list.\n            if num == x:\n                coordinates.append((row_num, col_num))\n\n    # Sort the list first by rows (first element of each tuple) in ascending order,\n    # and then by columns (second element of each tuple) in descending order.\n    coordinates.sort(key=lambda tup: (tup[0], -tup[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                result.append((i, j))\n    # Sort by row first and then column descendingly.\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Empty list for output\n    result = []\n    \n    # Enumerate through list to get row and column numbers\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row):\n            # Check if the number is x and if so, add coordinates to result\n            if col == x:\n                result.append((i, j))\n\n    # Sort coordinates first by row (in ascending order), then by column (in descending order)\n    result.sort(key=lambda x: (x[0], -x[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, item in enumerate(row):\n            if item == x:\n                result.append((i, j))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = [(i, j) for i, sublist in enumerate(lst) for j, val in enumerate(sublist) if val == x]\n    return sorted(coordinates, key=lambda y: (y[0], -y[1]))\nlst = [\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ]\nx = 1", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                result.append((i, j))\n\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    return sorted([(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x], key=lambda t: (t[0], -t[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    output = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                output.append((i, j))\n    return sorted(output, key=lambda t: (t[0], -t[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for y, row in enumerate(lst):\n        for z, cell in enumerate(row):\n            if cell == x:\n                coords.append((y, z))\n    coords.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coords", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 90.22336769759451, "dps_norm": 27.61904761904762, "pass@1": 15.0, "profiled": [{"solution": "def encrypt(s):\n    def shift_char(c):\n        # check if the character is an alphabet\n        if not c.isalpha():\n            return c\n        # calculate the shift\n        shift = (ord(c.lower()) - 97 + 4) % 26\n        # shift the character\n        result = chr(97 + shift)\n        # if character was uppercase, make it uppercase\n        if c.isupper():\n            result = result.upper()\n        return result\n\n    # apply the shift to each character in the string\n    return \"\".join([shift_char(c) for c in s])", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_val = ord(char) + 2 * 2\n            if char.islower():\n                if ascii_val > ord('z'):\n                    ascii_val -= 26\n            else:\n                if ascii_val > ord('Z'):\n                    ascii_val -= 26\n            encrypted += chr(ascii_val)\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    for char in s:\n        if char.isalpha():\n            code = ord(char.lower()) - 96\n            result += chr((code + 2 * 2 - 1) % 26 + 97).upper() if char.isupper() else chr((code + 2 * 2 - 1) % 26 + 97)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_string = ''\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted_string += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            encrypted_string += char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for i in s:\n        if i.isalpha():\n            shift = ord(i) + 2 * 2\n            if i.isupper():\n                result += chr(shift) if shift <= ord('Z') else chr(shift - 26)\n            else:\n                result += chr(shift) if shift <= ord('z') else chr(shift - 26)\n        else:\n            result += i\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for c in s:\n        # Convert to Unicode code point, subtract 97 (for 'a'), add 2 * 2, \n        # then get the modular 26 (number of letters in the alphabet) and add 'a' \n        # (shift back to ASCII equivalent of the start of the alphabet).\n        if c.isalpha():\n            result += chr((ord(c.lower()) - 97 + 2 * 2) % 26 + 97)\n        else:\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():  # only encrypt alphabet characters\n            ascii_offset = 65 if char.isupper() else 97  # determine offset for upper and lower case letters\n            encrypted_char = chr(((ord(char) - ascii_offset + 4) % 26) + ascii_offset)  # apply offset and shift\n            result += encrypted_char  # add to result\n        else:\n            result += char  # non-alphabet characters stay the same\n    return result", "matching_cluster_idx": 1}, {"solution": "def rot2mult2(c):\n    \"\"\"Encrypt a single character by shifting it down by two \n    multiplied by two places. This function is used in encrypt()\n    \"\"\"\n    if not c.isalpha():\n        return c\n    offset = 2 * 2\n    start = 'a' if c.islower() else 'A'\n    return chr((ord(c) - ord(start) + offset) % 26 + ord(start))\ndef encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \"\"\"\n    return ''.join(rot2mult2(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for i in s:\n        if i.isalpha():\n            ascii_val = ord(i) + 2 * 2\n            if i.isupper():\n                if ascii_val > ord('Z'):\n                    encrypted += chr(ascii_val - 26)\n                else:\n                    encrypted += chr(ascii_val)\n            else:\n                if ascii_val > ord('z'):\n                    encrypted += chr(ascii_val - 26)\n                else:\n                    encrypted += chr(ascii_val)\n        else:\n            encrypted += i\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    for i in s:\n        if i.isalpha():\n            ascii_num = ord(i) + 2 * 2\n            if i.islower():\n                if ascii_num > ord('z'):\n                    result += chr(ascii_num - 26)\n                else:\n                    result += chr(ascii_num)\n            else:\n                if ascii_num > ord('Z'):\n                    result += chr(ascii_num - 26)\n                else:\n                    result += chr(ascii_num)\n        else:\n            result += i\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for i in s:\n        if i.isalpha():\n            ascii_offset = 65 if i.isupper() else 97\n            i_shifted = chr((ord(i) - ascii_offset + 2*2) % 26 + ascii_offset)\n            result += i_shifted\n        else:\n            result += i\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        # convert char to ascii\n        ascii_value = ord(char)\n        \n        # check if char is an uppercase letter\n        if 65 <= ascii_value <= 90:\n            # increment char by 2*2 which is equivalent to rotation of 2 places\n            encrypted += chr((ascii_value - 65 + 2*2) % 26 + 65)\n        # check if char is a lowercase letter\n        elif 97 <= ascii_value <= 122:\n            # increment char by 2*2 which is equivalent to rotation of 2 places\n            encrypted += chr((ascii_value - 97 + 2*2) % 26 + 97)\n        else:\n            # if char is not a letter, append it as is\n            encrypted += char\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"This function takes in a string 's' and returns a new string \n       by shifting the alphabet down by 2 positions and multiplying \n       by 2 places. For the lowercase alphabet it follows that 'a' \n       becomes 'c' and 'b' becomes 'd'. For 'w' and 'x' it shifts 'y' \n       and 'z', respectively. Similarly, 'A' becomes 'C' and 'B' becomes \n       'D'. For 'W' and 'X', it shifts 'Y' and 'Z', respectively.\"\"\"\n\n    result = \"\"\n    for letter in s:\n        if 'a' <= letter <= 'z':\n            letter = chr(((ord(letter) - ord('a') + 2 * 2) % 26) + ord('a'))\n        elif 'A' <= letter <= 'Z':\n            letter = chr(((ord(letter) - ord('A') + 2 * 2) % 26) + ord('A'))\n        result += letter\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            offset = 2 * 2 if char.islower() else -(2 * 2)\n            encrypted_char = chr(((ord(char) - (ord('a' if char.islower() else 'A')) + offset) % 26) + (ord('a' if char.islower() else 'A')))\n            result += encrypted_char\n        else:\n            result += char\n    return result", "matching_cluster_idx": 0}]}, "HumanEval/90": {"dps": 81.67315175097276, "dps_norm": 56.25, "pass@1": 54.0, "profiled": [{"solution": "def next_smallest(lst):\n    if len(lst) < 2:  # If list has less than 2 elements, return None\n        return None\n    else:  # Remove duplicate elements if any and sort the list\n        lst = list(set(lst))\n        lst.sort()\n        if len(lst) < 2:  # If list has less than 2 unique elements, return None\n            return None\n        else:  # Return the second smallest element\n            return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    first = second = float('inf')\n    for num in lst:\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n            \n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    unique_lst = list(set(lst))  # remove duplicates\n    unique_lst.sort()\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # Filter out duplicates and sort the list\n    sorted_lst = sorted(list(set(lst)))\n    \n    # Return the second element if exists, otherwise return None\n    return sorted_lst[1] if len(sorted_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    unique_lst = list(set(lst))  # Remove duplicates if any\n    unique_lst.sort()  # Sort the list in ascending order\n    if len(unique_lst) < 2:  # If less than two elements are present, return None\n        return None\n    else:\n        return unique_lst[1]  # Return the second smallest element, index is 1 as lists are 0-indexed", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    unique_lst = list(set(lst))\n    unique_lst.sort()\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst = list(set(lst))\n    lst.sort()\n    return lst[1] if len(lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    # remove duplicates\n    lst = list(set(lst))\n\n    # return None if there's less than 2 distinct elements\n    if len(lst) < 2:\n        return None\n\n    # sort the list and return the 2nd element\n    return sorted(lst)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    else:\n        # Remove duplicates if any\n        lst = list(set(lst))\n        \n        if len(lst) < 2:\n            return None\n        else:\n            # Sort list and return 2nd smallest element\n            lst.sort()\n            return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates from the list.\n    lst = list(set(lst))\n    \n    # If list is empty or has only 1 element, return None.\n    if len(lst) < 2:\n        return None\n\n    # Sort the list and return 2nd element (index 1) as it is the 2nd smallest element.\n    return sorted(lst)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    \n    unique_lst = list(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    else:\n        unique_lst.sort()\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of a list, or None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) \n    next_smallest([5, 1, 4, 3, 2]) \n    next_smallest([]) \n    next_smallest([1, 1]) \n    \"\"\"\n\n    # Remove duplicates from the list\n    lst = list(set(lst))\n\n    # If there are less than 2 distinct elements in the list, return None\n    if len(lst) < 2:\n        return None\n\n    # Sort the list and return the 2nd element (0-indexed)\n    else:\n        lst.sort()\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    min_val = min(lst)\n    min_val_second = None\n    for num in lst:\n        if num > min_val and (min_val_second is None or num < min_val_second):\n            min_val_second = num\n\n    return min_val_second", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    This function finds the second smallest element in the list.\n    \"\"\"\n    # Removing duplicates and sorting the list\n    lst = sorted(list(set(lst)))\n    \n    # Checking if the list has a second smallest number\n    if len(lst) < 2:\n        return None\n    else:\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst = list(set(lst))  # Remove duplicates\n    lst.sort()  # Sort the list\n    if len(lst) < 2:  # If there are less than 2 distinct elements\n        return None\n    else:  # Return the 2nd smallest element\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    lst = list(set(lst)) # remove duplicates\n    if len(lst) < 2:\n        return None\n    else:\n        lst.sort()\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    \"\"\"\n    unique_lst = list(set(lst)) # Remove duplicate elements\n    if len(unique_lst) < 2: # If there are fewer than two distinct elements in the list, return None\n        return None\n    else:\n        unique_lst.sort() # Sort the list in ascending order\n        return unique_lst[1] # Return the 2nd smallest element in the list", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # Removing duplicate elements if any\n    lst = list(set(lst))\n\n    # If the list only has one unique element, return None\n    if len(lst) < 2:\n        return None\n\n    # Sorting the list and returning the second smallest element\n    else:\n        lst.sort()\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n\n    # Remove duplicates\n    lst = list(set(lst))\n    \n    # Check if there is only one element in the list or no elements at all\n    if len(lst) < 2:\n        return None\n    \n    # Sort the list and return the 2nd smallest element\n    lst.sort()\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    lst = list(set(lst))\n    lst.sort()\n    if len(lst) >= 2:\n        return lst[1]\n    else:\n        return None", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 94.32048681541582, "dps_norm": 64.16666666666667, "pass@1": 50.0, "profiled": [{"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for s in lst:\n        odd_count = sum(int(c) % 2 for c in s)\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i, string in enumerate(lst):\n        count = sum(int(digit) % 2 for digit in string)\n        result = f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.'\n        output.append(result)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        count = sum([int(d) % 2 == 1 for d in s])\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for string in lst:\n        count = sum(1 for c in string if int(c) % 2 != 0)\n        result.append(f'the number of odd elements {count}n the str{count}ng {count} of the {count}nput.')\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i in range(len(lst)):\n        count = sum([int(x) % 2 for x in lst[i]])\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i, s in enumerate(lst, start=1):\n        odd_count = sum(int(c) % 2 for c in s)\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    res = []\n    for i in lst:\n        num_odds = sum(1 for char in i if int(char) % 2 == 1)\n        res.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(num_odds, num_odds, num_odds, num_odds))\n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(int(digit) % 2 != 0 for digit in s)\n        result.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum([1 for d in s if int(d) % 2 != 0])\n\n    return [f\"the number of odd elements {count_odds(s)}n the str{count_odds(s)}ng {count_odds(s)} of the {count_odds(s)}nput.\" for s in lst]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    output = []\n    for string in lst:\n        count = sum(1 for digit in string if int(digit) % 2 != 0)\n        new_string = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        output.append(new_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i in range(len(lst)):\n        odd_count = sum(int(digit) % 2 for digit in lst[i])\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i in range(len(lst)):\n        odd_count = len([digit for digit in lst[i] if int(digit) % 2 != 0])\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        odd_count = sum(int(d) % 2 for d in s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        num_odd_digits = sum(1 for digit in lst[i] if int(digit) % 2 == 1)\n        result.append(\"the number of odd elements \" + str(num_odd_digits) +\n                      \"n the str\" + str(num_odd_digits) + \"ng \" +\n                      str(num_odd_digits) + \" of the \" + str(num_odd_digits) + \"nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    results = []\n    for string in lst:\n        odd_digits_count = len([digit for digit in string if int(digit) % 2 != 0])\n        results.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    return results", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    results = []\n    for i, string in enumerate(lst):\n        odd_digits = sum(int(digit) % 2 for digit in string)\n        result_str = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        results.append(result_str)\n    return results", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i in range(len(lst)):\n        count = len([n for n in lst[i] if int(n) % 2 != 0])\n        output.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count))\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(int(c) % 2 == 1 for c in s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for string in lst:\n        count = sum(1 for char in string if int(char) % 2 != 0)\n        result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count))\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": null, "dps_norm": null, "pass@1": 3.0, "profiled": []}, "HumanEval/120": {"dps": null, "dps_norm": null, "pass@1": 6.0, "profiled": []}, "HumanEval/121": {"dps": 85.51569506726457, "dps_norm": 65.0, "pass@1": 98.0, "profiled": [{"solution": "def solution(lst):\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(i for i in lst[::2] if i % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum([lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0])", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, \n    return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(n for i, n in enumerate(lst) if i % 2 == 0 and n % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(n for i, n in enumerate(lst) if i % 2 == 0 and n % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    # Initialize sum at zero\n    sum = 0\n    # Iterate over the list\n    for i in range(len(lst)):\n        # Check if the current element is in an even index and is odd\n        if i%2==0 and lst[i]%2==1:\n            # Add it to the sum\n            sum += lst[i]\n    # Return the final sum\n    return sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    \n    sum_odd_even_pos = 0\n    for i in range(0, len(lst), 2):  # iterate over even positions\n        if lst[i] % 2 != 0:  # if odd\n            sum_odd_even_pos += lst[i]\n    return sum_odd_even_pos", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \"\"\"\n\n    # Ensure the list is not empty\n    if len(lst) == 0:\n        return 0\n\n    # Initialise the sum\n    even_pos_odd_sum = 0\n\n    # Iterate over the elements in the list\n    for i in range(len(lst)):\n        # Check if the element is at an even position and odd\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            # Add the element to the sum\n            even_pos_odd_sum += lst[i]\n\n    # Return the sum\n    return even_pos_odd_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(i for i in lst[::2] if i % 2 != 0)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 != 0)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 89.3700787401575, "dps_norm": 67.85714285714286, "pass@1": 92.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    # Filter list to delete strings with odd lengths\n    lst = [x for x in lst if len(x) % 2 == 0]\n    \n    # Return list sorted by length and then alphabetically\n    return sorted(sorted(lst), key=len)", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes the strings with odd lengths,\n    sorts the remaining strings in a way that their length is always the same.\n    \"\"\"\n    # filter out odd-length strings\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # sort by length, and then alphabetically\n    return sorted(sorted(lst), key=len)", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    # Delete strings with odd lengths\n    lst = [string for string in lst if len(string) % 2 == 0]\n    \n    # Sort by length then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings that have odd lengths from the list\n    lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length of each word, and then alphabetically\n    lst.sort(key=lambda word: (len(word), word))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # sorting by length and then alphabetical order\n    lst = sorted(lst, key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    \n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # create a new list with even length strings\n    even_length_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # sort the list of strings by length, then by alphabet\n    sorted_lst = sorted(even_length_lst, key=lambda s: (len(s), s))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [x for x in lst if len(x) % 2 == 0]\n\n    # Sort the list first by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filtering the strings with odd length\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    # Sorting the list first by length, then alphabetically\n    sorted_lst = sorted(sorted(filtered_lst), key=len)\n    return sorted_lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    even_length_lst = [word for word in lst if len(word) % 2 == 0]\n    sorted_lst = sorted(even_length_lst, key=lambda word: (len(word), word))\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sort the list based on length and alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n\n    # Filter out words with odd length\n    lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort by length of each word, then alphabetically\n    lst.sort(key=lambda word: (len(word), word))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter list of strings based on even length\n    lst = [x for x in lst if len(x) % 2 == 0]\n    \n    # Sort the list of strings first by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # filter out strings with odd length\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    # sort the list first by length, then alphabetically\n    sorted_lst = sorted(sorted(filtered_lst), key=len)\n    return sorted_lst", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    lst = [i for i in lst if len(i) % 2 == 0]\n    return sorted(sorted(lst), key=len)", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function filters the list to remove strings of odd length, and then sorts the remaining strings.\n    It compares the lengths of strings, and in case of a tie, sorts by alphabetical order.\n    \"\"\"\n    #filter list to remove strings of odd length\n    lst = [x for x in lst if len(x)%2==0]\n    \n    #sort the list\n    lst.sort(key=lambda x: (len(x),x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Deleting strings with odd lengths\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sorting list\n    lst = sorted(lst, key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter the list to only include strings of even length\n    lst = [x for x in lst if len(x) % 2 == 0]\n\n    # If the list is not empty, sort the list by length of each word,\n    # and alphabetically within same length words\n    if lst:\n        lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings of odd length\n    lst = [x for x in lst if len(x) % 2 == 0]\n    \n    # Sort the list first by length of string and then alphabetically\n    lst = sorted(lst, key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Remove the strings of odd length\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Return the list sorted by length and then alphabetically\n    return sorted(lst, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Remove strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort the list based on length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 65.97457627118644, "dps_norm": 74.375, "pass@1": 91.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    This function takes an integer and checks whether it is a prime number or not.\n    It returns False if the number is prime and True if it is not.\n\n    Args:\n    n (int): an integer to be checked\n\n    Returns:\n    bool: Returns True if n is not prime, else False.\n\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n == 1:\n        return True\n    elif n == 2:\n        return False\n    else:\n        for i in range(2, n):\n            if (n % i) == 0:\n                return True\n        return False", "matching_cluster_idx": 0}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, n):\n        if (n % i) == 0:\n            return True\n    return False", "matching_cluster_idx": 1}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, n):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 1}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks whether the input number n is a non-prime number.\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n%2 == 0 or n%3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n%i == 0 or n%(i+2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    if num < 2:\n        return True\n    for i in range(2, num):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 1}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5)+1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if the number is not a prime number, False otherwise.\"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n%2 == 0 or n%3 == 0:\n        return True\n    i = 5\n    while i*i <= n:\n        if n%i == 0 or n%(i+2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True  # Numbers less than 2 are not primes by definition\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # The number is not a prime if it's divisible by any number up to its square root\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks if the given number n is a non-prime number\n    \"\"\"\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2):\n        return True\n    else:\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return True\n        return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 88.05460750853243, "dps_norm": 83.33333333333333, "pass@1": 80.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(lst, n):\n    heap = lst[:n]\n    import heapq\n    heapq.heapify(heap)\n    \n    for val in lst[n:]:\n        if val > heap[0]:\n            heapq.heapreplace(heap, val)\n    \n    return sorted(heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(num_list, n):\n    \"\"\"\n    This function takes a list of numbers and an integer 'n' as input and \n    returns the 'n' largest numbers from the list in descending order.\n    \"\"\"\n\n    # Using heapq library to create a max heap\n    max_heap = []\n    \n    # Insert each number into max_heap\n    for num in num_list:\n        heapq.heappush(max_heap, -num)\n\n    # Pop out 'n' largest numbers from max_heap\n    result = [heapq.heappop(max_heap) * -1 for _ in range(n)]\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Function to find the n largest integers from a given list of numbers, \n    returned in descending order.\n    \"\"\"\n    # Using the heapq module\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    heap = numbers[:n]\n    heapq.heapify(heap)\n    for number in numbers[n:]:\n        if number > heap[0]:\n            heapq.heapreplace(heap, number)\n    heap.sort(reverse=True)\n    return heap", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(lst, n):\n    import heapq\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        return []\n    else:\n        numbers.sort(reverse=True)\n        return numbers[:n]", "matching_cluster_idx": 11}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(num_list, n):\n    \"\"\"\n    Return n largest integers from a given list of numbers in descending order.\n    \"\"\"\n    largest = heapq.nlargest(n, num_list)\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n): \n    \"\"\"\n    This function takes as input a list of numbers and an integer n. \n    The function returns a list containing the n largest integers from the given list. \n    \"\"\"\n    # Use the heapq library to create a max heap\n    max_heap = [-x for x in lst]\n    heapq.heapify(max_heap)\n\n    # Pop the n largest elements from the max heap\n    n_largest = [heapq.heappop(max_heap) for _ in range(n)]\n\n    # Convert back to positive integers (heapq pops negative values) and return the list in reverse order\n    return sorted([-x for x in n_largest], reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        print(\"Cannot find more than the total numbers in the list!\")\n        return None\n    else:\n        # Use Python's built-in heapq library\n        n_largest = heapq.nlargest(n, numbers)\n        # Return in descending order\n        return sorted(n_largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(num_list, n):\n    if n > len(num_list) or n <= 0:\n        raise ValueError('n should be between 1 and len(num_list)')\n    largest_nums = heapq.nlargest(n, num_list)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    # Using Python's inbuilt heapq module to get the n largest elements\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(num_list, n):\n    return sorted(heapq.nlargest(n, num_list), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    This function takes in a list of numbers and a positive integer n. \n    It returns a list of the 'n' largest integers in the list, in descending order.\n    \"\"\"\n    # Use the nlargest function from heapq to find the n largest numbers.\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapify to turn list into a heap, in-place, in O(len(list)) time.\n    heapq.heapify(nums)\n    # Use nlargest to get the n largest numbers in a list.\n    # The function itself is a wrapper around the more generic function, nlargest() and can handle larger input lists.\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use a heap to get the n largest numbers in descending order\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Using heapify to convert list into heap\n    heapq.heapify(nums)\n    # Iterate n times\n    for i in range(len(nums) - n):\n        # Remove smallest (topmost element)\n        heapq.heappop(nums)\n    # Use nlargest to get top n elements\n    result = heapq.nlargest(n, nums)\n    return result", "matching_cluster_idx": 8}]}, "Mbpp/9": {"dps": 73.80952380952381, "dps_norm": 55.0, "pass@1": 16.0, "profiled": [{"solution": "def find_Rotations(string):\n    \"\"\"Function to find minimum number of rotations required\"\"\"\n    # store the length of the string\n    length = len(string)\n    # append the string with itself, and then slice off the first\n    # and last elements, storing the rest in new_string. Repeat\n    # this process by incrementing the index i\n    for i in range(1, length):\n        new_string = string[i:length] + string[0:i]\n        if new_string == string:\n            return i\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string):\n    length = len(string)\n    temp = string + string\n    for i in range(1, length):\n        if temp[i:i+length] == string:\n            return i\n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str1):\n    rotations = 1\n    len_str = len(str1)\n    temp = str1 + str1\n    for i in range(1, len_str):\n        if temp[i:i + len_str] == str1:\n            return rotations\n        rotations += 1\n    return rotations", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1,n):\n        # generate all rotations of the string\n        temp = s[i:]+s[:i]\n        # If we find a duplicate rotation, then return 'i'\n        if s==temp:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1):\n    str2 = str1 + str1\n    n = len(str1)\n    for i in range(1, n):\n        substring = str2[i:i+n]\n        if substring == str1:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str1):\n    str1 += str1\n    n = len(str1)\n    for i in range(1, n//2):\n        if str1[i:n] + str1[0:i] == str1:\n            return i\n    return n//2", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string):\n    size = len(string)\n    temp = string + string\n    for i in range(1, size):\n        if temp[i: i + size] == string:\n            return i\n    return size", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(input_string):\n    if len(input_string) == 1:\n        return 0\n    else:\n        for i in range(1, len(input_string)):\n            if input_string == input_string[i:] + input_string[:i]:\n                return i\n        return len(input_string)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string):\n    length = len(string)\n    if length == 0:\n        return 0\n    for i in range(1, length):\n        # Take substring of string from i to length-1 and add to front\n        # if it matches with original string\n        temp = string[i:] + string[0:i]\n        if string == temp:\n            return i\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string):\n    double_string = string + string\n    length = len(string)\n    for i in range(1, length):\n        if double_string[i:i+length] == string:\n            return i\n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    length = len(s)\n    temp = s + s\n    for i in range(1, length):\n        if temp[i:i + length] == s:\n            return i\n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # The function will look for the minimum number of rotations required to get the same string.\n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1):\n    str1 = str1.lower()\n    len_str1 = len(str1)\n    \n    # Finding the rotation length\n    for i in range(1, len_str1):\n        if str1[i:] + str1[:i] == str1:\n            return i\n            \n    return len_str1", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    if len(s) == 1:\n        return 0\n    for i in range(1, len(s)):\n        if s[i:] + s[:i] == s:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    s2 = s + s\n    for i in range(1, len(s)):\n        if s2[i:i+len(s)] == s:\n            return i\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(input_str):\n    size = len(input_str)\n    temp = input_str + input_str  # Concatenating the string to itself\n    for i in range(1, size):\n        substring = temp[i:size+i]\n        if substring == input_str: # Comparing with original string\n            return i\n    return size", "matching_cluster_idx": 5}]}, "Mbpp/11": {"dps": 82.00716845878136, "dps_norm": 90.0, "pass@1": 47.0, "profiled": [{"solution": "def remove_Occ(string, char):\n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n    if first_occurrence != -1:  # char found in string\n        string = string[:first_occurrence] + string[first_occurrence+1:]  # remove first occurrence\n        if last_occurrence != first_occurrence:  # ensure not already removed\n            string = string[:last_occurrence-1] + string[last_occurrence:]  # remove last occurrence\n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    # Finding the first and last occurrence of character \n    first_index = s.find(c)\n    last_index = s.rfind(c)\n\n    # If character is found in the string\n    if first_index != -1 and last_index != -1:\n        return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n    else:\n        # If character is not found in the string\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    first_char = s.find(char)\n    if first_char != -1:  # if character is in the string\n        last_char = s.rfind(char)\n        # if first and last occurrence of character are same, remove only one occurrence\n        if first_char == last_char:\n            return s[:first_char] + s[first_char+1:]\n        # if they're not same, remove first and last occurrence\n        else:\n            return s[:first_char] + s[first_char+1:last_char] + s[last_char+1:]\n    else:  # if character is not in the string\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if char in string:\n        # Find the first and last occurrence of the character\n        first_index = string.index(char)\n        last_index = string.rindex(char)\n        \n        # Remove the first and last occurrence from the string\n        new_string = string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]\n        \n        return new_string\n    else:\n        # The character doesn't exist in the string, return the original string\n        return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str, char):\n    # Find first and last occurrence of the character\n    first_index = str.find(char)\n    last_index = str.rfind(char)\n\n    # If the character is not in the string\n    if first_index == -1:\n        return str\n\n    # Remove the first and last occurrence of the character\n    result = str[:first_index] + str[first_index + 1:last_index] + str[last_index + 1:]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, character):\n    first_index = string.find(character)\n    last_index = string.rfind(character)\n    \n    if first_index != -1 and last_index != -1 and first_index != last_index:\n        string = string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]\n    elif first_index != -1:\n        string = string[:first_index] + string[first_index+1:]\n    elif last_index != -1:\n        string = string[:last_index] + string[last_index+1:]\n    \n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Remove the first and last occurrence of character c in string s.\n    \"\"\"\n    # Find first occurrence of c\n    first = s.find(c)\n    # If c not in s\n    if first == -1:\n        return s\n    # Find last occurrence of c\n    last = s.rfind(c)\n    # If c is at position 0, then remove the first occurrence,\n    # else remove both the first and last occurrences\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n\n    if first_occ != -1 and last_occ != -1 and first_occ != last_occ:\n        s = s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]\n    elif first_occ != -1 and last_occ != -1 and first_occ == last_occ:\n        s = s[:first_occ] + s[first_occ+1:]\n\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    first_occurrence = input_string.find(char)\n    if first_occurrence != -1:\n        last_occurrence = input_string.rfind(char)\n        if last_occurrence == first_occurrence:\n            return input_string[:first_occurrence] + input_string[first_occurrence + 1:]\n        else:\n            return input_string[:first_occurrence] + input_string[first_occurrence + 1:last_occurrence] + input_string[last_occurrence + 1:]\n    else:\n        return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    if char in input_string:\n        first_occ = input_string.index(char)\n        last_occ = input_string.rindex(char)\n        if first_occ == last_occ:\n            return input_string[:first_occ] + input_string[first_occ+1:]\n        else:\n            return input_string[:first_occ] + input_string[first_occ+1:last_occ] + input_string[last_occ+1:]\n    else:\n        return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Check if character exists in the string\n    if char in s:\n        # Find the index of first and last occurrence\n        first_index = s.index(char)\n        last_index = s.rindex(char)\n        # Remove first and last occurrence\n        s = s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, char):\n    first_index = input_str.find(char)\n    last_index = input_str.rfind(char)\n    \n    if first_index == -1 or last_index == -1:\n        return input_str\n    elif first_index == last_index:\n        return input_str[:first_index] + input_str[first_index + 1:]\n    else:\n        return input_str[:first_index] + input_str[first_index + 1:last_index] + input_str[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Remove the first occurrence of the character\n    string = string.replace(char, '', 1)\n    # Reverse the string\n    string = string[::-1]\n    # Remove the first occurrence of the character\n    string = string.replace(char, '', 1)\n    # Reverse the string back to its original form\n    string = string[::-1]\n    return string", "matching_cluster_idx": 3}, {"solution": "def remove_Occ(input_str, char):\n    # Remove first occurrence of the character\n    input_str = input_str.replace(char, '', 1)\n    # Remove last occurrence of the character\n    reverse_str = input_str[::-1]\n    input_str = reverse_str.replace(char, '', 1)\n    input_str = input_str[::-1]\n    return input_str", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, char):\n    try:\n        index_first = s.index(char)\n        index_last = s.rindex(char)\n        return s[:index_first] + s[index_first+1:index_last] + s[index_last+1:]\n    except ValueError:\n        print(\"Character not found in string.\")\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1, ch):\n    if ch in str1:\n        first_occurrence = str1.find(ch)\n        last_occurrence = str1.rfind(ch)\n        str1 = str1[:first_occurrence] + str1[first_occurrence+1:last_occurrence] + str1[last_occurrence+1:]\n    return str1", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    index = -1\n    for i in range(len(s)):\n        if s[i] == c:\n            index = i\n            break\n    if index != -1:\n        s = s[0:index] + s[index+1:]\n    index = -1\n    for i in range(len(s)):\n        if s[i] == c:\n            index = i\n    if index != -1:\n        s = s[0:index] + s[index+1:]\n    return s", "matching_cluster_idx": 0}, {"solution": "def remove_Occ(string, char):\n    while char in string:\n        first_index = string.index(char)\n        last_index = string.rindex(char)\n        if first_index == last_index:\n            return string[:first_index] + string[first_index + 1:]\n        else:\n            return string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]\n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    first = string.find(char)\n    if first != -1:\n        last = string.rfind(char)\n        if first != last:\n            return string[:first] + string[first+1:last] + string[last+1:]\n        else:\n            return string[:first] + string[first+1:]\n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    # Find the index of the first occurrence of the character\n    index_first = s.find(c)\n    # If the character exists in the string\n    if index_first != -1:\n        # Find the index of the last occurrence of the character\n        index_last = s.rfind(c)\n        # Remove the first occurrence of the character and the last occurrence if they are different\n        if index_first != index_last:\n            return s[:index_first] + s[index_first+1:index_last] + s[index_last+1:]\n        # If they are the same (only one occurrence), return the string without the first occurrence\n        else:\n            return s[:index_first] + s[index_first+1:]\n    # If the character does not exist in the string, return the original string\n    else:\n        return s", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 94.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row in the matrix\n    sums = [sum(row) for row in matrix]\n    # Sort the matrix according to the sums\n    sorted_matrix = [row for (_, row) in sorted(zip(sums, matrix))]\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix in-place based on the sum of its rows.\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # calculate the sum for each row and store it along with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # sort the row_sums by the sum and keep the row index\n    sorted_row_sums = sorted(row_sums)\n    sorted_rows = [matrix[i] for _, i in sorted_row_sums]\n    return sorted_rows", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return [row for row in sorted(matrix, key=sum)]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    This function sorts a given matrix in ascending order based on the sum of its rows.\n    \"\"\"\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # return sorted matrix based on row sums\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix rows by their sum\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Returns a sorted version of the provided matrix based on the sum of its rows.\n    \n    :param matrix: The matrix to be sorted.\n    :return: A sorted version of the provided matrix.\n    \"\"\"\n    # Sort the matrix by row sums\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sum_rows(matrix):\n    return [sum(row) for row in matrix]\ndef sort_matrix(matrix):\n    rows_sum = sum_rows(matrix)\n    sorted_indices = sorted(range(len(rows_sum)), key=lambda i: rows_sum[i])\n    return [matrix[i] for i in sorted_indices]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum for each row in the matrix\n    row_sums = [sum(row) for row in matrix]\n\n    # Create a list of tuples, where each tuple contains an index and the corresponding row sum\n    rows_and_sums = list(enumerate(row_sums))\n\n    # Sort the list of tuples based on the row sum\n    sorted_rows_and_sums = sorted(rows_and_sums, key=lambda x: x[1])\n\n    # Extract the original row from the matrix using the sorted indices\n    sorted_matrix = [matrix[i] for i, _ in sorted_rows_and_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Here we use the key parameter of the sorted function to sort by the sum of rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return [row for row in sorted(matrix, key=sum)]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # calculate the sum for each row in the matrix\n    sums = [sum(row) for row in matrix]\n    # sort the matrix based on the calculated sums\n    result = [x for _, x in sorted(zip(sums, matrix))]\n    return result", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return [row for row in sorted(matrix, key=sum)]", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 71.64634146341464, "dps_norm": 80.0, "pass@1": 32.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    if pattern.match(s):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(input_string):\n    # Split the string by underscore and check each part\n    for word in input_string.split('_'):\n        if not word.islower():  # if any part is not lowercase\n            return False\n    return True  # if all parts are lowercase", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(text):\n    parts = text.split(\"_\")\n    for part in parts:\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    if re.match(pattern, text):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text):\n    parts = text.split('_')\n    for part in parts:\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match lowercase letters joined with underscores\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    # Using match function with the pattern and input_string\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text):\n    # Split text into separate words\n    words = text.split('_')\n\n    # Check each word to ensure it contains only lowercase letters\n    for word in words:\n        if not word.islower():\n            return False\n    \n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(input_string):\n    # Split string by underscore and check if each part is lowercase\n    parts = input_string.split('_')\n    for part in parts:\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(text):\n    parts = text.split('_')\n    for part in parts:\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    if not s:\n        return False\n    for word in s.split('_'):\n        if not word.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function returns True if the input string contains sequences of lowercase \n    letters joined with an underscore and False otherwise.\n    \"\"\"\n    # Using regular expression to check if the string contains the pattern of lowercase letters joined with an underscore\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    if pattern.match(text):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    return bool(re.fullmatch('[a-z]+(_[a-z]+)*', s))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text):\n    if not text: # For the case when the text is empty\n        return False\n    words = text.split('_')\n    for word in words:\n        if not word.islower(): # If any word is not in lowercase\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(text):\n    # split the text into words\n    words = text.split(\"_\")\n    \n    # check if each word is only lowercase and consists of letters\n    for word in words:\n        if not word.islower() or not word.isalpha():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(text):\n    for word in text.split(\"_\"):\n        if not word.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    import re\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    if re.match(pattern, s):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    s = s.split('_')\n    return all(x.islower() and x.isalpha() for x in s)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(text):\n    # Split the text into words using underscore as separator\n    words = text.split('_')\n    # For each word, check if it's a lowercase string\n    return all(word.islower() for word in words)", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(string):\n    # Using Regular Expression to check if string contains lowercase letters joined with an underscore\n    if re.search(r'^[a-z]+(_[a-z]+)*$', string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    if re.search(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}]}, "Mbpp/19": {"dps": 66.41414141414141, "dps_norm": 81.0, "pass@1": 94.0, "profiled": [{"solution": "def test_duplicate(input_array):\n    # Convert list to set to check if duplicate exist (Set only allows unique elements)\n    if len(input_array) == len(set(input_array)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(input_list):\n    \"\"\"Check if the list has any duplicate elements\"\"\"\n    if len(input_list) == len(set(input_list)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    # Check if there are any duplicates in a list of integers\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    return len(lst) != len(set(lst))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    # The below line creates a set from the list and then checks if length of list and set are equal\n    return len(lst) != len(set(lst))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    This function takes a list of integers as input and checks if it contains any duplicate element.\n    \"\"\"\n    # Using a set to check for duplicates in list\n    if len(array) == len(set(array)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(set(arr)) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # using set to check for duplicates, as sets don't allow duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(numbers):\n    seen = set()\n    for number in numbers:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(lst):\n    return len(lst) != len(set(lst))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 98.5, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    # Initialize the first element as smallest\n    smallest = lst[0]\n    \n    # Iterate over the list\n    for num in lst:\n        # If the current number is less than the smallest found so far, then update the smallest\n        if num < smallest:\n            smallest = num\n    \n    # Return the smallest number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Write a python function to find smallest number in a list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    \"\"\"\n    This function accepts a list of numbers as an argument\n    and returns the smallest number in the list.\n    \"\"\"\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function returns the smallest number in a list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Function to find smallest number in a list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function receives a list of numbers and returns the smallest number.\n    Parameters:\n        lst (list): A list of numbers.\n    Returns:\n        The smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Return minimum number in list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function finds the smallest number in a list\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    \"\"\"Function to find the smallest number in a list\"\"\"\n    return min(num_list)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples, k):\n    result = []\n    for tup in tuples:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(i % k == 0 for i in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    return [t for t in list_of_tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"Find tuples with all elements divisible by k\"\"\"\n    result = [tpl for tpl in lst if all(x % k == 0 for x in tpl)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tup_list, k):\n    return [tup for tup in tup_list if all(i % k == 0 for i in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tup_list, k):\n    res = []\n    for tup in tup_list:\n        if all(i % k == 0 for i in tup):\n            res.append(tup)\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tup_list, k):\n    result = []\n    for t in tup_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = [t for t in tuples_list if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    return [t for t in tuple_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = [t for t in tuples_list if all(elem % k == 0 for elem in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(el % k == 0 for el in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = [t for t in lst if all(i % k == 0 for i in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    return [t for t in tuple_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    result = [tup for tup in tuple_list if all(elem % k == 0 for elem in tup)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = []\n    for tup in lst:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 84.50980392156862, "dps_norm": 77.85714285714285, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    freqs = {}\n    for i in lst:\n        if i in freqs:\n            freqs[i] += 1\n        else:\n            freqs[i] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    count_dict = {}\n    for i in lst:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in lst}", "matching_cluster_idx": 0}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in lst}", "matching_cluster_idx": 0}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for num in lst:\n        if num in freqs:\n            freqs[num] += 1\n        else:\n            freqs[num] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for num in lst:\n        if num in freqs:\n            freqs[num] += 1\n        else:\n            freqs[num] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary\n    frequency_dict = {}\n    \n    # Iterate over the list\n    for item in lst:\n        # If the item is in the dictionary, increment its count.\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1.\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for item in lst:\n        if item in freqs:\n            freqs[item] += 1\n        else:\n            freqs[item] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        freq_dict[i] = freq_dict.get(i, 0) + 1\n    return freq_dict", "matching_cluster_idx": 4}, {"solution": "def freq_count(input_list):\n    frequency_dict = {}\n    for i in input_list:\n        if (i in frequency_dict):\n            frequency_dict[i] += 1\n        else:\n            frequency_dict[i] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item not in freq:\n            freq[item] = 1\n        else:\n            freq[item] += 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for i in lst:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    return freq", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 72.85365853658537, "dps_norm": 82.85714285714285, "pass@1": 67.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    The function len_log() takes a list of words as input and returns the length of the longest word in the list.\n    \"\"\"\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initializing max_len with 0 to compare against the length of the words\n    max_len = 0\n    for word in words:\n        # If length of word is more than max_len, updating max_len\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # First, we'll iterate over each word in the list\n    for word in words:\n        # For each word, we'll count its length and keep track of the largest\n        word_length = len(word)\n        if 'longest_word_length' not in locals():\n            longest_word_length = word_length\n        elif word_length > longest_word_length:\n            longest_word_length = word_length\n    return longest_word_length", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    \"\"\"\n    This function returns the length of the longest word in a given list of words.\n    \"\"\"\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(list_words):\n    # Initialize max_len with the length of the first word in the list\n    max_len = len(list_words[0])\n\n    # Iterate over the list of words to find the longest word\n    for word in list_words:\n        if len(word) > max_len:\n            max_len = len(word)\n\n    # Return the length of the longest word\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(list):\n    #Initialize a variable to hold the length of the longest word\n    max_len = len(list[0])\n    #Initialize a variable to hold the longest word\n    max_word = list[0]\n\n    #Traverse through the list to find the word with maximum length\n    for i in range(1, len(list)):\n        if max_len < len(list[i]):\n            max_len = len(list[i])\n            max_word = list[i]\n\n    return max_len", "matching_cluster_idx": 4}, {"solution": "def len_log(word_list):\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 82.85060975609755, "dps_norm": 69.0, "pass@1": 94.0, "profiled": [{"solution": "def index_minimum(lst):\n    return min(lst, key=lambda t: t[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"Return the first value of the tuple with the smallest second value.\"\"\"\n    if not tuples:\n        raise ValueError(\"The list of tuples is empty\")\n    min_tuple = min(tuples, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_tuples):\n    if len(list_tuples) == 0:\n        return None\n    # Sort the list of tuples based on the second value of each tuple\n    sorted_list = sorted(list_tuples, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return sorted_list[0][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tup_list):\n    \"\"\"\n    Function to get the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(tup_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Check if list is not empty\n    if len(lst) == 0:\n        return None\n\n    # Initialize min_value to be the second element of the first tuple\n    min_value = lst[0][1]\n\n    # Initialize result to be the first element of the first tuple\n    result = lst[0][0]\n\n    # Iterate through all tuples in the list\n    for i in lst:\n\n        # If a tuple's second element is less than min_value, update min_value and result\n        if i[1] < min_value:\n            min_value = i[1]\n            result = i[0]\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    # Start with the first tuple\n    min_tuple = tuple_list[0]\n    \n    # Iterate through the rest of the list\n    for tuple in tuple_list[1:]:\n        # If the second value of this tuple is smaller than the current minimum,\n        if tuple[1] < min_tuple[1]:\n            # then replace the current minimum tuple with this one\n            min_tuple = tuple\n            \n    # Finally, return the first value of the minimum tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    # If there are no tuples, return None\n    if not tuples:\n        return None\n\n    # Initialize minimum value and index\n    min_val = tuples[0][1]\n    min_index = tuples[0][0]\n\n    # Iterate through the tuples\n    for i in range(1, len(tuples)):\n        # If current tuple's second element is less than minimum, update minimum and index\n        if tuples[i][1] < min_val:\n            min_val = tuples[i][1]\n            min_index = tuples[i][0]\n\n    # Return the first value of the tuple with the smallest second value\n    return min_index", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    if not list_of_tuples:  # edge case: if the list is empty\n        return None\n    # find the tuple with the smallest second value\n    min_tuple = min(list_of_tuples, key=lambda x: x[1])\n    return min_tuple[0]  # return the first value of the tuple", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if len(lst) > 0:\n        return min(lst, key=lambda x: x[1])[0]\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    # Assuming all tuples have a second value (i.e., that there are at least two elements in each tuple)\n    min_val = list_of_tuples[0][1]\n    min_index = list_of_tuples[0][0]\n    for tuple in list_of_tuples:\n        if tuple[1] < min_val:\n            min_val = tuple[1]\n            min_index = tuple[0]\n    return min_index", "matching_cluster_idx": 4}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n\n    :param lst: a list of tuples where each tuple contains a string and a number\n    :type lst: list of tuples\n    :return: the first value in the tuple with the smallest second value\n    :rtype: str\n\n    \"\"\"\n    # Initialize minimum value as the first tuple in the list\n    min_value = lst[0][1]\n    min_tuple = lst[0]\n\n    # Iterate over each tuple in the list\n    for t in lst:\n        # If the current tuple's second element is smaller than the current minimum\n        if t[1] < min_value:\n            # Update minimum value and minimum tuple\n            min_value = t[1]\n            min_tuple = t\n\n    # Return the first element of the minimum tuple\n    return min_tuple[0]", "matching_cluster_idx": 4}, {"solution": "def index_minimum(lst):\n    if len(lst) == 0:\n        return None\n    min_val = lst[0][1]\n    min_index = lst[0][0]\n    for tup in lst:\n        if tup[1] < min_val:\n            min_val = tup[1]\n            min_index = tup[0]\n    return min_index", "matching_cluster_idx": 4}, {"solution": "def index_minimum(lst):\n    if not lst:\n        return None\n    min_val = lst[0]\n    for item in lst:\n        if item[1] < min_val[1]:\n            min_val = item\n    return min_val[0]", "matching_cluster_idx": 3}]}, "Mbpp/96": {"dps": 68.125, "dps_norm": 42.857142857142854, "pass@1": 61.0, "profiled": [{"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    i = 1\n    while i <= n:\n        if n % i == 0:\n            count += 1\n        i += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    divisors = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors += 1\n    return divisors", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize count to 0\n    count = 0\n    for i in range(1, n+1):\n        # Check if current number is a divisor\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize count to 0\n    count = 0\n    # Go from 1 to n+1 (we do +1 to include n itself)\n    for i in range(1, n+1):\n        # Check if remainder is 0 which means i is a divisor\n        if n % i == 0:\n            # Increment the count\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    divisors = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors += 1\n    return divisors", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    i = 1\n\n    while i <= n:\n        if n % i == 0:\n            count += 1\n        i += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def divisor(n):\n    if n < 1:\n        return 0\n    cnt = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                cnt += 1\n            else:\n                cnt += 2\n    return cnt", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    divisors = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors += 1\n    return divisors", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    i = 1\n    while i <= n:\n        if n % i == 0:\n            count += 1\n        i += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 81.38461538461539, "dps_norm": 77.5, "pass@1": 98.0, "profiled": [{"solution": "from typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    \n    # Use dictionary to count the frequency\n    frequency_dict = {i: flat_list.count(i) for i in flat_list}\n    \n    return frequency_dict", "matching_cluster_idx": 1}, {"solution": "def flatten(lists):\n    return [item for sublist in lists for item in sublist]\ndef frequency_lists(list_of_lists):\n    flattened = flatten(list_of_lists)\n    frequency = {}\n    for item in flattened:\n        if item not in frequency:\n            frequency[item] = 1\n        else:\n            frequency[item] += 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def flatten(lst):\n    \"\"\"\n    Function to flatten the list of lists\n    \"\"\"\n    flattened = []\n    for sublist in lst:\n        for item in sublist:\n            flattened.append(item)\n    return flattened\ndef frequency_lists(lst):\n    \"\"\"\n    Function to find frequency of each element in a flattened list\n    \"\"\"\n    flat = flatten(lst)\n    frequency = {}\n    for item in flat:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flatten_list = [item for sublist in lst for item in sublist]\n    return {i: flatten_list.count(i) for i in flatten_list}", "matching_cluster_idx": 1}, {"solution": "from collections import Counter\ndef flatten(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    flattened_list = flatten(lst)\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "def flatten(l):\n    \"\"\"Flatten a list of lists\"\"\"\n    return [item for sublist in l for item in sublist]\ndef frequency_lists(lst):\n    \"\"\"Find frequency of each element in a flattened list of lists\"\"\"\n    flattened_list = flatten(lst)\n    return {i: flattened_list.count(i) for i in flattened_list}", "matching_cluster_idx": 1}, {"solution": "def frequency_lists(input_list):\n    # Flatten the list of lists\n    flat_list = [item for sublist in input_list for item in sublist]\n\n    # Create an empty dictionary to store the frequency of each element\n    freq_dict = {}\n\n    # Count the frequency of each element\n    for item in flat_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def flatten_list(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    flat_lst = flatten_list(lst)\n    freq = {}\n    for num in flat_lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    flattened = [item for sublist in list_of_lists for item in sublist]\n    frequency = {}\n    for num in flattened:\n        if num not in frequency:\n            frequency[num] = 1\n        else:\n            frequency[num] += 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef flatten(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    flattened_list = flatten(lst)\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "def flatten(lst):\n    \"\"\"Flatten a nested list\"\"\"\n    result = []\n    for sublist in lst:\n        if isinstance(sublist, list):\n            result.extend(flatten(sublist))\n        else:\n            result.append(sublist)\n    return result\ndef frequency_lists(lst):\n    \"\"\"Find frequency of each element in a flattened list of lists\"\"\"\n    flattened = flatten(lst)\n    frequency = {}\n    for element in flattened:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def flatten_lists(list_of_lists):\n    return [item for sublist in list_of_lists for item in sublist]\ndef frequency_lists(list_of_lists):\n    flattened_list = flatten_lists(list_of_lists)\n    freq_dict = {}\n    for item in flattened_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def flatten(lst):\n    flattened = [item for sublist in lst for item in sublist]\n    return flattened\ndef frequency_lists(lst):\n    flattened = flatten(lst)\n    frequency_dict = {}\n    for item in flattened:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    \"\"\"Find frequency of each element in a flattened list of lists.\"\"\"\n    frequency_dict = {}\n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def flatten_list(lst):\n    flat_list = []\n    for sublist in lst:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list\ndef frequency_lists(lst):\n    flat_list = flatten_list(lst)\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    flat_list = [item for sublist in lists for item in sublist]\n    frequency_dict = {}\n    \n    for i in flat_list:\n        if i in frequency_dict:\n            frequency_dict[i] += 1\n        else:\n            frequency_dict[i] = 1\n            \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def flatten(lst):\n    \"\"\"Function to flatten a list of lists\"\"\"\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    \"\"\"Function to calculate frequency of each element in a flattened list\"\"\"\n    flat_list = flatten(lst)\n    frequency = {}\n    for item in flat_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def flatten_list(lst):\n    \"\"\"\n    Function that flattens a list of lists.\n    \"\"\"\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst):\n    \"\"\"\n    Function that finds frequency of each element in a list.\n    \"\"\"\n    flattened_list = flatten_list(lst)\n    frequency_dict = {}\n    for i in flattened_list:\n        if i not in frequency_dict:\n            frequency_dict[i] = 1\n        else:\n            frequency_dict[i] += 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def flatten_lists(nested_list):\n    \"\"\"\n    Helper function to flatten a list of lists.\n    \"\"\"\n    return [item for sublist in nested_list for item in sublist]\ndef frequency_lists(nested_list):\n    \"\"\"\n    Function to find the frequency of each element in a flattened list of lists, returned in a dictionary.\n    \"\"\"\n    flat_list = flatten_lists(nested_list)\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 52.72727272727273, "dps_norm": 84.16666666666666, "pass@1": 98.0, "profiled": [{"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append a list to a tuple\n\n    Parameters:\n    lst (list): The list to be appended\n    tpl (tuple): The tuple where list is to be appended\n\n    Returns:\n    tuple: A new tuple with the list appended\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    # This function takes in a list and a tuple as arguments\n    # It returns a new tuple that is the result of appending the list to the tuple\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Use the + operator to concatenate the tuple and list\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Concatenate the list and tuple, then convert back to a tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the given list to the given tuples.\n    \"\"\"\n    # Append the list to the tuple using the tuple concatenation.\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # Convert tuple to list, append list to tuple, and convert back to tuple\n    result = list(tpl) + lst\n    return tuple(result)", "matching_cluster_idx": 2}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    This function appends the given list to the given tuple.\n    \n    Parameters:\n        input_list (list): The list to be added to the tuple.\n        input_tuple (tuple): The tuple to which the list is to be appended.\n    \n    Returns:\n        tuple: A tuple which includes the elements of the input_tuple and input_list.\n    \"\"\"\n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_value, tuple_value):\n    return tuple_value + tuple(list_value)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_, tuples):\n    return tuples + tuple(list_)", "matching_cluster_idx": 5}, {"solution": "def add_lists(my_list, my_tuple):\n    # Convert the tuple to a list, append the provided list, and convert the result back to a tuple\n    return tuple(list(my_tuple) + my_list)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_append, tuples_to_append):\n    if not isinstance(list_to_append, list):\n        raise ValueError(\"First argument should be a list\")\n    if not isinstance(tuples_to_append, tuple):\n        raise ValueError(\"Second argument should be a tuple\")\n    tuples_to_append += tuple(list_to_append)\n    return tuples_to_append", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 96.02409638554217, "dps_norm": 99.54545454545455, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    merged_list = lst1 + lst2 + lst3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*args):\n    result = []\n    for lst in args:\n        result += lst\n    return sorted(result)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    combined_list = list1 + list2 + list3\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*args):\n    result = []\n    for l in args:\n        result.extend(l)\n    result.sort()\n    return result", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*args):\n    # Flatten lists into a single list\n    flattened_list = [item for sublist in args for item in sublist]\n    # Use Python's built-in sorting function to sort the list\n    flattened_list.sort()\n    return flattened_list", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*args):\n    merged_list = []\n    for l in args:\n        merged_list.extend(l)\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*args):\n    merged_list = []\n\n    for list in args:\n        merged_list.extend(list)\n\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merging all three lists into one\n    merged_list = list1 + list2 + list3\n    \n    # Sorting the merged list\n    merged_list.sort()\n    \n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # concatenate the 3 lists\n    merged_list = list1 + list2 + list3\n    # sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # concatenate all lists\n    merged_list = list1 + list2 + list3\n    # sort and return the merged list\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*args):\n    merged_list = []\n    for lst in args:\n        merged_list.extend(lst)\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge lists\n    merged_list = list1 + list2 + list3\n    \n    # Sort the list\n    merged_list.sort()\n    \n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    \"\"\"Merge three sorted lists into a single sorted list.\"\"\"\n    merged_list = lst1 + lst2 + lst3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 83.6923076923077, "dps_norm": 85.0, "pass@1": 95.0, "profiled": [{"solution": "def common_in_nested_lists(lst):\n    return list(set(lst[0]).intersection(*lst))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n    :param nested_lists: A list of lists.\n    :return: A list of common elements.\n    \"\"\"\n    return set(set(nested_lists[0]).intersection(*nested_lists[1:]))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Function to find the common elements in given nested lists\n    :param lists: List of lists\n    :return: List of common elements\n    \"\"\"\n    return list(set(lists[0]).intersection(*lists[1:]))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    common_elements = set(lists[0])\n    for i in range(1, len(lists)):\n        common_elements = common_elements.intersection(lists[i])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    This function takes a list of lists and returns a list of common elements across all the lists\n    \"\"\"\n    return list(set(lists[0]).intersection(*lists[1:]))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    Function to find the common elements in a nested list\n    \"\"\"\n    if not nested_list:  # in case an empty list is passed\n        return []\n    if len(nested_list) == 1:  # in case only 1 list is passed\n        return set(nested_list[0])\n\n    # convert lists to sets to remove duplicates and perform intersection\n    # convert back to list for consistent type\n    common_elements = list(set(nested_list[0]).intersection(*map(set, nested_list[1:])))\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # initialize the common elements to the first list\n    common = set(nested_lists[0])\n    \n    # find the intersection of the common elements and the current list\n    for lst in nested_lists[1:]:\n        common = common.intersection(lst)\n    \n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    common_elements = set(lists[0])\n    for i in lists[1:]:\n        common_elements = common_elements.intersection(set(i))\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    Given a list of lists, the function will find common elements among all sublists.\n    \"\"\"\n    return list(set.intersection(*map(set, nested_list)))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for i in range(1, len(nested_lists)):\n        common_elements = common_elements.intersection(nested_lists[i])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if len(nested_lists) == 0:\n        return []\n    else:\n        common_elements = set(nested_lists[0])\n        for each_list in nested_lists[1:]:\n            common_elements.intersection_update(each_list)\n        return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    return set(nested_list[0]).intersection(*nested_list[1:])", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # convert all lists to sets, then take intersection of set with every other list\n    common = set(lists[0])\n    for lst in lists[1:]:\n        common &= set(lst)\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    if not nested_list:\n        return []\n    common = set(nested_list[0])\n    for sublist in nested_list[1:]:\n        common.intersection_update(sublist)\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    if not all(isinstance(sublist, list) for sublist in lists):\n        raise ValueError(\"All inputs must be lists\")\n    \n    if len(lists) == 0:\n        return []\n    \n    first_set = set(lists[0])\n    \n    for sublist in lists[1:]:\n        first_set.intersection_update(sublist)\n    \n    return list(first_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    return list(set.intersection(*map(set, nested_list)))", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    if len(nested_lists) == 0:\n        return []\n    common = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common = common & set(lst)  # \"&\" operator performs intersection operation\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    return set(lists[0]).intersection(*lists[1:])", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    return set(nested_lists[0]).intersection(*nested_lists[1:])", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # The function uses built-in set and intersection functions.\n    # It gets the intersection of all sets created from nested lists.\n    # At the end, it converts the result back to a list and returns it.\n    return list(set.intersection(*map(set, lists)))", "matching_cluster_idx": 5}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 39.0, "profiled": [{"solution": "def divisor_sum(n):\n    result = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:\n                result += n // i\n    result -= n\n    return result\ndef amicable_numbers_sum(n):\n    total_sum = 0\n    for i in range(1, n + 1):\n        d = divisor_sum(i)\n        if i != d and d <= n and divisor_sum(d) == i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def proper_divisor_sum(n):\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i != i:\n                divisors_sum += i\n                divisors_sum += n / i\n            else:\n                divisors_sum += i\n    return divisors_sum\ndef amicable_numbers_sum(n):\n    amicable_sum = 0\n    for i in range(2, n + 1):\n        m = proper_divisor_sum(i)\n        if i != m and proper_divisor_sum(m) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def divisor_sum(n):\n        i = 1\n        sum = 0\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if i * (n // i) == n:\n                    sum += i + n // i\n                    i += 1\n        return sum - n\n\n    sum = 0\n    for i in range(2, n + 1):\n        s = divisor_sum(i)\n        if s != i and divisor_sum(s) == i:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def proper_divisors(num):\n        div_sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                div_sum += i + num//i\n        return div_sum\n\n    sum = 0\n    for i in range(2, n+1):\n        if proper_divisors(proper_divisors(i)) == i and proper_divisors(i) != i:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    \"\"\"\n    Function to calculate sum of proper divisors\n    \"\"\"\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if n // i == i:\n                sum = sum + i\n            else:\n                sum = sum + i + n // i\n            i += 1\n    return sum\ndef amicable_numbers_sum(n):\n    \"\"\"\n    Function to get sum of amicable numbers from 1 to n\n    \"\"\"\n    total = 0\n    for i in range(1, n+1):\n        j = d(i)\n        if (i != j) and (i == d(j)):\n            total += i\n    return total", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    \"\"\"\n    Function to find proper divisors sum of a number n\n    \"\"\"\n    div_sum = 1\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            if n//i != i:\n                div_sum = div_sum + i + n//i\n            else:\n                div_sum = div_sum + i\n    return div_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Function to find sum of all amicable numbers up to limit\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = d(a)\n        if a != b and d(b) == a:\n            amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    sum_div = 1\n    i = 2\n    while i*i <= n:\n        if n%i:\n            i += 1\n        else:\n            if i*i == n:\n                sum_div += i\n            else:\n                sum_div += i\n                sum_div += n//i\n            i += 1\n    return sum_div\ndef amicable_numbers_sum(n):\n    sum_amicables = 0\n    for i in range(2, n+1):\n        d_i = sum_divisors(i)\n        d_di = sum_divisors(d_i)\n        if i == d_di and i != d_i:\n            sum_amicables += i\n    return sum_amicables", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_divisors(n):\n        sum = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                sum += i\n                if n // i != i:\n                    sum += n // i\n        return sum\n\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n        sum_i = sum_divisors(i)\n        sum_j = sum_divisors(sum_i)\n        if sum_j == i and sum_i != sum_j:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum += i\n            if i*i != n:  # Add complement of i if i^2 != n\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(n):\n    sum_amicable = 0\n    for i in range(1, n):\n        j = d(i)\n        if i != j and i == d(j):\n            sum_amicable += i\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    # function to calculate the sum of proper divisors\n    s = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            s += i\n            if n // i != i:\n                s += n // i\n    return s\ndef amicable_numbers_sum(n):\n    # function to calculate sum of amicable numbers up to n\n    amicable_numbers = set()\n    for i in range(2, n+1):\n        # ignore non-amicable numbers\n        if i not in amicable_numbers:\n            s = sum_of_divisors(i)\n            if s != i and s <= n and sum_of_divisors(s) == i:\n                amicable_numbers.add(i)\n                amicable_numbers.add(s)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    result = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if n == i * i:\n                result += i\n            else:\n                result += i\n                result += n//i\n            i += 1\n    return result\ndef amicable_numbers_sum(n):\n    if n < 2:\n        return 0\n    divisors_sum = [0]*(n+1)\n    for i in range(1, n+1):\n        divisors_sum[i] = sum_of_divisors(i)\n    result = 0\n    for i in range(2, n+1):\n        if i == divisors_sum[i] or divisors_sum[i] > n or divisors_sum[i]==1 or divisors_sum[divisors_sum[i]] != i:\n            continue\n        else:\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    s = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                s += i\n            else:\n                s += i\n                s += n // i\n    return s\ndef amicable_numbers_sum(limit):\n    num_list = [0] * (limit + 1)\n    for i in range(1, limit + 1):\n        num_list[i] = d(i)\n    s = 0\n    for i in range(1, limit + 1):\n        if num_list[i] <= limit and num_list[i] != i:\n            if num_list[num_list[i]] == i:\n                s += i\n    return s", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * i != n:\n                sum = sum + i + n//i\n            else:\n                sum = sum + i\n            i += 1\n    return sum\ndef amicable_numbers_sum(n):\n    sum = 0\n    for i in range(1,n+1):\n        j = d(i)\n        if j != i and d(j)==i:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def divisors(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if n // i == i:\n                sum += i\n            else:\n                sum = sum + i + n//i\n            i += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    s = 0\n    for i in range(2, limit+1):\n        if i == divisors(divisors(i)) and i != divisors(i):\n            s += i\n    return s", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def d(num):\n        divisors_sum = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors_sum += i\n                if num / i != i:\n                    divisors_sum += num // i\n        return divisors_sum\n    amicable_sum = 0\n    for i in range(2, n+1):\n        b = d(i)\n        if i != b and d(b) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * i != n:\n                sum = sum + i + n // i\n            else:\n                sum = sum + i\n            i += 1\n    return sum\ndef amicable_numbers_sum(upper_limit):\n    sum = 0\n    for i in range(2, upper_limit+1):\n        j = sum_of_divisors(i)\n        if (sum_of_divisors(j) == i) and i != j:\n            sum += i\n    return sum", "matching_cluster_idx": 11}, {"solution": "def divisor_sum(n):\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum += i\n            if n // i != i:\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(limit):\n    total_sum = 0\n    for i in range(2, limit+1):\n        a = divisor_sum(i)\n        b = divisor_sum(a)\n        if b == i and a != b:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n/i:\n                sum += i\n            else:\n                sum += i\n                sum += n/i\n    return sum\ndef amicable_numbers_sum(n):\n    amicable_numbers_sum = 0\n    for i in range(1, n+1):\n        j = sum_of_divisors(i)\n        if i != j and j <= n and sum_of_divisors(j) == i:\n            amicable_numbers_sum += i\n    return amicable_numbers_sum", "matching_cluster_idx": 11}, {"solution": "def d(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * i != n:\n                sum = sum + i + n // i\n            else:\n                sum = sum + i\n            i += 1\n    return sum\ndef amicable_numbers_sum(limit):\n    sum = 0\n    for i in range(1, limit + 1):\n        j = d(i)\n        if (j > i) and (d(j) == i):\n            sum += i + j\n    return sum", "matching_cluster_idx": 11}, {"solution": "def d(n):  # Function to calculate the sum of the divisors\n    sum_div = 1\n    for x in range(2, int(n**0.5) + 1):\n        if n % x == 0:\n            sum_div += x\n            if x != n // x:  # Check to avoid duplicate of the square root\n                sum_div += n // x\n    return sum_div\ndef amicable_numbers_sum(n):  # Function to calculate the sum of all amicable numbers\n    sum_amicable = 0\n    for x in range(2, n+1):\n        y = d(x)\n        if x != y and d(y) == x:\n            sum_amicable += x\n    return sum_amicable", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    words = sentence.split()  # split the sentence into words\n    return [word for word in words if len(word) > n]  # return words with length > n", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    word_list = sentence.split()\n    long_words_list = [word for word in word_list if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    This function finds the words in a sentence that are longer than 'n' characters.\n    \"\"\"\n    words = sentence.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    word_list = sentence.split(' ')\n    long_words = [word for word in word_list if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # split sentence into words\n    words = sentence.split(' ')\n    \n    # filter out words that are longer than n characters\n    long_words = [word for word in words if len(word) > n]\n    \n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    word_list = words.split()\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    words = string.split(' ')\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, phrase):\n    words = phrase.split(' ')\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    words = string.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # split the sentence into words\n    words = sentence.split()\n\n    # filter out the words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from a sentence that are longer than n characters.\n    \n    Args:\n    n: The minimum length of words in the returned list.\n    sentence: The sentence to parse for words.\n    \n    Returns:\n    A list of words from the sentence that are longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, phrase):\n    word_list = phrase.split()\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # split the text into words\n    words = text.split()\n    # filter the words longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 63.63520408163266, "dps_norm": 92.33333333333333, "pass@1": 37.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    if len(matrix) != len(matrix[0]):\n        return False\n    \n    # Check sum of row elements\n    for row in matrix:\n        if sum(row) != sum(matrix[0]):\n            return False\n\n    # Check sum of column elements\n    for col_index in range(len(matrix)):\n        if sum([row[col_index] for row in matrix]) != sum(matrix[0]):\n            return False\n\n    # Check sum of diagonals\n    main_diagonal_sum = sum([matrix[i][i] for i in range(len(matrix))])\n    if main_diagonal_sum != sum(matrix[0]):\n        return False\n\n    secondary_diagonal_sum = sum([matrix[i][len(matrix)-1-i] for i in range(len(matrix))])\n    if secondary_diagonal_sum != sum(matrix[0]):\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # check for square matrix\n    if not all(len(row) == len(matrix) for row in matrix):\n        return False\n    \n    # calculate the sum of a row\n    row_sum = sum(matrix[0])\n    \n    # check for magic square\n    for row in matrix:\n        if sum(row) != row_sum:\n            return False\n            \n    # calculate the sum of a column\n    for col in range(len(matrix[0])):\n        col_sum = sum(matrix[i][col] for i in range(len(matrix)))\n        if col_sum != row_sum:\n            return False\n            \n    # check diagonals\n    diag1 = sum(matrix[i][i] for i in range(len(matrix)))\n    diag2 = sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix)))\n    return diag1 == diag2 == row_sum", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # calculate sum of elements in first row as a reference\n    sum_of_first_row = sum(matrix[0])\n    \n    # check the rows sum\n    for row in matrix:\n        if sum(row) != sum_of_first_row:\n            return False\n        \n    # check the columns sum\n    for i in range(len(matrix)):\n        column_sum = sum([row[i] for row in matrix])\n        if column_sum != sum_of_first_row:\n            return False\n        \n    # check the diagonal sum\n    diagonal_sum1 = sum([matrix[i][i] for i in range(len(matrix))])\n    if diagonal_sum1 != sum_of_first_row:\n        return False\n    \n    # check other diagonal sum\n    diagonal_sum2 = sum([matrix[i][len(matrix)-i-1] for i in range(len(matrix))])\n    if diagonal_sum2 != sum_of_first_row:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # first, check if the matrix is square (has the same number of rows and columns)\n    n = len(matrix)\n    if n != len(matrix[0]):\n        return False\n    # next, check if the sums of the rows, columns and diagonals are equal\n    row_sums = [sum(row) for row in matrix]\n    if len(set(row_sums)) > 1:\n        return False\n    col_sums = [sum([matrix[j][i] for j in range(n)]) for i in range(n)]\n    if len(set(col_sums)) > 1:\n        return False\n    diag_sum = sum([matrix[i][i] for i in range(n)])\n    if diag_sum != row_sums[0]:\n        return False\n    if n % 2 == 0:  # check if the matrix is odd-sized\n        diag_sum = sum([matrix[i][n-i-1] for i in range(n)])\n        if diag_sum != row_sums[0]:\n            return False\n    return True", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Calculate the sum of the first row.\n    target_sum = sum(matrix[0])\n    # Check the rows and columns.\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n        if sum(matrix[j][i] for j in range(n)) != target_sum:\n            return False\n    # Check the diagonal sums.\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    # If none of the checks failed, the matrix is a magic square.\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    #calculating the sum of any row or column\n    target = sum(matrix[0])\n    \n    #testing the rows\n    for row in matrix:\n        if sum(row) != target:\n            return False\n    \n    #testing the columns\n    for i in range(n):\n        if sum(matrix[j][i] for j in range(n)) != target:\n            return False\n    \n    #testing the diagonals\n    if sum(matrix[i][i] for i in range(n)) != target:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != target:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check rows and columns\n    for i in range(len(matrix)):\n        if sum(matrix[i]) != magic_sum or sum(matrix[j][i] for j in range(len(matrix))) != magic_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum or sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # get the sum of any row, col or diag\n    target = sum(matrix[0])\n\n    # test rows and cols\n    for row in matrix:\n        if sum(row) != target:\n            return False\n    for col in zip(*matrix):\n        if sum(col) != target:\n            return False\n\n    # test diags\n    diag1 = [matrix[i][i] for i in range(len(matrix))]\n    diag2 = [matrix[i][-i-1] for i in range(len(matrix))]\n    if sum(diag1) != target or sum(diag2) != target:\n        return False\n\n    # if no discrepancies found\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if it's a square matrix\n    if not all(len(row) == len(matrix) for row in matrix):\n        return False\n\n    # Check if the sum of each row, each column, and the main diagonals are equal\n    n = len(matrix)\n    target = sum(matrix[0])\n\n    for i in range(n):\n        if sum(matrix[i]) != target or sum(matrix[j][i] for j in range(n)) != target:\n            return False\n\n    if sum(matrix[i][i] for i in range(n)) != target or sum(matrix[i][n-i-1] for i in range(n)) != target:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the input is a square matrix\n    if not all(len(row) == len(matrix) for row in matrix):\n        return False\n    \n    # calculate the sum of elements in first row as sum_reference\n    sum_reference = sum(matrix[0])\n    \n    # Checking rows and columns\n    for row in matrix:\n        if sum(row) != sum_reference:\n            return False\n    for i in range(len(matrix)):\n        if sum(row[i] for row in matrix) != sum_reference:\n            return False\n\n    # Checking diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != sum_reference:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != sum_reference:\n        return False\n\n    # If none of the checks failed, return True\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # This function checks if a matrix is a magic square.\n\n    # Check if matrix is square\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Check sum across all rows\n    row_sums = [sum(row) for row in matrix]\n    if len(set(row_sums)) > 1:\n        return False\n\n    # Check sum across all columns\n    column_sums = [sum(matrix[j][i] for j in range(n)) for i in range(n)]\n    if len(set(column_sums)) > 1:\n        return False\n\n    # Check sum along diagonals\n    diagonal_sums = [sum(matrix[i][i] for i in range(n)), sum(matrix[i][n - i - 1] for i in range(n))]\n    if len(set(diagonal_sums)) > 1:\n        return False\n\n    # If all checks passed, then the matrix is a magic square\n    return True", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    # check if matrix is square\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # calculate the sum of the first row\n    row_sum = sum(matrix[0])\n\n    # compare the sum with sums of other rows and columns\n    for i in range(len(matrix)):\n        if sum(matrix[i]) != row_sum:\n            return False\n        if sum(matrix[j][i] for j in range(len(matrix))) != row_sum:\n            return False\n\n    # check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != row_sum:\n        return False\n    if sum(matrix[i][len(matrix) - i - 1] for i in range(len(matrix))) != row_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    A magic square is a matrix in which all rows, columns, and diagonals sum up to the same number.\n    This function checks if a given matrix is a magic square.\n    \"\"\"\n    # Check if matrix is square\n    if len(matrix) != len(matrix[0]):\n        return False\n    \n    # Calculate the sum of numbers in first row. All other rows should have same sum\n    total_sum = sum(matrix[0])\n    \n    # Check if each row, column and diagonal sum up to total_sum\n    for row in matrix:\n        if sum(row) != total_sum:\n            return False\n    \n    for col_index in range(len(matrix)):\n        if sum(matrix[row_index][col_index] for row_index in range(len(matrix))) != total_sum:\n            return False\n    \n    if sum(matrix[index][index] for index in range(len(matrix))) != total_sum:\n        return False\n    \n    if sum(matrix[index][len(matrix) - index - 1] for index in range(len(matrix))) != total_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # get the sum of the first row\n    sum_row = sum(matrix[0])\n    # iterate through each row and check the sum of the rows\n    for row in matrix:\n        if sum(row) != sum_row:\n            return False\n    # iterate through each column and check the sum of the columns\n    for i in range(len(matrix)):\n        if sum(matrix[j][i] for j in range(len(matrix))) != sum_row:\n            return False\n    # check sum of two diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != sum_row:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != sum_row:\n        return False\n    # if all checks pass, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # calculate the sum of the first row\n    reference_sum = sum(matrix[0])\n\n    # check if all rows sum up to the reference sum\n    for row in matrix:\n        if sum(row) != reference_sum:\n            return False\n\n    # transpose the matrix to check the column sums\n    transposed_matrix = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n    for row in transposed_matrix:\n        if sum(row) != reference_sum:\n            return False\n\n    # check the diagonal sum\n    diagonal_sum1 = sum([matrix[i][i] for i in range(len(matrix))])\n    if diagonal_sum1 != reference_sum:\n        return False\n\n    # check the other diagonal sum\n    diagonal_sum2 = sum([matrix[i][len(matrix)-i-1] for i in range(len(matrix))])\n    if diagonal_sum2 != reference_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    expected_sum = sum(matrix[0])\n    for i in range(n):\n        if sum(matrix[i]) != expected_sum:\n            return False\n        if sum([matrix[j][i] for j in range(n)]) != expected_sum:\n            return False\n    if sum([matrix[i][i] for i in range(n)]) != expected_sum:\n        return False\n    if sum([matrix[i][n - i - 1] for i in range(n)]) != expected_sum:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    This function checks whether the input matrix is a magic square.\n    A magic square is a square matrix that contains the same numbers in every row, every column, and the sums of diagonals are equal.\n    \"\"\"\n    # Calculate the sum of the first row to be the expected sum\n    expected_sum = sum(matrix[0])\n\n    # Check if each row's sum equals the expected sum\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n\n    # Check if each column's sum equals the expected sum\n    for i in range(len(matrix)):\n        if sum(matrix[j][i] for j in range(len(matrix))) != expected_sum:\n            return False\n\n    # Check if the diagonal sums are equal\n    if sum(matrix[i][i] for i in range(len(matrix))) != expected_sum:\n        return False\n\n    # Check if the reverse diagonal sums are equal\n    if sum(matrix[i][len(matrix) - i - 1] for i in range(len(matrix))) != expected_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    if len(set(len(row) for row in matrix)) != 1:\n        return False\n    \n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # check row sums\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n        \n    # check column sums\n    for i in range(n):\n        if sum(matrix[j][i] for j in range(n)) != target_sum:\n            return False\n    \n    # check diagonal sums\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    if len(set(len(row) for row in matrix)) > 1:\n        return False  # Not a valid square\n\n    if len(matrix) != len(matrix[0]):\n        return False  # Not a square\n\n    target_sum = sum(matrix[0])  # Sum of the first row\n\n    # Check rows and columns\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    for column in zip(*matrix):\n        if sum(column) != target_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is a square\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # Check sum of each row and column\n    sum_row = [sum(row) for row in matrix]\n    sum_col = [sum(column) for column in zip(*matrix)]\n\n    if len(set(sum_row)) != 1 or len(set(sum_col)) != 1:\n        return False\n\n    # Check sum of diagonals\n    sum_diag1 = sum(matrix[i][i] for i in range(len(matrix)))\n    sum_diag2 = sum(matrix[i][len(matrix) - i - 1] for i in range(len(matrix)))\n\n    if sum_diag1 != sum_diag2 or sum_diag1 != sum_row[0]:\n        return False\n\n    return True", "matching_cluster_idx": 8}]}, "Mbpp/130": {"dps": 70.26905829596413, "dps_norm": 65.0, "pass@1": 61.0, "profiled": [{"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    max_freq_item = max(count_dict, key=count_dict.get)\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    max_freq_item = max(freq, key=freq.get)\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    return max(Counter(lst).items(), key=lambda x: x[1])[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(input_list):\n    frequency_dict = {}\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_frequency_item = max(frequency_dict, key=frequency_dict.get)\n    return max_frequency_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {i: lst.count(i) for i in lst}\n    max_key = max(count_dict, key=count_dict.get)\n    return max_key", "matching_cluster_idx": 1}, {"solution": "def max_occurrences(lst):\n    # Use dictionary to map each item to its frequency\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    # Find the item with maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    max_count = 0\n    max_item = None\n\n    # count the frequency of each item\n    for i in lst:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n\n    # find the item with the maximum frequency\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    max_freq = max(freq_dict.values())\n    for item, freq in freq_dict.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use collections.Counter to count frequency of each item in list\n    counts = Counter(lst)\n    \n    # The most_common method of Counter returns a list of tuples where each tuple contains an item and its count\n    # Sort the list by frequency in descending order and return the first item\n    return sorted(counts.items(), key=lambda item: item[1], reverse=True)[0][0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Use dictionary to store each item as a key and its frequency as the value\n    dict_lst = {}\n    for num in lst:\n        if num in dict_lst:\n            dict_lst[num] += 1\n        else:\n            dict_lst[num] = 1\n            \n    # Find the item with maximum frequency\n    max_freq = max(dict_lst.values())\n    max_freq_items = [key for key, value in dict_lst.items() if value == max_freq]\n    \n    # If there are more than one item with maximum frequency, return the first one\n    if len(max_freq_items) > 1:\n        return max_freq_items[0]\n    else:\n        return max_freq_items[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    max_count = max(counts.values())\n    for item, count in counts.items():\n        if count == max_count:\n            return item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Initialize an empty dictionary\n    count_dict = {}\n\n    # Loop over the input list\n    for num in lst:\n        if num not in count_dict:\n            # If number not in dict, add it with count 1\n            count_dict[num] = 1\n        else:\n            # Else increment its count by 1\n            count_dict[num] += 1\n\n    # Return the number with maximum count\n    return max(count_dict, key=count_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    # Use Counter to get the count of each element\n    count = Counter(lst)\n    # Get the maximum value from the count dictionary\n    max_value = max(list(count.values()))\n    # Return the key that corresponds to the maximum value\n    for key, value in count.items():\n        if value == max_value:\n            return key", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    max_count = max(counts.values())\n    for num, count in counts.items():\n        if count == max_count:\n            return num", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(nums):\n    # Create a dictionary that counts the frequency of each number in the list\n    counts = {}\n    for num in nums:\n        if num not in counts:\n            counts[num] = 1\n        else:\n            counts[num] += 1\n    # Find the item (number) with maximum frequency\n    max_freq = 0\n    max_freq_num = None\n    for num, freq in counts.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_freq_num = num\n    return max_freq_num", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n    count_dict = {}\n    for number in numbers:\n        if number in count_dict:\n            count_dict[number] += 1\n        else:\n            count_dict[number] = 1\n    \n    max_count = 0\n    max_item = None\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n            \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(num_list):\n    count = Counter(num_list)\n    max_count = max(list(count.values()))\n    return [num for num, freq in count.items() if freq == max_count][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(input_list):\n    counts = {}\n    for item in input_list:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n\n    max_count = max(counts.values())\n    for item, count in counts.items():\n        if count == max_count:\n            return item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"Function to find the item with maximum frequency in a given list.\"\"\"\n    freqs = {}\n    for item in lst:\n        if item in freqs:\n            freqs[item] += 1\n        else:\n            freqs[item] = 1\n    max_item = lst[0]\n    max_freq = freqs[max_item]\n    for item in freqs:\n        if freqs[item] > max_freq:\n            max_freq = freqs[item]\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    if not lst:\n        return None\n    freq_dict = {i: lst.count(i) for i in lst}\n    max_key = max(freq_dict, key=freq_dict.get)\n    return max_key", "matching_cluster_idx": 1}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/140": {"dps": 65.82298136645963, "dps_norm": 73.75, "pass@1": 79.0, "profiled": [{"solution": "def extract_singly(lst):\n    return [item for sublist in lst for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    result = []\n    for inner_list in list_of_lists:\n        result.extend(inner_list)\n    return result", "matching_cluster_idx": 7}, {"solution": "def flatten(nested_list):\n    flat_list = []\n    for sublist in nested_list:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list\ndef extract_singly(nested_list):\n    return set(flatten(nested_list))", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    flat_list = []\n    for sublist in lst:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    single_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            single_list.extend(item)\n        else:\n            single_list.append(item)\n    return single_list", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    flat_list = []\n    for sublist in list_of_lists:\n        for item in sublist:\n            flat_list.append(item)\n    return set(flat_list)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(multi_list):\n    flattened_list = []\n    for single_list in multi_list:\n        flattened_list.extend(single_list)\n    return set(flattened_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    # create a new empty list\n    flat_list = []\n    \n    # loop through each list in the nested list\n    for sublist in nested_list:\n        # loop through each element in the current sublist\n        for item in sublist:\n            # add the item to the flat list\n            flat_list.append(item)\n    \n    # return the flat list converted to a set to remove duplicates\n    return set(flat_list)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    return [item for sublist in lst for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    return set([number for sublist in list_of_lists for number in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(input_list):\n    return [i for sublist in input_list for i in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    flat_list = []\n    for sublist in lst:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    flattened = [number for sublist in list_of_lists for number in sublist]\n    return flattened", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    flat_list = []\n    for sublist in nested_list:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    return [item for sublist in list_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    flat_list = []\n    for sublist in nested_list:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    flatten_list = []\n    for inner_list in nested_list:\n        for element in inner_list:\n            flatten_list.append(element)\n    return flatten_list", "matching_cluster_idx": 4}, {"solution": "def extract_singly(input_list):\n    flat_list = [item for sublist in input_list for item in sublist]\n    return flat_list", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    flat_list = []\n    for sublist in list_of_lists:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Function to flatten the list of lists into a single set of numbers.\n    :param list_of_lists: input list of lists.\n    :return: returns a set of numbers extracted from the input list of lists.\n    \"\"\"\n    result = set()\n    for list_ in list_of_lists:\n        result.update(list_)\n    return result", "matching_cluster_idx": 7}]}, "Mbpp/141": {"dps": 87.12018140589569, "dps_norm": 51.875, "pass@1": 54.0, "profiled": [{"solution": "def pancake_sort(lst):\n    lst_copy = lst.copy()\n    lst_copy.sort()\n    return lst_copy", "matching_cluster_idx": 7}, {"solution": "def find_max(l, start, end):\n    i = start\n    max_elem = l[start]\n    for j in range(start, end + 1):\n        if l[j] > max_elem:\n            max_elem = l[j]\n            i = j\n    return i\ndef flip(l, start, end):\n    while start < end:\n        l[start], l[end] = l[end], l[start]\n        start += 1\n        end -= 1\n    return l\ndef pancake_sort(l):\n    n = len(l)\n    for i in range(n - 1, -1, -1):\n        max_pos = find_max(l, 0, i)\n        if max_pos != i:\n            flip(l, 0, max_pos)\n            flip(l, 0, i)\n    return l", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    \n    for i in range(n):\n        max_idx = max(range(n-i), key=arr.__getitem__)\n        arr[:max_idx+1] = arr[max_idx::-1] \n        arr[:n-i] = arr[n-i-1::-1] \n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(list_):\n    # Reverse sort function\n    def flip(list_, k):\n        i = 0\n        while i < k/2:\n            list_[i], list_[k-i-1] = list_[k-i-1], list_[i]\n            i += 1\n        return list_\n\n    # Pancake sort function\n    for size in range(len(list_), 0, -1):\n        # Identify index of the maximum element\n        max_index = list_.index(max(list_[:size]))\n\n        # Move maximum element to its correct position\n        if max_index != size - 1:\n            list_ = flip(list_, max_index + 1)\n            list_ = flip(list_, size)\n\n    return list_", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(elements):\n    for i in range(len(elements)):\n        max_index = 0\n        for j in range(len(elements)-i):\n            if elements[j] > elements[max_index]:\n                max_index = j\n        elements[max_index], elements[-i-1] = elements[-i-1], elements[max_index]\n    return elements", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst), 0, -1):\n        index = lst.index(max(lst[:i]))\n        lst = lst[:index+1][::-1] + lst[index+1:]\n        lst = lst[:i][::-1] + lst[i:]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Function that sorts a list of elements using pancake sort.\n    Pancake sort works by reversing the order of the elements in the list.\n    \"\"\"\n    # Iterate over the whole list\n    for size in range(len(lst), 0, -1):\n        # Find the index of the maximum element in the unsorted part of the list\n        max_index = lst.index(max(lst[:size]))\n\n        # If the maximum element is not at the end of the list, flip the list to put it there\n        if max_index != size - 1:\n            # Reverse the first `max_index + 1` elements to move the max element to the beginning of the list\n            lst = lst[max_index::-1] + lst[max_index + 1:size] + lst[size:]\n\n            # Reverse the first `size` elements to move the max element to the correct position\n            lst = lst[size - 1::-1] + lst[size:]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(input_list):\n    # Using bubble sort as the simplest and most straightforward sorting algorithm.\n    # This function works on the principle of repeatedly swapping the adjacent elements if they are in wrong order.\n    for i in range(len(input_list)-1,0,-1): \n        for j in range(i):\n            if input_list[j]>input_list[j+1]:\n                temp = input_list[j]\n                input_list[j] = input_list[j+1]\n                input_list[j+1] = temp\n    return input_list", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for size in reversed(range(len(lst))):\n        max_idx = max(range(size+1), key=lst.__getitem__)\n        if max_idx != size:\n            lst[:max_idx+1] = reversed(lst[:max_idx+1])\n            lst[:size+1] = reversed(lst[:size+1])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst), 0, -1):\n        max_index = lst.index(max(lst[:i]))\n        if max_index != i-1:\n            lst[:max_index+1] = lst[:max_index+1][::-1]\n            lst[:i] = lst[:i][::-1]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    # Create a copy of the list to avoid mutating it\n    lst = lst[:]\n    # Our last element to flip is the first index\n    end = len(lst)\n\n    # Our outer loop will keep running until we've sorted all elements\n    while end > 0:\n        # Let's find the index of the largest element in the current unsorted segment\n        max_index = lst[:end].index(max(lst[:end]))\n\n        # Flip the max element to its correct position (i.e., the front)\n        lst[:max_index + 1] = reversed(lst[:max_index + 1])\n        # Flip the entire unsorted segment to its correct position (i.e., the front)\n        lst[:end] = reversed(lst[:end])\n\n        # Our sorted segment is now the end of the list\n        end -= 1\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(list):\n    for cur_size in reversed(range(len(list))):\n        # Find index of max element in the array:\n        max_index = max(range(cur_size + 1), key=list.__getitem__)\n        # If max is at beginning of current sublist, no need to flip\n        if max_index != cur_size:\n            # Move max item to end of list\n            list = list[:max_index + 1][::-1] + list[max_index + 1:]\n            # Move the largest number to the start\n            list = list[:cur_size + 1][::-1] + list[cur_size + 1:]\n    return list", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(list_to_sort):\n    # Utilize python's in-built sorting function\n    list_to_sort.sort()\n    return list_to_sort", "matching_cluster_idx": 7}, {"solution": "def pancake_sort(lst):\n    def flip(sub_lst, k):\n        return sub_lst[:k][::-1] + sub_lst[k:]\n\n    def max_index(sub_lst):\n        return sub_lst.index(max(sub_lst))\n\n    for size in reversed(range(len(lst))):\n        max_pos = max_index(lst[:size+1])\n        if max_pos != size:\n            if max_pos != 0:\n                lst = flip(lst, max_pos+1)\n            lst = flip(lst, size+1)\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    The pancake_sort function sorts an input list.\n    \"\"\"\n    for i in range(len(lst), 0, -1):\n        max_idx = lst.index(max(lst[0:i]))\n        if max_idx != i - 1:\n            lst = lst[:max_idx+1][::-1] + lst[max_idx+1:]\n            lst = lst[:i][::-1] + lst[i:]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    for size in reversed(range(len(arr))):\n        max_idx = max(range(size+1), key=arr.__getitem__)\n        if max_idx != size:\n            arr[:max_idx+1] = reversed(arr[:max_idx+1])\n            arr[:size+1] = reversed(arr[:size+1])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        max_idx = lst.index(max(lst[:len(lst)-i]))\n        lst = flip(lst, max_idx)\n        lst = flip(lst, len(lst)-i-1)\n    return lst\ndef flip(lst, idx):\n    return lst[:idx+1][::-1] + lst[idx+1:]", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst), 1, -1):\n        idx = lst.index(max(lst[:i]))\n        if idx+1 != i:\n            lst[:idx+1] = reversed(lst[:idx+1])\n            lst[:i] = reversed(lst[:i])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Function to sort a list of elements.\n    \"\"\"\n    for i in range(len(lst)-1, 0, -1):\n        max_index = lst.index(max(lst[0:i+1]))\n        lst[0:max_index+1] = reversed(lst[0:max_index+1])\n        lst[0:i+1] = reversed(lst[0:i+1])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    for cur in range(len(arr), 0, -1):\n        max_pos = max_pos_finder(arr, cur)\n        arr = flip(arr, max_pos)\n        arr = flip(arr, cur-1)\n    return arr\ndef max_pos_finder(arr, cur):\n    max_pos = arr[:cur].index(max(arr[:cur]))\n    return max_pos\ndef flip(arr, k):\n    return arr[:k+1][::-1] + arr[k+1:]", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 66.0, "profiled": [{"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:  # xor operation\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(num_list):\n    count = 0\n    for i in range(len(num_list)):\n        for j in range(i+1, len(num_list)):\n            if (num_list[i] ^ num_list[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    pair_count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0: # Using bitwise XOR operator to calculate xor and then check if it's even\n                pair_count += 1\n    return pair_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:  # Python ^ operator performs the XOR operation\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    pairs_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0: # ^ is the bitwise XOR operator.\n                pairs_count += 1\n    return pairs_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    counter = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                counter += 1\n    return counter", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:  # '^' is the xor operator in Python\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    pairs = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                pairs += 1\n    return pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    # Iterate over each pair of numbers in the list\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # Xor the pair and check if the result is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(num_list):\n    count = 0\n    for i in range(len(num_list)):\n        for j in range(i + 1, len(num_list)):\n            if (num_list[i] ^ num_list[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 73.0, "profiled": [{"solution": "def sum_range_list(num_list, start_idx, end_idx):\n    return sum(num_list[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(list, start_index, end_index):\n    return sum(list[start_index : end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    return sum(lst[start_idx:end_idx + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(list, start_index, end_index):\n    if end_index > len(list) - 1:  # if the end index is greater than the list length, set it equal to the last index.\n        end_index = len(list) - 1\n        \n    return sum(list[start_index:end_index+1])  # use python's built-in sum function and slicing to find the sum", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(input_list, start_index, end_index):\n    return sum(input_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(list, start, end):\n    \"\"\"\n    A function to calculate the sum of a list within a range specified by two indices.\n    \"\"\"\n    return sum(list[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    if end >= len(nums) or start < 0:\n        return 0\n    elif start > end:\n        return 0\n    else:\n        return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start, end):\n    return sum(num_list[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, i, j):\n    return sum(numbers[i:j+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(input_list, start_index, end_index):\n    return sum(input_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Function to calculate sum of numbers within a range in a list\n    \"\"\"\n    if len(lst) > end_index:\n        return sum(lst[start_index:end_index+1])\n    else:\n        return \"Invalid Range\"", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 78.56589147286822, "dps_norm": 51.42857142857142, "pass@1": 94.0, "profiled": [{"solution": "def odd_values_string(str):\n    return str[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    # empty string to hold the output\n    output_string = ''\n    # iterate through each character in the input string\n    for i in range(len(input_string)):\n        # check if the index is even\n        if i % 2 == 0:\n            # add the character to the output string\n            output_string += input_string[i]\n    return output_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    new_str = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            new_str += s[i]\n    return new_str", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    # empty string to store result\n    result = \"\"\n    # iterate over the string\n    for i in range(len(str)):\n        # check if the index is even\n        if i % 2 == 0:\n            # append the character to the result\n            result += str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(string):\n    return string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    # We use list comprehension and join method to concatenate only the characters\n    # with even index values from the input string\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    return str[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    new_string = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0: \n            new_string = new_string + str[i]\n    return new_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    return input_str[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(string):\n    # Using list comprehension + range() function\n    # To get characters at odd index\n    # and join() method to concatenate the characters\n    return ''.join([string[i] for i in range(len(string)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 5}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(input_str, replacer):\n    return input_str.replace(' ', replacer)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    # Replace the blank spaces in the string with the character\n    new_string = string.replace(' ', char)\n    return new_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Function to replace all blank spaces with a given character.\n    \n    Parameters:\n    string (str): The string that needs to be modified.\n    char (str): The character that will replace the blank spaces.\n    \n    Returns:\n    str: The string with all blank spaces replaced by the provided character.\n    \"\"\"\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, replacement):\n    return input_str.replace(' ', replacement)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string,char):\n    return string.replace(' ',char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    This function replaces all the blank spaces in the string with the specified character\n    and returns the modified string.\n    \"\"\"\n    # Replace all blank spaces in the string with the replacement character\n    new_string = input_string.replace(' ', replacement_char)\n    \n    return new_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, replacement):\n    return text.replace(' ', replacement)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/240": {"dps": 78.47560975609757, "dps_norm": 86.66666666666667, "pass@1": 48.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    # Replace last element of first list with second list\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    lst1.pop()\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if len(list1) > 0:\n        list1[-1:] = list2\n    else:\n        list1 = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(l1, l2):\n    # Remove the last element from the first list\n    l1.pop()\n    # Add the elements of the second list to the first list\n    l1.extend(l2)\n    return l1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from the first list\n    lst1 = lst1[:-1]\n    # Concatenate the lists\n    lst1.extend(lst2)\n    # Return the result\n    return lst1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    if len(list1) > 0:\n        list1.pop()\n    return list1 + list2", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of the first list with the elements of the second list\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # check if lst1 is not empty\n    if lst1:\n        # replace last element with lst2\n        lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from the first list\n    lst1.pop()\n    # Then append the elements from the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    This function replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    # get the last element of the first list\n    last_elem = lst1[-1]\n\n    # replace last element of the first list with the elements of the second list\n    new_lst = lst1[:-1] + lst2\n\n    return new_lst", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if len(list1) == 0:\n        return list2\n    else:\n        list1[-1:] = list2\n        return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Check if lst1 is not empty\n    if lst1:\n        # Remove the last element\n        lst1.pop()\n        # Append lst2 to lst1\n        lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 is not empty\n    if list1:\n        # Replace the last element of list1 with elements of list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": 78.59195402298852, "dps_norm": 70.0, "pass@1": 50.0, "profiled": [{"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Function to insert a given element before each element in a list\n    \"\"\"\n    res = []\n    for i in lst:\n        res.extend([elem, i])\n    return res", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    for i in range(len(lst)-1, -1, -1):\n        lst.insert(i, elem)\n    return lst", "matching_cluster_idx": 0}, {"solution": "def insert_element(input_list, element):\n    output_list = []\n    for i in input_list:\n        output_list.append(element)\n        output_list.append(i)\n    return output_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Insert an element before each element in a list.\n    \"\"\"\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # The insert() function inserts a specified value at the specified position in the list\n    for i in range(len(lst)):\n        lst.insert(i*2, element)\n    return lst", "matching_cluster_idx": 2}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    new_lst = []\n    for i in lst:\n        new_lst.append(element)\n        new_lst.append(i)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(my_list, element):\n    new_list = []\n    for item in my_list:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    for i in range(len(lst)):\n        lst.insert(2*i, elem)\n    return lst", "matching_cluster_idx": 2}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for item in input_list:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    new_lst = []\n    for item in lst:\n        new_lst += [element, item]\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    new_lst = []\n    for item in lst:\n        new_lst.append(el)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elm):\n    result = []\n    for item in lst:\n        result += [elm, item]\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for i in lst:\n        result.append(elem)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for item in input_list:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 60.45662100456621, "dps_norm": 56.470588235294116, "pass@1": 90.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return sum(is_prime(i) for i in range(n))", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Checks if a number is a prime number\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Count the number of prime numbers less than the given non-negative number\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    count = 0\n    for num in range(n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return sum(is_prime(i) for i in range(n))", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    prime_count = 0\n    for i in range(n):\n        if is_prime(i):\n            prime_count += 1\n\n    return prime_count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\n    if n == 0 or n == 1:\n        return False\n    for x in range(2, int(n ** 0.5) + 1):\n        if n % x == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Main function to count the number of prime numbers less than a given number.\n    \"\"\"\n    count = 0\n    for x in range(2, n):\n        if is_prime(x):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n == 0 or n == 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    return sum(is_prime(i) for i in range(n))", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(num):\n    # Define the function to check if a number is prime\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    # Count the number of primes that are less than the given non-negative number\n    count = 0\n    for i in range(num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(n) if is_prime(i)]\n    return len(primes)", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n ** 0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2,int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n    count = 0\n    for i in range(2,n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    return sum(is_prime(i) for i in range(2, n))", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"\n    Helper function to check if a number is prime\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    \"\"\"\n    Count the number of prime numbers less than num\n    \"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(num):\n    \"\"\"Checks if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    elif num == 2:\n        return True\n    else:\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\ndef count_Primes_nums(num):\n    \"\"\"Counts the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    prime_count = 0\n    for i in range(n):\n        if is_prime(i):\n            prime_count += 1\n    return prime_count", "matching_cluster_idx": 8}]}, "Mbpp/265": {"dps": 70.93023255813954, "dps_norm": 83.33333333333333, "pass@1": 14.0, "profiled": [{"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Function checks if all elements of the given list are unique.\n\n    Args:\n    lst (list): The list to be checked for duplicates.\n\n    Returns:\n    bool: True if all elements in the list are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(list):\n    \"\"\"\n    This function checks if all elements in a given list are unique.\n    \"\"\"\n    if len(list) == len(set(list)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a given list are unique\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Return True if all elements in the given list are unique. Otherwise, return False.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a given list are unique or not.\n    \"\"\"\n    # return True if there are no duplicates in the list\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(list):\n    if len(list) == len(set(list)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 42.56410256410256, "dps_norm": 73.33333333333334, "pass@1": 86.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    inversion_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if arr[i] > arr[j]: \n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_and_count_split_inv(left, right, arr):\n    i = j = k = 0\n    inv_count = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i\n        k += 1\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n    return inv_count\ndef merge_sort_and_count_inv(arr):\n    if len(arr) <= 1:\n        return 0\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    x = merge_sort_and_count_inv(left)\n    y = merge_sort_and_count_inv(right)\n    z = merge_and_count_split_inv(left, right, arr)\n    return x+y+z\ndef get_Inv_Count(arr):\n    return merge_sort_and_count_inv(arr)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i+1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_and_count(arr, temp, left, mid, right):\n    inv_count = 0\n    i = left\n    j = mid\n    k = left\n    \n    while i < mid and j < right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            i += 1\n        else:\n            temp[k] = arr[j]\n            j += 1\n            inv_count += mid - i\n        k += 1\n    \n    while i < mid:\n        temp[k] = arr[i]\n        i += 1\n        k += 1\n    \n    while j < right:\n        temp[k] = arr[j]\n        j += 1\n        k += 1\n        \n    for i in range(left, right):\n        arr[i] = temp[i]\n        \n    return inv_count\ndef merge_sort_and_count(arr, temp, left, right):\n    inv_count = 0\n    if right > left + 1:\n        mid = (left + right) // 2\n        inv_count += merge_sort_and_count(arr, temp, left, mid)\n        inv_count += merge_sort_and_count(arr, temp, mid, right)\n        inv_count += merge_and_count(arr, temp, left, mid, right)\n    return inv_count\ndef get_Inv_Count(arr):\n    temp = [0]*len(arr)\n    return merge_sort_and_count(arr, temp, 0, len(arr))", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if(arr[i] > arr[j]):\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_sort_inversion_count(lst):\n    if len(lst) <= 1:\n        return lst, 0\n\n    mid = len(lst) // 2\n    left, left_inv_count = merge_sort_inversion_count(lst[:mid])\n    right, right_inv_count = merge_sort_inversion_count(lst[mid:])\n\n    merged, merge_inv_count = merge_inversion_count(left, right)\n\n    return merged, left_inv_count + right_inv_count + merge_inv_count\ndef merge_inversion_count(left, right):\n    i = j = k = 0\n    inversions = 0\n    merged = [0] * (len(left) + len(right))\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged[k] = left[i]\n            i += 1\n        else:\n            merged[k] = right[j]\n            j += 1\n            inversions += len(left) - i\n        k += 1\n\n    while i < len(left):\n        merged[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        merged[k] = right[j]\n        j += 1\n        k += 1\n\n    return merged, inversions\ndef get_Inv_Count(lst):\n    _, inversion_count = merge_sort_inversion_count(lst)\n    return inversion_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1,len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inversion_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count", "matching_cluster_idx": 3}, {"solution": "def merge(left, right):\n    inv_count = 0\n    i = j = 0\n    temp = []\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            temp.append(left[i])\n            i += 1\n        else:\n            temp.append(right[j])\n            j += 1\n            inv_count += (len(left)-i)\n    \n    temp.extend(left[i:])\n    temp.extend(right[j:])\n    \n    return temp, inv_count\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, l_count = merge_sort(arr[:mid])\n    right, r_count = merge_sort(arr[mid:])\n    \n    sorted_arr, inv_count = merge(left, right)\n    total_inv_count = l_count + r_count + inv_count\n    \n    return sorted_arr, total_inv_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(array):\n    inv_count = 0\n    for i in range(len(array)):\n        for j in range(i+1, len(array)):\n            if array[i] > array[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 84.3448275862069, "dps_norm": 63.333333333333336, "pass@1": 89.0, "profiled": [{"solution": "def large_product(list1, list2, num):\n    products = [(x * y) for x in list1 for y in list2]\n    products.sort(reverse=True)\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    product_list = [i*j for i in list1 for j in list2]\n    product_list.sort(reverse=True)\n    return product_list[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    \"\"\"\n    This function finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \"\"\"\n    products = [x*y for x in list1 for y in list2]\n    products.sort(reverse=True)\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, number):\n    product_list = [i*j for i in list1 for j in list2]\n    product_list.sort(reverse=True)\n    return product_list[:number]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Merging two lists into a list of tuples of pairs\n    pairs = [(x, y) for x in list1 for y in list2]\n\n    # Sorting pairs in descending order according to product\n    pairs.sort(key=lambda pair: pair[0]*pair[1], reverse=True)\n    \n    # Returning the first 'n' products\n    return [pair[0]*pair[1] for pair in pairs[:n]]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    products = [a*b for a in list1 for b in list2]\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    import heapq\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x*y)\n    return heapq.nlargest(num, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    if n > len(list1)*len(list2):\n        raise ValueError(\"The specified number of products exceeds the total number of products from both lists.\")\n    products = sorted([x*y for x in list1 for y in list2], reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    combined = [(x * y) for x in list1 for y in list2]\n    combined.sort(reverse=True)\n    return combined[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    #create list of products of all pairs\n    products = [i*j for i in list1 for j in list2]\n    #sort list in descending order\n    products.sort(reverse=True)\n    #return first n elements\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    products = [a*b for a in list1 for b in list2]\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    product_list = [i*j for i in list1 for j in list2]\n    product_list.sort(reverse=True)\n    return product_list[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    pairs = [(i, j) for i in list1 for j in list2]\n    products = sorted(pairs, key=lambda pair: pair[0]*pair[1], reverse=True)\n    return [pair[0]*pair[1] for pair in products[:num]]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, num):\n    import itertools\n    products = []\n    for i, j in itertools.product(list1, list2):\n        products.append(i*j)\n    products.sort(reverse=True)\n    return products[:num]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Function to find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \"\"\"\n    # Combine the two lists into one and find the product of each pair of numbers\n    product_list = [i*j for i in list1 for j in list2]\n\n    # Sort the product list in descending order and select the first n items\n    result = sorted(product_list, reverse=True)[:n]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, num):\n    product_list = [a * b for a in lst1 for b in lst2]\n    product_list.sort(reverse=True)\n    return product_list[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Compute the products of the elements in the two lists\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the list of products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    #Combine the two lists into a single list of tuples where each tuple consists of an element from each list.\n    all_pairs = [(x, y) for x in list1 for y in list2]\n    \n    #Compute the product of each pair and sort the products in descending order.\n    all_products = sorted([x*y for (x, y) in all_pairs], reverse=True)\n    \n    #Return the top n products\n    return all_products[:n]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, num):\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'num' products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i*j)\n    return sorted(products, reverse=True)[:num]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 73.59154929577466, "dps_norm": 76.15384615384616, "pass@1": 37.0, "profiled": [{"solution": "def get_max_sum(n, dp = {}):\n    # Memoization to store previously computed values\n    if n in dp: return dp[n]\n    # Base case\n    elif n < 2: return n\n    # Recursive case\n    else:\n        dp[n] = max((get_max_sum(n//2, dp) + get_max_sum(n//3, dp) + get_max_sum(n//4, dp) + get_max_sum(n//5, dp)), n)\n        return dp[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    cache = {0: 0, 1: 1}  # store previously computed results in cache\n\n    def calculate_max_sum(n):\n        # If n is not present in the cache, calculate it\n        if n not in cache:\n            cache[n] = max(calculate_max_sum(n//2) + calculate_max_sum(n//3) + calculate_max_sum(n//4) + calculate_max_sum(n//5), n)\n        return cache[n]\n\n    return calculate_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "memoize_dict = {0:0, 1:1}\ndef get_max_sum(n):\n    if n not in memoize_dict: # If we have already calculated f(n) and stored it in memoize_dict\n        memoize_dict[n] = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n    return memoize_dict[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n <= 5:\n        return n\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 8}, {"solution": "def get_max_sum(n, result_dict={}):\n    \"\"\"\n    Function to find the maximum sum using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Parameters:\n    n (int): The initial number for which we need to find the max sum.\n    result_dict (dict): A dictionary to store the results of sub-problems.\n\n    Returns:\n    int: The maximum sum.\n    \"\"\"\n    # Base case\n    if n <= 1:\n        return n\n\n    # Check if the result is already in dictionary\n    if n in result_dict:\n        return result_dict[n]\n    \n    # Recursive case\n    result_dict[n] = max((get_max_sum(n // 2, result_dict) +\n                          get_max_sum(n // 3, result_dict) +\n                          get_max_sum(n // 4, result_dict) +\n                          get_max_sum(n // 5, result_dict)), n)\n    return result_dict[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, dp = {0: 0}):\n    if n not in dp:\n        dp[n] = max((get_max_sum(n//2, dp) + get_max_sum(n//3, dp) + get_max_sum(n//4, dp) + get_max_sum(n//5, dp)), n)\n    return dp[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n<=1:\n        return n\n\n    if n not in memo:\n        memo[n] = max(get_max_sum(n//2)+get_max_sum(n//3)+get_max_sum(n//4)+get_max_sum(n//5), n)\n\n    return memo[n]\nmemo = {}", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n < 6:\n        return n\n\n    max_sums = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5}\n\n    def get_max(n):\n        if n in max_sums:\n            return max_sums[n]\n\n        max_sum = max(get_max(n//2) + get_max(n//3) + get_max(n//4) + get_max(n//5), n)\n        max_sums[n] = max_sum\n        return max_sum\n\n    return get_max(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n  dp = {0: 0, 1: 1}\n\n  # Recursive function for calculating maximum sum\n  def max_sum(n):\n    if n not in dp:\n      dp[n] = max(max_sum(n // 2) + max_sum(n // 3) + max_sum(n // 4) + max_sum(n // 5), n)\n    return dp[n]\n\n  return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    function to find the maximum sum using given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    parameters:\n    n (int) : Number for which we need to find maximum sum\n\n    returns:\n    max_sum (int) : Maximum sum for given n\n    \"\"\"\n    # Checking base case \n    if n == 0 or n == 1:\n        return n\n        \n    # calculating recursively for n/2, n/3, n/4, n/5\n    n_by_2 = get_max_sum(n//2)\n    n_by_3 = get_max_sum(n//3)\n    n_by_4 = get_max_sum(n//4)\n    n_by_5 = get_max_sum(n//5)\n    \n    # getting max sum from each of the four divided components\n    max_sum = max(n_by_2 + n_by_3 + n_by_4 + n_by_5, n)\n    \n    return max_sum", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    # Recursively calculate the sum\n    result = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n, cache = {}):\n    #if the value is cached, return it\n    if n in cache:\n        return cache[n]\n\n    if n < 2: \n        return n\n    else:\n        value = max(n, get_max_sum(n//2, cache) + get_max_sum(n//3, cache) + get_max_sum(n//4, cache) + get_max_sum(n//5, cache))\n\n    #caching the calculated value\n    cache[n] = value\n    return value", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    return max((get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    memo = {0:0, 1:1}  # Initial values\n    def f(n):\n        if n in memo:  # Check if the value has been calculated before\n            return memo[n]\n        else:\n            # Compute the value with the formula and store it in the memo dict\n            memo[n] = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n            return memo[n]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n <= 1:\n        return n\n    if n in memo:\n        return memo[n]\n\n    result = max((get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo)), n)\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialising cache for previously calculated sums\n    cache = {0: 0, 1: 1}\n    def calc_max_sum(n):\n        # If value is already calculated, return from cache\n        if n in cache:\n            return cache[n]\n        # Calculate the sum using the given equation\n        else:\n            cache[n] = max((calc_max_sum(n//2) + calc_max_sum(n//3) + calc_max_sum(n//4) + calc_max_sum(n//5)), n)\n            return cache[n]\n    # Start calculating the sum from the required number\n    return calc_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, lookup={}):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n in lookup:\n        return lookup[n]\n    lookup[n] = max(n, get_max_sum(n//2, lookup) + get_max_sum(n//3, lookup) + get_max_sum(n//4, lookup) + get_max_sum(n//5, lookup))\n    return lookup[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 3}]}, "Mbpp/395": {"dps": 89.34865900383141, "dps_norm": 70.0, "pass@1": 98.0, "profiled": [{"solution": "def first_non_repeating_character(string):\n    char_frequency = {}\n    # Count the frequency of each character in the string\n    for char in string:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    # Check each character in the string\n    for char in string:\n        # If the character's frequency is 1, it is the first non-repeating character\n        if char_frequency[char] == 1:\n            return char\n    # If no character repeats, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    character_count = {}\n    for char in s:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n    for char in s:\n        if character_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_str):\n    for char in input_str:\n        if input_str.count(char) == 1:\n            return char\n    return None", "matching_cluster_idx": 1}, {"solution": "def first_non_repeating_character(string):\n    count_dict = {}\n    for char in string:\n        if char in count_dict:\n            count_dict[char] += 1\n        else:\n            count_dict[char] = 1\n            \n    for char in string:\n        if count_dict[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    for ch in string:\n        if string.count(ch) == 1:\n            return ch\n    return None", "matching_cluster_idx": 1}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"Function to find the first non-repeated character in a given string.\"\"\"\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    # Count the frequency of each character in the string.\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    # Check the frequency of each character.\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    character_count = {}\n\n    for char in string:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n\n    for char in string:\n        if character_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_dict = {}\n    for char in string:\n        if char not in char_dict:\n            char_dict[char] = 1\n        else:\n            char_dict[char] += 1\n\n    for char in string:\n        if char_dict[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    character_count = {}\n    for char in input_string:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n\n    for char in input_string:\n        if character_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a count of characters\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    from collections import Counter\n\n    counter_dict = Counter(string)\n    for character in string:\n        if counter_dict[character] == 1:\n            return character\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    count = {}\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    for char in string:\n        if count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    char_count = {}\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    character_count = {}\n    for char in string:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n    for char in string:\n        if character_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    count = {}\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n\n    for char in string:\n        if count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_frequency = {}\n    for char in string:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    for char in string:\n        if char_frequency[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # Create a dictionary to store character frequency\n    frequency = {}\n\n    # Traverse the given string\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # Traverse the string again\n    for char in string:\n        if frequency[char] == 1:\n            return char\n\n    # Return None if no unique character is found\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks if an element exists within a tuple.\n    Parameters:\n    tuplex (tuple): The tuple to be checked\n    element: The element to be checked\n    Returns:\n    bool: True if the element exists, False otherwise\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, val):\n    return val in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, ele):\n    return ele in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, val):\n    # checking the tuple for the element\n    if val in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    if elem in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    \"\"\"\n    Returns True if elem is in tuplex and False otherwise\n    \"\"\"\n    return elem in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuplex, element):\n    return element in input_tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, key):\n    if key in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, elem):\n    if elem in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, item):\n    return item in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 74.03726708074534, "dps_norm": 81.66666666666667, "pass@1": 74.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    #Check if any value in seq1 exists in seq2\n    if any(value in seq2 for value in seq1):\n        return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    if set(seq1) & set(seq2):\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 overlaps with any value in seq2.\n    \n    Parameters:\n    seq1 (list): First sequence to be checked.\n    seq2 (list): Second sequence to be checked.\n    \n    Returns:\n    bool: True if any value in seq1 overlaps with any value in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for elem in seq1:\n        if elem in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks if any value from the first sequence is in the second sequence.\n\n    Args:\n    seq1: The first sequence.\n    seq2: The second sequence.\n\n    Returns:\n    A boolean value True if there is an overlap, else False.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    for i in sequence1:\n        for j in sequence2:\n            if i == j:\n                return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def overlapping(seq1, seq2):\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Convert lists to sets to check for overlapping in constant time\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Check if any common elements\n    if len(set1.intersection(set2)) > 0:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}]}, "Mbpp/421": {"dps": 40.65843621399177, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(str(x) for x in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter=\"-\"):\n    return delimiter.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(item) for item in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(str(x) for x in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    return delimiter.join(str(x) for x in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    This function concatenates each element in the tuple into a string separated by the given delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple):\n    # Using the join() method to concatenate elements of tuple by the delimiter\n    result = '-'.join(str(i) for i in input_tuple)\n    return result", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tuple_to_concatenate, delimiter='-'):\n    return delimiter.join(str(x) for x in tuple_to_concatenate)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tuple, delimiter = '-'):\n    return delimiter.join(str(x) for x in tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(x) for x in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    return \"-\".join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(str(x) for x in input_tuple)", "matching_cluster_idx": 4}]}, "Mbpp/424": {"dps": 97.5812274368231, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [i[-1] for i in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [x[-1] for x in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [string[-1] for string in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    # Use list comprehension to extract the rear index element of each string in the tuple\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    return [word[-1] for word in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    return [word[-1] for word in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    This function receives a tuple of strings and returns a list with the rear index element of each string.\n    \"\"\"\n    # Use a list comprehension to extract the rear index element of each string in the tuple.\n    rear_elements = [string[-1] for string in strings]\n    return rear_elements", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_str):\n    return [s[-1] for s in tuple_str]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [word[-1] for word in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [word[-1] for word in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    # Initialize an empty list to hold the extracted rear index elements\n    extract_list = []\n\n    # Loop over the elements in the given tuple\n    for element in t:\n        # Get the rear index element of each string\n        rear_index_element = element[-1]\n        # Append it to the list\n        extract_list.append(rear_index_element)\n\n    return extract_list", "matching_cluster_idx": 3}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, el):\n    \"\"\"This function counts the number of sublists that contain the specified element\"\"\"\n    count = sum(el in sublist for sublist in lst)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, target):\n    count = 0\n    for sublist in lst:\n        if target in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, x):\n    count = 0\n    for sublist in lst:\n        if x in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, num):\n    count = 0\n    for sublist in lst:\n        if num in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    \"\"\"\n    Function to count the number of sublists containing a particular element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, el):\n    count = 0\n    for sublist in lst:\n        if el in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum([1 for sublist in lst if element in sublist])", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a counter\n    counter = 0\n    # Loop through the sublists in the list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increase the counter if the element is found\n            counter += 1\n    # Return the counter\n    return counter", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, el):\n    count = 0\n    for sublist in lst:\n        if el in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, el):\n    return sum([1 for sublist in lst if el in sublist])", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sub_lists, element):\n    count = 0\n    for sublist in sub_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 34.421487603305785, "dps_norm": 46.11111111111111, "pass@1": 95.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n                \n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n//2\n  \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order\n    # keep reducing the gap until it's 1\n    while gap > 0:\n        # add a[gap+i] to the elements that have been gap sorted\n        # save a[gap+i] in temp and make a hole at position i\n        for i in range(gap,n):\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n              \n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    sublist_count = len(arr)//2\n    # While we're still sublist count > 0,\n    while sublist_count > 0:\n        for start_position in range(sublist_count):\n            # Use a gap insertion sort on this sublist \n            gap_insertion_sort(arr,start_position,sublist_count)\n        sublist_count = sublist_count//2\n    return arr\ndef gap_insertion_sort(arr,start,gap):\n    for i in range(start+gap,len(arr),gap):\n        current_value = arr[i]\n        position = i\n        # Using the Gap \n        while position>=gap and arr[position-gap]>current_value:\n            arr[position]=arr[position-gap]\n            position = position-gap\n        arr[position]=current_value\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 3}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 3}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 3}, {"solution": "def shell_sort(input_array):\n    gap = len(input_array) // 2\n    while gap > 0:\n        for i in range(gap, len(input_array)):\n            temp = input_array[i]\n            j = i\n            while j >= gap and input_array[j - gap] > temp:\n                input_array[j] = input_array[j - gap]\n                j = j - gap\n            input_array[j] = temp\n        gap = gap // 2\n    return input_array", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n    \n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap = gap // 2\n    return array", "matching_cluster_idx": 3}, {"solution": "def shell_sort(array):\n    # Set the gap value\n    gap = len(array) // 2\n    \n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n            # Sorted sublist\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        # Decrease the gap\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            \n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    # Rearrange elements at each n/2, n/4, n/8, ... intervals\n    interval = len(array) // 2\n    while interval > 0:\n        for i in range(interval, len(array)):\n            temp = array[i]\n            j = i\n            # Sort the sub list for this interval\n            while j >= interval and array[j - interval] > temp:\n                array[j] = array[j - interval]\n                j -= interval\n\n            array[j] = temp\n        interval //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/433": {"dps": 78.82978723404256, "dps_norm": 86.0, "pass@1": 39.0, "profiled": [{"solution": "def check_greater(array, number):\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function will take in a list of numbers (arr) and a number (num) and \n    will return True if all numbers in the list are less than num else it returns False.\n    \"\"\"\n    for i in arr:\n        if i >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for n in arr:\n        if num <= n:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, number):\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    The function takes in an array of numbers and a number. \n    It checks whether the number is greater than all the elements in the array.\n    Returns True if the number is greater, False otherwise.\n    \"\"\"\n    for element in array:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    for elem in arr:\n        if num <= elem:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # iterate over each element in the array\n    for i in arr:\n        # if the number is not greater than any element in the array, return False\n        if num <= i:\n            return False\n    # if none of the elements in the array are greater than the number, return True\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, num):\n    for i in array:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for elem in arr:\n        if num <= elem:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(num_list, num):\n    for x in num_list:\n        if x >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, num):\n    return all(element < num for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    for num in array:\n        if number <= num:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Returns True if the given number is greater than all elements in the array, else returns False\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, num):\n    return all(i < num for i in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    # Check each element in the array\n    for i in array:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/437": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 66.0, "profiled": [{"solution": "def count_Occurrence(tpl,lst):\n    count = 0\n    for elem in lst:\n        count += tpl.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    count = 0\n    for i in my_list:\n        count += my_tuple.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple, list):\n    count = 0\n    for i in list:\n        count += tuple.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, list):\n    count = 0\n    for element in list:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for ele in lst:\n        count += tup.count(ele)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    counter = 0\n    for element in lst:\n        counter += tup.count(element)\n    return counter", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for i in list_input:\n        count += tuple_input.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(lst, keys):\n    count = 0\n    for key in keys:\n        count += lst.count(key)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    count = 0\n    for element in lst:\n        count += tpl.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    count = 0\n    for item in lst:\n        count += tpl.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_, list_):\n    count = 0\n    for element in list_:\n        count += tuple_.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t,l):\n    cnt = [t.count(i) for i in l]\n    return sum(cnt)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, list_elem):\n    count = 0\n    for elem in list_elem:\n        count += tup.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    count = 0\n    for i in lst:\n        count += tpl.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for elem in lst:\n        count += tup.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for i in lst:\n        count += tup.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 91.86440677966101, "dps_norm": 97.0, "pass@1": 91.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    This function removes all whitespaces from the given string.\n\n    Parameters:\n    s (str): The string from which to remove whitespaces.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    # Use the replace() method to remove all spaces from the string\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"Remove all whitespaces from the given string\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    This function removes all whitespaces from the given string.\n    \"\"\"\n    # Replace all white spaces with no space.\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_whitespaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_string = string[::-1]\n        reversed_list.append(reversed_string)\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    This function takes a list of strings and returns a new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    Reverses each string in a list of string values.\n    :param lst: List of string values to be reversed\n    :return: List of reversed string values\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"Reverse each string in a given list of strings.\"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(list_values):\n    return [i[::-1] for i in list_values]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 71.4423076923077, "dps_norm": 89.0, "pass@1": 87.0, "profiled": [{"solution": "def Extract(input_list):\n    return [sublist[0] for sublist in input_list]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublist):\n    return [sub[0] for sub in sublist if sub]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublist):\n    return [sub[0] for sub in sublist]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sub_lists):\n    return [sub[0] for sub in sub_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [i[0] for i in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublist):\n    return [i[0] for i in sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sub[0] for sub in lst if sub]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    result = []\n    for sublist in sublists:\n        result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    result = [sublist[0] for sublist in lst]\n    return result", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 96.73170731707317, "dps_norm": 97.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(input_str,old,new):\n    return input_str.replace(old,new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, char_to_replace, new_char):\n    return input_str.replace(char_to_replace, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, c1, c2):\n    return s.replace(c1, c2)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, target_char, replacement_char):\n    return input_string.replace(target_char, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, char_to_find, char_to_replace):\n    return input_str.replace(char_to_find, char_to_replace)", "matching_cluster_idx": 6}, {"solution": "def replace_char(str, char1, char2):\n    return str.replace(char1, char2)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old, new):\n    \"\"\"\n    This function replaces all occurrences of old character with new character in a given string.\n    \n    Arguments:\n    string: The original string.\n    old: The character to be replaced.\n    new: The character to replace old character with.\n    \n    Returns:\n    string: The modified string where all old characters are replaced by new character.\n    \"\"\"\n    return string.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    # replace characters in a string\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == old:\n            s[i] = new\n    return ''.join(s)", "matching_cluster_idx": 2}, {"solution": "def replace_char(input_str, char_to_replace, new_char):\n    return input_str.replace(char_to_replace, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str,old_char,new_char):\n    return input_str.replace(old_char,new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, o, n):\n    return s.replace(o, n)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, c, r):\n    return s.replace(c, r)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 96.20805369127517, "dps_norm": 97.5, "pass@1": 87.0, "profiled": [{"solution": "def big_sum(array):\n    if not array:\n        return 0\n    return max(array) + min(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function accepts a list of integers as input and\n    returns the sum of the smallest and the largest value in the list.\n    \"\"\"\n    # Check if the list is empty\n    if len(arr) == 0:\n        return None\n\n    # Find the smallest and largest number in the array\n    min_val = min(arr)\n    max_val = max(arr)\n\n    # Return the sum\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    else:\n        return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # check if arr is not empty\n    if not arr:\n        return 0\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    if len(nums) < 2:\n        return 'Array needs to contain at least two numbers'\n    else:\n        return min(nums) + max(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not arr: # if arr is empty return None\n        return None\n    else:\n        return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # sort the array\n    arr.sort()\n    # return the sum of the first and last elements of the sorted array\n    return arr[0] + arr[-1]", "matching_cluster_idx": 2}, {"solution": "def big_sum(arr):\n    if len(arr) < 2:\n        return \"Input array should have at least 2 elements\"\n    else:\n        return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    if len(nums) < 2:\n        return None\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return None\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function takes a list of numbers as an input and returns the sum of the largest and smallest number in the list.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) < 2:\n        return \"Array should have at least two elements.\"\n    else:\n        min_val = min(arr)\n        max_val = max(arr)\n        return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    if not array:\n        return 0\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:  # Handle empty list case\n        return None\n\n    min_value = min(arr)\n    max_value = max(arr)\n    return min_value + max_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) < 1:\n        return \"The array is empty\"\n    else:\n        return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    if len(numbers) >= 2:\n        return min(numbers) + max(numbers)\n    else:\n        return \"The list must have at least two elements\"", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 97.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    values = re.findall(r'\"([^\"]*)\"', s)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # We use the 'findall' function from 're' module to get all substrings (not groups) of\n    # the string that match the quotation marks pattern\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regex to find all substrings between double quotes\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = re.compile(r'\"(.*?)\"')\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # using regex to find all strings between quotation marks\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = re.compile(r'\"(.*?)\"')\n    return [m.group(1) for m in pattern.finditer(s)]", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"(.*?)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    This function will extract values between quotation marks from a string.\n    \"\"\"\n    # Regular expression to match any text between quotation marks\n    match_pattern = re.findall(r'\"(.*?)\"', s)\n    return match_pattern", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    matches = re.findall(r'\"(.*?)\"', string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    This function is used to extract values between quotation marks from a string.\n    \"\"\"\n    # Using regular expression to find all substrings inside quotation marks\n    values = re.findall('\"([^\"]*)\"', string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    #Using the re.findall method to extract values\n    matches = re.findall('\\\"(.*?)\\\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/578": {"dps": 87.22222222222221, "dps_norm": 70.45454545454545, "pass@1": 99.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = [x for sublist in zip(list1, list2, list3) for x in sublist]\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Input validation\n    assert len(list1) == len(list2) == len(list3), \"Lists should be of the same length.\"\n\n    # Interleave the lists and return\n    return [item for pair in zip(list1, list2, list3) for item in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list2) != len(list3) or len(list1) != len(list3):\n        return \"Input lists are not of the same length\"\n\n    result = []\n    for item1, item2, item3 in zip(list1, list2, list3):\n        result.append(item1)\n        result.append(item2)\n        result.append(item3)\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for pair in zip(list1, list2, list3) for item in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    # this function uses a list comprehension to interleave three lists\n    # the 'for' loop iterates through the indices of lst1\n    # 'i' is used to index into lst2 and lst3 at the corresponding index\n    # 'zip' function is used to create a single list of tuples, which is then flattened by the '*' operator\n    # the resulting flat list is returned by the function\n    return [item for sublist in zip(lst1, lst2, lst3) for item in sublist]\nlst1 = [1,2,3,4,5,6,7]\nlst2 = [10,20,30,40,50,60,70]\nlst3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    interleaved_list = []\n    for i in range(len(lst1)):\n        interleaved_list.extend([lst1[i], lst2[i], lst3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 83.0, "profiled": [{"solution": "def split_Arr(lst, n):\n    # Split the list at nth index and store the two parts.\n    left = lst[:n]\n    right = lst[n:]\n\n    # Combine the right part with the left part and return the result.\n    return right + left", "matching_cluster_idx": 6}, {"solution": "def split_Arr(list, n):\n    return list[n:] + list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(list, n):\n    return list[n:] + list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n == 0:\n        return arr\n    else:\n        return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Use python's slicing to split the list\n    sliced_lst = lst[n:] + lst[:n]\n    return sliced_lst", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    split_part = input_list[:n]\n    remainder = input_list[n:]\n    return remainder + split_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Splitting the array at the nth element\n    split_list = arr[n:] + arr[:n]\n    return split_list", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    split_lst = lst[n:] + lst[:n]\n    return split_lst", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Extract the first n elements\n    first_part = lst[:n]\n    # Extract the rest of the elements\n    second_part = lst[n:]\n    # Concatenate the second part with the first part\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Using slicing\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list at the nth element\n    split_list = arr[n:] + arr[:n]\n    return split_list", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 95.60810810810811, "dps_norm": 98.75, "pass@1": 80.0, "profiled": [{"solution": "def list_tuple(l):\n    return tuple(l)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list_to_convert):\n    return tuple(list_to_convert)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a given list to a tuple.\n    :param lst: list to be converted\n    :return: tuple created from the list\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(l):\n    \"\"\"\n    This function takes a list as an input and returns a tuple.\n    \"\"\"\n    return tuple(l)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Function to convert a list to a tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Function that converts a given list to a tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    This function converts a list into a tuple\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(lst):\n    \"\"\"\n    This function takes a list of integers as an input and returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of integers\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n\n    if lst:   # Check if the list is not empty\n        return max(lst) - min(lst)\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if lst:\n        return max(lst) - min(lst)\n    return 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if lst: # checking if the list is not empty\n        return max(lst) - min(lst)\n    else:\n        return 0 # return 0 if list is empty", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if lst: \n        return max(lst) - min(lst)\n    else:\n        return 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest value in a list.\n    \"\"\"\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if len(lst) > 0:\n        return max(lst) - min(lst)\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:  # if list is empty\n        return None\n    else:\n        return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Args:\n    lst: list of integers or floats\n\n    Returns:\n    difference: the difference between the maximum and minimum values in the list\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The provided list is empty.\")\n    else:\n        difference = max(lst) - min(lst)\n        return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if len(lst) == 0:\n        return 0\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if lst:\n        return max(lst) - min(lst)\n    else:\n        return 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    This function takes in a list of numbers and returns the\n    difference between the largest and smallest numbers.\n\n    Args:\n    nums (list): A list of numbers.\n\n    Returns:\n    int: The difference between the largest and smallest numbers.\n\n    \"\"\"\n    if nums:\n        return max(nums) - min(nums)\n    else:\n        return 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/597": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 46.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Function to find kth element from the given two sorted arrays.\n    \"\"\"\n    # Concatenate both lists and sort them\n    merged_list = sorted(arr1 + arr2)\n    \n    # Return kth element (index starts from 0)\n    return merged_list[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine the arrays and sort\n    merged_arr = sorted(arr1 + arr2)\n    # Check if k is within the range of merged array\n    if k <= len(merged_arr):\n        return merged_arr[k-1]  # Return kth element\n    else:\n        return \"k is out of range\"", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged_arr = sorted(arr1 + arr2)  # merges and sorts the two lists\n    return merged_arr[k - 1]  # returns the kth element", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine two sorted lists\n    combined_list = sorted(arr1 + arr2)\n    # Check if 'k' is within list bounds\n    if 0 < k <= len(combined_list):\n        return combined_list[k - 1]\n    else:\n        return 'Please provide a valid k. It should be greater than 0 and less than or equal to size of combined lists.'", "matching_cluster_idx": 3}, {"solution": "def find_kth(array1, array2, k):\n    \"\"\"\n    Find kth element from the given two sorted arrays.\n    \"\"\"\n    merged_array = sorted(array1 + array2)\n    if k <= len(merged_array):\n        return merged_array[k-1]\n    else:\n        return \"kth element does not exist\"", "matching_cluster_idx": 3}, {"solution": "def find_kth(list1, list2, k):\n    \"\"\"Return the kth smallest number from two sorted arrays.\"\"\"\n    merged_list = sorted(list1 + list2)  # Merge and sort the two lists.\n    return merged_list[k-1]  # Return the kth smallest element.", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    This function takes two sorted arrays arr1 and arr2 and the kth element as input.\n    It merges the two arrays and returns the kth element.\n    \"\"\"\n    merged_arr = sorted(arr1 + arr2) # Merging the two arrays and sorting\n    if k > len(merged_arr): # If k is greater than length of merged array\n        return None\n    else:\n        return merged_arr[k - 1] # Return kth element", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two lists\n    merged = sorted(arr1 + arr2)\n    # Return the kth element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(array1, array2, k):\n    result = sorted(array1 + array2)\n    if k > len(result):\n        return None\n    else:\n        return result[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = arr1 + arr2\n    merged.sort()\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(list1, list2, k):\n    # Combine both lists into one and sort\n    combined_list = sorted(list1 + list2)\n    # Return kth element\n    return combined_list[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(array1, array2, k):\n    # merge two sorted lists into one sorted list\n    merged_list = sorted(array1 + array2)\n    # return kth element\n    return merged_list[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(array1, array2, k):\n    result = array1 + array2\n    result.sort()\n    return result[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Initial check\n    if len(arr1) + len(arr2) < k or k <= 0:\n        return \"Invalid input.\"\n    \n    # Merge the two arrays\n    arr = arr1 + arr2\n    \n    # Sort the merged array\n    arr.sort()\n    \n    # Return kth element\n    return arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Returns kth element from the merged sorted arrays.\n    :param arr1: Sorted array.\n    :param arr2: Sorted array.\n    :param k: Index of the element to return.\n    :return: Kth element.\n    \"\"\"\n    # Merging two sorted arrays into one\n    merged = sorted(arr1 + arr2)\n    # Returning kth element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(list1, list2, k):\n    #Merge the two lists\n    merged_list = list1 + list2\n    #Sort the merged list\n    merged_list.sort()\n    #Return the kth element\n    return merged_list[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged_list = sorted(arr1 + arr2)\n    if k > len(merged_list):\n        return None\n    else:\n        return merged_list[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    # Merge sorted lists\n    merged_list = sorted(nums1 + nums2)\n\n    # Find kth element\n    kth_element = merged_list[k-1] if 0 < k <= len(merged_list) else None\n\n    return kth_element", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find kth element from the given two sorted arrays\n    :param arr1: list\n    :param arr2: list\n    :param k: int\n    :return: int\n    \"\"\"\n    # merge the two arrays\n    merged_array = sorted(arr1 + arr2)\n    \n    # return the kth element\n    return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = arr1 + arr2\n    merged.sort()\n    return merged[k - 1] if k-1 < len(merged) else None", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 90.45454545454545, "dps_norm": 98.0, "pass@1": 50.0, "profiled": [{"solution": "def reverse_words(s):\n    \"\"\"\n    Returns the string with words reversed in position.\n    \"\"\"\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    words = string.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    # split the string into words and reverse the list of words\n    reversed_words = input_str.split()[::-1]\n    # join the reversed words back together\n    result = \" \".join(reversed_words)\n    return result", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = \" \".join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n    return ' '.join(reversed(text.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Function to reverse the words in a string separated by spaces\n    \"\"\"\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    return \" \".join(string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Splitting the string into list of words.\n    words = s.split()\n    # Reversing the list of words.\n    words = words[::-1]\n    # Joining the list back into a string.\n    s = ' '.join(words)\n    return s", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    words = string.split()  # Splitting the string into words\n    reversed_words = words[::-1]  # Reversing the list of words\n    return ' '.join(reversed_words)  # Joining the words back into a single string with spaces", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string by spaces and reverse the list of words\n    reversed_words = s.split()[::-1]\n    # Join the reversed words back into a string with spaces\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 73.73188405797102, "dps_norm": 73.57142857142857, "pass@1": 24.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Function to remove the kth element from a list.\n    \n    Parameters:\n        lst (list): List of elements.\n        k (int): Position of the element to remove.\n        \n    Returns:\n        List with kth element removed.\n    \"\"\"\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    if 0 < k <= len(input_list):\n        input_list.pop(k - 1)\n    return input_list", "matching_cluster_idx": 5}, {"solution": "def remove_kth_element(lst, k):\n    if k > 0 and k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    del lst[k-1]  # because Python uses 0-based indexing\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if 1 <= k <= len(lst):\n        lst.pop(k-1)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Takes a list and an integer, removes the k'th element\n    \"\"\"\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(input_list, k):\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    if 1 <= k <= len(input_list):\n        return input_list[:k-1] + input_list[k:]\n    else:\n        return \"Invalid value of k\"", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(list, k):\n    return list[:k-1] + list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 70.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # firstly, check if n is within the column index of the matrix\n    if n < len(matrix[0]):\n        # return the maximum value in the nth column of the matrix\n        return max(row[n] for row in matrix)\n    else:\n        return \"Error: n is out of range.\"", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # use list comprehension to get the nth column\n    column = [row[n] for row in matrix]\n    # return the max of the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Return the max of the n'th column in the matrix.\"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\n    \"\"\"\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the nth column\n    column = [row[n] for row in matrix]\n    # Return the max of the nth column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    #return max(x[n-1] for x in matrix)\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Get the column with index 'n' from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum element in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 78.93518518518518, "dps_norm": 75.69444444444444, "pass@1": 18.0, "profiled": [{"solution": "def replace_spaces(input_string):\n    output_string = \"\"\n    for character in input_string:\n        if character == \" \":\n            output_string += \"_\"\n        elif character == \"_\":\n            output_string += \" \"\n        else:\n            output_string += character\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces all whitespaces in the input string with underscores.\n    And replaces all underscores with whitespaces.\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    if \" \" in input_string:\n        return input_string.replace(\" \", \"_\")\n    else:\n        return input_string.replace(\"_\", \" \")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    # replacing white spaces with underscore\n    if ' ' in s:\n        s = s.replace(' ', '_')\n    # replacing underscores with white spaces\n    elif '_' in s:\n        s = s.replace('_', ' ')\n    return s", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    if '_' in s:\n        return s.replace('_', ' ')\n    else:\n        return s.replace(' ', '_')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    if ' ' in s:\n        return s.replace(' ', '_')\n    else:\n        return s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    if '_' in s:\n        s = s.replace('_', ' ')\n    else:\n        s = s.replace(' ', '_')\n    return s", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_str):\n    if \" \" in input_str:\n        output_str = input_str.replace(\" \", \"_\")\n    else:\n        output_str = input_str.replace(\"_\", \" \")\n    return output_str", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_str):\n    if \" \" in input_str:\n        output_str = input_str.replace(\" \", \"_\")\n    else:\n        output_str = input_str.replace(\"_\", \" \")\n    return output_str", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(text):\n    #Replace underscore with space\n    if \"_\" in text:\n        return text.replace(\"_\", \" \")\n    #Replace space with underscore\n    else:\n        return text.replace(\" \", \"_\")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    output_string = ''\n    for char in input_string:\n        if char == ' ':\n            output_string += '_'\n        elif char == '_':\n            output_string += ' '\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    result = \"\"\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    if ' ' in input_string:\n        return input_string.replace(' ', '_')\n    else:\n        return input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(string):\n    # Replace spaces with underscore\n    if ' ' in string:\n        new_string = string.replace(' ', '_')\n    # Replace underscores with spaces\n    elif '_' in string:\n        new_string = string.replace('_', ' ')\n    else:\n        new_string = string\n    return new_string", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_str):\n    if '_' in input_str:\n        output_str = input_str.replace('_', ' ')\n    else:\n        output_str = input_str.replace(' ', '_')\n\n    return output_str", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}]}, "Mbpp/632": {"dps": 95.1219512195122, "dps_norm": 97.14285714285714, "pass@1": 95.0, "profiled": [{"solution": "def move_zero(lst):\n    count = 0\n    for i in range(len(lst)):\n        if lst[i] != 0:\n            lst[count] = lst[i]\n            count += 1\n    while count < len(lst):\n        lst[count] = 0\n        count += 1\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    non_zero = [num for num in nums if num != 0]\n    zero = [num for num in nums if num == 0]\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    for i in lst:\n        if i == 0:\n            lst.remove(i)\n            lst.append(i)\n    return lst", "matching_cluster_idx": 2}, {"solution": "def move_zero(numbers):\n    # create a list of non-zero numbers\n    no_zeroes = [i for i in numbers if i != 0]\n    \n    # create a list of zeroes with length equals to the number of zeroes in the original list\n    zeroes = [0]*numbers.count(0)\n    \n    # concatenate no_zeroes and zeroes lists\n    return no_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # count the number of zeros\n    zeros = lst.count(0)\n    # remove all zeros from the list\n    lst = [x for x in lst if x != 0]\n    # add zeros at the end of the list\n    lst.extend([0]*zeros)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    \n    # Remove the zeroes from the list\n    lst = [i for i in lst if i != 0]\n    \n    # Append zero_count number of zeroes to the end of the list\n    lst.extend([0]*zero_count)\n    \n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # create a new list containing only the non-zero elements\n    no_zeros = [i for i in lst if i != 0]\n    # create a new list containing only the zeros\n    zeros = [i for i in lst if i == 0]\n    # join the two lists to get the final result\n    result = no_zeros + zeros\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(numbers):\n    non_zeros = [num for num in numbers if num != 0]\n    zeros = [num for num in numbers if num == 0]\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # We use two pointers (i and j) to move non-zero elements to the front of the list\n    i = 0  # Pointer 1\n    j = 0  # Pointer 2\n\n    while j < len(lst):\n        if lst[j] != 0:\n            lst[i], lst[j] = lst[j], lst[i]  # Swap non-zero elements to the front\n            i += 1\n        j += 1\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(numbers):\n    non_zero = [num for num in numbers if num != 0]\n    zero = [num for num in numbers if num == 0]\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    :param lst: A list of integers.\n    :return: The same list but with all zeros moved to the end.\n    \"\"\"\n    # Count the number of zeroes.\n    num_zero = lst.count(0)\n    # Remove all zeroes from the list.\n    lst = [num for num in lst if num != 0]\n    # Append the number of zeroes to the end of the list.\n    lst.extend([0] * num_zero)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a new list to hold the non-zero numbers\n    no_zeros = [num for num in nums if num != 0]\n    # Create a new list to hold the zero numbers\n    zeroes = [num for num in nums if num == 0]\n    # Combine the non-zero list and the zero list\n    return no_zeros + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements into a new list\n    non_zeros = [i for i in lst if i != 0]\n    \n    # Separate zeros into a new list\n    zeros = [i for i in lst if i == 0]\n    \n    # Combine non-zero elements with zeros\n    result = non_zeros + zeros\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    no_zero = [i for i in lst if i != 0]\n    count = len(lst) - len(no_zero)\n    no_zero.extend([0] * count)\n    return no_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Count of non-zero elements\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            # replace non-zero with count incrementing\n            nums[count] = nums[i]\n            count += 1\n    # Make all elements from count to end as 0\n    while count < len(nums):\n        nums[count] = 0\n        count += 1\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # List comprehension to collect all non-zero elements first, followed by zeros\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    This function moves all zeroes to the end of the list.\n    Args:\n    input_list: List of integers.\n\n    Returns:\n    List with zeroes moved to the end.\n    \"\"\"\n    # Count of non-zero elements\n    non_zero_count = sum(i != 0 for i in input_list)\n\n    # Updating the list with all non-zero elements before the 0's\n    input_list[:non_zero_count] = [i for i in input_list if i != 0]\n\n    # Appending the number of 0's in the end\n    input_list[non_zero_count:] = [0] * (len(input_list) - non_zero_count)\n\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Filter out all zeroes and concatenate with the filtered zeroes\n    return [i for i in lst if i != 0] + [0] * lst.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [num for num in lst if num != 0] + [0] * lst.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    return [i for i in arr if i != 0] + [0]*(arr.count(0))", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 38.0, "profiled": [{"solution": "def pair_xor_Sum(arr, n):\n    sum = 0\n    for i in range(0,n):\n        for j in range(i+1,n):\n            sum += arr[i] ^ arr[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += lst[i] ^ lst[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, N):\n    if N <= 0:\n        return 0\n\n    XOR_SUM = 0\n\n    for i in range(N):\n        for j in range(i+1, N):\n            XOR_SUM += nums[i] ^ nums[j]\n\n    return XOR_SUM", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, length):\n    sum = 0\n    for i in range(length):\n        for j in range(i + 1, length):\n            sum += numbers[i] ^ numbers[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    total = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total += lst[i] ^ lst[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += (nums[i] ^ nums[j])\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, l):\n    xor_sum = 0\n    for i in range(l):\n        for j in range(i + 1, l):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum += (lst[i] ^ lst[j])\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += nums[i] ^ nums[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            res += nums[i] ^ nums[j]\n    return res", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(list, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum += list[i] ^ list[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += lst[i] ^ lst[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(list, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += list[i] ^ list[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum += nums[i] ^ nums[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, length):\n    sum = 0\n    for i in range(length):\n        for j in range(i+1, length):\n            sum += (lst[i] ^ lst[j])\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    # Initialize the sum\n    res = 0\n    for i in range(n):\n        # Compute the XOR with the rest\n        for j in range(i+1, n):\n            # Update the sum\n            res += nums[i] ^ nums[j]\n    return res", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(list_of_numbers, pairs):\n    \"\"\"\n    Calculate sum of xor of all pairs in the list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(pairs):\n        for j in range(i+1, pairs):\n            xor_sum += list_of_numbers[i] ^ list_of_numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += lst[i] ^ lst[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, length):\n    xor_Sum = 0\n    for i in range(length):\n        for j in range(i+1, length):\n            xor_Sum += lst[i] ^ lst[j]\n    return xor_Sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 80.77127659574467, "dps_norm": 81.0, "pass@1": 80.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    if k < 1 or k > len(arr):\n        return \"Invalid position\"\n    arr[0:k] = arr[0:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(array, k):\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[0:k] = arr[0:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Check if k is within the array's range\n    if k > len(arr) or k < 1:\n        return arr\n    \n    # Reverse upto position k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(input_array, k):\n    return input_array[:k][::-1] + input_array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    # If the array is empty or the k value is greater than length of the array, return the array as is.\n    if len(array) == 0 or k > len(array):\n        return array\n    else:\n        return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    if k <= len(array):\n        temp = array[:k]\n        temp = temp[::-1]\n        result = temp + array[k:]\n        return result\n    else:\n        print(\"Error: Value of 'K' should be less than or equal to the length of the array.\")", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the list\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(array, k):\n    if k > len(array):\n        raise ValueError('K is greater than the length of the array')\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    A function to reverse the array up to a given position 'k'.\n    \"\"\"\n    if k > len(arr):\n        return arr\n    else:\n        arr[:k] = reversed(arr[:k])\n        return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(array, k):\n    # Check if the given position is valid.\n    if k > len(array) or k < 1:\n        return \"Invalid position. Please provide a position between 1 and length of array.\"\n    else:\n        # Reverse the sub-array from the start till kth position.\n        array[:k] = array[:k][::-1]\n        return array", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Ensure that K is valid\n    if k < 1 or k > len(arr):\n        raise ValueError(\"Invalid value for k. Must be between 1 and size of array.\")\n    \n    # Split the array into two halves up to position K\n    first_half = arr[:k]\n    second_half = arr[k:]\n\n    # Reverse the first half and join the second half to get the result\n    result = first_half[::-1] + second_half\n    return result", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    n = len(arr)\n    if k > n:\n        return \"K is larger than the length of the array.\"\n    elif k <= 0:\n        return \"K must be a positive integer.\"\n    else:\n        new_arr = arr[:k][::-1] + arr[k:]\n        return new_arr", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array from index 0 to k-1\n    arr[:k] = arr[:k][::-1]\n    \n    # Return the updated array\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(array, k):\n    array[:k] = array[:k][::-1]\n    return array", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(array, k):\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first K elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}]}, "Mbpp/720": {"dps": 84.61538461538461, "dps_norm": 95.0, "pass@1": 99.0, "profiled": [{"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    This function takes a tuple and a dictionary as inputs, \n    and returns a new tuple which is the original tuple with \n    the dictionary appended to it as the last element.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    # Convert the tuple to a list for easier manipulation\n    list_t = list(t)\n    # Append the dictionary to the list\n    list_t.append(d)\n    # Convert the list back to a tuple\n    return tuple(list_t)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dic):\n    # Convert the tuple to a list\n    list_tup = list(tup)\n\n    # Append the dictionary to the list\n    list_tup.append(dic)\n\n    # Convert the list back to a tuple\n    tup = tuple(list_tup)\n\n    # Return the resulting tuple\n    return tup", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, diction):\n    tup = list(tup)\n    tup.append(diction)\n    return tuple(tup)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_obj, dict_obj):\n    return tuple_obj + (dict_obj,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    tup = list(tup)\n    tup.append(dictionary)\n    tup = tuple(tup)\n    return tup", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    \"\"\"Adds a dictionary to the tuple and returns the new tuple.\"\"\"\n    new_tpl = tpl + (dct,)\n    return new_tpl", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    new_tup = tup + (dic,)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_, dict_):\n    return tuple_ + (dict_,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dictionary):\n    return tpl + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    # Concatenate the tuple with the dictionary\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    output_tuple = input_tuple + (input_dict,)\n    return output_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(my_tuple, my_dict):\n    return my_tuple + (my_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    tpl_plus_dct = tpl + (dct,)\n    return tpl_plus_dct", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    # Convert tuple to list\n    tup_list = list(tup)\n    \n    # Add dictionary to list\n    tup_list.append(dic)\n    \n    # Convert list back to tuple\n    new_tup = tuple(tup_list)\n    \n    return new_tup", "matching_cluster_idx": 3}]}, "Mbpp/725": {"dps": 85.02732240437157, "dps_norm": 80.625, "pass@1": 98.0, "profiled": [{"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = re.compile(r'\"(.*?)\"')\n    return [match.group(1) for match in pattern.finditer(s)]", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    This function takes a string as an argument and returns a list of values\n    between quotation marks in the string.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all the matches and return them as a list\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    quotes_value = re.findall('\"([^\"]*)\"', input_string)\n    return quotes_value", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(text):\n    import re\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall('\"([^\"]*)\"', string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(string):\n    import re\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    # Using regular expressions to find all quoted values\n    quoted_values = re.findall(r'\"([^\"]*)\"', s)\n    return quoted_values", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    # using regular expression to find all matches in the string\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    # Using Regular Expression to find strings inside quotation marks\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}]}, "Mbpp/732": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def replace_specialchar(string):\n    return string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    replaced_string = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return replaced_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':')\n    s = s.replace(',', ':')\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(sentence):\n    sentence = sentence.replace(\" \", \":\")\n    sentence = sentence.replace(\",\", \":\")\n    sentence = sentence.replace(\".\", \":\")\n    return sentence", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    new_string = input_string.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")\n    return new_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(str):\n    return str.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    text = text.replace(' ', ':')\n    text = text.replace(',', ':')\n    text = text.replace('.', ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(sentence):\n    new_sentence = sentence.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return new_sentence", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    return string.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\" Replaces spaces, commas and dots with colon in the input string \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    return input_str.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    specialchars = ['.', ',', ' ']\n    for char in specialchars:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    for char in ['.', ',', ' ']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    return input_str.replace(',', ':').replace('.', ':').replace(' ', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(\",\", \":\").replace(\".\", \":\").replace(\" \", \":\")", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 88.54545454545455, "dps_norm": 76.66666666666667, "pass@1": 99.0, "profiled": [{"solution": "def tuple_to_dict(t):\n    # Ensure that the tuple length is even (otherwise, zip would fail)\n    if len(t)%2 != 0:\n        t = t[:-1]\n    \n    # Convert the tuple to dictionary using zip with two elements each as a key and value\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    # Ensure the length of tuple is even, otherwise cannot form key-value pairs\n    if len(tup)%2 != 0:\n        raise ValueError(\"Tuple length should be even to form key-value pairs\")\n\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(my_tuple):\n    return {my_tuple[i]: my_tuple[i+1] for i in range(0, len(my_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        return \"Error: Tuple length should be even.\"\n\n    dic = {}\n    for i in range(0, len(tup), 2):\n        dic[tup[i]] = tup[i+1]\n\n    return dic", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # check that the number of elements in the tuple is even\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"The input tuple has an odd number of elements\")\n    else:\n        # create an empty dictionary\n        output_dict = {}\n        # iterate over every two elements in the tuple\n        for i in range(0, len(input_tuple), 2):\n            # add these two elements as a key-value pair to the dictionary\n            output_dict[input_tuple[i]] = input_tuple[i+1]\n        return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # checking if the length of the tuple is even\n    if len(input_tuple) % 2 == 0:\n        # using dict comprehension to convert the tuple to a dictionary\n        return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}\n    else:\n        # if length is not even, return an empty dictionary\n        return {}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tpl):\n    return {tpl[i]: tpl[i + 1] for i in range(0, len(tpl), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements\")\n\n    result = {}\n    for i in range(0, len(input_tuple), 2):\n        result[input_tuple[i]] = input_tuple[i+1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tpl):\n    if len(tpl) % 2 != 0:\n        raise ValueError(\"Odd number of elements in the tuple. Cannot create a key-value dictionary.\")\n    return {tpl[i]: tpl[i+1] for i in range(0, len(tpl), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError('Tuple must have an even number of elements')\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}]}, "Mbpp/744": {"dps": 89.07534246575342, "dps_norm": 92.5, "pass@1": 100.0, "profiled": [{"solution": "def check_none(tpl):\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    if None in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    # The any() function returns True if at least one element of an iterable is True.\n    # If not, it returns False.\n    # Here, we pass a generator expression that returns True if the element is None.\n    # If an element is None, the expression is True, otherwise it's False.\n    return any(val is None for val in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(my_tuple):\n    return any(value is None for value in my_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    This function checks if the given tuple has any None value\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple):\n    if None in tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_to_check):\n    return None in tuple_to_check", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple):\n    return None in tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any none value.\n\n    :param tup: The tuple to check.\n    :type tup: tuple\n    :return: True if the tuple contains any None value, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    for item in t:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    This function checks if the given tuple has any None value or not.\n\n    Arguments:\n    t (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tpl):\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    if None in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 69.25170068027211, "dps_norm": 68.33333333333333, "pass@1": 98.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    # Add the elements of tuple to the end of list\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Function to add a tuple to a list\n    Args:\n        lst (List): List of integers.\n        tup (Tuple): Tuple of integers.\n    Returns:\n        lst (List): Updated list with the integers from the tuple added.\n    \"\"\"\n    # Convert tuple to a list and then extend the original list\n    lst.extend(list(tup))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Function to add the given tuple to the given list.\n    :param lst: The given list.\n    :param tpl: The given tuple.\n    :return: The list after adding the tuple.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Use the extend() method to add elements from tup to lst\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    #Appends the tuple to the list\n    input_list.extend(input_tuple)\n    return input_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(my_list, my_tuple):\n    return my_list + list(my_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    # Check if inputs are of valid types\n    if not isinstance(lst, list) or not isinstance(tpl, tuple):\n        raise ValueError(\"Both inputs must be of list and tuple types.\")\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_, tuple_):\n    # If tuple_ is a sequence (list, tuple, etc.), extend the list_ with it.\n    # Otherwise, just append tuple_ to the list_.\n    if hasattr(tuple_, \"__iter__\"):\n        list_.extend(tuple_)\n    else:\n        list_.append(tuple_)\n\n    return list_", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(my_list, my_tuple):\n    # Adding tuple to list using extend method\n    my_list.extend(my_tuple)\n    return my_list", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 92.51677852348993, "dps_norm": 73.75, "pass@1": 92.0, "profiled": [{"solution": "def min_k(tuple_list, k):\n    return sorted(tuple_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(data, k):\n    return sorted(data, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(record_list, k):\n    record_list.sort(key=lambda x: x[1])  # Sort the list based on the value (second element in tuple)\n    return record_list[:k]  # Return the first k elements of the sorted list", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    return sorted(lst, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on second element in each tuple\n    sorted_records = sorted(records, key = lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    # sort the list in ascending order based on the second element in tuple\n    sorted_lst = sorted(lst, key=lambda x: x[1])\n    # return first k elements\n    return sorted_lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tup_list, k):\n    return sorted(tup_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    \"\"\" Function to find minimum k records from tuple list.\n    Arguments:\n        tuples {list} -- list of tuples\n        k {int} -- number of minimum records to find\n\n    Returns:\n        list -- list of minimum k records\n    \"\"\"\n    if k > len(tuples):\n        raise ValueError('K is larger than the length of the list.')\n    \n    # Sort the list by the second element of each tuple.\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    \n    # Return first k elements from sorted list.\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    return sorted(lst, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    # Sorting the list of tuples based on the second item in tuple\n    sorted_lst = sorted(lst, key=lambda x: x[1])\n    # Returning first k items from the sorted list\n    return sorted_lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    return sorted(tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # First we sort the list of tuples by the second value of each tuple\n    # This way, we ensure that all tuples with the smallest second value come first.\n    # Then we return the first k tuples from the sorted list.\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # sort the list by the second element of the tuple in ascending order\n    sorted_records = sorted(records, key=lambda record: record[1])\n    # return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list, k):\n    list.sort(key=lambda x: x[1])\n    return list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    # sort the list based on the second element (record value)\n    lst = sorted(lst, key = lambda x: x[1])\n    \n    # return the first k elements (minimum k records)\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list, k):\n    return sorted(list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    # Sort the list based on the second element of each tuple\n    # This will place tuples with smaller second element first\n    lst.sort(key = lambda x: x[1])\n\n    # Return the first 'k' elements from the list\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_of_tuples, k):\n    list_of_tuples.sort(key=lambda x: x[1])\n    return list_of_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list, k):\n    return sorted(list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 91.20689655172414, "dps_norm": 89.375, "pass@1": 25.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common = [i for i, j, k in zip(l1, l2, l3) if i == j == k]\n    return common", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common.append(l1[i])\n    return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # the built-in zip function combines lists into tuples at the same indexes.\n    # Then, the next function compares the tuples' elements and returns a list of common elements.\n    common = [a for a, b, c in zip(l1, l2, l3) if a == b == c]\n    return common", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    length = min(len(l1), len(l2), len(l3))\n    for i in range(length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = [a for a, b, c in zip(l1, l2, l3) if a == b == c]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for idx in range(min(len(l1), len(l2), len(l3))):\n        if l1[idx] == l2[idx] == l3[idx]:\n            common_elements.append(l1[idx])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 68.53982300884955, "dps_norm": 81.66666666666667, "pass@1": 27.0, "profiled": [{"solution": "def second_smallest(numbers):\n    \"\"\"\n    This function finds the second smallest number in a list\n    :param numbers: list of numbers\n    :return: the second smallest number\n    \"\"\"\n    # handling edge case\n    if len(numbers) < 2:\n        return None\n\n    # initializing first and second smallest number as infinity\n    first, second = float('inf'), float('inf')\n\n    # iterating over the list\n    for num in numbers:\n        # updating first and second smallest number if the number is smaller than first or second\n        if num < first:\n            second, first = first, num\n        elif first < num < second:\n            second = num\n\n    # if there was no change of second after the iteration (i.e., all numbers in the list were equal), return None\n    if second == float('inf'):\n        return None\n\n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    if len(numbers)<2:\n        return None\n    else:\n        numbers=list(set(numbers))\n        numbers.sort()\n        if len(numbers)<2:\n            return None\n        else:\n            return numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates\n    numbers = list(set(numbers))\n\n    # If the list contains less than 2 unique numbers\n    if len(numbers) < 2:\n        return None\n\n    # Sort the list and return the second element\n    numbers.sort()\n    return numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(num_list):\n    num_list = list(set(num_list))\n    num_list.sort()\n    if len(num_list) < 2:\n        return None\n    else:\n        return num_list[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # first sort the list in ascending order\n    sorted_nums = sorted(numbers)\n    # then find the second smallest number by looping through the list\n    # and checking if the current number is smaller than the second smallest\n    second_smallest_number = None\n    for num in sorted_nums:\n        if num > sorted_nums[0] and (second_smallest_number is None or num < second_smallest_number):\n            second_smallest_number = num\n    return second_smallest_number", "matching_cluster_idx": 0}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    This function returns the second smallest number in a list.\n    \"\"\"\n    # Sort the list and remove duplicates\n    numbers = list(set(numbers))\n    numbers.sort()\n    \n    # If there's a least two elements in the list\n    if len(numbers) > 1:\n        return numbers[1]\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Function to find the second smallest number in a list.\n    It first removes duplicates from the list, sorts them in ascending order and returns the second element (index 1).\n    \"\"\"\n    # First remove duplicates\n    numbers = list(set(numbers))\n\n    # If there's only one unique number in the list, return None\n    if len(numbers) < 2:\n        return None\n    else:\n        numbers.sort()\n        return numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums.sort()\n    unique_nums = list(set(nums))\n    unique_nums.sort()\n    if len(unique_nums) <= 1:\n        return None\n    else:\n        return unique_nums[1]", "matching_cluster_idx": 2}, {"solution": "def second_smallest(nums):\n    nums.sort()\n    for num in nums:\n        if num > nums[0]:\n            return num\n    return None", "matching_cluster_idx": 2}, {"solution": "def second_smallest(nums):\n    # Remove duplicate numbers in the list\n    nums = list(set(nums))\n    # Handle the case where the list contains less than 2 elements\n    if len(nums) < 2:\n        return None\n    # Sort the list in ascending order\n    nums.sort()\n    # Return the second element\n    return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_lst = list(set(lst))\n    unique_lst.sort()\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    first, second = float('inf'), float('inf')\n    for number in numbers:\n        if number < first:\n            first, second = number, first\n        elif number < second and number != first:\n            second = number\n    return second if second != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))  # remove duplicates\n    if len(nums) < 2:\n        return None  # not enough distinct numbers in the list\n    smallest = second_smallest = float('inf')\n    for num in nums:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif second_smallest > num > smallest:\n            second_smallest = num\n    return second_smallest if second_smallest < float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    numbers.sort()\n    unique_numbers = list(set(numbers))\n    unique_numbers.sort()\n    if len(unique_numbers) > 1:\n        return unique_numbers[1]\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Return the second smallest number in the list.\n    \"\"\"\n    first_min = second_min = float('inf')\n    for num in numbers:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif num < second_min and num != first_min:\n            second_min = num\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(num_list):\n    # Get unique numbers from list\n    unique_nums = list(set(num_list))\n    \n    # Check if we have more than one unique number\n    if len(unique_nums) < 2:\n        return None\n    \n    # Sort unique numbers and return the second one\n    unique_nums.sort()\n    return unique_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    if len(numbers)<2:\n        return None\n    first_min = second_min = float('inf')\n    for number in numbers:\n        if number < first_min:\n            second_min = first_min\n            first_min = number\n        elif first_min<number<second_min:\n            second_min = number\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))\n    if len(nums) < 2:\n        return None\n    nums.sort()\n    return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    lst = list(set(lst)) # remove duplicates\n    lst.sort() # sort the list\n    if len(lst) < 2:\n        return None # return None if there's not enough numbers\n    else:\n        return lst[1] # return the second smallest number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicate values\n    lst = list(set(lst))\n    \n    # If there are less than 2 unique numbers, return None\n    if len(lst) < 2:\n        return None\n    \n    # Otherwise, sort the list in ascending order and return the second item\n    else:\n        lst.sort()\n        return lst[1]", "matching_cluster_idx": 5}]}, "Mbpp/757": {"dps": 66.19937694704049, "dps_norm": 40.38461538461539, "pass@1": 12.0, "profiled": [{"solution": "def count_reverse_pairs(str_list):\n    reversed_pairs = 0\n    str_dict = {}\n    \n    for s in str_list:\n        if s[::-1] in str_dict:\n            reversed_pairs += str_dict[s[::-1]]\n            \n        if s not in str_dict:\n            str_dict[s] = 0\n        str_dict[s] += 1\n\n    return reversed_pairs", "matching_cluster_idx": 11}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1] or lst[j] == lst[i][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1] or lst[j] == lst[i][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(string_list):\n    counter = 0\n    dict_string = {}\n    for string in string_list:\n        reverse_string = string[::-1]\n        if reverse_string in dict_string:\n            counter += dict_string[reverse_string]\n        dict_string[string] = dict_string.get(string, 0) + 1\n    return counter", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    reverse_map = {}\n\n    for s in strings:\n        if s in reverse_map:\n            count += reverse_map[s]\n        reverse_map[s[::-1]] = reverse_map.get(s[::-1], 0) + 1\n\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_reverse_pairs(strings):\n    pairs = 0\n    length = len(strings)\n\n    for i in range(length):\n        for j in range(i+1, length):\n            if strings[i] == strings[j][::-1] or strings[j] == strings[i][::-1]:\n                pairs += 1\n\n    return pairs", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(word_list):\n    reverse_dict = {}\n    count = 0\n\n    for word in word_list:\n        if word in reverse_dict:\n            count += reverse_dict[word]\n        reverse_word = word[::-1]\n        if reverse_word in reverse_dict:\n            reverse_dict[reverse_word] += 1\n        else:\n            reverse_dict[reverse_word] = 1\n            \n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(input_list):\n    count = 0\n    for i in range(len(input_list)):\n        for j in range(i+1, len(input_list)):\n            if input_list[i] == input_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    n = len(lst)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n            if lst[j] == lst[i][::-1]:\n                count += 1\n    return count//2", "matching_cluster_idx": 0}]}, "Mbpp/758": {"dps": 93.1081081081081, "dps_norm": 85.625, "pass@1": 81.0, "profiled": [{"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        sub_tuple = tuple(sublist)\n        if sub_tuple in counts:\n            counts[sub_tuple] += 1\n        else:\n            counts[sub_tuple] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        if tuple(sublist) in result:\n            result[tuple(sublist)] += 1\n        else:\n            result[tuple(sublist)] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple not in counts:\n            counts[sublist_tuple] = 1\n        else:\n            counts[sublist_tuple] += 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    from collections import Counter\n    lst = [tuple(lst) for lst in lst]\n    counter = Counter(lst)\n    return dict(counter)", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublst in lst:\n        sublst_tuple = tuple(sublst)\n        if sublst_tuple in count_dict:\n            count_dict[sublst_tuple] += 1\n        else:\n            count_dict[sublst_tuple] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        else:\n            counts[tuple_sublist] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    result_dict = {}\n    for sublist in input_list:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result_dict:\n            result_dict[tuple_sublist] += 1\n        else:\n            result_dict[tuple_sublist] = 1\n    return result_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    unique_sublists = {}\n    for sub_list in lst:\n        tuple_sub_list = tuple(sub_list)\n        if tuple_sub_list in unique_sublists:\n            unique_sublists[tuple_sub_list] += 1\n        else:\n            unique_sublists[tuple_sub_list] = 1\n    return unique_sublists", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    count_dict = {}\n    for sublist in input_list:\n        tup = tuple(sublist)\n        if tup not in count_dict:\n            count_dict[tup] = 1\n        else:\n            count_dict[tup] += 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    dict = {}\n    for sublst in lst:\n        tuple_sublst = tuple(sublst)\n        if tuple_sublst in dict:\n            dict[tuple_sublst] += 1\n        else:\n            dict[tuple_sublst] = 1\n    return dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    dic = {}\n    for sub_list in lst:\n        sub_tuple = tuple(sub_list)\n        if sub_tuple in dic:\n            dic[sub_tuple] += 1\n        else:\n            dic[sub_tuple] = 1\n    return dic", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list):\n    count_dict = {}\n    for sublist in list:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    counts = defaultdict(int)\n    for sublist in lst:\n        counts[tuple(sublist)] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    output_dict = {}\n    for sublist in input_list:\n        tupled_sublist = tuple(sublist)\n        if tupled_sublist in output_dict:\n            output_dict[tupled_sublist] += 1\n        else:\n            output_dict[tupled_sublist] = 1\n    return output_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    d = {}\n    for sublist in lst:\n        t = tuple(sublist)\n        d[t] = d.get(t, 0) + 1\n    return d", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Create an empty dictionary\n    sublists_dict = {}\n\n    # Iterate over the input list\n    for sublist in lst:\n        # Convert each sublist to a tuple and check if it's in the dictionary\n        if tuple(sublist) not in sublists_dict:\n            # If not, add it to the dictionary with a count of 1\n            sublists_dict[tuple(sublist)] = 1\n        else:\n            # If it is, increment its count in the dictionary\n            sublists_dict[tuple(sublist)] += 1\n\n    # Return the dictionary\n    return sublists_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        # Convert list to tuple to ensure immutability\n        tuplified_sublist = tuple(sublist)\n        if tuplified_sublist in count_dict:\n            count_dict[tuplified_sublist] += 1\n        else:\n            count_dict[tuplified_sublist] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_dict = {}\n    for sublist in lst:\n        tup = tuple(sublist)\n        if tup in sublist_dict:\n            sublist_dict[tup] += 1\n        else:\n            sublist_dict[tup] = 1\n    return sublist_dict", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 71.0, "profiled": [{"solution": "def unique_Element(numbers):\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numList):\n    return len(set(numList)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Checking if the set of the list has only one element\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Using a set to remove duplicate values and check length\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    \"\"\"\n    Checks if a list has only one distinct element.\n    Returns True if it does, False otherwise.\n    \"\"\"\n    if len(set(num_list)) == 1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if a list contains only one unique element\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    This function takes a list as input and returns True if the list only contains one distinct element and False otherwise.\n    \"\"\"\n    if len(set(lst)) == 1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    A Python function to check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    nums: a list of numbers\n    \n    Returns:\n    True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return lst.count(lst[0]) == len(lst)", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    if len(set(lst)) == 1:\n        return True\n    return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    # Set datastructure removes duplicate values and\n    # hence if the length of the set is 1, all elements are same\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    ctr = 0\n    for char in s:\n        if char.isdigit():\n            ctr += 1\n    return ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    cnt = sum(c.isdigit() for c in str)\n    return cnt", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for character in input_string:\n        if character.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    return sum(c.isdigit() for c in str)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(1 for c in s if c.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    return sum(c.isdigit() for c in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for character in s:\n        if character.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    count = 0\n    for i in string:\n        if i.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 82.75700934579439, "dps_norm": 73.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(items):\n    return [(items[i], items[i+1]) for i in range(len(items)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i + 1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    :param lst: The list of items.\n    :return: A list of tuples, each containing two consecutive items in the given list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}]}, "Mbpp/775": {"dps": 71.63999999999999, "dps_norm": 49.285714285714285, "pass@1": 61.0, "profiled": [{"solution": "def odd_position(input_list):\n    for i in range(len(input_list)):\n        if i % 2 != 0 and input_list[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(list):\n    for i in range(len(list)):\n        if i % 2 != 0:\n            if list[i] % 2 == 0:\n                return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0:\n            if lst[i] % 2 == 0:\n                return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(list):\n    for i in range(len(list)):\n        if i % 2 != 0 and list[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(v % 2 == 1 for i, v in enumerate(lst) if i % 2 == 1)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(ele % 2 != 0 for i, ele in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # start at index 1, go by 2-increments, thus only checking every odd index\n        if lst[i] % 2 == 0:  # if the element at an odd index is even, return False\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(el % 2 != 0 for el in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(val % 2 == 1 for idx, val in enumerate(lst) if idx % 2 == 1)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(n % 2 != 0 for i, n in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(n % 2 == 1 for i, n in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(list_in):\n    return all(list_in[i] % 2 == 1 for i in range(len(list_in)) if i % 2 == 1)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(n % 2 == 1 for n in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    This function checks if every odd index in a list contains an odd number.\n    \"\"\"\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all([num % 2 != 0 for idx, num in enumerate(lst) if idx % 2 != 0])", "matching_cluster_idx": 2}, {"solution": "def odd_position(nums):\n    return all(nums[i] % 2 == 1 for i in range(1, len(nums), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for idx, val in enumerate(lst):\n        if idx % 2 != 0 and val % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": 94.36224489795919, "dps_norm": 96.11111111111111, "pass@1": 47.0, "profiled": [{"solution": "def find_sum(lst):\n    unique_elements = set(lst)\n    sum_non_repeat = sum(unique_elements)\n    return sum_non_repeat", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    unique_numbers = set(numbers)\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    return sum(set(arr))", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    arr_no_dup = list(set(arr))\n    return sum(arr_no_dup)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # If the list is empty, return 0\n    if not numbers:\n        return 0\n\n    # Convert list to set to remove duplicates\n    distinct_numbers = set(numbers)\n\n    # Return the sum of distinct numbers\n    return sum(distinct_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Convert the list to a set to remove duplicates\n    set_lst = set(lst)\n    # If there are repeated elements in the set, they are removed from the list\n    # The sum of non-repeated elements is then calculated\n    return sum(set_lst)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Convert list to set to get unique elements\n    unique_elements = set(lst)\n\n    # Sum the unique elements\n    sum_unique = sum(unique_elements)\n\n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    This function takes a list of integers as an input and returns the sum of all unique elements in the list.\n    \"\"\"\n    # convert the list to a set (sets only keep unique elements)\n    # then convert it back to list\n    unique_lst = list(set(lst))\n    \n    # sum the unique list\n    sum_unique = sum(unique_lst)\n    \n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    unique_values = set(lst)\n    return sum(unique_values)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(num_list):\n    unique_nums = set(num_list)\n    sum_unique_nums = sum(unique_nums)\n    return sum_unique_nums", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # create a set out of the list to remove duplicates and then add them up\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    no_repeat_elements = set(lst)\n    return sum(no_repeat_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    sum = 0\n    dict = {}\n    for i in lst:\n        if i not in dict:\n            dict[i] = 1\n            sum += i\n        else:\n            dict[i] += 1\n    return sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    return sum(x for x in set(lst))", "matching_cluster_idx": 5}, {"solution": "def find_sum(lst):\n    # Convert the list to a set to remove duplicate values and\n    # then convert it back to a list\n    non_repeated = list(set(lst))\n    \n    # Use the sum function to return the sum of non-repeated elements\n    return sum(non_repeated)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    This function takes a list as input and returns the sum of unique elements in the list.\n    \"\"\"\n    # Remove duplicates from the list\n    unique_elements = list(set(lst))\n    # Calculate the sum of the unique elements\n    sum_unique = sum(unique_elements)\n    return sum_unique", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 73.77952755905511, "dps_norm": 60.0, "pass@1": 80.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"Function to calculate the count of divisors of a number.\"\"\"\n    count = 0\n    i = 1\n    while i <= n:\n        if n % i == 0:\n            count += 1\n        i += 1\n    # If count is even, return True else return False\n    return count % 2 == 0", "matching_cluster_idx": -1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, int(num ** 0.5) + 1):\n        if num % i == 0:\n            if num / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(num):\n    divisors = 0\n    for i in range(1, num+1):\n        if num % i == 0:\n            divisors += 1\n    return divisors % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors += 1\n            if n // i != i:\n                divisors += 1\n    return divisors % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function checks if the count of the divisors of n is even or not.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i <= n ** 0.5:\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 2}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if n // i == i:  # square root is an integer, so the divisor is unique, thus count ++\n                count += 1\n            else:  # divisor pairs that multiply to form the number, so count += 2\n                count += 2\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \"\"\"\n    count = 0\n    i = 1\n    while(i <= n):\n        if (n % i == 0):\n            count += 1\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            count += 1\n            if i * i < n:\n                count += 1\n            i += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    # function to calculate the number of divisors of a number\n    def divisors_count(n):\n        count = 2  # one for 1 and the number itself\n        sqrt = int(n**0.5)\n        for x in range(2, sqrt + 1):\n            if n % x == 0:\n                count += 2  # x and n/x\n        return count if sqrt * sqrt != n else count - 1  # remove duplicates if sqrt is a divisor\n    \n    return divisors_count(n) % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function returns whether the number of divisors of n is even.\n    \"\"\"\n    if n == 0: \n        return False  # A number is not divisible by zero\n    else:\n        return len([i for i in range(1, n+1) if n % i == 0]) % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n            i += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"Function to count the number of divisors of a given number.\"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    # Create a variable to count the number of divisors\n    divisor_count = 0\n    # Loop through every number from 1 to n\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment the divisor count\n        if n % i == 0:\n            divisor_count += 1\n    # Check if the number of divisors is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            count += 1 if n // i == i else 2\n            i += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return len(divisors) % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"Check if the count of divisors is even.\"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, num+1):\n        if num % i == 0:\n            count += 1\n    if count % 2 == 0:\n        return True\n    else:\n        return False", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 94.0, "profiled": [{"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(str1):\n    return str1.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # Use the built-in replace() function to remove all spaces from the string\n    s = s.replace(' ', '')\n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n    return text.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces in a string\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # Removing all white spaces from the string.\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # return the input_string after replacing all whitespace characters with nothing\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Function to remove all whitespaces from a string.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Removes all spaces from a string.\n    >>> remove_all_spaces('python  program')\n    'pythonprogram'\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(str):\n    return str.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 95.0, "profiled": [{"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = float('-inf')\n    max_lst = None\n    for sublist in lst:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_lst = sublist\n    return max_lst", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = -float('inf')  # Initialize max sum to negative infinity\n    max_list = None  # Initialize max list to None\n\n    # Iterate over each sub-list in the given list\n    for sub_list in lst:\n        sub_sum = sum(sub_list)  # Calculate the sum of the current sub-list\n        # If the sum of the current sub-list is greater than the max sum so far, update max sum and max list\n        if sub_sum > max_sum:\n            max_sum = sub_sum\n            max_list = sub_list\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(input_list):\n    max_sum = float('-inf')\n    max_list = []\n    for lst in input_list:\n        if sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(l):\n    return max(l, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    max_sum = -float('inf')\n    max_sum_list = None\n    \n    for sublist in list_of_lists:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_sum_list = sublist\n    \n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    \"\"\"\n    Returns the list with the maximum sum of its elements.\n    \"\"\"\n    # Initialize the maximum sum and corresponding list to the first list in the list of lists.\n    max_sum = sum(lst[0])\n    max_list = lst[0]\n\n    # Loop through each list in the list of lists.\n    for l in lst:\n        # Check if the sum of the current list is higher than the current maximum sum.\n        if sum(l) > max_sum:\n            # If so, update the maximum sum and corresponding list.\n            max_sum = sum(l)\n            max_list = l\n\n    # Return the list with the maximum sum of elements.\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = -float('inf')\n    max_list = []\n    for sublist in lst:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_list = sublist\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Define a variable that will hold the maximum sum of elements of a sublist\n    max_sum = float('-inf')\n    \n    # Define a variable that will hold the sublist with the maximum sum of elements\n    max_sum_list = None\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Calculate the sum of the elements in the current sublist\n        sum_sublist = sum(sublist)\n        \n        # If the current sublist has a higher sum than the previous maximum\n        if sum_sublist > max_sum:\n            # Update the maximum sum and the sublist with the maximum sum\n            max_sum = sum_sublist\n            max_sum_list = sublist\n    \n    # Return the sublist with the maximum sum of elements\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"Return the list in a list of lists with the highest sum of elements.\"\"\"\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize maximum sum and the result list\n    max_sum = float('-inf')\n    result = []\n    \n    # Iterate over each list in the input list\n    for sub_list in lst:\n        # Calculate the sum of current sublist\n        curr_sum = sum(sub_list)\n        \n        # If the current sublist has a higher sum, update max_sum and result\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            result = sub_list\n            \n    return result", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 96.53508771929825, "dps_norm": 99.16666666666667, "pass@1": 92.0, "profiled": [{"solution": "def check_K(tpl, k):\n    if k in tpl:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    if k in tuple_input:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    This function checks if the given tuple contains the value of k or not.\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    return k in tpl", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuples contain the k.\n    :param tup: input tuple\n    :param k: value to check in the tuple\n    :return: boolean whether the k exists in the tuple or not\n    \"\"\"\n    if k in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the k\n    :param tup: Input tuple\n    :param k: the number to check\n    :return: True if k is in the tuple, False otherwise\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    if k in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple, k):\n    if k in tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple, k):\n    return k in tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple, k):\n    return k in tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_k, k):\n    \"\"\"\n    Function that checks if k is in the given tuple\n    \"\"\"\n    return k in tuple_k", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple1, k):\n    return k in tuple1", "matching_cluster_idx": 5}]}}}
