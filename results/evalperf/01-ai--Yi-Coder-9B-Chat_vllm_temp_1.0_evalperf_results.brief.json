{"date": "2024-10-19 16:28", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 83.60305818801254, "dps_norm": 78.76801867108128, "pass@1": 78.80508474576271}, "eval": {"HumanEval/9": {"dps": 70.56782334384857, "dps_norm": 65.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    max_num = numbers[0]\n\n    for number in numbers[1:]:\n        max_num = max(number, max_num)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_numbers = [numbers[0]]\n\n    for num in numbers[1:]:\n        max_numbers.append(max(max_numbers[-1], num))\n\n    return max_numbers", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_nums = []\n    max_so_far = float('-inf')\n\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        max_nums.append(max_so_far)\n    \n    return max_nums", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    max_numbers = []\n    max_number = float('-inf')\n    for number in numbers:\n        if number > max_number:\n            max_number = number\n        max_numbers.append(max_number)\n    return max_numbers", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_list = []\n    max_num = float('-inf')\n    for number in numbers:\n        if number > max_num:\n            max_num = number\n        max_list.append(max_num)\n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n\n    if not numbers:\n        return []\n\n    max_numbers = [numbers[0]]\n    for num in numbers[1:]:\n        max_numbers.append(max(num, max_numbers[-1]))\n\n    return max_numbers", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    result = []\n    max_num = float('-inf')\n\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_values = [numbers[0]]\n    \n    for i in range(1, len(numbers)):\n        max_values.append(max(max_values[-1], numbers[i]))\n        \n    return max_values", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_list = []\n    if numbers:\n        max_so_far = numbers[0]\n        max_list.append(max_so_far)\n        for num in numbers[1:]:\n            max_so_far = max(max_so_far, num)\n            max_list.append(max_so_far)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n\n    # Check if the input list is empty\n    if not numbers:\n        return []\n\n    # Initialize rolling_max list with the first element of numbers\n    rolling_max_list = [numbers[0]]\n\n    # Iterate over the rest of the numbers\n    for i in range(1, len(numbers)):\n        # If the current number is larger than the last element in the rolling_max_list\n        if numbers[i] > rolling_max_list[-1]:\n            # Add it to the rolling_max_list\n            rolling_max_list.append(numbers[i])\n        else:\n            # Otherwise, add the last element again\n            rolling_max_list.append(rolling_max_list[-1])\n\n    return rolling_max_list", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    max_num = float('-inf')\n    for num in numbers:\n        max_num = max(num, max_num)\n        result.append(max_num)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:  # if the input list is empty, return an empty list\n        return []\n\n    max_list = []\n    max_val = numbers[0]\n\n    for num in numbers:\n        max_val = max(num, max_val)\n        max_list.append(max_val)\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_num = float('-inf')\n\n    for number in numbers:\n        max_num = max(max_num, number)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_numbers = []\n    max_val = float('-inf')\n    \n    for num in numbers:\n        max_val = max(max_val, num)\n        max_numbers.append(max_val)\n\n    return max_numbers", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_list = []\n    max_value = float('-inf')\n    for num in numbers:\n        max_value = max(num, max_value)\n        max_list.append(max_value)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    rolling_max_list = []\n    for i, num in enumerate(numbers):\n        if i == 0:\n            rolling_max_list.append(num)\n        else:\n            rolling_max_list.append(max(num, rolling_max_list[-1]))\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if len(numbers) == 0:\n        return []\n        \n    max_list = [numbers[0]]\n    max_val = numbers[0]\n    \n    for num in numbers[1:]:\n        max_val = max(max_val, num)\n        max_list.append(max_val)\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_list = []\n    max_value = None\n\n    for num in numbers:\n        if max_value is None:\n            max_value = num\n        else:\n            max_value = max(max_value, num)\n        max_list.append(max_value)\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    max_num = numbers[0]\n\n    for num in numbers[1:]:\n        if num > max_num:\n            max_num = num\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_nums = []\n    max_num = float('-inf')\n\n    for num in numbers:\n        if num > max_num:\n            max_num = num\n        max_nums.append(max_num)\n\n    return max_nums", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 50.058139534883715, "dps_norm": 56.42857142857143, "pass@1": 99.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list in ascending order\n    \n    # Check if adjacent numbers are closer than the threshold\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport numpy as np\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    \n    numbers.sort()\n\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport numpy as np\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers)-1):\n        if np.abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport numpy as np\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n\n    n = len(numbers)\n    # sort the list\n    numbers.sort()\n    \n    # check for every consecutive pair if they are closer to each other than the threshold\n    for i in range(1, n):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport itertools\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    \n    # if the list contains less than 2 numbers, we return False by default\n    if len(numbers) < 2:\n        return False\n\n    # sort the numbers\n    numbers.sort()\n\n    # check pairs of neighbouring numbers in the sorted list\n    for num1, num2 in itertools.pairwise(numbers):\n        if abs(num1 - num2) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    \n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 25.838607594936708, "dps_norm": 70.83333333333334, "pass@1": 98.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    differences = [abs(x - mean) for x in numbers]\n    mad = sum(differences) / len(differences)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(num - mean) for num in numbers]\n    return sum(abs_diffs) / len(abs_diffs)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    abs_diff = [abs(x - mean) for x in numbers]\n    mad = sum(abs_diff) / len(abs_diff)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    x_mean = sum(numbers) / n\n    return sum(abs(x - x_mean) for x in numbers) / n", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    \n    # Calculate the mean of the list\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute differences from the mean\n    differences = [abs(num - mean) for num in numbers]\n\n    # Return the mean of the differences\n    return sum(differences) / len(differences)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n\n    # calculate absolute differences from the mean\n    differences = [abs(x - mean) for x in numbers]\n\n    # calculate the mean of these differences, which is MAD\n    mad = sum(differences) / len(differences)\n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Compute the mean of the list\n    mean_val = sum(numbers) / len(numbers)\n    \n    # Compute absolute differences between each element and mean\n    diffs = [abs(num - mean_val) for num in numbers]\n    \n    # Return the mean value of those absolute differences as MAD\n    return sum(diffs) / len(diffs)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    # check if the list is empty\n    if not numbers:\n        return 0.0\n\n    # calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n\n    # calculate the absolute differences from the mean\n    differences = [abs(num - mean) for num in numbers]\n\n    # return the mean of the absolute differences as the MAD\n    return sum(differences) / len(differences)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if len(numbers) == 0:\n        raise ValueError(\"numbers must not be an empty list\")\n    \n    mean = sum(numbers) / len(numbers)\n    differences = [abs(x - mean) for x in numbers]\n    mad = sum(differences) / len(differences)\n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    # Check if the list is empty\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate absolute differences\n    differences = [abs(x - mean) for x in numbers]\n\n    # Calculate Mean Absolute Deviation\n    mad = sum(differences) / len(differences)\n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(num - mean) for num in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    \n    # Calculate the mean of the list of numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences between each number and the mean\n    differences = [abs(num - mean) for num in numbers]\n    \n    # Calculate the mean absolute deviation and return it\n    mad = sum(differences) / len(differences)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate absolute differences and their average\n    abs_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # compute the mean of the list\n    mean = sum(numbers) / len(numbers)\n    \n    # compute absolute differences from the mean\n    diffs = [abs(x - mean) for x in numbers]\n    \n    # return the mean of the absolute differences\n    return sum(diffs) / len(diffs)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = statistics.mean(numbers)\n    abs_diffs = [abs(num - mean) for num in numbers]\n    return statistics.mean(abs_diffs)", "matching_cluster_idx": 0}]}, "HumanEval/16": {"dps": 96.74418604651163, "dps_norm": 97.22222222222223, "pass@1": 99.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to disregard case\n    lower_string = string.lower()\n    # Convert the string to a set to remove duplicates, then return the length\n    distinct_chars = set(lower_string)\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"Input list should contain at least two numbers.\")\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i+1])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    res = None\n\n    for i in range(1, len(sorted_numbers)):\n        diff = sorted_numbers[i] - sorted_numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            res = (sorted_numbers[i-1], sorted_numbers[i])\n\n    return res", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"At least two numbers are required.\")\n    \n    numbers.sort()\n    \n    min_diff = float('inf')\n    result = None\n    \n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < min_diff:\n            min_diff = numbers[i] - numbers[i-1]\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # sort the list in ascending order\n    numbers.sort()\n    \n    # initialize the minimum difference to be the maximum float number\n    min_diff = float('inf')\n    result = (None, None)\n    \n    # for each pair of numbers\n    for i in range(1, len(numbers)):\n        # calculate the difference\n        diff = numbers[i] - numbers[i-1]\n        \n        # if the difference is less than the minimum difference found so far,\n        # then update the minimum difference and save the pair of numbers\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"The list of numbers must contain at least two elements.\")\n    \n    numbers.sort()\n    \n    min_diff = float('inf')\n    result = None\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = None\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # First, sort the numbers.\n    numbers.sort()\n\n    # Initialize smallest_difference to be the difference between the first two numbers,\n    # and closest_pair to be the first two numbers.\n    smallest_difference = numbers[1] - numbers[0]\n    closest_pair = (numbers[0], numbers[1])\n\n    # Iterate over the pairs of numbers in the list.\n    for i in range(1, len(numbers) - 1):\n        difference = numbers[i+1] - numbers[i]\n        if difference < smallest_difference:\n            smallest_difference = difference\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    result = None\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = None\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < min_diff:\n            min_diff = numbers[i] - numbers[i - 1]\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = None\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the list in increasing order\n    numbers.sort()\n    \n    # Initially, set closest pair as the first two numbers\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = numbers[1] - numbers[0]\n\n    # Iterate over the list, starting from the second number\n    for i in range(1, len(numbers) - 1):\n        # Compute the difference between the current number and the next one\n        diff = numbers[i + 1] - numbers[i]\n\n        # If the difference is smaller than the current smallest difference,\n        # update the closest pair and the minimum difference\n        if diff < min_diff:\n            closest_pair = (numbers[i], numbers[i + 1])\n            min_diff = diff\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    # Initialize minimum difference and closest elements\n    min_diff = float('inf')\n    closest_elements = None\n    # Iterate over pairs of elements\n    for i in range(1, len(sorted_numbers)):\n        # Calculate the difference between current pair\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # If the difference is smaller than the current minimum, update closest elements\n        if diff < min_diff:\n            min_diff = diff\n            closest_elements = (sorted_numbers[i - 1], sorted_numbers[i])\n    return closest_elements", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list\n    numbers.sort()\n\n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = None\n\n    # Traverse the list to find the closest pair\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    assert len(numbers) >= 2, \"List of numbers must contain at least two elements\"\n\n    # Sort the numbers\n    numbers.sort()\n\n    # Initialize minimum difference and closest pair\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    # Scan through the list to find the closest pair\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    sorted_numbers = sorted(numbers)\n    diff = float('inf')\n    result = (None, None)\n    for i in range(len(sorted_numbers)-1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < diff:\n            diff = sorted_numbers[i+1] - sorted_numbers[i]\n            result = (sorted_numbers[i], sorted_numbers[i+1])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # First we sort the list\n    numbers.sort()\n\n    # We initialize the closest pair with the first two elements\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[1] - numbers[0])\n\n    # We iterate over the list to find any pair with smaller difference\n    for i in range(1, len(numbers) - 1):\n        diff = abs(numbers[i+1] - numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    diff = float('inf')\n    result = (None, None)\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < diff:\n            diff = numbers[i] - numbers[i-1]\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 68.26530612244898, "dps_norm": 25.625, "pass@1": 99.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    # check the input is a positive integer\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # start from n - 1 and iterate backwards until we find a divisor\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # iterate from n-1 down to 1\n    for i in range(n-1, 0, -1):\n        # check if i is a divisor of n\n        if n % i == 0:\n            return i\n    # if no divisor found (which is not possible for n>1), return None\n    return None", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Starting from half of the given number, decrement until a divisor is found\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}]}, "HumanEval/26": {"dps": 66.6, "dps_norm": 76.25, "pass@1": 70.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    \n    counts = {}\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 1\n        else:\n            counts[num] += 1\n\n    unique_numbers = [num for num in numbers if counts[num] == 1]\n\n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    no_dups = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            no_dups.append(num)\n    return no_dups", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    num_counts = {}\n    for num in numbers:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    unique_numbers = [num for num in numbers if num_counts[num] == 1]\n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    unique_numbers = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            unique_numbers.append(num)\n    return unique_numbers", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    numbers_count = {}\n    result = []\n\n    for number in numbers:\n        if number in numbers_count:\n            numbers_count[number] += 1\n        else:\n            numbers_count[number] = 1\n\n    for number in numbers:\n        if numbers_count[number] == 1:\n            result.append(number)\n            \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create an empty dictionary to count the occurrences of each number\n    num_dict = {}\n    for num in numbers:\n        if num in num_dict:\n            num_dict[num] += 1\n        else:\n            num_dict[num] = 1\n\n    # Create a new list with numbers that occur only once\n    unique_nums = [num for num in numbers if num_dict[num] == 1]\n\n    return unique_nums", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    occurrence = {}\n    no_duplicates = []\n    \n    for num in numbers:\n        if num not in occurrence:\n            occurrence[num] = 1\n            no_duplicates.append(num)\n        else:\n            occurrence[num] += 1\n            if num in no_duplicates:\n                no_duplicates.remove(num)\n    \n    return no_duplicates", "matching_cluster_idx": 2}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    num_counts = Counter(numbers)\n    return [num for num in numbers if num_counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_dict = {}\n    result = []\n    for num in numbers:\n        if num not in count_dict:\n            count_dict[num] = 1\n            result.append(num)\n        else:\n            count_dict[num] += 1\n            if num in result:\n                result.remove(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    \n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n            result.append(num)\n\n    return [num for num in result if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # create a dictionary where key is the number and value is its frequency\n    num_freq = {}\n\n    for num in numbers:\n        if num in num_freq:\n            num_freq[num] += 1\n        else:\n            num_freq[num] = 1\n\n    # create a new list with numbers that appear only once\n    unique_numbers = [num for num in numbers if num_freq[num] == 1]\n\n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_dict = {}\n    result = []\n    for num in numbers:\n        if num not in count_dict:\n            count_dict[num] = 1\n            result.append(num)\n        else:\n            count_dict[num] += 1\n            if num in result:\n                result.remove(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # initialize an empty dictionary to store numbers and their occurrences\n    num_dict = {}\n    # initialize an empty list to store numbers left after removal of duplicates\n    numbers_left = []\n\n    for num in numbers:\n        # if the number has already been encountered\n        if num in num_dict:\n            # increment its count\n            num_dict[num] += 1\n        else:\n            # add the number to the dictionary and its count as 1\n            num_dict[num] = 1\n\n    # iterate over the numbers in the input list\n    for num in numbers:\n        # if the number count in the dictionary is 1 (i.e., it occurs only once in the list)\n        if num_dict[num] == 1:\n            # add it to the list of numbers left\n            numbers_left.append(num)\n\n    # return the list of numbers left\n    return numbers_left", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = {}\n    result = []\n    \n    for num in numbers:\n        if num not in seen:\n            seen[num] = 1\n            result.append(num)\n        else:\n            seen[num] += 1\n            if seen[num] > 1 and num in result:\n                result.remove(num)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    occurrences = {}\n    unique_numbers = []\n    for num in numbers:\n        if num not in occurrences:\n            occurrences[num] = 1\n            unique_numbers.append(num)\n        else:\n            occurrences[num] += 1\n\n    return [num for num in unique_numbers if occurrences[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_map = {}\n    result = []\n    for num in numbers:\n        if num not in count_map:\n            count_map[num] = 1\n            result.append(num)\n        else:\n            count_map[num] += 1\n    return [num for num in result if count_map[num] == 1]", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 69.36708860759494, "dps_norm": 80.0, "pass@1": 97.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    # Handle the cases where n is less than 2\n    if n < 2:\n        return False\n    # Check for factors up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # Check if n is a positive integer\n    if n <= 1 or not isinstance(n, int):\n        return False\n    # Check if n is divisible by any number up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:  # 0 and 1 are not primes\n        return False\n    for i in range(2, int(n**0.5)+1):  # range starts from 2 to sqrt(n)\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # numbers less than 2 are not prime\n    if n < 2:\n        return False\n\n    # 2 and 3 are prime\n    if n < 4:\n        return True\n\n    # numbers divisible by 2 or 3 are not prime\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    # we have already checked divisibility by 2 and 3. Now, we will check for\n    # divisibility by any numbers from 5 to square root of n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 83.39120370370371, "dps_norm": 79.54545454545455, "pass@1": 96.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    div_by_three = sorted([l[i] for i in range(0, len(l), 3)])\n    result = l.copy()\n    for i, val in enumerate(div_by_three):\n        result[i*3] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \n    # Creating a separate list of elements which are on the indices divisible by three\n    sorted_elements = sorted(l[i] for i in range(0, len(l), 3))\n    \n    # Creating the transformed list:\n    l_prime = []\n    for i in range(len(l)):\n        if i % 3 == 0:  # If index divisible by 3, get the sorted element\n            l_prime.append(sorted_elements.pop(0))\n        else:  # If index not divisible by 3, copy the original element\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    div_by_three = sorted([l[i] for i in range(0, len(l), 3)])\n    return [div_by_three.pop(0) if i%3 == 0 else l[i] for i in range(len(l))]", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n\n    # Gather the elements at index divisible by 3\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort the gathered elements\n    to_sort.sort()\n\n    # Initialize the resulting list\n    result = l.copy()\n\n    # Insert the sorted elements back into the list at index divisible by 3\n    for i, value in zip(range(0, len(result), 3), to_sort):\n        result[i] = value\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    third_elements = sorted([l[i] for i in range(0, len(l), 3)])\n    result = l.copy()\n    result[::3] = third_elements\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Creating a new list with elements at indices divisible by 3\n    div_by_3 = [l[i] for i in range(0, len(l), 3)]\n    # Sorting the list at indices divisible by 3\n    div_by_3.sort()\n    # Replacing the elements at indices divisible by 3 in the original list with sorted ones\n    for i, val in enumerate(div_by_3):\n        l[i * 3] = val\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    div3_indexes = [i for i in range(0, len(l), 3)]\n    div3_values = sorted([l[i] for i in div3_indexes])\n    l_copy = l.copy()\n    for i, j in zip(div3_indexes, div3_values):\n        l_copy[i] = j\n    return l_copy", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Get the values at indices divisible by 3\n    div_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort them\n    div_by_three.sort()\n    # Replace the values in l at indices divisible by 3 with the sorted ones\n    for i, val in enumerate(div_by_three):\n        l[i*3] = val\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n\n    # Get a list of elements at indices divisible by 3\n    div_by_three = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort these elements\n    div_by_three.sort()\n\n    # Construct the result list\n    result = l.copy()\n    for i, value in zip(range(0, len(l), 3), div_by_three):\n        result[i] = value\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # get the elements at the indices divisible by three, sort them\n    div_by_three = sorted(l[i] for i in range(0, len(l), 3))\n\n    # replace the elements at the indices divisible by three with the sorted ones\n    for i, val in zip(range(0, len(l), 3), div_by_three):\n        l[i] = val\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    divisible_by_three_indices = [index for index in range(0, len(l), 3)]\n    divisible_by_three_values = sorted([l[index] for index in divisible_by_three_indices])\n\n    l_prime = l.copy()\n    for index, value in zip(divisible_by_three_indices, divisible_by_three_values):\n        l_prime[index] = value\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # First, let's filter out elements at positions divisible by 3\n    div_three = [l[i] for i in range(0, len(l), 3)]\n    # Now, we sort this list\n    div_three.sort()\n    # Let's replace elements at positions divisible by 3 in original list with sorted elements\n    for i in range(0, len(l), 3):\n        l[i] = div_three.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l):\n    third_elements = sorted([l[i] for i in range(0, len(l), 3)])\n    result = l.copy()\n    for i, j in enumerate(range(0, len(l), 3)):\n        result[j] = third_elements[i]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Get the elements at index divisible by three, sorted\n    sorted_by_threes = sorted(x for i, x in enumerate(l) if i % 3 == 0)\n    \n    # Recreate the list, swapping in the sorted values at index divisible by three\n    l_prime = [sorted_by_threes.pop(0) if i % 3 == 0 else x for i, x in enumerate(l)]\n    \n    return l_prime", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    div3_indexes = [i for i in range(len(l)) if i % 3 == 0]\n    div3_values = [l[i] for i in div3_indexes]\n    div3_values.sort()\n\n    l_prime = l.copy()\n    for new_val, i in zip(div3_values, div3_indexes):\n        l_prime[i] = new_val\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    third_elements = sorted([l[i] for i in range(0, len(l), 3)])\n    result = l.copy()\n    for i, e in enumerate(third_elements):\n        result[i*3] = e\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    div_by_3 = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    div_by_3.sort()\n    \n    # Replace the elements at indices divisible by 3 in the original list with the sorted elements\n    for i, val in enumerate(div_by_3):\n        l[i*3] = val\n    \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    third_elements = sorted([l[i] for i in range(0, len(l), 3)])\n    for i, val in enumerate(third_elements):\n        l[i*3] = val\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Create a sorted list of the elements at index divisible by 3\n    sorted_at_3 = sorted(l[i] for i in range(0, len(l), 3))\n\n    # Replace the elements at index divisible by 3 in the original list with the sorted elements\n    for i, val in zip(range(0, len(l), 3), sorted_at_3):\n        l[i] = val\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    third_elements = sorted([l[i] for i in range(0, len(l), 3)])\n    for i, val in enumerate(third_elements):\n        l[i*3] = val\n    return l", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # convert the list to a set to remove duplicates then sort and convert back to list\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    # Initialize count of digit 7 to 0\n    count = 0\n    for i in range(n):\n        # Check if i is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Count appearances of 7 in i\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    :param n: upper bound (exclusive) of the range of integers to check\n    :return: count of digit 7 in numbers within the specified range that are divisible by either 11 or 13\n    \"\"\"\n\n    count = 0  # variable to hold the count of digit 7\n\n    for num in range(n):  # iterate through all numbers less than n\n        if num % 11 == 0 or num % 13 == 0:  # check if the number is divisible by either 11 or 13\n            count += str(num).count('7')  # increment the count by the number of times 7 appears in the number\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    return sum(str(i).count('7') for i in range(n) if i % 11 == 0 or i % 13 == 0)", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 95.18003273322422, "dps_norm": 90.5, "pass@1": 99.0, "profiled": [{"solution": "def sort_even(l):\n    even_indices_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    result = l.copy()\n    result[::2] = even_indices_elements\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract even-indexed items and sort\n    sorted_evens = sorted([l[i] for i in range(0, len(l), 2)])\n    # Initialize a new list to hold result\n    result = [None]*len(l)\n    # Fill result with sorted even-indexed items and keep original odd-indexed items\n    result[::2] = sorted_evens\n    result[1::2] = l[1::2]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract values at even indices\n    evens = [l[i] for i in range(0, len(l), 2)]\n\n    # Sort the extracted values\n    evens.sort()\n\n    # Create a new list and populate it with sorted even values and original odd values\n    sorted_l = [None] * len(l)\n    sorted_l[::2] = evens\n    sorted_l[1::2] = l[1::2]\n\n    return sorted_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Create a new list with elements at the even indices of l, retaining the order.\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even_elements list.\n    even_elements.sort()\n    # Create a new list to store the resulting list.\n    result = l.copy()\n    # Replace the elements at the even indices of result with the sorted elements.\n    for i, val in enumerate(even_elements):\n        result[2 * i] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Prepare two lists to store even and odd indexed elements separately.\n    evens = []\n    odds = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            evens.append(l[i])\n        else:\n            odds.append(l[i])\n    \n    # Sort the even indexed elements.\n    evens.sort()\n\n    # Reconstruct the list by alternately picking from the sorted evens and the originals.\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(evens.pop(0))\n        else:\n            l_prime.append(odds.pop(0))\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    l[::2] = evens\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    even_list = sorted(l[i] for i in range(0, len(l), 2))\n    result = l.copy()\n    result[::2] = even_list\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_list = sorted(l[::2])\n    for i, elem in enumerate(l[::2]):\n        l[2 * i] = even_list[i]\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    \n    # Extracting the elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sorting the even_indices_elements\n    even_indices_elements.sort()\n    \n    # Replacing the elements at even indices with the sorted elements\n    for i, e in enumerate(even_indices_elements):\n        l[i * 2] = e\n        \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \"\"\"\n    # Grab the even-indexed items and sort them\n    sorted_evens = sorted(l[i] for i in range(0, len(l), 2))\n\n    # Initialize the new list l'\n    l_prime = l.copy()\n\n    # Replace the even-indexed items in l' with the sorted items\n    l_prime[::2] = sorted_evens\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \"\"\"\n\n    # Separate the values at the even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n\n    # Sort the values at the even indices\n    even_indices_values.sort()\n\n    # Reconstruct the list with sorted values at even indices\n    result = [None] * len(l)\n    result[::2] = even_indices_values\n    result[1::2] = l[1::2]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    evens = sorted(l[::2])\n    l[::2] = evens\n    return l", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    l[::2] = even_elements\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_items = sorted([l[i] for i in range(0, len(l), 2)])\n    l[::2] = even_items\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    l[::2] = evens\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract even index elements and sort them\n    sorted_evens = sorted(l[i] for i in range(0, len(l), 2))\n\n    # Insert sorted even index elements back into the list\n    l[::2] = sorted_evens\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    l[::2] = evens\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \"\"\"\n\n    # Creating a separate list for even indexed elements, excluding those in odd positions.\n    even_indexed_elements = [l[i] for i in range(0, len(l), 2)]\n\n    # Sorting the elements of the even indexed elements list.\n    even_indexed_elements.sort()\n\n    # Replacing the even indexed elements in the original list with the sorted ones.\n    for i in range(0, len(l), 2):\n        l[i] = even_indexed_elements.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_indices_items = sorted([l[i] for i in range(0, len(l), 2)])\n    result = l.copy()\n    result[::2] = even_indices_items\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \"\"\"\n    # Sort the elements at even indices of the list\n    even_indices_sorted = sorted(l[i] for i in range(0, len(l), 2))\n\n    # Initialize the new list\n    result = l[:]\n\n    # Replace the elements at even indices of the new list with the sorted elements\n    result[::2] = even_indices_sorted\n\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 93.88235294117646, "dps_norm": 98.0, "pass@1": 97.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return 2**n % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return 2**n % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # use python's built-in pow function with three arguments\n    # pow(2, n, p) calculates (2 ** n) % p but more efficiently and without numeric issues\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 87.70531400966183, "dps_norm": 70.625, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    # Converting string to list for easy mutation\n    text_list = list(text)\n    # Removing vowels\n    text_list = [char for char in text_list if char not in vowels]\n    # Converting list back to string\n    text = \"\".join(text_list)\n    return text", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    text_without_vowels = ''\n    \n    for char in text:\n        if char not in vowels:\n            text_without_vowels += char\n    return text_without_vowels", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return ''.join([char for char in text if char.lower() not in {'a', 'e', 'i', 'o', 'u'}])", "matching_cluster_idx": 1}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    no_vowels_text = ''.join([char for char in text if char not in vowels])\n    return no_vowels_text", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join([char for char in text if char.lower() not in 'aeiou'])", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    text_without_vowels = \"\".join([char for char in text if char not in vowels])\n    return text_without_vowels", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    return ''.join([letter for letter in text if letter not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([letter for letter in text if letter not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    text_without_vowels = \"\".join([char for char in text if char not in vowels])\n    return text_without_vowels", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([letter for letter in text if letter not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 76.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return sorted(set(s0)) == sorted(set(s1))", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Use set operation to eliminate duplicate characters, and check if two sets are equal.\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets and compare.\n    # If the sets are equal, then all characters in one string are present in the other\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # using sets to eliminate repeated characters and check equality\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return sorted(set(s0)) == sorted(set(s1))", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert each string to a set of characters.\n    # Two sets are equal if they have the same elements, regardless of their order.\n    # Therefore, this function checks if two strings have the same characters.\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Use sets to get unique characters in each string, then compare if they are equal\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # convert both strings to sets and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n\n    # get intersection of lists and sort\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    # Calculate the intersection of the two lists and sort the result\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # use set intersection and list sorting to get unique sorted common elements\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Using set data type and in-built intersection function of Python.\n    common_elements = list(set(l1) & set(l2))\n    # Sorts the list in increasing order.\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_set = set(l1) & set(l2)  # find common elements\n    return sorted(list(common_set))  # sort and return", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    # Find common elements by using set intersection\n    common_elements = set(l1) & set(l2)\n\n    # Return the sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    # Finding common elements by converting each list into set\n    common_elements = set(l1) & set(l2)\n\n    # Converting set to list and sorting it\n    sorted_common_elements = sorted(list(common_elements))\n\n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 90.83333333333333, "dps_norm": 95.55555555555556, "pass@1": 97.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest = -1\n    while n % 2 == 0:\n        largest = 2\n        n //= 2\n\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest = i\n            n //= i\n\n    if n > 2:\n        largest = n\n    return largest", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"\n        Check if a number is prime.\n        \"\"\"\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = None\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            factor = n // i\n            if is_prime(factor):\n                largest_factor = factor\n                break\n            elif is_prime(i):\n                largest_factor = i\n\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n\n    # Start from the smallest prime number (2)\n    i = 2\n\n    # While i * i is less or equal to n\n    while i * i <= n:\n        # If n can be evenly divided by i\n        if n % i:\n            i += 1\n        # If n can be evenly divided by i\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        sqrt_num = int(num**0.5) + 1\n        for i in range(3, sqrt_num, 2):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = None\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            n //= i\n    if n > 2 and is_prime(n):\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if the given number is prime.\"\"\"\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n if is_prime(n) else factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest_prime = -1\n    \n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i== 0:\n            largest_prime = i\n            n //= i\n    \n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n\n    factor = 2\n    largest = 1\n    while n > 1:\n        if n % factor == 0 and is_prime(factor):\n            largest = factor\n            while n % factor == 0:\n                n /= factor\n        factor += 1\n    return largest", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # Start from the smallest prime, which is 2.\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num == 2:\n            return True\n        if num < 2 or num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5)+1, 2):\n            if num % i == 0:\n                return False\n        return True\n\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n if is_prime(n) else i", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(n):\n        if n <= 1 or (n % 2 == 0 and n > 2): \n            return False\n        return all(n % i for i in range(3, int(n**0.5) + 1, 2))\n\n    def get_factors(n):\n        factors = []\n        for i in range(2, n+1):\n            if n % i == 0:\n                factors.append(i)\n        return factors\n\n    factors = get_factors(n)\n    prime_factors = [factor for factor in factors if is_prime(factor)]\n\n    return max(prime_factors)", "matching_cluster_idx": 1}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest = -1\n    while n % 2 == 0:\n        largest = 2\n        n //= 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest = i\n            n //= i\n    if n > 2:\n        largest = n\n    return largest", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 67.29634002361276, "dps_norm": 52.27272727272727, "pass@1": 11.0, "profiled": [{"solution": "def vowels_count(s):\n    count = 0\n    for i in range(len(s)):\n        ch = s[i].lower()\n        if ch in ['a', 'e', 'i', 'o', 'u']:\n            count += 1\n        if ch == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    count = sum(1 for char in s if char in 'aeiou')\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Make the string lowercase so it's easier to compare\n    s = s.lower()\n\n    # Initialize counter\n    count = 0\n\n    # Loop through each letter in string and increment count if it's a vowel\n    for i in range(len(s)):\n        if s[i] in ['a', 'e', 'i', 'o', 'u']:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:  # 'y' is a vowel only when it's at the end of the word\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for i in range(len(s)):\n        # check if letter is a vowel\n        if s[i].lower() in vowels:\n            count += 1\n        # check if 'y' is a vowel\n        elif s[i].lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    # add an extra count for 'y' only when it's at the end\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    vowels = 'aeiou'\n    count = sum(1 for char in s if char in vowels)\n    \n    # check for 'y' at end of word\n    if s.endswith('y'):\n        count += 1\n        \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for c in s if c in vowels)\n    # add extra count if last character of string is 'y'\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if i == len(s) - 1 and s[i] == 'y':\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    s_endswith_y = s.endswith('y') or s.endswith('Y')\n    return sum(1 for c in s if c in vowels) + s_endswith_y", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Return the number of vowels in a string.\"\"\"\n    s = s.lower()\n    vowels = 'aeiou'\n    count = sum(1 for char in s if char in vowels)\n\n    # If the string ends with y, count it as a vowel.\n    if s.endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum(1 for c in s if c in vowels)\n    # check 'y' at the end of string\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    # Calculate total chars in each list\n    total_chars_lst1 = sum(len(i) for i in lst1)\n    total_chars_lst2 = sum(len(i) for i in lst2)\n    \n    # Return the list with fewer total chars or lst1 if equal\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum([len(s) for s in lst1])\n    len2 = sum([len(s) for s in lst2])\n    return lst1 if len1 <= len2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # calculate sum of characters in each list\n    sum_lst1 = sum(len(word) for word in lst1)\n    sum_lst2 = sum(len(word) for word in lst2)\n    \n    # return the list with the smaller character sum, or lst1 if they are equal\n    return lst1 if sum_lst1 <= sum_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum([len(x) for x in lst1])\n    sum_lst2 = sum([len(x) for x in lst2])\n    \n    if sum_lst1 <= sum_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum([len(i) for i in lst1])\n    total_chars_lst2 = sum([len(i) for i in lst2])\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum([len(i) for i in lst1])\n    sum_lst2 = sum([len(i) for i in lst2])\n    \n    if sum_lst1 <= sum_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # calculate the total characters in each list\n    total_chars_lst1 = sum(len(item) for item in lst1)\n    total_chars_lst2 = sum(len(item) for item in lst2)\n\n    # return the list with the fewer total characters or lst1 if they are the same\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum(len(item) for item in lst1)\n    len_lst2 = sum(len(item) for item in lst2)\n    return lst1 if len_lst1 <= len_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    chars_lst1 = sum(len(i) for i in lst1)\n    chars_lst2 = sum(len(i) for i in lst2)\n\n    if chars_lst1 <= chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \n    # Helper function to calculate total characters in a list\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n\n    return lst1 if total_chars(lst1) <= total_chars(lst2) else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum([len(x) for x in lst1])\n    total_chars_lst2 = sum([len(x) for x in lst2])\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum([len(i) for i in lst])\n\n    return lst1 if char_count(lst1) <= char_count(lst2) else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # find total chars in lst1\n    total_chars_lst1 = sum(len(word) for word in lst1)\n\n    # find total chars in lst2\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # return the list with fewer total chars or lst1 if they are equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \n    # Compute the total number of chars in both lists\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer total chars, or lst1 if they are equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(word) for word in lst1)\n    total_chars2 = sum(len(word) for word in lst2)\n\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum(len(i) for i in lst1)\n    len_lst2 = sum(len(i) for i in lst2)\n\n    return lst1 if len_lst1 <= len_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total characters in both lists\n    total_chars_lst1 = sum(len(i) for i in lst1)\n    total_chars_lst2 = sum(len(i) for i in lst2)\n\n    # Check which list has less characters and return it\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    return lst1 if len1 <= len2 else lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 86.33663366336633, "dps_norm": 53.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(len(lst)) if i % 2 and lst[i] % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    # Iterating over elements and their indices in the list\n    # if the index is odd and the element is even - add it to the sum\n    return sum(value for index, value in enumerate(lst) if index % 2 and not value % 2)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(len(lst)) if i % 2 != 0 and lst[i] % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(el for idx, el in enumerate(lst) if idx % 2 != 0 and el % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    # initialize sum\n    sum = 0\n\n    # go through the list, checking every element at odd index\n    for i in range(1, len(lst), 2):\n\n        # if element is even, add it to the sum\n        if lst[i] % 2 == 0:\n            sum += lst[i]\n\n    # return the calculated sum\n    return sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(len(lst)) if i % 2 != 0 and lst[i] % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    result = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            result += lst[i]\n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    result = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            result += lst[i]\n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    result = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            result += lst[i]\n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)\nlst = [4, 2, 6, 7]", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(el for idx, el in enumerate(lst) if idx % 2 and el % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(el for i, el in enumerate(lst) if i % 2 != 0 and el % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(v for i, v in enumerate(lst) if i % 2 and v % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(el for i, el in enumerate(lst) if i % 2 and el % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(el for idx, el in enumerate(lst) if idx % 2 and not el % 2)", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 85.20408163265306, "dps_norm": 88.0, "pass@1": 81.0, "profiled": [{"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    words = s.split(' ')\n    shuffled_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(shuffled_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    return \" \".join(\"\".join(sorted(word)) for word in s.split(\" \"))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Splitting the input string into a list of words\n    words = s.split(' ')\n    \n    # Sorting each character in each word and joining them back together\n    words = [''.join(sorted(word)) for word in words]\n    \n    # Joining all the words back together with a space character\n    sorted_s = ' '.join(words)\n    \n    # Returning the sorted string\n    return sorted_s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(\" \")\n    ordered_words = [\"\".join(sorted(word)) for word in words]\n    return \" \".join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # List of characters in the string s\n    chars = list(s)\n\n    # Index of the start of the current word\n    word_start = 0\n\n    # Iterate over the indices of the list chars\n    for i in range(len(chars)):\n        # If the current character is a space, sort the characters that make up the word so far\n        if chars[i] == ' ':\n            chars[word_start:i] = sorted(chars[word_start:i])\n            # Update the index of the start of the next word\n            word_start = i + 1\n        # If this is the last character in the string, sort the characters that make up the last word\n        elif i == len(chars) - 1:\n            chars[word_start:i+1] = sorted(chars[word_start:i+1])\n    # Convert the list of characters back into a string\n    sorted_s = \"\".join(chars)\n\n    # Return the ordered string\n    return sorted_s", "matching_cluster_idx": 0}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    \n    def sort_word(word):\n        \"\"\"\n        A helper function that sorts a word.\n        \"\"\"\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    result = []\n    for word in words:\n        sorted_chars = sorted(word, key=lambda c: (c.islower(), c))\n        result.append(''.join(sorted_chars))\n    return ' '.join(result)", "matching_cluster_idx": -1}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    \n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string as input and returns an ordered version of it.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = ''\n    # Initialize an empty string to store each word temporarily\n    word = ''\n    # Iterate through each character in the string\n    for char in s:\n        # If the character is not a space, append it to the current word\n        if char != ' ':\n            word += char\n        # If the character is a space, process the current word and add it to the result\n        else:\n            result += ''.join(sorted(word)) + ' '\n            word = ''\n    # Process the last word in the string\n    result += ''.join(sorted(word))\n    return result", "matching_cluster_idx": 1}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    result = []\n\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n\n    return ' '.join(result)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 82.88184438040346, "dps_norm": 55.0, "pass@1": 98.0, "profiled": [{"solution": "def get_row(lst, x):\n    coords = [(i, j) for i, row in enumerate(lst) for j, e in enumerate(row) if e == x]\n    return sorted(coords, key=lambda t: (t[0], -t[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    res = []\n    for i, row in enumerate(lst):\n        for j, elem in enumerate(row):\n            if elem == x:\n                res.append((i, j))\n    return sorted(res, key=lambda t: (t[0], -t[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = [(i, j) for i, row in enumerate(lst) for j, elem in enumerate(row) if elem == x]\n    return sorted(coordinates, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                result.append((i, j))\n    result.sort(key=lambda y: (y[0], -y[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, col in enumerate(row):\n            if col == x:\n                result.append((row_index, col_index))\n    return sorted(result, key=lambda y: (y[0], -y[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = [(i, j) for i, row in enumerate(lst) for j, num in enumerate(row) if num == x]\n    return sorted(result, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = [(i, j) for i, row in enumerate(lst) for j, element in enumerate(row) if element == x]\n    coords.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n                \n    return sorted(coordinates, key=lambda y: (y[0], -y[1]))", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    return sorted(coordinates, key=lambda coordinate: (coordinate[0], -coordinate[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = [(i, j) for i, row in enumerate(lst) for j, e in enumerate(row) if e == x]\n    return sorted(result, key=lambda r: (r[0], -r[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row):\n            if col == x:\n                coords.append((i, j))\n    return sorted(coords, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                coords.append((i, j))\n    return sorted(coords, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                result.append((i, j))\n    # sort by row in ascending order and by column in descending order\n    result.sort(key=lambda tup: (tup[0], -tup[1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    return sorted(sorted(coordinates, key=lambda y: y[1], reverse=True), key=lambda y: y[0])", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    return sorted(coordinates, key=lambda y: (y[0], -y[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = [(i, j) for i, row in enumerate(lst) for j, element in enumerate(row) if element == x]\n    return sorted(coordinates, key=lambda y: (y[0], -y[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = [(i, j) for i, inner_list in enumerate(lst) for j, element in enumerate(inner_list) if element == x]\n    return sorted(coordinates, key=lambda tup: (tup[0], -tup[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, l in enumerate(lst):\n        for j, num in enumerate(l):\n            if num == x:\n                result.append((i,j))\n    result.sort(key = lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for column_index, element in enumerate(row):\n            if element == x:\n                result.append((row_index, column_index))\n    return sorted(result, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 60.0, "profiled": [{"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            result += chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            result += chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    for char in s:\n        if char.lower() in alphabet:  # ensure char is a letter, not a digit or special character\n            char_index = (alphabet.index(char.lower()) + 4) % 26  # rotate and handle wrapping\n            # maintain original case\n            if char.isupper():\n                encrypted += alphabet[char_index].upper()\n            else:\n                encrypted += alphabet[char_index]\n        else:\n            encrypted += char  # non-letter characters remain the same\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \"\"\"\n    # create empty string to store encrypted text\n    encrypted_text = ''\n\n    # iterate through each character in the string\n    for char in s:\n        # check if character is an uppercase or lowercase letter\n        if 'A' <= char <= 'Z':\n            # shift character down by four places\n            encrypted_char = chr((ord(char) - 65 + 4) % 26 + 65)\n        elif 'a' <= char <= 'z':\n            # shift character down by four places\n            encrypted_char = chr((ord(char) - 97 + 4) % 26 + 97)\n        else:\n            # if character is not a letter, keep it as it is\n            encrypted_char = char\n\n        # append encrypted character to the encrypted text string\n        encrypted_text += encrypted_char\n\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    for char in s:\n        if 'a' <= char <= 'z':\n            new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        else:\n            new_char = char\n        result += new_char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for i in s:\n        char_num = ord(i)\n        if char_num >= 97 and char_num <= 122: # Check if char is lowercase letter\n            result += chr((char_num - 97 + 4) % 26 + 97) # Shift down by two multiplied to two places\n        elif char_num >= 65 and char_num <= 90: # Check if char is uppercase letter\n            result += chr((char_num - 65 + 4) % 26 + 65) # Shift down by two multiplied to two places\n        else: \n            result += i # If not a letter, just add the char to result\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        # Get ascii value of char and add 4 (2*2).\n        ascii_val = ord(char) + 4\n        if char.islower():\n            # If ascii value goes beyond 'z', subtract 26 to cycle back to 'a'.\n            if ascii_val > ord('z'):\n                ascii_val -= 26\n        elif char.isupper():\n            # If ascii value goes beyond 'Z', subtract 26 to cycle back to 'A'.\n            if ascii_val > ord('Z'):\n                ascii_val -= 26\n        else:\n            # If char is not a letter, don't change it.\n            ascii_val = ord(char)\n        result += chr(ascii_val)\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for i in s:\n        x = ord(i)\n        if x >= 97 and x <= 122: #Lowercase letters\n            result += chr(((x - 97 + 4) % 26) + 97)\n        elif x >= 65 and x <= 90: #Uppercase letters\n            result += chr(((x - 65 + 4) % 26) + 65)\n        else: #Non-alphabetic characters\n            result += i\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    for letter in s:\n        if 'a' <= letter <= 'z':\n            result += chr((ord(letter) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= letter <= 'Z':\n            result += chr((ord(letter) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            result += letter\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            result += chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            result += chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 4 if char.islower() else 4\n            new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) if char.islower() else chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            result += new_char\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for letter in s:\n        if 'a' <= letter <= 'z':\n            result += chr((ord(letter) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= letter <= 'Z':\n            result += chr((ord(letter) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            result += letter\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            result += chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            result += chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            result += chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            result += chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_index = (ord(char) - ord('a') + 4) % 26\n            result += chr(shifted_index + ord('a'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for c in s:\n        char_code = ord(c)\n        if 'a' <= c <= 'z':\n            result += chr((char_code - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            result += chr((char_code - ord('A') + 4) % 26 + ord('A'))\n        else:\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            new_char = chr((ord(char) - start + 4) % 26 + start)\n            result += new_char\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted += chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted += chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_str = \"\"\n    for i in s:\n        ascii_val = ord(i)\n        if ascii_val >= 97 and ascii_val <= 122:\n            encrypted_str += chr(((ascii_val - 97 + 4) % 26) + 97)\n        else:\n            encrypted_str += i\n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            result += chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            result += chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            result += chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 65.50583657587549, "dps_norm": 58.333333333333336, "pass@1": 72.0, "profiled": [{"solution": "def next_smallest(lst):\n    # Remove duplicates\n    lst = list(set(lst))\n    \n    # Check if list has less than 2 elements\n    if len(lst) < 2:\n        return None\n    \n    # If list has 2 or more elements, sort the list\n    lst.sort()\n    \n    # Return the second smallest element\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    else:\n        lst.sort()\n        smallest = lst[0]\n        for num in lst:\n            if num > smallest:\n                return num\n        return None", "matching_cluster_idx": 11}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_lst = list(set(lst))\n\n    if len(unique_lst) < 2:\n        return None\n    else:\n        unique_lst.sort()\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    smallest = second_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num > smallest:\n            second_smallest = num\n    \n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Return the 2nd smallest element of a list.\n    Return None if there is no such element.\n\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n\n    >>> next_smallest([])\n    None\n\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    \n    # Ensure the list has at least two distinct elements\n    if len(set(lst)) < 2:\n        return None\n\n    # Sort the list and return the second element\n    return sorted(set(lst))[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    \n    if len(lst) < 2:\n        return None\n\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n            \n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # create a sorted copy of the input list\n    sorted_list = sorted(lst)\n    \n    # edge cases\n    if len(sorted_list) < 2:\n        return None\n\n    # find the smallest unique number in the sorted list\n    for i in range(1, len(sorted_list)):\n        if sorted_list[i] > sorted_list[0]:\n            return sorted_list[i]\n            \n    # if no second unique smallest number exists, return None\n    return None", "matching_cluster_idx": 10}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    smallest = min(lst)\n    lst = [x for x in lst if x != smallest]\n    \n    if len(lst) == 0:\n        return None\n    \n    return min(lst)", "matching_cluster_idx": 3}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:  # If the list has less than 2 elements, return None.\n        return None\n    else:  # If the list has 2 or more elements, find and return the 2nd smallest element.\n        sorted_lst = sorted(set(lst))  # Removing duplicates first then sorting the list.\n        if len(sorted_lst) < 2:  # If after removing duplicates, list has less than 2 elements, return None.\n            return None\n        else:  # If after removing duplicates, list has 2 or more elements, return the 2nd smallest element.\n            return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    smallest = second_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num > smallest:\n            second_smallest = num\n\n    if second_smallest == float('inf'):\n        return None\n\n    return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates from the list\n    lst = list(set(lst))\n    \n    # Sort the list in ascending order\n    lst.sort()\n    \n    # If the list has at least 2 elements, return the 2nd smallest element\n    if len(lst) >= 2:\n        return lst[1]\n    else:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    lst.sort()\n    smallest = lst[0]\n    for num in lst:\n        if num > smallest:\n            return num\n    return None", "matching_cluster_idx": 11}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    else:\n        lst = list(set(lst))  # Removing duplicates\n        lst.sort()\n        if len(lst) < 2:\n            return None\n        else:\n            return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest, smallest = smallest, num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    This function returns the 2nd smallest element of the list.\n    If there is no such element, it returns None.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    if second_smallest == float('inf'):\n        return None\n    return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num > smallest:\n            second_smallest = num\n    \n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    smallest = second_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    if second_smallest == float('inf'):\n        return None\n\n    return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    smallest = second_smallest = float('inf')\n    \n    for num in lst:\n        if num < smallest:\n            second_smallest, smallest = smallest, num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    \n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 58.0, "profiled": [{"solution": "def odd_count(lst):\n    result = []\n    for i, string in enumerate(lst):\n        num_odd_digits = sum(1 for digit in string if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {num_odd_digits}n the str{num_odd_digits}ng {num_odd_digits} of the {num_odd_digits}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for index, string in enumerate(lst):\n        # Count the odd digits in the string\n        odd_digits_count = sum(int(digit) % 2 for digit in string)\n        \n        # Prepare the output string\n        output_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_digits_count, odd_digits_count, odd_digits_count, odd_digits_count)\n\n        # Add the output string to the result\n        result.append(output_string)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\"\"\"\n\n    # Function to count odd digits in a string\n    def count_odd_digits(s):\n        return sum(int(ch) % 2 for ch in s)\n\n    # Create the result list\n    result = []\n\n    # Loop over the input list\n    for i, s in enumerate(lst):\n        # Count the number of odd digits in the string\n        count = count_odd_digits(s)\n\n        # Create the output string and add it to the result list\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_in_str(s):\n        return len([int(i) for i in s if int(i) % 2 != 0])\n\n    def replace_number_in_str(s, count):\n        new_str = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        return new_str.format(count, count, count, count)\n\n    return [replace_number_in_str(i, count_odd_in_str(i)) for i in lst]", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for idx, string in enumerate(lst):\n        odd_count = len([char for char in string if int(char) % 2 != 0])\n        new_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count)\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    res = []\n    for i, s in enumerate(lst):\n        odd_digits_in_s = sum(int(c) % 2 for c in s)\n        string_replaced = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_digits_in_s, odd_digits_in_s, odd_digits_in_s, odd_digits_in_s)\n        res.append(string_replaced)\n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\"\"\"\n\n    result = []\n    for idx, string in enumerate(lst):\n        # count odd digits in the string\n        odd_digits_count = sum(int(char) % 2 for char in string)\n        \n        # create a new string with replaced numbers and add to the result list\n        replaced_str = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n                            odd_digits_count, odd_digits_count, odd_digits_count, odd_digits_count)\n        result.append(replaced_str)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i in range(len(lst)):\n        count = 0\n        for j in lst[i]:\n            if int(j) % 2 != 0:\n                count += 1\n        s = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        output.append(s)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = sum(int(c) % 2 for c in s)\n        sentence = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        result.append(sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        odd_digits = sum(int(c) % 2 for c in s)\n        result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_digits, odd_digits, odd_digits, odd_digits))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd(n):\n        count = 0\n        for digit in n:\n            if int(digit) % 2 != 0:\n                count += 1\n        return count\n\n    result = []\n    for i in range(len(lst)):\n        odd_num = count_odd(lst[i])\n        string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_num, odd_num, odd_num, odd_num)\n        result.append(string)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, string in enumerate(lst):\n        odd_count_in_string = sum(int(digit) % 2 for digit in string)\n        result.append(f\"the number of odd elements {odd_count_in_string}n the str{odd_count_in_string}ng {odd_count_in_string} of the {odd_count_in_string}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for idx, string in enumerate(lst):\n        num_odds = len([int(ch) for ch in string if int(ch) % 2 == 1])\n        formatted_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(num_odds, num_odds, num_odds, num_odds)\n        output.append(formatted_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i in range(len(lst)):\n        num_odds = sum([int(char) % 2 for char in lst[i]])\n        output.append(f\"the number of odd elements {num_odds}n the str{num_odds}ng {num_odds} of the {num_odds}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for idx, string in enumerate(lst):\n        count = sum(int(c) % 2 for c in string)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    # list of odd digits\n    odd_digits = ['1', '3', '5', '7', '9']\n\n    # list to hold results\n    results = []\n\n    for i in range(len(lst)):\n        # count of odd digits in the i'th string\n        count = sum(1 for d in lst[i] if d in odd_digits)\n\n        # create the output string and add to results\n        result_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        results.append(result_string)\n\n    return results", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        odd_nums = sum(int(c) % 2 for c in s)\n        result.append(f\"the number of odd elements {odd_nums}n the str{odd_nums}ng {odd_nums} of the {odd_nums}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i in range(len(lst)):\n        count = sum(1 for ch in lst[i] if int(ch) % 2 != 0)\n        new_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    results = []\n\n    def count_odds(number_str):\n        return len([int(ch) for ch in number_str if int(ch) % 2 != 0])\n\n    for index, number_str in enumerate(lst):\n        odd_number = count_odds(number_str)\n        formatted_string = f\"the number of odd elements {odd_number}n the str{odd_number}ng {odd_number} of the {odd_number}nput.\"\n        results.append(formatted_string)\n\n    return results", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": null, "dps_norm": null, "pass@1": 6.0, "profiled": []}, "HumanEval/120": {"dps": 97.41379310344827, "dps_norm": 99.28571428571429, "pass@1": 31.0, "profiled": [{"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse = True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse = True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse = True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse = True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    if k == 0:\n        return []\n\n    arr.sort()\n    arr = arr[len(arr)-k:]\n\n    return sorted(arr)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse = True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    # sort the array in reverse order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # slice first k elements\n    max_k_nums = sorted_arr[:k]\n\n    # sort the result in ascending order\n    result = sorted(max_k_nums)\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 83.36322869955157, "dps_norm": 62.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for idx, value in enumerate(lst) if idx % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    \n    # sum of odd numbers in even positions\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 == 1)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 == 1)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    total = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 == 1:\n            total += lst[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    result = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            result += lst[i]\n    return result", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(el for idx, el in enumerate(lst) if idx % 2 == 0 and el % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 == 1)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    total = 0\n    for idx, num in enumerate(lst):\n        if idx % 2 == 0 and num % 2 == 1:\n            total += num\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n\n    # Check if the list is empty\n    if not lst:\n        return 0\n    \n    # Initialize the sum\n    odd_sum = 0\n\n    # Loop through the list\n    for i in range(0, len(lst), 2):\n        # If the element is odd, add it to the sum\n        if lst[i] % 2 != 0:\n            odd_sum += lst[i]\n\n    return odd_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    \n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 == 1)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 89.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    # Deleting the strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sorting by length of each word and then alphabetically\n    lst.sort(key = lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings with odd lengths\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sort the list by length, then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # delete strings with odd lengths\n    lst = [x for x in lst if len(x) % 2 == 0]\n\n    # sort the list first by length, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # delete the strings that have odd lengths\n    lst = [x for x in lst if len(x) % 2 == 0]\n\n    # sort the list by length of each word and then alphabetically for same length words\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # sort by length and then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the list by length and then alphabetically\n    lst.sort(key = lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Removing strings with odd lengths\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sorting the list by length and then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    lst = [i for i in lst if len(i) % 2 == 0] # Filters out strings of odd lengths.\n    lst.sort(key=lambda x: (len(x), x)) # Sorts by string length and then alphabetically.\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Remove elements with odd length\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort list by length of word, then alphabetically for same length words\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([i for i in lst if len(i) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # filter out strings of odd lengths\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # sort the list first by length of each word, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort the list first by length of each word, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Remove strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list first by length and then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    lst.sort(key=lambda word: (len(word), word))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # delete the strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # sort by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Removing strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sorting by length of each word and alphabetically if they have the same length\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [x for x in lst if len(x) % 2 == 0]\n\n    # Sort the list by length and then alphabetically\n    lst.sort(key = lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Keep only the strings with even lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length first, then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # delete the strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # sort the list by length of each word, and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filtered out odd length strings\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sorted by length and then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 75.21186440677965, "dps_norm": 84.375, "pass@1": 93.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks if a number is not a prime number.\n    :param n: int\n    :return: bool\n    \"\"\"\n    # First it checks if the number is less than 2 (the smallest prime number)\n    if n < 2:\n        return True\n    # Then it checks if the number can be divided by any number up to its square root\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"Function to check if a number is not prime\"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function determines if a number is not prime.\n    \"\"\"\n    # check if the input is less than 2\n    if n < 2:\n        return True\n    # check if the number has any divisors other than 1 and itself.\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n    :param n: The number to check.\n    :return: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, n):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 0}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if the number is a non-prime number.\n    A non-prime number is any number that is not a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is non-prime, False if the number is prime.\n    \"\"\"\n    if n <= 1 or (n % 1 > 0):\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to check if the number is non-prime\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    A function to check if a number is not a prime number.\n    \"\"\"\n    if n <= 1: \n        return True\n    if n <= 3: \n        return False\n    if n % 2 == 0 or n % 3 == 0: \n        return True\n    i = 5\n    while i * i <= n: \n        if n % i == 0 or n % (i + 2) == 0: \n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Return True if the given number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks if a number is not a prime number.\n    \"\"\"\n    # numbers less than 2 are not prime\n    if n < 2:\n        return True\n\n    # 2 and 3 are prime\n    if n <= 3:\n        return False\n\n    # check if n is divisible by 2 or 3\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n\n    i = 5\n    while i * i <= n:\n        # check divisibility by potential factors\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 97.0, "profiled": [{"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    \"\"\"\n    Function to find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    \n    # Using nlargest function of heapq module\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    largest_nums = heapq.nlargest(n, numbers)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Using the inbuilt heapq module to find the n largest numbers\n    n_largest = heapq.nlargest(n, nums)\n    return n_largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    \"\"\"\n    Function to find n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    largest_nums = heapq.nlargest(n, lst)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(lst, n):\n    import heapq\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst,n):\n    # Use heapq largest function to find the 'n' largest elements \n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"Function to find the n largest integers from a given list of numbers, returned in descending order\"\"\"\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    This function uses 'heapq.nlargest' to find the 'n' largest numbers in 'numbers' list.\n    It then returns these numbers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(num_list, n):\n    import heapq\n    return heapq.nlargest(n, num_list)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 97.27891156462584, "dps_norm": 60.0, "pass@1": 11.0, "profiled": [{"solution": "def find_Rotations(string):\n    # Form a double String \n    doubleString = string + string\n    \n    n = len(string)\n    \n    for i in range(1,n+1):\n        # Get the rotated string\n        rotatedString = doubleString[i: n+i]\n        # Check if rotated string is same as original string\n        if string == rotatedString:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    # Create double string\n    double_string = string * 2\n\n    # check each rotation\n    for i in range(1, len(string) + 1):\n        # rotate the string by i\n        rotated_string = double_string[i:i + len(string)]\n        # if the rotated string is the same as the input string,\n        # then return the number of rotations, which is i\n        if rotated_string == string:\n            return i", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str):\n    # create a temporary string with value = 2*str\n    tmp = str * 2\n    n = len(str)\n    \n    # Try all rotations of 'str'\n    for i in range(1, n + 1):\n        rotation = tmp[i: n+i]\n\n        # If after rotation, we get the original string back\n        if str == rotation:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    # Concatenate the input string with itself\n    temp = string + string\n\n    # For each rotation of the input string\n    for i in range(1, len(string) + 1):\n\n        # Slice the temp string from the beginning up to the current index\n        rotated_str = temp[i: i + len(string)]\n\n        # If the rotation matches the input string, return the number of rotations\n        if rotated_str == string:\n            return i", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str):\n    # create a temporary string\n    temp = str + str\n\n    # consider all rotations of given string\n    for i in range(1, len(str) + 1):\n        # compare current rotation with given string\n        if (str == temp[i: len(str) + i]):\n            # return number of rotations\n            return i\n    return len(str)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    # concatenate the input string to itself.\n    tmp = string + string\n    \n    # do binary search in the rotated string array.\n    n = len(string)\n    for i in range(1, n + 1):\n        s = tmp[i: n+i]\n        if s == string:\n            return i\n    \n    # if no rotation is possible.\n    return -1", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    # doubling the string and creating an array \n    double_string = string + string\n    for i in range(1, len(string) + 1):\n        # using slicing operation to generate the rotated string\n        rotated_string = double_string[i: i + len(string)]\n        if rotated_string == string:\n            return i", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str):\n    # Concatenate str to str\n    tmp = str + str\n  \n    # Consider all rotations of str\n    # starting from the 2nd character\n    for i in range(1, len(str) + 1):\n        rotatedString = tmp[i : i + len(str)]\n  \n        # If rotated string matches with original string\n        if str == rotatedString:\n            return i\n  \n    # If no such rotation matches\n    return len(str)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str):\n    '''\n    The function finds the minimum number of rotations required to get the same string\n    '''\n\n    # If all characters in input string are same, \n    # then return 1, as rotating the same string \n    # will always result in the same string\n    if (len(set(str)) == 1):\n        return 1\n\n    # To store all rotations of string\n    temp = str + str\n    n = len(str)\n\n    for i in range(1, n + 1):\n        # To get the current rotation of str\n        curr = temp[i : n + i]\n\n        # If the current rotation is same as the given string\n        if (str == curr):\n            # Returning number of rotations\n            return i", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str):\n    \"\"\"\n    This function returns the minimum number of rotations \n    required to get the same string.\n    \"\"\"\n    if len(str) == 0:\n        return 0\n\n    # Create a temp string with value str.str\n    temp = str + str\n\n    # Now start doing comparisons\n    n = len(str)\n    for i in range(1, n + 1):\n        # See if first n characters of temp match with str\n        if temp[i: i + n] == str:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(string):\n    double_string = string * 2\n    for i in range(1, len(string) + 1):\n        if string == double_string[i:i + len(string)]:\n            return i", "matching_cluster_idx": 5}]}, "Mbpp/11": {"dps": 95.55555555555556, "dps_norm": 97.77777777777777, "pass@1": 45.0, "profiled": [{"solution": "def remove_Occ(string, char):\n    \"\"\"Remove the first and last occurrence of char in string\"\"\"\n    first = string.find(char)\n    if first != -1:\n        last = string.rfind(char)\n        string = string[:first] + string[first+1:last] + string[last+1:]\n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, character):\n    first_occurrence = input_string.find(character)\n    last_occurrence = input_string.rfind(character)\n    if first_occurrence != -1 and last_occurrence != -1:\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]\n    else:\n        return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    last = s.rfind(c)\n    \n    if first == last == -1:\n        return s\n    elif first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    if char not in s:\n        return s\n    s = s.replace(char, '', 1) # Removes first occurrence\n    s = s[::-1].replace(char, '', 1) # Removes last occurrence\n    return s[::-1]", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(str, char):\n    first_occ = str.find(char)\n    last_occ = str.rfind(char)\n    \n    if first_occ == -1 or last_occ == -1:  # if char not found in the string\n        return str\n\n    # remove first and last occurrence of the character\n    return str[:first_occ] + str[first_occ+1:last_occ] + str[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Find the first and last occurrence of the given character\n    first = string.find(char)\n    last = string.rfind(char)\n\n    # If the character is not found, return the original string\n    if first == -1:\n        return string\n\n    # If the first and last occurrence are the same (i.e., the character only appears once), remove it from the string\n    if first == last:\n        return string.replace(char, \"\")\n\n    # Otherwise, remove the first and last occurrence of the character\n    return string[:first] + string[first+1:last] + string[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    last = s.rfind(c)\n    if first == -1:\n        return s\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, character):\n    first_occurrence = input_string.find(character)\n    last_occurrence = input_string.rfind(character)\n\n    if first_occurrence == -1:  # Character not found in string\n        return input_string\n    else:\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n    if first_occ == -1 or last_occ == -1:\n        return s\n    return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1, char1):\n    first_occurrence = str1.find(char1)\n    last_occurrence = str1.rfind(char1)\n\n    if first_occurrence != -1 and last_occurrence != -1:\n        str1 = str1[:first_occurrence] + str1[first_occurrence + 1:last_occurrence] + str1[last_occurrence + 1:]\n\n    return str1", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, character):\n    first_occurrence = input_string.find(character)\n    last_occurrence = input_string.rfind(character)\n    \n    # For edge cases where the character does not exist in the string\n    if first_occurrence == -1:\n        return input_string\n\n    # For the case where first and last occurrence are the same character in the same position\n    if first_occurrence == last_occurrence:\n        return input_string[:first_occurrence] + input_string[first_occurrence + 1:]\n\n    return input_string[:first_occurrence] + input_string[first_occurrence + 1:last_occurrence] + input_string[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, target_char):\n    first_occurrence = input_string.find(target_char)\n    last_occurrence = input_string.rfind(target_char)\n    \n    # If the target_char doesn't exist in the string\n    if first_occurrence == -1:\n        return input_string\n    else:\n        # Remove the first and last occurrence\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    last = s.rfind(c)\n    \n    if first == last == -1:  # If character not found in string\n        return s\n    elif first == last:  # If character occurs only once\n        return s[:first] + s[first + 1:]\n    else:\n        return s[:first] + s[first + 1:last] + s[last + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    last = s.rfind(c)\n    if first == last == -1:  # If character is not found in string\n        return s\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string: str, char: str) -> str:\n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n    \n    if first_occurrence == -1 or last_occurrence == -1:  # if the char doesn't exist or only occurs once\n        return string\n\n    return string[:first_occurrence] + string[first_occurrence + 1:last_occurrence] + string[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    first_occurrence = input_string.find(char_to_remove)\n    last_occurrence = input_string.rfind(char_to_remove)\n    \n    if first_occurrence != -1 and last_occurrence != -1:\n        new_string = input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]\n        return new_string\n    else:\n        return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first_occ = s.find(ch)\n    last_occ = s.rfind(ch)\n    \n    if first_occ == -1 or last_occ == -1:\n        return s\n    \n    return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    #Find the first and last occurrence of the character.\n    first_occ = input_string.find(char_to_remove)\n    last_occ = input_string.rfind(char_to_remove)\n\n    #Check if the character occurs in the string.\n    if first_occ != -1:\n        #Remove the first and last occurrence.\n        input_string = input_string[:first_occ] + input_string[first_occ + 1:last_occ] + input_string[last_occ + 1:]\n\n    return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    last = s.rfind(c)\n    \n    if first == -1 or last == -1:  # If character is not found in the string\n        return s\n    \n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n    \n    if first_occurrence == -1 or last_occurrence == -1: \n        return string\n    else:\n        return string[:first_occurrence] + string[first_occurrence+1:last_occurrence] + string[last_occurrence+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(m):\n    # Sort the matrix by the sum of its rows in ascending order\n    return sorted(m, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(m):\n    m.sort(key=sum)\n    return m", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix in ascending order according to the sum of its rows\n    return sorted(mat, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # The function computes the sum of the rows in each row, sorts the rows based on the row sum\n    # and returns the sorted matrix\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate sum of each row and sort matrix based on those sums\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate sum of each row\n    sums = [sum(row) for row in matrix]\n    # Sort the matrix based on row sums\n    matrix = [x for _,x in sorted(zip(sums, matrix))]\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # First, calculate the sum of each row and store in a list of tuples where the first element is the sum \n    # and the second element is the row itself\n    sum_rows = [(sum(row), row) for row in matrix]\n\n    # Then sort this list of tuples, the rows with the smallest sum will be at the front\n    sum_rows.sort()\n\n    # Finally, we extract the sorted rows and return as a new matrix\n    sorted_matrix = [row for _, row in sum_rows]\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix by the sum of its rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # sort the matrix by the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and sort the matrix based on these sums.\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/19": {"dps": 64.64646464646465, "dps_norm": 80.0, "pass@1": 83.0, "profiled": [{"solution": "def test_duplicate(nums):\n    \"\"\"\n    The function checks if the input list contains duplicate elements.\n    \n    Parameters:\n    nums (list): the list of numbers to be checked\n    \n    Returns:\n    bool: True if there is at least one duplicate element in the list. False if all elements are unique.\n    \"\"\"\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    The function checks if a list of integers contains any duplicate element.\n    \n    Arguments:\n    nums {list} -- List of integers\n    \n    Returns:\n    bool -- True if the list has duplicate elements, False otherwise\n    \"\"\"\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    Check if an array contains duplicate elements.\n    \"\"\"\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"Function to check if an array contains duplicate elements.\"\"\"\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function will check if an array contains any duplicates.\n    It converts the given array into a set and then checks if the length of the set is less than the length of the given array.\n    If yes, it means that there were some duplicate elements in the array.\n    \"\"\"\n    \n    # Create a set from the input array\n    arr_set = set(arr)\n    \n    # If lengths of the set and array are equal, there are no duplicates.\n    if len(arr_set) == len(arr):\n        return False\n    else:\n        # If lengths are not equal, there are duplicates.\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(num_array):\n    if len(num_array) == len(set(num_array)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"Function to test if array has any duplicate elements.\"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(input_list):\n    if len(input_list) == len(set(input_list)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    if len(nums) == len(set(nums)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(input_list):\n    return len(input_list) != len(set(input_list))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    \"\"\"\n    Check if a list contains any duplicate elements\n    \"\"\"\n    if len(lst) == len(set(lst)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    Function to find if an array of integers contains any duplicate.\n\n    Parameters:\n        array (list): A list of integers.\n    \n    Returns:\n        bool: True if the array contains duplicate elements. False otherwise.\n    \"\"\"\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    if len(lst) == len(set(lst)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(list):\n    return min(list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(list_num):\n    return min(list_num)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function takes a list of numbers as input and returns the smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 93.21428571428572, "dps_norm": 68.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(lst, k):\n    result = [t for t in lst if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = [t for t in lst if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"Finds tuples which have all elements divisible by k from a given list of tuples.\n    \n    Args:\n        lst: List of tuples.\n        k: Integer divisor.\n\n    Returns:\n        List of tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = [t for t in lst if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(t_list, k):\n    return [t for t in t_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = [t for t in lst if all(i % k == 0 for i in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = [t for t in tuples if all(i % k == 0 for i in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    return [t for t in tuple_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(t_list, k):\n    #result list to store tuples that meet the criteria\n    result = []\n    #iterate over each tuple in the list\n    for t in t_list:\n        #all function returns True if all elements in iterable (tuple) are True\n        #we use a map object where every element is checked if it is divisible by k\n        if all(map(lambda x: x % k == 0, t)):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    # list to store results\n    result = []\n    for tuple in tuples:\n        # Boolean flag to store if tuple contains only elements divisible by k\n        is_divisible = True\n        for element in tuple:\n            # if element not divisible by k, set is_divisible to False and break\n            if element % k != 0:\n                is_divisible = False\n                break\n        # if is_divisible is True, append tuple to result\n        if is_divisible:\n            result.append(tuple)\n    return result", "matching_cluster_idx": 8}, {"solution": "def find_tuples(list_of_tuples, k):\n    return [t for t in list_of_tuples if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for i in lst:\n        if i in freqs:\n            freqs[i] += 1\n        else:\n            freqs[i] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    freq_dict = {}\n    for i in input_list:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    output_dict = {}\n    for item in input_list:\n        if item in output_dict:\n            output_dict[item] += 1\n        else:\n            output_dict[item] = 1\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    freq_dict = {}\n    for item in input_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for elem in lst:\n        if elem in freq_dict:\n            freq_dict[elem] += 1\n        else:\n            freq_dict[elem] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency count\n    freq_dict = {}\n\n    # Iterate over the list\n    for element in lst:\n        # If the element is not in the dictionary, add it with a count of 1\n        if element not in freq_dict:\n            freq_dict[element] = 1\n        # If the element is already in the dictionary, increment its count by 1\n        else:\n            freq_dict[element] += 1\n\n    # Return the dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to hold the frequency counts\n    freq_dict = {}\n    \n    # Iterate over each element in the input list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            freq_dict[element] = 1\n            \n    # Return the frequency dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    freq_dict = {}\n    for i in input_list:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for ele in lst:\n        if ele in freq:\n            freq[ele] += 1\n        else:\n            freq[ele] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freqs = {}\n    for element in lst:\n        if element in freqs:\n            freqs[element] += 1\n        else:\n            freqs[element] = 1\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for ele in lst:\n        if ele in frequency:\n            frequency[ele] += 1\n        else:\n            frequency[ele] = 1\n    return frequency", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/94": {"dps": 78.04878048780488, "dps_norm": 60.0, "pass@1": 98.0, "profiled": [{"solution": "def index_minimum(input_list):\n    # find the tuple with the smallest second value\n    smallest = min(input_list, key=lambda x: x[1])\n    # return the first value of that tuple\n    return smallest[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    return min(list_of_tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(t_list):\n    # sort the list of tuples by the second value of each tuple\n    sorted_list = sorted(t_list, key=lambda x: x[1])\n    # return the first value of the tuple with the smallest second value\n    return sorted_list[0][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    smallest_tuple = min(tuples_list, key=lambda x: x[1])\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    # The \"key\" argument of \"min\" is a function that gets applied to each item \n    # before comparing them. Here, it gives the second element of each tuple\n    smallest_tuple = min(tuples, key=lambda x: x[1])\n    # Return the first value of the smallest tuple\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    # Check if the list is not empty\n    if tuple_list:\n        # Return the first value of the tuple with the smallest second value.\n        return min(tuple_list, key=lambda x: x[1])[0]\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x:x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"Return the first value of the tuple with the smallest second value\"\"\"\n    return min(list_of_tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    # Use min function with a key to get the tuple with the smallest second value\n    min_tuple = min(list_of_tuples, key=lambda x: x[1])\n    # Return the first value of the tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x:x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    smallest_second_value = min(list_of_tuples, key=lambda x: x[1])\n    return smallest_second_value[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    # Find the index of the tuple with the smallest second value\n    index_min = min(range(len(tuples)), key=lambda i: tuples[i][1])\n    \n    # Return the first value of the tuple with the smallest second value\n    return tuples[index_min][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 91.1111111111111, "dps_norm": 77.14285714285714, "pass@1": 93.0, "profiled": [{"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2\n            if i * i == n:\n                count -= 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            count += 2 if n / i != i else 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 2 if n / i != i else 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            # In case of a divisor pair, say (2, 10), we increment the count by 2.\n            count += 2\n    # In case n is a perfect square, we have counted its square root twice.\n    if n == i*i:\n        count -= 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if n/i == i:\n                count = count + 1\n            else:\n                count = count + 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n//i:\n                count = count + 1\n            else:\n                count = count + 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal\n            if i * i == n:\n                count += 1\n            else: # Otherwise\n                count += 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1): \n        if n % i == 0: \n            count += 2 if n/i != i else 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2  # counting both i and n/i\n    # check if n is a perfect square and reduce the count by 1\n    if n**0.5 == i:\n        count -= 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # In case of a divisor pair (i, n//i)\n            count += 2 if i != n//i else 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2\n            if i == n // i:\n                count -= 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(num):\n    count = 0\n    for i in range(1, num+1):\n        if num % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1): \n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 6}]}, "Mbpp/97": {"dps": 90.35897435897436, "dps_norm": 81.25, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(lst):\n    flatten_list = [item for sublist in lst for item in sublist]\n    return {i: flatten_list.count(i) for i in flatten_list}", "matching_cluster_idx": 1}, {"solution": "def frequency_lists(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    frequency_dict = {}\n    for i in flat_list:\n        if i in frequency_dict:\n            frequency_dict[i] += 1\n        else:\n            frequency_dict[i] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    freq = {}\n    for item in flat_list:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Function that takes a list of lists and returns a dictionary with the frequency of each element.\n\n    Args:\n    list_of_lists: list of lists with integers\n\n    Returns:\n    Dictionary with integers as keys and frequency as values.\n\n    \"\"\"\n    from collections import Counter\n    flattened_list = [num for sublist in list_of_lists for num in sublist]\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists\n    flat_list = [element for sublist in list_of_lists for element in sublist]\n\n    # Create a dictionary to store element frequencies\n    freq_dict = {}\n\n    # Iterate over the flat list and update frequencies in dictionary\n    for element in flat_list:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    from collections import Counter\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    \"\"\"\n    This function finds the frequency of each element in a flattened list of lists and returns the results in a dictionary.\n    \"\"\"\n    flattened_lst = [i for sublist in lst for i in sublist]\n    freq_dict = {}\n    for item in flattened_lst:\n        if (item in freq_dict):\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    freq_dict = {}\n    for sublist in lst:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flatten_list = [item for sublist in lst for item in sublist]\n    frequency = {}\n    for i in flatten_list:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flattened = [item for sublist in lst for item in sublist]\n    frequency = {}\n    for i in flattened:\n        if i in frequency:\n            frequency[i] += 1\n        else:\n            frequency[i] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lsts):\n    freq_dict = {}\n    for lst in lsts:\n        for ele in lst:\n            if ele in freq_dict:\n                freq_dict[ele] += 1\n            else:\n                freq_dict[ele] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    freq_dict = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lsts):\n    from collections import Counter\n    flattened_list = [item for sublist in lsts for item in sublist]\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n\n    # Create a dictionary and populate it with the count of each element\n    freq_dict = {}\n    for i in flat_list:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    flattened_list = [elem for sublist in list_of_lists for elem in sublist]\n    frequency_dict = {}\n    for elem in flattened_list:\n        if elem in frequency_dict:\n            frequency_dict[elem] += 1\n        else:\n            frequency_dict[elem] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(ll):\n    \"\"\"Return the frequency of each element in a flattened list of lists.\n\n    Parameters:\n    ll (list): a list of lists\n\n    Returns:\n    dict: a dictionary where keys are the elements in the list of lists,\n          and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists\n    flat_list = [item for sublist in ll for item in sublist]\n    \n    # Initialize an empty dictionary\n    freq_dict = {}\n    \n    # Iterate over the flattened list\n    for i in flat_list:\n        # If the item is already in the dictionary, increment its count\n        if i in freq_dict:\n            freq_dict[i] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[i] = 1\n    \n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flattened_list = [item for sublist in lst for item in sublist]\n    frequency_dict = {}\n    for i in flattened_list:\n        if i in frequency_dict:\n            frequency_dict[i] += 1\n        else:\n            frequency_dict[i] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(ll):\n    # Flatten the list of lists\n    flat_list = [item for sublist in ll for item in sublist]\n\n    # Create a dictionary with the frequency of each element\n    freq_dict = {}\n    for elem in flat_list:\n        if elem in freq_dict:\n            freq_dict[elem] += 1\n        else:\n            freq_dict[elem] = 1\n\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flattened = [num for sublist in lst for num in sublist]\n    result = {num: flattened.count(num) for num in flattened}\n    return result", "matching_cluster_idx": 1}]}, "Mbpp/106": {"dps": 54.51298701298701, "dps_norm": 85.83333333333333, "pass@1": 90.0, "profiled": [{"solution": "def add_lists(lst, tpl):\n    return tuple(tpl) + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends a list to a tuple and returns a new tuple.\"\"\"\n    # Convert the tuple to a list so we can append the elements from the input list\n    new_tpl = list(tpl)\n    \n    # Append each element from the input list to the new list\n    for item in lst:\n        new_tpl.append(item)\n        \n    # Convert the new list back to a tuple and return\n    return tuple(new_tpl)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Convert the given list to a tuple and append it to the given tuples.\n    :param lst: The list to append.\n    :param tpl: The tuple to append to.\n    :return: The appended tuple.\n    \"\"\"\n    return tuple(tpl) + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Appends the list to the end of the tuple and return the combined tuple\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_append, tuple_to_append_to):\n    # Convert tuple to list\n    temp_list = list(tuple_to_append_to)\n    \n    # Append given list to the above list\n    temp_list.extend(list_to_append)\n    \n    # Convert the above list back to tuple and return\n    return tuple(temp_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list_to_append, tuple_to_append_to):\n    # Convert the tuple to a list\n    temp_list = list(tuple_to_append_to)\n    \n    # Append the given list to this list\n    temp_list.extend(list_to_append)\n    \n    # Convert the list back to a tuple and return\n    return tuple(temp_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # convert tuple to list\n    tup_list = list(tup)\n\n    # append the given list to the tuple\n    tup_list.extend(lst)\n\n    # convert the list back to tuple\n    new_tup = tuple(tup_list)\n\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_append, tuple_to_append_to):\n    # Convert tuple to list\n    tuple_as_list = list(tuple_to_append_to)\n    \n    # Append list to tuple (which is really list now)\n    tuple_as_list.extend(list_to_append)\n    \n    # Convert back to tuple and return\n    return tuple(tuple_as_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_append, tuple_to_append_to):\n    \"\"\"Appends a list to a tuple.\"\"\"\n    \n    # Convert the tuple to a list\n    temp_list = list(tuple_to_append_to)\n    \n    # Extend the list with the elements of the other list\n    temp_list.extend(list_to_append)\n    \n    # Return the extended list as a tuple\n    return tuple(temp_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tuple(tpl) + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tuple(tpl) + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # convert tuple to list\n    list_converted = list(tpl)\n    \n    # extend the converted list by given list\n    list_converted.extend(lst)\n    \n    # convert the list back to tuple\n    tuple_final = tuple(list_converted)\n    \n    return tuple_final", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_append, tuple_to_append_to):\n    return tuple_to_append_to + tuple(list_to_append)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tuple(tpl) + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # Convert the list to a tuple\n    tpl_list = tuple(lst)\n    \n    # Concatenate the tuples\n    result = tpl + tpl_list\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    # convert tuple to list\n    tpl = list(tpl)\n    \n    # append the list to the tuple\n    tpl.extend(lst)\n    \n    # return the final tuple\n    return tuple(tpl)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 92.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"Function to merge and sort three lists.\"\"\"\n    \n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    \n    # Sort the merged list\n    merged_list.sort()\n    \n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Concatenate the three lists\n    combined_list = list1 + list2 + list3\n    # Sort and return the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merges the lists and sorts them\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merging the three lists\n    merged_list = list1 + list2 + list3\n    # Sorting the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    return sorted(lst1 + lst2 + lst3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    result = lst1 + lst2 + lst3\n    result.sort()\n    return result", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1,l2,l3):\n    # concatenate three lists\n    l = l1 + l2 + l3\n    # sort and return the list\n    return sorted(l)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    combined_list = list1 + list2 + list3\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    merged_lst = lst1 + lst2 + lst3\n    merged_lst.sort()\n    return merged_lst", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # merge lists\n    merged_lst = lst1 + lst2 + lst3\n    # sort the list\n    sorted_lst = sorted(merged_lst)\n    # return the sorted list\n    return sorted_lst", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    return sorted(lst1 + lst2 + lst3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # combine three lists\n    combined = list1 + list2 + list3\n    # sort the combined list\n    combined.sort()\n    return combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # combine three lists\n    lst = lst1 + lst2 + lst3\n    \n    # sort the combined list\n    lst.sort()\n\n    return lst", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # merge three lists\n    merged = lst1 + lst2 + lst3\n    # sort the merged list\n    sorted_lst = sorted(merged)\n    return sorted_lst", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    combined_list = list1 + list2 + list3\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    return sorted(l1 + l2 + l3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 43.03076923076923, "dps_norm": 75.625, "pass@1": 97.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each list in the nested list to a set.\n    # Then convert the nested_lists variable to a set of sets for future use.\n    nested_sets = [set(lst) for lst in nested_lists]\n\n    # Use the intersection function provided by set object to find the common elements.\n    # This works because for set intersection, order doesn't matter.\n    common_elements = set.intersection(*nested_sets)\n\n    return list(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Start by converting the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the set by keeping only elements present in the current list\n        common_elements = common_elements.intersection(set(lst))\n    \n    # Return the common elements as a list\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function takes a list of nested lists as input. It finds the common elements in\n    all the nested lists and returns them in a list.\n    \"\"\"\n    return list(set.intersection(*map(set, nested_lists)))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    if len(nested_list) == 0:\n        return []\n\n    common = set(nested_list[0])\n    for lst in nested_list[1:]:\n        common &= set(lst)\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sub-list to a set and find the intersection of all sets\n    return list(set.intersection(*map(set, nested_lists)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Using set intersection\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lst):\n    \"\"\"\n    This function takes a list of lists as input and returns a set of common elements in all lists.\n    \n    Parameter:\n    lst (list): A list of lists.\n    \n    Returns:\n    set: A set of common elements in all lists.\n    \"\"\"\n    return set(lst[0]).intersection(*lst)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    This function takes a list of lists and returns a list of common elements.\n    \"\"\"\n    sets = [set(lst) for lst in lists]\n    common_elements = sets[0].intersection(*sets)\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    # return the intersection of all lists in the nested list, converted back to a list\n    return list(set.intersection(*map(set, nested_list)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(lst):\n    # Intersection of all lists\n    common_elements = set(lst[0]).intersection(*lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each list to a set. Then, find the intersection of all sets.\n    return list(set.intersection(*map(set, nested_lists)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists:\n        common_elements = common_elements.intersection(set(lst))\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lst):\n    # convert lists of lists to set of sets\n    set_lst = list(map(set, lst))\n    # find intersection of all sets\n    common_elements = set.intersection(*set_lst)\n    return list(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(lst):\n    return list(set(lst[0]).intersection(*lst))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    return list(set.intersection(*map(set, nested_lists)))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    # Convert each list to set for comparison\n    set_list = [set(lst) for lst in nested_list]\n\n    # Return the intersection of all sets\n    return list(set.intersection(*set_list))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"Return common elements in a nested list.\"\"\"\n    return list(set.intersection(*map(set, nested_lists)))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(lists):\n    if not lists:\n        return []\n    common_elements = set(lists[0])\n    for lst in lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)\nlists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"Return the common elements in a list of nested lists.\"\"\"\n    if not lists:\n        return []\n    common_elements = set(lists[0])\n    for lst in lists[1:]:\n        common_elements = common_elements & set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each inner list into a set, then find the intersection of all sets.\n    common_elements = set(nested_lists[0])\n    for l in nested_lists[1:]:\n        common_elements &= set(l)\n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 86.0, "profiled": [{"solution": "def proper_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            if n // i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return divisors\ndef amicable_numbers_sum(n):\n    result = 0\n    for i in range(2, n+1):\n        div_sum = sum(proper_divisors(i))\n        if i != div_sum and sum(proper_divisors(div_sum)) == i:\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i*i != n:\n                divisors.extend([i, n // i])\n            else:\n                divisors.append(i)\n    return divisors\ndef amicable_numbers_sum(n):\n    if n < 220:\n        return 0\n    divisor_sums = [0]*(n+1)\n    for i in range(2, n+1):\n        divisor_sums[i] = sum(proper_divisors(i))\n    total = 0\n    for i in range(2, n+1):\n        if divisor_sums[i] <= n and i != divisor_sums[i] and i == divisor_sums[divisor_sums[i]]:\n            total += i\n    return total", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return divisors\ndef amicable_numbers_sum(limit):\n    total_sum = 0\n    for num in range(2, limit + 1):\n        divisor_sum = sum(proper_divisors(num))\n        if divisor_sum != num and sum(proper_divisors(divisor_sum)) == num:\n            total_sum += num\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    result = 1\n    i = 2\n    while i * i <= n:\n        if (n % i == 0):\n            if (i == (n / i)):\n                result = result + i\n            else:\n                result = result + (i + n//i)\n        i += 1\n    return result\ndef amicable_numbers_sum(num):\n    result = 0\n    for i in range(2, num + 1):\n        sum1 = sum_of_proper_divisors(i)\n        if (sum1 != i):\n            sum2 = sum_of_proper_divisors(sum1)\n            if (i == sum2):\n                result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    result = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i * i != n:  # If i is not a square root of n\n                result += n // i\n    return result\ndef amicable_numbers_sum(limit):\n    result = 0\n    for i in range(2, limit + 1):\n        j = sum_of_proper_divisors(i)\n        if j > i and sum_of_proper_divisors(j) == i:\n            result += i + j\n    return result", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i != n:\n                divisors.extend([i, n // i])\n            else:\n                divisors.append(i)\n    return divisors\ndef amicable_numbers_sum(max_number):\n    sums_of_divisors = [0]*(max_number+1)\n    for i in range(1, max_number+1):\n        sums_of_divisors[i] = sum(proper_divisors(i))\n\n    result = 0\n    for i in range(1, max_number+1):\n        j = sums_of_divisors[i]\n        if j != i and j <= max_number and sums_of_divisors[j] == i:\n            result += i\n\n    return result", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    def divisors_sum(n):\n        result = 1\n        lim = int(n ** 0.5)\n        for i in range(2, lim + 1):\n            if n % i == 0:\n                if i == (n / i):\n                    result = result + i\n                else:\n                    result = result + (i + n // i)\n        return result\n\n    result = 0\n    for a in range(2, num + 1):\n        b = divisors_sum(a)\n        if a != b and divisors_sum(b) == a:\n            result += a\n\n    return result", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5)+1):\n        if n % i:\n            continue\n        if i * i != n:\n            divisors.extend([i, n//i])\n        else:\n            divisors.append(i)\n    return divisors\ndef amicable_numbers_sum(n):\n    result = 0\n    for i in range(1, n+1):\n        sum1 = sum(proper_divisors(i))\n        sum2 = sum(proper_divisors(sum1))\n        if i == sum2 and i != sum1:\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    \"\"\"Find the sum of the proper divisors of n.\"\"\"\n    result = 1\n    upper_bound = int(n**0.5)\n    for i in range(2, upper_bound + 1):\n        if n % i == 0:\n            result += i\n            if i * i != n:\n                result += n // i\n    return result\ndef amicable_numbers_sum(limit):\n    \"\"\"Find the sum of all amicable numbers up to the specified limit.\"\"\"\n    result = 0\n    for i in range(1, limit + 1):\n        j = proper_divisors(i)\n        if i != j and proper_divisors(j) == i:\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def proper_divisors_sum(n):\n    \"\"\"Returns the sum of proper divisors of n\"\"\"\n    result = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i * i != n:  # If i is not the square root of n\n                result += n // i\n    return result\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers up to the given limit\"\"\"\n    result = 0\n    for i in range(2, limit+1):\n        j = proper_divisors_sum(i)\n        if i != j and proper_divisors_sum(j) == i:\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * (n // i) == n:\n                sum = sum + i + n//i\n            else:\n                sum = sum + i\n            i += 1\n    return sum\ndef amicable_numbers_sum(max_num):\n    sum = 0\n    for num in range(1, max_num):\n        temp_num = sum_of_divisors(num)\n        if sum_of_divisors(temp_num) == num and temp_num != num:\n            sum += num\n    return sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    result = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i * i != n:\n                result += n // i\n    return result\ndef amicable_numbers_sum(limit):\n    sums = [0]*(limit+1)\n    for i in range(1, limit+1):\n        sums[i] = sum_of_proper_divisors(i)\n\n    total = 0\n    for i in range(2, limit+1):\n        if sums[i] <= limit and i != sums[i] and i == sums[sums[i]]:\n            total += i\n    return total", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    result = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            result.append(i)\n            if i * i != n and i != 1:\n                result.append(n // i)\n    return result\ndef is_amicable(n):\n    sum_divisors = sum(proper_divisors(n))\n    if sum_divisors == n or sum(proper_divisors(sum_divisors)) != n:\n        return False\n    return True\ndef amicable_numbers_sum(n):\n    result = 0\n    for i in range(1, n + 1):\n        if is_amicable(i):\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def divisors(n):\n    divs = [1]\n    for i in range(2,int(n**0.5)+1):\n        if n%i == 0:\n            if n/i == i:\n                divs.append(i)\n            else:\n                divs.extend([i, n//i])\n    return divs\ndef amicable_numbers_sum(limit):\n    sums = [0]*(limit+1)\n    for i in range(1, limit+1):\n        sums[i] = sum(divisors(i))\n\n    total = 0\n    for i in range(2, limit+1):\n        if sums[i] <= limit and i != sums[i] and i == sums[sums[i]]:\n            total += i\n\n    return total", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def divisors(num): \n        divs = [1] \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                if num//i == i:\n                    divs.append(i)\n                else:\n                    divs.extend([i, num//i])\n        return divs \n\n    def is_amicable(a):\n        b = sum(divisors(a))\n        return a != b and sum(divisors(b)) == a\n\n    return sum(x for x in range(2, n+1) if is_amicable(x))", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5)+1):\n        if n % i:\n            continue\n        if i * i != n:\n            divisors.extend([i, n // i])\n        else:\n            divisors.append(i)\n    return divisors\ndef is_amicable(n):\n    sum1 = sum(proper_divisors(n))\n    if sum1 == n or n == 1:\n        return False\n    sum2 = sum(proper_divisors(sum1))\n    return n == sum2\ndef amicable_numbers_sum(limit):\n    total = 0\n    for num in range(1, limit+1):\n        if is_amicable(num):\n            total += num\n    return total", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    \"\"\"Returns the sum of the proper divisors of n\"\"\"\n    result = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i * i != n:\n                result += n // i\n    return result\ndef amicable_numbers_sum(upper_limit):\n    \"\"\"Returns the sum of all amicable numbers up to upper_limit\"\"\"\n    result = 0\n    for a in range(2, upper_limit + 1):\n        b = proper_divisors(a)\n        if a != b and proper_divisors(b) == a:\n            result += a\n    return result", "matching_cluster_idx": 11}, {"solution": "def divisors_sum(n):\n    \"\"\"Find the sum of divisors of a number\"\"\"\n    result = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * (n // i) == n:\n                result = result + i + n//i\n            i += 1\n    return result\ndef amicable_numbers_sum(limit):\n    \"\"\"Find the sum of all amicable numbers from 1 to a specified number\"\"\"\n    result = 0\n    for i in range(2, limit+1):\n        j = divisors_sum(i)\n        if j > i and divisors_sum(j) == i:\n            result += i + j\n    return result", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n\"\"\"\n    result = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i * i != n:\n                result += n // i\n    return result\ndef is_amicable(n):\n    \"\"\"Checks if a number is amicable\"\"\"\n    pair = proper_divisors(n)\n    return pair != n and proper_divisors(pair) == n\ndef amicable_numbers_sum(upper_limit):\n    \"\"\"Sum all amicable numbers from 1 to a specified number\"\"\"\n    result = 0\n    for i in range(2, upper_limit + 1):\n        if is_amicable(i):\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def proper_divisors_sum(n):\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i:\n            continue\n        if i * i != n:\n            sum = sum + i + n//i\n        else:\n            sum = sum + i\n    return sum\ndef amicable_numbers_sum(limit):\n    sum = 0\n    for i in range(2, limit + 1):\n        j = proper_divisors_sum(i)\n        if j > i and proper_divisors_sum(j) == i:\n            sum += (i + j)\n    return sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    words = str.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    words = string.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    words_list = words.split()\n    return [word for word in words_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Filter words that are longer than n characters\n    long_words = [word for word in words if len(word) > n]\n\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Function to find words that are longer than n characters from a given sentence.\n    :param n: an integer specifying the minimum length of the word\n    :param sentence: a string of words separated by spaces\n    :return: a list of words in the sentence that are longer than n characters\n    \"\"\"\n    words = sentence.split(\" \")\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words_str):\n    word_list = words_str.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    words_list = words.split(\" \")\n    return [word for word in words_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"Find words longer than n characters from a given list.\"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    # Splitting the string into words and storing them in a list\n    words = string.split()\n    # Using list comprehension to find words longer than n characters\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 72.39795918367346, "dps_norm": 93.66666666666667, "pass@1": 41.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row for comparison\n    first_row_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != first_row_sum:\n            return False\n\n    # Check the sum of each column\n    for j in range(n):\n        column_sum = 0\n        for i in range(n):\n            column_sum += matrix[i][j]\n        if column_sum != first_row_sum:\n            return False\n\n    # Check the sum of the first diagonal\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != first_row_sum:\n        return False\n\n    # Check the sum of the second diagonal\n    diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum != first_row_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # check rows and columns length\n    for i in range(n):\n        if len(matrix[i]) != n:\n            return False\n\n    # calculate the magic constant (sum of each line for a magic square)\n    magic_constant = sum(matrix[0])\n\n    # check sum of each row and each column\n    for i in range(n):\n        if sum(matrix[i]) != magic_constant:\n            return False\n        if sum([row[i] for row in matrix]) != magic_constant:\n            return False\n\n    # check sum of both diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != magic_constant:\n        return False\n\n    # if all the checks passed, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(square):\n    # Calculate the length of the square\n    n = len(square)\n\n    # Calculate the sum of the elements in a row, a column or the two diagonals\n    magicsum = sum(square[0])\n\n    # Test sum of rows\n    for row in square:\n        if sum(row) != magicsum:\n            return False\n\n    # Test sum of columns\n    for i in range(n):\n        if sum(row[i] for row in square) != magicsum:\n            return False\n\n    # Test sum of diagonals\n    if sum(square[i][i] for i in range(n)) != magicsum:\n        return False\n\n    if sum(square[i][n-i-1] for i in range(n)) != magicsum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Get the length of the matrix\n    n = len(matrix)\n\n    # Get the sum of the first row, to be used for comparison\n    first_row_sum = sum(matrix[0])\n\n    # Check rows sums\n    for row in matrix:\n        if sum(row) != first_row_sum:\n            return False\n\n    # Check columns sums\n    for i in range(n):\n        if sum(row[i] for row in matrix) != first_row_sum:\n            return False\n\n    # Check diagonals sums\n    if sum(matrix[i][i] for i in range(n)) != first_row_sum:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != first_row_sum:\n        return False\n\n    # If all checks passed, it is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the required sum\n    total_sum = sum(matrix[0])\n\n    # Check the sum of the rows\n    for row in matrix:\n        if sum(row) != total_sum:\n            return False\n\n    # Check the sum of the columns\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != total_sum:\n            return False\n\n    # Check the sum of the diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != total_sum:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != total_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Get the size of the matrix\n    n = len(matrix)\n\n    # Calculate the magic constant (which should be the same for all rows, columns, and diagonals)\n    magic_constant = sum(matrix[0])\n\n    # Check all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check all columns\n    for i in range(n):\n        if sum(row[i] for row in matrix) != magic_constant:\n            return False\n\n    # Check both diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if matrix is square\n    if len(matrix) == 0 or len(matrix) != len(matrix[0]):\n        return False\n    \n    # Calculate the magic constant (the sum in any row, column or diagonal)\n    magic_constant = sum(matrix[0])\n    \n    # Check sum of each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n            \n    # Check sum of each column\n    for col in range(len(matrix)):\n        if sum(row[col] for row in matrix) != magic_constant:\n            return False\n            \n    # Check sum of diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_constant:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(square):\n    n = len(square)\n\n    # calculate the sum of any row, any column or any diagonal\n    standard_sum = sum(square[0])\n\n    # check all rows and columns\n    for i in range(n):\n        if sum(square[i]) != standard_sum or sum(square[j][i] for j in range(n)) != standard_sum:\n            return False\n\n    # check both diagonals\n    if sum(square[i][i] for i in range(n)) != standard_sum or sum(square[i][n-i-1] for i in range(n)) != standard_sum:\n        return False\n\n    # all checks passed\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row for comparison\n    sum_row = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != sum_row:\n            return False\n\n    # Check columns\n    for i in range(n):\n        if sum(matrix[j][i] for j in range(n)) != sum_row:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != sum_row:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != sum_row:\n        return False\n\n    # If all rows, columns and diagonals sum to the same value, it is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n\n    # Check all row lengths are the same\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the magic constant (sum of one row/col/diag)\n    magic_constant = sum(matrix[0])\n\n    # Check all rows and columns\n    for i in range(n):\n        if sum(row[i] for row in matrix) != magic_constant or sum(matrix[i]) != magic_constant:\n            return False\n\n    # Check both diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant or sum(matrix[i][n-i-1] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    #Calculate the length of the matrix\n    n = len(matrix)\n    #Create a list to hold the sums\n    sum_list = []\n    #Calculate the sum of the first row as reference\n    magic_sum = sum(matrix[0])\n    \n    #Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    sum_list.append(magic_sum)\n    \n    #Check the sum of each column\n    for column in range(n):\n        if sum(row[column] for row in matrix) != magic_sum:\n            return False\n    sum_list.append(magic_sum)\n    \n    #Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    sum_list.append(magic_sum)\n    \n    #Check the sum of the secondary diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    sum_list.append(magic_sum)\n\n    #If passed all tests, return True\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    s = sum(matrix[0])\n\n    # Check the sums of the rows\n    for row in matrix:\n        if sum(row) != s:\n            return False\n\n    # Check the sums of the columns\n    for i in range(len(matrix)):\n        if sum(row[i] for row in matrix) != s:\n            return False\n\n    # Check the sum of the first diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != s:\n        return False\n\n    # Check the sum of the second diagonal\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != s:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Checking that input matrix is N x N\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculating the target sum (the \"magic constant\")\n    magic_constant = sum(matrix[i][i] for i in range(n))\n\n    # Checking rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Checking columns\n    for i in range(n):\n        if sum(matrix[j][i] for j in range(n)) != magic_constant:\n            return False\n\n    # Checking diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Get the length of the matrix\n    N = len(matrix)\n\n    # Calculate the sum of any row, column or diagonal\n    target_sum = sum(matrix[0])\n\n    # Check rows and columns\n    for i in range(N):\n        if sum(matrix[i]) != target_sum:\n            return False\n        if sum([row[i] for row in matrix]) != target_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(N)) != target_sum:\n        return False\n    if sum(matrix[i][N-i-1] for i in range(N)) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Function to check if a given matrix is a magic square\n\n    # The number of rows and columns in the input matrix must be equal\n    # Otherwise, it's not a magic square by definition\n    if len(matrix) == 0 or len(matrix) != len(matrix[0]):\n        return False\n\n    n = len(matrix)\n    \n    # Create a list of the sums of each row, column and the two main diagonals\n    sums = []\n    \n    # Sum of each row\n    sums += [sum(row) for row in matrix]\n    \n    # Sum of each column\n    sums += [sum(matrix[i][j] for i in range(n)) for j in range(n)]\n    \n    # Sum of the main diagonal\n    sums.append(sum(matrix[i][i] for i in range(n)))\n    \n    # Sum of the secondary diagonal\n    sums.append(sum(matrix[i][n-i-1] for i in range(n)))\n    \n    # If all sums are equal, the matrix is a magic square\n    return len(set(sums)) == 1", "matching_cluster_idx": 4}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    N = len(matrix)\n    for row in matrix:\n        if len(row) != N:\n            return False\n\n    # Calculate the magic constant (sum of one row/column/diagonal)\n    magic_constant = sum(matrix[i][i] for i in range(N))\n\n    # Check rows and columns\n    for i in range(N):\n        if sum(matrix[i]) != magic_constant or sum(matrix[j][i] for j in range(N)) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][N-i-1] for i in range(N)) != magic_constant:\n        return False\n\n    # All checks passed\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Finding the length of the matrix\n    size = len(matrix)\n    # Calculating the sum of the first row\n    total_sum = sum(matrix[0])\n    # Comparing the sum of the each row with total_sum\n    for row in matrix:\n        if sum(row) != total_sum:\n            return False\n    # Comparing the sum of the each column with total_sum\n    for column in range(size):\n        column_sum = sum(row[column] for row in matrix)\n        if column_sum != total_sum:\n            return False\n    # Comparing the sum of the main diagonal with total_sum\n    diagonal_sum = sum(matrix[i][i] for i in range(size))\n    if diagonal_sum != total_sum:\n        return False\n    # Comparing the sum of the other diagonal with total_sum\n    diagonal_sum = sum(matrix[i][size-i-1] for i in range(size))\n    if diagonal_sum != total_sum:\n        return False\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the size of the square\n    n = len(matrix)\n\n    # Define the sum of a row or column or diagonal\n    sum_of_row_or_col_or_diagonal = sum(matrix[0])\n\n    # Checking if all the rows and columns sums are equal\n    for i in range(n):\n        if sum(matrix[i]) != sum_of_row_or_col_or_diagonal:\n            return False\n        if sum(matrix[j][i] for j in range(n)) != sum_of_row_or_col_or_diagonal:\n            return False\n\n    # Checking if the sum of both main diagonals are equal\n    if sum(matrix[i][i] for i in range(n)) != sum_of_row_or_col_or_diagonal:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != sum_of_row_or_col_or_diagonal:\n        return False\n\n    # If all checks passed, the square is a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    magic_number = sum(matrix[0])\n\n    # Check rows and columns\n    for i in range(n):\n        if sum(matrix[i]) != magic_number or sum(matrix[j][i] for j in range(n)) != magic_number:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_number or sum(matrix[i][n-i-1] for i in range(n)) != magic_number:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # calculate the sum of the first row elements. this sum should be the same for all rows, columns and diagonals\n    first_row_sum = sum(matrix[0])\n    \n    # function to check if sums of all rows, columns and both diagonals are the same as the first row sum\n    def sums_are_the_same(matrix, first_row_sum, n):\n        for i in range(n):\n            if sum(matrix[i]) != first_row_sum: # check the sum of rows\n                return False\n            if sum(matrix[j][i] for j in range(n)) != first_row_sum: # check the sum of columns\n                return False\n        if sum(matrix[i][i] for i in range(n)) != first_row_sum: # check the sum of main diagonal\n            return False\n        if sum(matrix[i][n-i-1] for i in range(n)) != first_row_sum: # check the sum of second diagonal\n            return False\n        return True\n        \n    return sums_are_the_same(matrix, first_row_sum, n)", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 76.1322869955157, "dps_norm": 68.33333333333334, "pass@1": 71.0, "profiled": [{"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(list):\n    counts = {}\n    for item in list:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    max_count = max(counts.values())\n    for key, value in counts.items():\n        if value == max_count:\n            return key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count_dict = Counter(lst)\n    max_count = max(list(count_dict.values()))\n    max_freq_item = [item for item, count in count_dict.items() if count == max_count]\n    return max_freq_item[0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\" \n    Finds the item with maximum frequency in a given list.\n\n    Args:\n    lst: a list of integers\n\n    Returns:\n    The item with maximum frequency. If there are multiple items with \n    maximum frequency, it returns the first one it encounters.\n    \"\"\"\n\n    # Dictionary to store frequency of each item\n    freq_dict = {}\n\n    # Loop through the list and update frequency count\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    # Get the item with maximum frequency\n    max_freq_item = max(freq_dict, key=freq_dict.get)\n\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Function that finds item with maximum frequency in a given list.\n    \"\"\"\n    # Initialize dictionary to hold item frequencies\n    frequencies = {}\n    # Iterate over the list\n    for item in lst:\n        # If item exists in the dictionary, increment its count\n        if item in frequencies:\n            frequencies[item] += 1\n        # Else, add the item to the dictionary with a count of 1\n        else:\n            frequencies[item] = 1\n    # Find and return the item with the maximum frequency\n    return max(frequencies, key=frequencies.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"Function to find the item with maximum frequency in a given list.\"\"\"\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_frequency = max(list(frequency_dict.values()))\n    for key, value in frequency_dict.items():\n        if value == max_frequency:\n            return key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    max_count = max(count_dict.values())\n    for item, count in count_dict.items():\n        if count == max_count:\n            return item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return max(count_dict, key=count_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"Return item with maximum frequency in a given list.\"\"\"\n    # Create a dictionary to count frequency of each item in list\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find item with maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(input_list):\n    \"\"\"Return the item with maximum frequency in a given list.\"\"\"\n    frequency_dict = {}\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    max_frequency = max(frequency_dict.values())\n    for item, frequency in frequency_dict.items():\n        if frequency == max_frequency:\n            return item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for i in lst:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    max_freq = max(count_dict.values())\n    for key, value in count_dict.items():\n        if value == max_freq:\n            return key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    This function accepts a list of integers and returns the item with maximum frequency.\n    \"\"\"\n    from collections import Counter\n    count = Counter(lst)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    max_freq = max(freq_dict.values())\n    for key, value in freq_dict.items():\n        if value == max_freq:\n            return key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # create a dictionary to hold item frequencies\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    # find the item with maximum frequency\n    max_freq = max(freq_dict.values())\n    for item, freq in freq_dict.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): input list\n    \n    Returns:\n    int: item with maximum frequency\n    \"\"\"\n    count_dict = {}\n    for i in lst:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    max_value = max(list(count_dict.values()))\n    max_freq_items = [k for k, v in count_dict.items() if v == max_value]\n    return max_freq_items[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"Return the item with maximum frequency in the given list\"\"\"\n    from collections import Counter\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(list):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n    \"\"\"\n    count_dict = {}\n    for num in list:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    max_freq = max(count_dict.values())\n    max_freq_item = [k for k, v in count_dict.items() if v == max_freq]\n\n    return max_freq_item[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    max_count = 0\n    max_item = None\n    for item in lst:\n        count = lst.count(item)\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 1}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    This function returns the item with maximum frequency in a given list.\n    \"\"\"\n    counts = {}\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    return max(counts, key=counts.get)", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/140": {"dps": 66.08695652173913, "dps_norm": 71.25, "pass@1": 96.0, "profiled": [{"solution": "def extract_singly(lst):\n    return set([num for sublist in lst for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    # flatten the list of lists into a single list\n    flattened_list = [num for sublist in list_of_lists for num in sublist]\n    # convert the list into a set to remove duplicates and return\n    return set(flattened_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    flat_list = []\n    for tpl in list_of_tuples:\n        for num in tpl:\n            flat_list.append(num)\n    return set(flat_list)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    # Flatten the list of lists\n    flattened_list = [num for sublist in nested_list for num in sublist]\n    \n    # Return the set of unique numbers\n    return set(flattened_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    # Converts each tuple into a list and then combines all of the lists into one.\n    combined_lst = [num for sublist in lst for num in sublist]\n    # Converts the combined list into a set to remove any duplicate numbers.\n    return set(combined_lst)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    # initializing empty list\n    result = []\n    # iterate over all the nested lists in the input list\n    for sub_list in lst:\n        # iterate over all elements in each nested list\n        for item in sub_list:\n            # add each item to the result list\n            result.append(item)\n    # return the list as a set to remove any duplicates and convert it to a list\n    return list(set(result))", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    return set(num for sublist in lst for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    # Use set to keep unique values\n    result = set()\n    for sublist in lst:\n        for number in sublist:\n            result.add(number)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    # Using set to eliminate duplicates, then turning the list into a set\n    return set(num for sublist in lst for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    # Using a set to remove duplicates\n    flat_set = set()\n    for sub_list in list_of_lists:\n        for item in sub_list:\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    # Using list comprehension to flatten the list of lists and \n    # converting the result to a set to eliminate duplicate values.\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    return set([num for sublist in lst for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst_lst):\n    return set([num for sublist in lst_lst for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    return set(num for sublist in lst for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    result = set()\n    for t in lst:\n        for item in t:\n            result.add(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    return set([num for sublist in lst for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    flattened_list = [number for sublist in list_of_lists for number in sublist]\n    return set(flattened_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst_of_lst):\n    # Use set to avoid duplicates\n    unique_elements = set()\n    \n    # Iterate over each sublist\n    for sublist in lst_of_lst:\n        # Extend the unique elements set with new elements from the sublist\n        unique_elements.update(sublist)\n        \n    # Return the final unique elements set\n    return unique_elements", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    # Initialize an empty list to collect elements\n    numbers = []\n    \n    # Loop over the outer list\n    for sublist in lst:\n        # Loop over the inner tuples\n        for num in sublist:\n            numbers.append(num)\n    \n    # Return a set of the collected elements\n    return set(numbers)", "matching_cluster_idx": 4}]}, "Mbpp/141": {"dps": 64.05895691609977, "dps_norm": 40.625, "pass@1": 53.0, "profiled": [{"solution": "def pancake_sort(lst):\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    def findMaxIndex(arr, n):\n        maxIndex = 0\n        for i in range(0, n):\n            if arr[i] > arr[maxIndex]:\n                maxIndex = i\n        return maxIndex\n\n    n = len(lst)\n    while n > 0:\n        maxIndex = findMaxIndex(lst, n)\n        if maxIndex != n-1:\n            flip(lst, maxIndex)\n            flip(lst, n-1)\n        n -= 1\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        min_index = i\n        for j in range(i+1, len(lst)):\n            if lst[min_index] > lst[j]:\n                min_index = j\n        lst[i], lst[min_index] = lst[min_index], lst[i]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(nums):\n    for i in range(len(nums)):\n        # get the minimum value index in the remaining list\n        min_val_index = nums[i:].index(min(nums[i:]))\n        # place the minimum value at the current index\n        nums[i], nums[min_val_index + i] = nums[min_val_index + i], nums[i]\n    return nums", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    n = len(lst)\n    for i in range(n):\n        min_idx = lst.index(min(lst[i:]), i, n)\n        if min_idx != i:\n            lst[i:min_idx+1] = lst[i:min_idx+1][::-1]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"Sort list using Pancake Sort method.\"\"\"\n    for i in range(len(lst)):\n        min_idx = i\n        for j in range(i+1, len(lst)):\n            if lst[j] < lst[min_idx]:\n                min_idx = j\n\n        # Swap the found minimum element with the first element of remaining list\n        lst[i], lst[min_idx] = lst[min_idx], lst[i]\n    \n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        min_index = i\n        for j in range(i+1, len(lst)):\n            if lst[min_index] > lst[j]:\n                min_index = j\n        lst[i], lst[min_index] = lst[min_index], lst[i]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        min_index = i\n        for j in range(i+1, len(lst)):\n            if lst[j] < lst[min_index]:\n                min_index = j\n                \n        lst[i], lst[min_index] = lst[min_index], lst[i]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        minimum = i\n        for j in range(i+1, len(lst)):\n            if lst[j] < lst[minimum]:\n                minimum = j\n        lst[i], lst[minimum] = lst[minimum], lst[i]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    \"\"\"Return sorted list with the classic pancake sort method.\"\"\"\n    \n    def flip(lst, k):\n        \"\"\"Return lst reversed up to k.\"\"\"\n        return lst[:k][::-1] + lst[k:]\n    \n    n = len(lst)\n    result = []\n    \n    for i in range(n, 0, -1):\n        # Find max in lst[:i]\n        max_index = lst[:i].index(max(lst[:i]))\n        \n        if max_index != i - 1:\n            # Flip the max value to the beginning\n            lst = flip(lst, max_index + 1)\n            # Flip the max value to the end\n            lst = flip(lst, i)\n        \n        result.append(lst[i - 1])\n    \n    return result[::-1]", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        min_idx = i\n        for j in range(i + 1, len(lst)):\n            if lst[j] < lst[min_idx]:\n                min_idx = j\n        lst[i], lst[min_idx] = lst[min_idx], lst[i]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        left = 0\n        right = k - 1\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    for i in range(n, 0, -1):\n        max_index = arr.index(max(arr[:i]))\n        if max_index != i - 1:\n            flip(arr, max_index + 1)\n            flip(arr, i)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    for i in range(len(arr)):\n        min_idx = i\n        for j in range(i+1, len(arr)):\n            if arr[min_idx] > arr[j]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        minimum = i\n        for j in range(i+1, len(lst)):\n            if lst[j] < lst[minimum]:\n                minimum = j\n        lst[i], lst[minimum] = lst[minimum], lst[i]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        min_index = i\n        for j in range(i+1, len(lst)):\n            if lst[j] < lst[min_index]:\n                min_index = j\n        lst[i], lst[min_index] = lst[min_index], lst[i]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    def find_max_index(arr, n):\n        max_index = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        return max_index\n\n    n = len(arr)\n    while n > 1:\n        max_index = find_max_index(arr, n)\n        if max_index != n - 1:\n            flip(arr, max_index)\n            flip(arr, n - 1)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        min_index = i\n        for j in range(i + 1, len(lst)):\n            if lst[j] < lst[min_index]:\n                min_index = j\n                \n        lst[i], lst[min_index] = lst[min_index], lst[i]\n                \n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(nums):\n    for i in range(len(nums)):\n        # Find the maximum element in remaining unsorted array\n        max_idx = nums.index(max(nums[:len(nums) - i]))\n\n        # If the maximum number is not at the end of the array\n        if max_idx != len(nums) - i:\n            # Flip the maximum number to the start of the array\n            nums[:max_idx + 1] = nums[:max_idx + 1][::-1]\n\n            # Flip the maximum number to the correct position\n            nums[:len(nums) - i] = nums[:len(nums) - i][::-1]\n\n    return nums", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        minimum = i\n        for j in range(i + 1, len(lst)):\n            if lst[j] < lst[minimum]:\n                minimum = j\n                \n        lst[i], lst[minimum] = lst[minimum], lst[i]\n\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        min_idx = i\n        for j in range(i+1, len(lst)):\n            if lst[j] < lst[min_idx]:\n                min_idx = j\n        lst[i], lst[min_idx] = lst[min_idx], lst[i]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        minimum = i + lst[i:].index(min(lst[i:]))\n        if minimum != i:\n            lst[i], lst[minimum] = lst[minimum], lst[i]\n    return lst", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 98.0, "profiled": [{"solution": "def find_even_pair(lst):\n    \"\"\"\n    Function that counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    n = len(lst)\n    count = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    n = len(arr)\n\n    for i in range(0, n):\n        for j in range(i+1, n):\n            if ((arr[i] ^ arr[j]) % 2 == 0):\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_pairs = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                even_pairs += 1\n    return even_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    n = len(arr)\n\n    # Select two elements from array\n    for i in range(0, n):\n        for j in range(i+1, n):\n            # XOR the two selected elements and check if it's an even number\n            if (arr[i] ^ arr[j]) & 1 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    pair_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                pair_count += 1\n    return pair_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    n = len(lst)\n    count = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    '''\n    Function to count the number of pairs of integers in a list that xor to an even number\n    '''\n    \n    # Initialize the result\n    result = 0\n    \n    # Loop through the list\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # If the xor of the pair is even, increment the result\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                result += 1\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    # Creating a variable to store the count\n    count = 0\n    \n    # Loop through the list\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            # Check if xor is even\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    for i in range(0, n):\n        for j in range(i+1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_pair_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) & 1 == 0:\n                even_pair_count += 1\n    return even_pair_count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 82.0, "profiled": [{"solution": "def sum_range_list(num_list, start_index, end_index):\n    \"\"\"Function to calculate the sum of a list from a start index to an end index\"\"\"\n    return sum(num_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, index1, index2):\n    return sum(lst[index1:index2+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_index, end_index):\n    return sum(num_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, i, j):\n    return sum(lst[i:j+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Function to calculate the sum of list items within a specified range of indices\n    \n    Parameters:\n    lst (list): List of numbers\n    start_index (int): Starting index of the range\n    end_index (int): Ending index of the range\n    \n    Returns:\n    int: Sum of list elements within the range of indices\n    \"\"\"\n    \n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # The function returns the sum of the elements in a list between two indices (inclusive).\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_index, end_index):\n    \"\"\"\n    The function takes a list of numbers and two indices as parameters. \n    It returns the sum of the numbers in the list within the range specified by the two indices.\n    \n    :param num_list: list of numbers\n    :param start_index: start of range index\n    :param end_index: end of range index\n    :returns: sum of numbers within the range\n    \"\"\"\n    return sum(num_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_index, end_index):\n    return sum(num_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    return sum(nums[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    return sum(nums[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, i, j):\n    return sum(lst[i:j+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    This function receives a list and two indices as parameters.\n    It returns the sum of elements of the list from the start index to the end index (inclusive).\n    :param lst: list\n    :param start: int\n    :param end: int\n    :return: int\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    This function returns the sum of the elements in the input list that lie \n    between the start_index and end_index (both inclusive)\n    \"\"\"\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_index, end_index):\n    return sum(num_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 83.10077519379844, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(my_string):\n    result = \"\"\n    for i in range(len(my_string)):\n        if i % 2 == 0:\n            result = result + my_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"This function returns a string of characters\n    with even index values of a given string\"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(str):\n    return str[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(str):\n    return str[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result = result + s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, character):\n    return input_string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, char):\n    \"\"\"\n    Function to replace blank spaces in a string with a given character.\n    \"\"\"\n    return input_str.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    return s.replace(\" \", ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    return input_string.replace(\" \", replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_with):\n    return input_string.replace(' ', replace_with)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(my_string, my_char):\n    \"\"\"\n    This function replaces blank spaces in the string with a given character and returns the string.\n    \n    :param my_string: a string that will be processed.\n    :param my_char: a character that will replace spaces in the string.\n    :return: the string with spaces replaced by the given character.\n    \"\"\"\n    return my_string.replace(' ', my_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(str_input, char_input):\n    return str_input.replace(\" \", char_input)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, replace_char):\n    return input_str.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(' ', character)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 89.36781609195403, "dps_norm": 85.83333333333333, "pass@1": 12.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    # Create a DP table to store the results\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Initialize the first row with 1's\n    for j in range(m + 1):\n        dp[1][j] = 1\n\n    # Fill up the DP table\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(2 * j, m + 1):\n                dp[i][j] += dp[i - 1][k]\n                \n    # The total number of sequences of length 'n' is the sum of the last row\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # The base case, when n is 0 or 1\n    if n <= 1:\n        return m\n    # Creating a memoization table to store previously computed values\n    memo = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    # Initializing the base cases\n    for i in range(m+1):\n        memo[i][0] = 1\n        memo[i][1] = i\n    # Computing the other values\n    for i in range(2, m+1):\n        for j in range(2, n+1):\n            if j > i:\n                break\n            else:\n                # Using the formula: memo[i][j] = memo[i-1][j] + memo[i//2][j-1]\n                memo[i][j] = memo[i-1][j] + memo[i//2][j-1]\n    # Returning the result\n    return memo[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2D DP table filled with 0's\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n\n    # Initialize the table for the base case\n    for i in range(1, m+1):\n        dp[i][1] = 1\n\n    # Fill up the DP table\n    for i in range(1, m+1):\n        for j in range(2, n+1):\n            for k in range(2*i, m+1):\n                dp[k][j] += dp[i][j-1]\n\n    # Get the total number of sequences\n    res = 0\n    for i in range(1, m+1):\n        res += dp[i][n]\n\n    return res", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # initial dp array\n    dp = [[0 for _ in range(n+1)] for __ in range(m+1)]\n    dp[0][0] = 1\n    for i in range(1, m+1):\n        dp[i][0] = 1\n        for j in range(1, min(i, n)+1):\n            dp[i][j] = dp[i-1][j] + dp[i//2][j-1]\n\n    return dp[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    dp[0][0] = 1\n    for i in range(1, m+1):\n        dp[i][0] = 1\n        for j in range(1, n+1):\n            dp[i][j] = dp[i-1][j] + dp[i//2][j-1]\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D array dp with dimensions (m+1) x (n+1)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # For each number i from 1 to m, set the base case where sequence length is 1 to i\n    for i in range(1, m + 1):\n        dp[i][1] = i\n    \n    # For each sequence length j from 2 to n, and for each number i from 1 to m\n    for j in range(2, n + 1):\n        for i in range(1, m + 1):\n            # The number of possible sequences of length j ending with number i \n            # is the sum of number of possible sequences of length j-1 for numbers \n            # that are twice smaller than i, which can be calculated using prefix sum\n            dp[i][j] = dp[i - 1][j] + dp[max(i // 2, i - m)][j - 1]\n            \n    # Return the number of possible sequences of length n ending with number m\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initializing a 2D DP table of size (m+1)*(n+1)\n    dp = [[0]*(n+1) for _ in range(m+1)]\n\n    # When n = 1, there are m possibilities\n    for i in range(1, m+1):\n        dp[i][1] = i\n\n    # When m < n, there are no possibilities\n    for j in range(2, n+1):\n        for i in range(j, m+1):\n            dp[i][j] = dp[i-1][j] + dp[i//2][j-1]\n\n    return dp[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2D array dp of size (m+1) x (n+1) to store the count of sequences\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # There is one sequence of length 1: [1], [2], ..., [m]\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n\n    for i in range(1, m + 1):\n        for j in range(2, n + 1):\n            # Each new element can be at least twice the previous one\n            # Hence, start from i*2 to m\n            for k in range(i * 2, m + 1):\n                dp[k][j] += dp[i][j - 1]\n\n    # Sum up the counts of sequences of length n for all possible values of m\n    total = sum(dp[i][n] for i in range(1, m + 1))\n\n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return m - 1\n\n    # Initiate the DP table\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    for i in range(m+1):\n        dp[i][1] = i  # When n == 1, there are i possibilities for sequence starting with any number < m.\n\n    # Fill the DP table\n    for seq_length in range(2, n+1):\n        for max_element in range(2, m+1):\n            dp[max_element][seq_length] = dp[max_element-1][seq_length] + dp[max_element//2][seq_length-1]\n\n    return dp[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D array with size (m+1) x (n+1) filled with zero\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill up the array using dynamic programming\n    for i in range(1, m + 1):\n        dp[i][1] = i\n        for j in range(2, n + 1):\n            dp[i][j] = dp[i // 2][j - 1] + dp[i - 1][j]\n\n    return dp[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # initialize a DP array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # base case: sequence of length 1 with elements from 1 to m\n    for i in range(1, m + 1):\n        dp[1][i] = i\n\n    # fill up the DP array\n    for i in range(2, n + 1):\n        prefix_sum = 0\n        for j in range(2, m + 1):\n            prefix_sum += dp[i - 1][j // 2]\n            dp[i][j] = prefix_sum\n\n    return dp[n][m]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = 1\n    for i in range(1, m + 1):\n        dp[i][0] = 1\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    return dp[m][n]", "matching_cluster_idx": 8}]}, "Mbpp/240": {"dps": 56.21951219512196, "dps_norm": 72.77777777777777, "pass@1": 89.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    # Remove the last element of the first list\n    list1 = list1[:-1]\n    # Add the second list elements to the first list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Append list2 to list1\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    list1[:] = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    list1[:] = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    list1.pop()  # remove the last element of the list1\n    list1.extend(list2)  # add the elements of list2 to list1\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(l1, l2):\n    l1[:] = l1[:-1] + l2\n    return l1", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element of list1\n    list1 = list1[:-1]\n    # Append list2 to list1\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1[:] = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    # removing last element from list1\n    list1 = list1[:-1]\n    # appending list2 to list1\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # replace the last element of list1 with all elements in list2\n    list1 = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1[:] = list1[:-1] + list2\n    return list1", "matching_cluster_idx": 4}, {"solution": "def replace_list(list1, list2):\n    # removes last element of list1\n    list1 = list1[:-1]\n    # concatenate list1 and list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # Replaces the last element of the first list with the elements of the second list\n    del list1[-1]\n    return list1 + list2", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # Remove last element of the first list\n    list1 = list1[:-1]\n    # Add elements of the second list to the first\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element from the first list\n    list1 = list1[:-1]\n    # Extend the first list with the elements of the second list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # remove last element of list1\n    list1 = list1[:-1]\n    # extend list1 with elements of list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # remove the last element from the first list\n    list1 = list1[:-1]\n    # add the elements of the second list to the first list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    list1.pop()\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # remove last element from list1\n    list1 = list1[:-1]\n    # add elements of list2 to list1\n    return list1 + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1.pop() # Remove the last element of the first list\n    return list1 + list2 # Combine the two lists", "matching_cluster_idx": 6}]}, "Mbpp/251": {"dps": 85.05747126436782, "dps_norm": 76.66666666666666, "pass@1": 86.0, "profiled": [{"solution": "def insert_element(lst, ele):\n    result = []\n    for item in lst:\n        result.append(ele)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(list_input, element):\n    return [val for item in list_input for val in (element, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(list, element):\n    result = []\n    for i in list:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    return [item for element_in_list in input_list for item in (element, element_in_list)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for item in input_list:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, ele):\n    result = []\n    for item in lst:\n        result.append(ele)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result_list = []\n    for item in input_list:\n        result_list.append(element)\n        result_list.append(item)\n    return result_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for i in lst:\n        result.extend([elem, i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for i in input_list:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    output_list = []\n    for item in input_list:\n        output_list.append(element)\n        output_list.append(item)\n    return output_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for item in input_list:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, insert_item):\n    result_list = []\n    for item in input_list:\n        result_list.append(insert_item)\n        result_list.append(item)\n    return result_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, elem):\n    result = []\n    for i in input_list:\n        result.append(elem)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, ele):\n    result = []\n    for i in lst:\n        result.append(ele)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result_list = []\n    for item in input_list:\n        result_list.append(element)\n        result_list.append(item)\n    return result_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 50.970319634703195, "dps_norm": 45.88235294117647, "pass@1": 87.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for ind, val in enumerate(primes):\n        if val is True:\n            primes[ind*2::ind] = [False] * (((n - 1)//ind) - 1)\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    This function receives a non-negative number and returns the number of\n    prime numbers less than the given non-negative number.\n    \"\"\"\n\n    def is_prime(num):\n        \"\"\"\n        This helper function checks if a given number is prime.\n        \"\"\"\n        if num <= 1:\n            return False\n\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n\n        return True\n\n    # Count the number of prime numbers less than 'n'\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Primes_nums(n):\n    def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [1] * n\n    sieve[0] = sieve[1] = 0\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = 0\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes_count = 0\n    for num in range(n):\n        if is_prime(num):\n            primes_count += 1\n    return primes_count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Function to count prime numbers less than n\n    \"\"\"\n    if n < 2:\n        return 0\n\n    primes = [0, 0] + [1]*(n-2)\n    p = 2\n    while p * p <= n:\n        if primes[p] == 1:\n            for i in range(p*p, n, p):\n                primes[i] = 0\n        p += 1\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2,int(num**0.5)+1):\n            if num%i==0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2,num):\n            if num%i == 0:\n                return False\n        return True\n    primes = [i for i in range(n) if is_prime(i)]\n    return len(primes)", "matching_cluster_idx": 2}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2,num):\n            if num%i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Primes_nums(num):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [x for x in range(2, num) if is_prime(x)]\n    return len(primes)", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n: int) -> int:\n    def is_prime(num):\n        \"\"\"Utility function to check if a number is prime\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n: int) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(num):\n    def is_prime(n):\n        if n <= 1 or (n % 2 == 0 and n > 2): \n            return False\n        return all(n % i for i in range(3, int(n**0.5) + 1, 2))\n\n    primes = [n for n in range(num) if is_prime(n)]\n    return len(primes)", "matching_cluster_idx": 9}, {"solution": "def count_Primes_nums(n):\n    '''Return the number of prime numbers less than n.'''\n\n    # Helper function to check if a number is prime\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n\n    # Count the primes\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Primes_nums(n: int) -> int:\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for current_prime in range(2, int(n ** 0.5) + 1):\n        if sieve[current_prime]:\n            for multiple in range(current_prime * current_prime, n, current_prime):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2,num):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2,n) if is_prime(i)]\n    return len(primes)", "matching_cluster_idx": 1}, {"solution": "def count_Primes_nums(n: int) -> int:\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2,num):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/265": {"dps": 67.5, "dps_norm": 80.83333333333333, "pass@1": 95.0, "profiled": [{"solution": "def list_split(lst, n):\n    splits = [[] for _ in range(n)]\n    for i, element in enumerate(lst):\n        splits[i % n].append(element)\n    return splits", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i%n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(l, n):\n    return [l[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Split a list into sublists for every nth element.\n\n    Arguments:\n    lst: Input list\n    n: Number of elements in each sublist\n\n    Returns:\n    A list of sublists\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    res = []\n    for i in range(n):\n        sublist = [lst[x] for x in range(i, len(lst), n)]\n        res.append(sublist)\n    return res", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    list_len = len(input_list)\n    output_lists = [ [] for _ in range(n) ]\n    for i in range(list_len):\n        output_lists[i%n].append(input_list[i])\n    return output_lists", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    lists = [[] for _ in range(n)]\n    for i, value in enumerate(input_list):\n        lists[i % n].append(value)\n    return lists", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(l, n):\n    return [l[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    result = []\n    for i in range(n):\n        result.append(input_list[i::n])\n    return result", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    This function checks if the elements in a given list are unique or not.\n    :param lst: List of elements\n    :return: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Function that checks if all elements in a list are unique\n    :param lst: List of elements\n    :return: True if all elements are unique, False otherwise\n    \"\"\"\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    The function checks if the elements in the list are unique.\n\n    Parameters:\n    lst (list): a list of elements\n\n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a list are unique.\n\n    Parameters:\n    lst (list): a list of elements\n\n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 28.205128205128204, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 90.96551724137932, "dps_norm": 65.0, "pass@1": 93.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n    # Create a list of products for each pair of values from two lists\n    products = [a*b for a in list1 for b in list2]\n    # Sort the list in descending order and return the first n elements\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    from itertools import product\n    from heapq import nlargest\n\n    # Compute products for each pair of numbers from both lists\n    products = [a * b for a, b in product(list1, list2)]\n\n    # Return the n largest products\n    return nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    from heapq import nlargest\n    from operator import mul\n\n    products = [mul(a, b) for a in list1 for b in list2]\n    return nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Create a list of products by multiplying each element in list1 with each element in list2\n    products = [i*j for i in list1 for j in list2]\n    # Sort the list of products in descending order\n    products.sort(reverse=True)\n    # Return the first 'num' elements from the sorted list of products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate products\n    products = [i*j for i in list1 for j in list2]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the first 'n' products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    from itertools import product\n    from operator import mul\n    from heapq import nlargest\n    return nlargest(n, [mul(*pair) for pair in product(list1, list2)])", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    import heapq\n    \n    # Generate all possible pairs of factors\n    pairs = [(i*j, i, j) for i in list1 for j in list2]\n    \n    # Use a heap to get the n largest products\n    return [x[0] for x in heapq.nlargest(n, pairs)]", "matching_cluster_idx": 3}, {"solution": "def large_product(list_a, list_b, k):\n    # Generate pairs of products\n    products = [(a * b) for a in list_a for b in list_b]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the top k largest products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, num):\n    \"\"\"\n    This function returns the specified number of largest products from two given lists.\n    \"\"\"\n    import heapq\n    # Multiply each element in lst1 with each element in lst2 and store results in a heap\n    heap = [a * b for a in lst1 for b in lst2]\n    # Get the n largest elements from the heap\n    return heapq.nlargest(num, heap)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    products = [a*b for a in list1 for b in list2]\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, n):\n    from itertools import product\n    from heapq import nlargest\n    return nlargest(n, (x * y for x, y in product(lst1, lst2)))", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    import heapq\n\n    # Make a list of tuples from the two lists\n    pairs = [(i, j) for i in list1 for j in list2]\n    # Use a heap to find the n largest products\n    largest_products = heapq.nlargest(n, pairs, key=lambda x: x[0]*x[1])\n    # Return a list of the products themselves\n    return [i*j for i, j in largest_products]", "matching_cluster_idx": 2}, {"solution": "import itertools\nimport heapq\ndef large_product(list1, list2, N):\n    \"\"\"\n    The function returns the N largest products that can be formed from elements\n    of two lists.\n    \"\"\"\n    # get all pairs\n    pairs = list(itertools.product(list1, list2))\n    \n    # get the product of each pair and create a list of tuples (product, pair)\n    pair_products = [(pair[0]*pair[1], pair) for pair in pairs]\n    \n    # use a min-heap with size N to find the N largest products\n    largest_N_products = heapq.nlargest(N, pair_products)\n    \n    return [product[0] for product in largest_N_products]", "matching_cluster_idx": 2}, {"solution": "import itertools\ndef large_product(list1, list2, n):\n    # Get all possible product combinations\n    product_combinations = [a*b for a,b in itertools.product(list1,list2)]\n    # Sort the combinations in descending order\n    product_combinations.sort(reverse=True)\n    # Return the first 'n' largest combinations\n    return product_combinations[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    products = []\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, count):\n    import heapq\n    h = []\n    for i in list1:\n        for j in list2:\n            heapq.heappush(h, i*j)\n    return sorted(heapq.nlargest(count, h), reverse=True)", "matching_cluster_idx": 3}, {"solution": "def large_product(l1, l2, n):\n    import heapq\n    l = []\n    for i in l1:\n        for j in l2:\n            l.append(i * j)\n    largest = heapq.nlargest(n, l)\n    return largest", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, num):\n    import heapq\n    \n    products = [-a*b for a in lst1 for b in lst2]\n    return [-x for x in heapq.nsmallest(num, products)]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, n):\n    # Find all possible products\n    products = [x*y for x in lst1 for y in lst2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the first n elements (largest products)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    import heapq\n    from itertools import product\n    \n    prod_list = [-a*b for a, b in product(list1, list2)]\n    return [-i for i in heapq.nsmallest(num, prod_list)]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 96.05633802816901, "dps_norm": 98.84615384615384, "pass@1": 83.0, "profiled": [{"solution": "def get_max_sum(n, dp = {}):\n    \"\"\"\n    Function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n\n    :param n: input number \n    :param dp: dictionary to store intermediate results\n    :return: maximum sum\n    \"\"\"\n    if n == 0:\n        return 0\n\n    if n in dp:\n        return dp[n]\n\n    dp[n] = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n    return dp[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    # If result is already computed, return it\n    if n in memo:\n        return memo[n]\n    \n    # Base case\n    if n == 0:\n        return 0\n    \n    # Recursive case\n    result = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n    \n    # Memoize the result and return it\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "memo = {0: 0, 1: 1}\ndef get_max_sum(n):\n    if n not in memo:\n        memo[n] = max(n, get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5))\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    else:\n        res = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n        memo[n] = res\n        return res", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    A function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n\n    else:\n        memo[n] = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n        return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Function to calculate the maximum sum possible using the given equation.\n    Assumes that n is a positive integer.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    else:\n        memo[n] = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n        return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    if n in memo: \n        return memo[n]\n    if n < 2: \n        result = n\n    else: \n        result = max(sum(get_max_sum(n // div, memo) for div in range(2, 6)), n)\n    memo[n] = result\n    return result", "matching_cluster_idx": 11}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \"\"\"\n    if n == 0:\n        return 0\n    if n not in memo:\n        memo[n] = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    if n == 0:\n        return 0\n\n    # check if calculated before\n    if n not in memo:\n        # Calculate max sum\n        memo[n] = max(\n            get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo),\n            n\n        )\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"Find the maximum sum possible using the given function.\"\"\"\n    # If the value is in the memo, use it\n    if n in memo:\n        return memo[n]\n    # if the value is 0, then return 0\n    elif n == 0:\n        return 0\n    # Otherwise, calculate the maximum sum\n    else:\n        memo[n] = max(get_max_sum(n//2)+get_max_sum(n//3)+get_max_sum(n//4)+get_max_sum(n//5), n)\n        return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    if n in memo: return memo[n]\n    if n == 0: return 0\n    result = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # if result is already calculated, return it\n    if n in memo:\n        return memo[n]\n    # base case\n    elif n < 2:\n        return n\n    else:\n        # recursive case: calculate result and save to memo\n        memo[n] = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n        return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    This function calculates the maximum sum by applying the given equation.\n    It uses memoization for reducing the time complexity by not doing repeated work.\n    \"\"\"\n\n    # base case\n    if n == 0: \n        return 0\n\n    # check if the result is already calculated\n    if n not in memo:\n\n        # recursive case\n        memo[n] = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n\n    # return the stored result\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    elif n == 0:\n        return 0\n    else:\n        memo[n] = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n        return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={0:0, 1:1}):\n    \"\"\"\n    Function to calculate the maximum sum.\n    \"\"\"\n    if n not in memo:\n        memo[n] = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    else:\n        res = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n        memo[n] = res\n        return res", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, dp=None):\n    if dp == None:\n        dp = [-1 for _ in range(n+1)]\n\n    if n <= 0:\n        return 0\n    if dp[n] != -1:\n        return dp[n]\n\n    dp[n] = max(get_max_sum(n//2, dp) + get_max_sum(n//3, dp) + get_max_sum(n//4, dp) + get_max_sum(n//5, dp), n)\n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "cache = {}\ndef get_max_sum(n):\n    \"\"\"\n    This function uses a top-down dynamic programming approach with memoization\n    to compute the maximum sum as per the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \"\"\"\n    global cache\n\n    # Base case\n    if n == 0:\n        return 0\n    \n    # Return the cached result if already computed\n    if n in cache:\n        return cache[n]\n\n    # Recursively compute the max sum\n    max_sum = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n\n    # Cache the result\n    cache[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, cache=None):\n    if cache is None: cache = dict()\n    if n in cache: return cache[n]\n    if n < 2: return n\n    cache[n] = max(get_max_sum(n // 2, cache) + get_max_sum(n // 3, cache) + get_max_sum(n // 4, cache) + get_max_sum(n // 5, cache), n)\n    return cache[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \"\"\"\n    if n in memo: \n        return memo[n]\n    elif n == 0: \n        return 0\n    else:\n        memo[n] = max(get_max_sum(n//2)+get_max_sum(n//3)+get_max_sum(n//4)+get_max_sum(n//5), n)\n        return memo[n]", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(input_string):\n    \"\"\"Return the first non-repeating character in a string\"\"\"\n    character_frequency = {}\n    for character in input_string:\n        if character in character_frequency:\n            character_frequency[character] += 1\n        else:\n            character_frequency[character] = 1\n    for character in input_string:\n        if character_frequency[character] == 1:\n            return character\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store character frequencies\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    \n    # Check the characters in the string in order\n    for char in s:\n        if freq[char] == 1:\n            return char\n    \n    # If no non-repeating character found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character in the string\n    char_count = {}\n    \n    # Iterate through the string, updating the character count in the dictionary\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string again, checking if the count of each character in the dictionary is 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated characters are found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    frequency = {}\n    for char in string:\n        if char not in frequency:\n            frequency[char] = 1\n        else:\n            frequency[char] += 1\n    for char in string:\n        if frequency[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    frequency = {} \n    # Get frequency of each character in string\n    for char in s: \n        if char in frequency: \n            frequency[char] += 1 \n        else: \n            frequency[char] = 1 \n    \n    # Loop through string to find first character with frequency 1\n    for char in s: \n        if frequency[char] == 1: \n            return char\n    \n    # If there is no non-repeating character, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # Create a dictionary to keep track of character frequencies\n    char_freq = {}\n    \n    for char in string:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n    \n    # Iterate over string and check if char count in dict is 1\n    for char in string:\n        if char_freq[char] == 1:\n            return char\n            \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    count = {}\n    # first, count the frequency of each character\n    for ch in s:\n        if ch in count:\n            count[ch] += 1\n        else:\n            count[ch] = 1\n    # then, check each character in the string if it's the first one that appears only once\n    for ch in s:\n        if count[ch] == 1:\n            return ch\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    character_count = {}\n\n    for character in input_string:\n        if character in character_count:\n            character_count[character] += 1\n        else:\n            character_count[character] = 1\n\n    for character in input_string:\n        if character_count[character] == 1:\n            return character\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store character frequency\n    frequency = {}\n\n    for char in s:\n        if char not in frequency:\n            frequency[char] = 1\n        else:\n            frequency[char] += 1\n\n    for char in s:\n        if frequency[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    \n    # Count the occurrence of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Scan string and find first char with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # Using dictionary to hold character counts\n    character_counts = {}\n\n    # First loop through the string to count character occurrences\n    for char in string:\n        if char in character_counts:\n            character_counts[char] += 1\n        else:\n            character_counts[char] = 1\n\n    # Second loop through the string to find first non-repeating character\n    for char in string:\n        if character_counts[char] == 1:\n            return char\n\n    # Return None if no non-repeating characters found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char not in char_count:\n            char_count[char] = 1\n        else:\n            char_count[char] += 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"Return first non-repeated character from given string\"\"\"\n    character_count = {}\n\n    # counting frequency of each character\n    for character in string:\n        if character in character_count:\n            character_count[character] += 1\n        else:\n            character_count[character] = 1\n\n    # iterating over string to find first character with count 1\n    for character in string:\n        if character_count[character] == 1:\n            return character\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_counts = {}\n    for char in s:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # create a dictionary to store character frequency\n    frequency = {}\n\n    # count frequency of each character\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # find first character with frequency 1\n    for char in string:\n        if frequency[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char not in char_count:\n            char_count[char] = 1\n        else:\n            char_count[char] += 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_order = []\n    char_count = {}\n\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n            char_order.append(char)\n\n    for char in char_order:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    char_count = {}\n    \n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n            \n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n            \n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, val):\n    return val in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex,element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, x):\n    return x in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, item):\n    if item in tuplex:\n        return True\n    return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, x):\n    return x in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, item):\n    return item in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 85.24844720496894, "dps_norm": 86.66666666666666, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function to check if any value from one sequence exists in another sequence\n    \n    Inputs: \n    seq1: First sequence \n    seq2: Second sequence\n    \n    Returns: \n    True if any value from the first sequence exists in the second \n    False otherwise\n    \"\"\"\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function to check whether any value in sequence1 exists in sequence2\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks if any value in the first sequence exists in the second sequence.\n    \n    Arguments:\n    seq1: a sequence like object (list, tuple, set)\n    seq2: a sequence like object (list, tuple, set)\n    \n    Return:\n    A boolean value. It's True if seq1 and seq2 have at least one common element, otherwise False.\n    \"\"\"\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"Return True if any element in the first sequence exists in the second sequence.\"\"\"\n    for elem in seq1:\n        if elem in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"Check if any value in the first sequence exists in the second sequence.\"\"\"\n    for val in seq1:\n        if val in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    \"\"\"\n    Checks if any value in the first list exists in the second list.\n    \n    Args:\n    list1 (list): A list of elements.\n    list2 (list): Another list of elements.\n    \n    Returns:\n    bool: Whether any element from list1 exists in list2.\n    \"\"\"\n    for i in list1:\n        if i in list2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks if any value in the first sequence exists in the second sequence.\n    Returns True if any overlap is found. Otherwise, it returns False.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any value from seq1 exists in seq2\n    return any(val in seq2 for val in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function that checks if any element in the first sequence\n    exists in the second sequence\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function takes two sequences as input and returns True if any value in \n    the first sequence exists in the second sequence, else returns False.\n    \"\"\"\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    for element in sequence1:\n        if element in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        for j in seq2:\n            if i == j:\n                return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks whether any value in the first sequence exists in the second sequence.\n    Returns a boolean value accordingly.\n    \"\"\"\n    for val in seq1:\n        if val in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return not set(seq1).isdisjoint(set(seq2))", "matching_cluster_idx": 6}]}, "Mbpp/421": {"dps": 15.226337448559672, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(t):\n    return '-'.join(str(e) for e in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(x) for x in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple by a specified delimiter\n    \n    :param t: Input tuple\n    :param delimiter: Delimiter to join the elements\n    :return: String concatenated with the specified delimiter\n    \"\"\"\n    return delimiter.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(my_tuple, delimiter='-'):\n    return delimiter.join(str(element) for element in my_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n    \"\"\"\n    A function to concatenate each element of a tuple by the delimiter.\n    \"\"\"\n    return '-'.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter=\"-\"):\n    return delimiter.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    return delimiter.join(str(i) for i in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    \"\"\" \n    This function takes a tuple and concatenate each element by the delimiter.\n    \n    Arguments:\n    t {tuple} -- input tuple\n    \n    Returns:\n    str -- concatenated string\n    \"\"\"\n    return '-'.join(str(e) for e in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter=\"-\"):\n    return delimiter.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(elem) for elem in tup)", "matching_cluster_idx": 4}]}, "Mbpp/424": {"dps": 63.71841155234657, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    output_list = [s[-1] for s in input_tuple]\n    return output_list", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    output_list = [s[-1] for s in input_tuple]\n    return output_list", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_str):\n    return [s[-1] for s in tuple_str]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(words):\n    return [word[-1] for word in words]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    This function extracts and returns a list of the last character of each string in the given tuple.\n    \n    :param input_tuple: tuple of strings\n    :return: list of last characters of the strings in the input_tuple\n    \"\"\"\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 86.0, "profiled": [{"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, ele):\n    count = 0\n    for sublist in lst:\n        if ele in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list,element):\n    count = 0\n    for sub_list in main_list:\n        if element in sub_list:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    return sum(1 for sublist in sublists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, target):\n    count = 0\n    for sublist in sublists:\n        if target in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, target):\n    count = 0\n    for sublist in sublists:\n        if target in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, element):\n    count = 0\n    for sublist in main_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, target):\n    count = 0\n    for sublist in sublists:\n        if target in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, el):\n    count = 0\n    for sublist in lst:\n        if el in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, element):\n    count = 0\n    for sublist in input_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    return sum(element in sublist for sublist in sublists)", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 81.36363636363636, "dps_norm": 55.0, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    \n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            \n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n                \n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(input_list):\n    gap = len(input_list) // 2\n    while gap > 0:\n        for i in range(gap, len(input_list)):\n            temp = input_list[i]\n            j = i\n            while j >= gap and input_list[j - gap] > temp:\n                input_list[j] = input_list[j - gap]\n                j -= gap\n            input_list[j] = temp\n        gap //= 2\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        \n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n\n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap = gap // 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n//2\n    while gap > 0:\n        for i in range(gap,n):\n            temp = array[i]\n            j = i\n            while  j >= gap and array[j-gap] >temp:\n                array[j] = array[j-gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    \n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n\n            array[j] = temp\n        gap //= 2\n\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(input_list):\n    gap = len(input_list) // 2\n    while gap > 0:\n        for i in range(gap, len(input_list)):\n            temp = input_list[i]\n            j = i\n            while j >= gap and input_list[j - gap] > temp:\n                input_list[j] = input_list[j - gap]\n                j = j-gap\n            input_list[j] = temp\n        gap = gap // 2\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n//2\n \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order \n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n \n        # Add a[gap...n] elements to the elements that have been gap sorted\n        for i in range(gap,n):\n \n            # add a[i] to the elements that have been gap sorted\n            temp = arr[i]\n \n            # shift earlier gap-sorted elements up until the correct\n            # location for a[i] is found\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n \n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 69.46808510638297, "dps_norm": 70.0, "pass@1": 26.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks if all elements in a list are smaller than a number.\n\n    Args:\n    arr (list): a list of integers\n    num (int): a number\n\n    Returns:\n    bool: True if all elements in arr are smaller than num, False otherwise\n    \"\"\"\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"Return True if all elements in the array are smaller than num, else False.\"\"\"\n    for i in arr:\n        if i >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    return all(x < number for x in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks if the given number is greater than all elements in a given list.\n    \n    :param arr: List of integers\n    :param num: An integer\n    :return: Boolean (True if num > all elements in arr, False otherwise)\n    \"\"\"\n    for i in arr:\n        if i >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    \"\"\"Return True if all elements in array are less than number.\"\"\"\n    for i in array:\n        if i >= number:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # return False if all elements in the array are less than num\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks if the entered number is greater than the elements of a given array.\n    It returns True if the number is greater than all elements of the array, otherwise False.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks if the entered number is greater than all elements in the array.\n\n    Parameters:\n    array (list): A list of integers.\n    number (int): A single integer.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(number > i for i in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    return all(i < num for i in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    for element in array:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    This function checks whether all elements in the given array are less than a specific number.\n\n    :param array: a list of integers.\n    :param num: an integer.\n    :returns: True if all elements in the array are less than num, False otherwise.\n    \"\"\"\n    return all(i < num for i in array)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 68.6029411764706, "dps_norm": 22.0, "pass@1": 56.0, "profiled": [{"solution": "def remove_odd(string):\n    return ''.join([string[i] for i in range(len(string)) if i%2==1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(s):\n    return ''.join([s[i] for i in range(len(s)) if (i+1)%2==0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n    return ''.join([char for index, char in enumerate(string) if (index+1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([s[i] for i in range(len(s)) if (i+1)%2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([s[i] for i in range(len(s)) if (i+1)%2==0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return \"\".join([s[i] for i in range(len(s)) if (i+1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return \"\".join(c for i, c in enumerate(s) if (i+1) % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    output_string = \"\"\n    for i in range(len(input_string)):\n        if (i+1) % 2 == 0: # Even index (Python uses 0-based indexing)\n            output_string += input_string[i]\n    return output_string", "matching_cluster_idx": -1}, {"solution": "def remove_odd(input_string):\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(string):\n    return ''.join([char for index, char in enumerate(string) if (index + 1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([s[i] for i in range(len(s)) if (i+1)%2==0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([s[i] for i in range(len(s)) if (i+1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join(s[i] for i in range(len(s)) if i%2==1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return \"\".join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(input_string):\n    return ''.join([input_string[i] for i in range(len(input_string)) if (i+1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Using list comprehension to remove odd characters\n    return ''.join([s[i] for i in range(len(s)) if (i+1)%2==0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n    return ''.join([char for index, char in enumerate(string) if (index + 1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_str):\n    return ''.join([input_str[i] for i in range(len(input_str)) if (i+1)%2==0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    return ''.join([input_string[i] for i in range(len(input_string)) if (i+1)%2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"\n    Function to remove odd characters in a string.\n    \"\"\"\n    return ''.join([input_string[i] for i in range(len(input_string)) if (i+1)%2 == 0])", "matching_cluster_idx": 0}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(list_of_strings):\n    return [s[::-1] for s in list_of_strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(list_of_strings):\n    return [s[::-1] for s in list_of_strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [x[::-1] for x in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    # Function to reverse a string\n    def reverse_string(input_string):\n        return input_string[::-1]\n\n    # Apply the reverse_string function to each item in the list\n    return [reverse_string(item) for item in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(list_of_strings):\n    \"\"\"Reverse each string in a given list of string values.\"\"\"\n    return [s[::-1] for s in list_of_strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [i[::-1] for i in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 97.40384615384616, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lists):\n    return [sub[0] for sub in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sub_lst[0] for sub_lst in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_lists):\n    return [sub_list[0] for sub_list in list_of_lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(input_list):\n    output_list = [sublist[0] for sublist in input_list]\n    return output_list", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    result = [sub_lst[0] for sub_lst in lst]\n    return result", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sub_list[0] for sub_list in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(my_list):\n    return [sublist[0] for sublist in my_list]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    \"\"\"\n    This function takes a list of sublists as input. It returns a new list that contains the first\n    element from each sublist.\n    \n    Parameters:\n    sublists (list of lists): The list containing sublists.\n    \n    Returns:\n    list: A new list that contains the first element of each sublist.\n    \n    Example:\n    Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) returns [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(input_list):\n    output_list = [sublist[0] for sublist in input_list]\n    return output_list", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sub_lst[0] for sub_lst in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(l):\n    return [x[0] for x in l]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sub_lst[0] for sub_lst in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sub_lst[0] for sub_lst in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    This function takes three parameters, a string and two characters.\n    It replaces all occurrences of the old character in the string with the new character.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a specified character in a string with another specified character.\n\n    Args:\n    input_str (str): The original string.\n    old_char (str): The character to replace.\n    new_char (str): The new character to replace the old character.\n\n    Returns:\n    The modified string with characters replaced.\n    \"\"\"\n\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, new_char):\n    return input_string.replace(char_to_replace, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char_to_replace, replacement_char):\n    return s.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char_to_replace, replacement_char):\n    return s.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(num_list):\n    return min(num_list) + max(num_list)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    The function takes an array as input and returns the sum\n    of the largest and smallest values in the array.\n    \"\"\"\n    if len(array) < 1:\n        raise ValueError(\"Input array should not be empty.\")\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # If array is empty\n    if not arr:\n        return 0\n\n    # If array has only one element\n    if len(arr) == 1:\n        return 2 * arr[0]\n\n    min_val = min(arr)\n    max_val = max(arr)\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    \"\"\"\n    This function finds the sum of the largest and smallest value in a given array.\n    \n    Args:\n    nums (list): list of integers\n    \n    Returns:\n    int: sum of smallest and largest numbers in the list\n    \"\"\"\n    \n    if len(nums) == 0: # if the list is empty, return 0\n        return 0\n    \n    return min(nums) + max(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"Returns the sum of the largest and smallest value in a given list.\"\"\"\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(num_list):\n    return min(num_list) + max(num_list)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array\n    \"\"\"\n    \n    # Check if the list is not empty\n    assert len(arr) > 0, \"List cannot be empty\"\n    \n    # Return the sum of the largest and smallest value in the list\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(lst):\n    return max(lst) + min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(s):\n    \"\"\"Convert the given string to lower case.\n    \n    Args:\n    s (str): the string to convert\n\n    Returns:\n    str: the string converted to lower case\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    This function converts the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str):\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    This function takes a string as input and returns the string in lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str):\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str):\n    return str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert a given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    This function will convert the given string to lower case.\n    \"\"\"\n    try:\n        return input_string.lower()\n    except AttributeError:\n        raise ValueError(\"The input value is not a string\")", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str):\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    This function converts a given string to lower case.\n    It uses Python's lower() method which converts all uppercase characters in a string into lowercase characters and returns it.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str):\n    return input_str.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 80.32786885245902, "dps_norm": 80.0, "pass@1": 25.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_str):\n    return re.findall(r'\"([^\"]*)\"', input_str)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(str_input):\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, str_input)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = '\"([^\"]*)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    # initialize an empty list to store the extracted values\n    values = []\n    \n    # initialize an empty string to accumulate characters within quotes\n    accumulator = ''\n\n    # initialize a flag to track whether we are currently within quotes\n    within_quotes = False\n\n    for char in s:\n        if char == '\"':\n            # toggle whether we are within quotes\n            within_quotes = not within_quotes\n            if within_quotes:\n                # start of a value, clear the accumulator\n                accumulator = ''\n            else:\n                # end of a value, append it to the list and reset the accumulator\n                values.append(accumulator)\n                \n        elif within_quotes:\n            # accumulate characters when within quotes\n            accumulator += char\n\n    return values", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(str_with_quotes):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, str_with_quotes)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = '\"([^\"]*)\"'\n    match = re.findall(pattern, input_string)\n    return match", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_str):\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, input_str)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Regular expression to match values within quotes\n    regex = r'\"([^\"]*)\"'\n    \n    # re.findall function returns all non-overlapping matches of pattern in string, as a list of strings\n    # The string is scanned left-to-right, and matches are returned in the order found\n    return re.findall(regex, input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_str):\n    return re.findall(r'\"(.*?)\"', input_str)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    values = []\n    in_quotes = False\n    current_word = ''\n    for character in s:\n        if character == '\"':\n            in_quotes = not in_quotes\n            if in_quotes is False:\n                values.append(current_word)\n                current_word = ''\n        elif in_quotes:\n            current_word += character\n    return values", "matching_cluster_idx": 6}]}, "Mbpp/572": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/578": {"dps": 92.98412698412699, "dps_norm": 71.81818181818183, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [item for sublist in zip(l1, l2, l3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [item for sublist in zip(l1, l2, l3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [val for tup in zip(l1, l2, l3) for val in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleave_list = []\n    for i in range(len(list1)):\n        interleave_list.append(list1[i])\n        interleave_list.append(list2[i])\n        interleave_list.append(list3[i])\n    return interleave_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Zip function is used to combine lists of same length\n    # List comprehension is used to flatten into single list\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [item for sublist in zip(l1, l2, l3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [x for t in zip(l1, l2, l3) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    assert len(list1) == len(list2) == len(list3), \"All lists should be of the same length\"\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    interleaved_lst = [item for sublist in zip(lst1, lst2, lst3) for item in sublist]\n    return interleaved_lst", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [element for tup in zip(list1, list2, list3) for element in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def split_Arr(lst,n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr,n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr,n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, split_index):\n    if split_index > len(input_list):\n        return \"Error: Split index larger than list length.\"\n    else:\n        return input_list[split_index:] + input_list[:split_index]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # We return the list 'arr' by slicing it at index 'n' and concatenating the two slices in reverse order.\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr,n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr,n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst,n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr,n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr,n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"Converts a list into a tuple.\"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(l):\n    return tuple(l)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 97.13302752293578, "dps_norm": 99.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(input_list):\n    # Function to find the difference between largest and smallest value in a given list\n    return max(input_list) - min(input_list)", "matching_cluster_idx": 5}, {"solution": "def big_diff(l):\n    if len(l) == 0:\n        return 0\n    min_val = l[0]\n    max_val = l[0]\n    for val in l:\n        if val < min_val:\n            min_val = val\n        if val > max_val:\n            max_val = val\n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(input_list):\n    return max(input_list) - min(input_list)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 60.00000000000001, "dps_norm": 55.0, "pass@1": 27.0, "profiled": [{"solution": "import math\ndef sum_Of_product(n):\n    total = 0\n    for i in range(n):\n        total += math.comb(n, i) * math.comb(n, i+1)\n    return total", "matching_cluster_idx": 5}, {"solution": "def binom(n, k):\n    \"\"\"Return binomial coefficient of n and k.\"\"\"\n    result = 1\n    for i in range(min(k, n-k)):\n        result = result * (n - i) // (i + 1)\n    return result\ndef sum_Of_product(n):\n    \"\"\"Find the sum of the product of consecutive binomial coefficients.\"\"\"\n    total = 0\n    for i in range(n):\n        total += binom(n, i) * binom(n, i+1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    binomial = [1, 1]\n    for i in range(2, n+1):\n        temp = [1]\n        for j in range(len(binomial)-1):\n            temp.append(binomial[j] + binomial[j + 1])\n        temp.append(1)\n        binomial = temp\n\n    result = 0\n    for i in range(len(binomial)-1):\n        result += binomial[i] * binomial[i + 1]\n\n    return result", "matching_cluster_idx": 6}, {"solution": "import math\ndef sum_Of_product(n):\n    sum = 0\n    for i in range(n):\n        sum += math.comb(n, i) * math.comb(n, i+1)\n    return sum", "matching_cluster_idx": 5}, {"solution": "def binomial_coeff(n, k):\n    res = 1\n    if (k > n - k):\n        k = n - k\n    for x in range(0 , k):\n        res = res * (n - x)\n        res = res // (x + 1)\n    return res\ndef sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += binomial_coeff(n, i) * binomial_coeff(n, i+1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coeff(n, k):\n    result = 1\n    if (k > n - k):\n        k = n - k\n    for x in range(0 , k):\n        result = result * (n - x)\n        result = result // (x + 1)\n    return result\ndef sum_Of_product(n):\n    sum = 0\n    for i in range(n):\n        sum += binomial_coeff(n, i) * binomial_coeff(n, i+1)\n    return sum", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    binomial_coefficients = [0]*(n+1)\n    binomial_coefficients[0] = 1\n    for i in range(1, n+1):\n        for j in range(i, 0, -1):\n            binomial_coefficients[j] = binomial_coefficients[j] + binomial_coefficients[j-1]\n            \n    sum_of_products = 0\n    for i in range(1, n+1):\n        sum_of_products += binomial_coefficients[i-1]*binomial_coefficients[i]\n\n    return sum_of_products", "matching_cluster_idx": 6}, {"solution": "def binomial_coeff(n, k):\n    result = 1\n    if (k > n - k):\n        k = n - k\n    for x in range(0 , k):\n        result = result * (n - x)\n        result = result // (x + 1)\n    return result\ndef sum_Of_product(n):\n    res = 0\n    for i in range(n):\n        res += binomial_coeff(n, i) * binomial_coeff(n, i+1)\n    return res", "matching_cluster_idx": 4}, {"solution": "def binomial_coeff(n, k):\n    res = 1\n    if (k > n - k):\n        k = n - k\n    for i in range(k):\n        res = res * (n - i)\n        res = res // (i + 1)\n\n    return res\ndef sum_Of_product(n):\n    sum = 0\n    for i in range(n):\n        sum += binomial_coeff(n, i) * binomial_coeff(n, i + 1)\n    return sum", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    if n <= 0:\n        return \"Input must be a positive integer.\"\n    \n    def binom_coeff(n, k):\n        # Function to find binomial coefficient\n        res = 1\n        if (k > n - k):\n            k = n - k\n        for x in range(0 , k):\n            res = res * (n - x)\n            res = res // (x + 1)\n        return res\n\n    total = 0\n    for i in range(n):\n        total += binom_coeff(n, i) * binom_coeff(n, i + 1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def binomial_coeff(n, k):\n    res = 1\n    \n    if (k > n - k):\n        k = n - k\n\n    for x in range(0 , k):\n        res = res * (n - x)\n        res = res // (x + 1)\n\n    return res\ndef sum_Of_product(n):\n    sum = 0\n    for i in range(n):\n        sum += binomial_coeff(n, i) * binomial_coeff(n, i+1)\n    return sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    total = 0\n    for i in range(n):\n        total += math.comb(n, i) * math.comb(n, i + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "def binomial_coeff(n, k):\n    res = 1\n    if (k > n - k):\n        k = n - k\n    for i in range(k):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\ndef sum_Of_product(n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum += (binomial_coeff(n, i) * binomial_coeff(n, i - 1))\n    return sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    total_sum = 0\n    for i in range(n):\n        total_sum += math.comb(n, i) * math.comb(n, i+1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    def binom_coef(n, k):  # compute binomial coefficient n over k\n        if k > n:\n            return 0\n        if k > n - k:\n            k = n - k\n        result = 1\n        for i in range(k):\n            result *= n - i\n            result //= i + 1\n        return result\n\n    total = 0\n    for i in range(n):\n        total += binom_coef(n, i) * binom_coef(n, i+1)\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    from math import comb  # this function helps to compute binomial coefficients\n    sum = 0\n    for i in range(n+1):\n        if i == 0:\n            continue\n        sum += comb(n, i) * comb(n, i-1)\n    return sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    import math\n    total = 0\n    for i in range(n):\n        total += math.comb(n, i) * math.comb(n, i + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    total = 0\n    for i in range(n):\n        total += math.comb(n, i) * math.comb(n, i+1)\n    return total", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    # Initialize array to store binomial coefficients\n    C = [[0 for x in range(n+1)] for x in range(n+1)]\n\n    # Calculate value of Binomial Coefficient in bottom up manner\n    for i in range(n+1):\n        for j in range(min(i, n)+1):\n            # Base Cases\n            if j == 0 or j == i:\n                C[i][j] = 1\n            # Calculate value using previously stored values\n            else:\n                C[i][j] = C[i-1][j-1] + C[i-1][j]\n\n    # Calculate the sum of the product of consecutive binomial coefficients\n    sum = 0\n    for i in range(n):\n        sum += C[n][i] * C[n][i+1]\n\n    return sum", "matching_cluster_idx": 3}, {"solution": "def binomial_coeff(n, k):\n    result = 1\n    if (k > n - k):\n        k = n - k\n    for x in range(0 , k):\n        result = result * (n - x)\n        result = result // (x + 1)\n\n    return result\ndef sum_Of_product(n):\n    total = 0\n    for i in range(n):\n        total += binomial_coeff(n, i) * binomial_coeff(n, i+1)\n    return total", "matching_cluster_idx": 4}]}, "Mbpp/597": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 42.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    # Merge the sorted arrays\n    merged = sorted(arr1 + arr2)\n    # Return kth element\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(a, b, k):\n    merged = sorted(a + b)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"Function to find kth element in two sorted arrays.\"\"\"\n    # Merge two sorted arrays\n    merged = sorted(arr1 + arr2)\n    # Return kth element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # merge two lists into one\n    merged = arr1 + arr2\n    # sort the merged list\n    merged.sort()\n    # return the kth element\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merging two arrays\n    arr = arr1 + arr2\n    \n    # Sorting the array\n    arr.sort()\n    \n    # Return kth element\n    return arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge both arrays\n    merge_arr = sorted(arr1 + arr2)\n    # Return kth element\n    return merge_arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    combined = sorted(arr1 + arr2)\n    return combined[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    combined = sorted(arr1 + arr2)\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Function to find kth element in two sorted arrays.\n    \"\"\"\n    combined = sorted(arr1 + arr2)\n    if k <= len(combined):\n        return combined[k-1]\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # combine both arrays into one\n    arr = arr1 + arr2\n    # sort the combined array\n    arr.sort()\n    # return the kth element (list indices start at 0)\n    return arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    arr1.extend(arr2)\n    arr1.sort()\n    return arr1[k-1] if k <= len(arr1) else None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays\n    merged = sorted(arr1 + arr2)\n\n    # Check if k is within the bounds of the merged list\n    if k <= len(merged):\n        # Return the kth element in the merged list\n        return merged[k - 1]\n    else:\n        return \"Error: k is out of bounds\"", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the arrays\n    arr = arr1 + arr2\n    arr.sort()\n    # Return the kth element\n    return arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate the two sorted arrays\n    merged = arr1 + arr2\n    \n    # Sort the merged array\n    merged.sort()\n\n    # Return the kth element (remember that indexing starts at 0)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    combined_arr = sorted(arr1 + arr2)\n    if len(combined_arr) < k:\n        return \"Error: k is larger than the total number of elements\"\n    else:\n        return combined_arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    '''Function to find kth element from two sorted arrays.\n\n    :param arr1: list of integers.\n    :param arr2: list of integers.\n    :param k: the kth element to find.\n\n    :return: integer, the kth element in the combined array.\n    '''\n\n    combined_array = sorted(arr1 + arr2)\n    \n    if k <= len(combined_array):\n        return combined_array[k-1]\n    else:\n        raise ValueError(\"k is greater than the total number of elements in the combined array\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # merge two sorted arrays\n    sorted_arr = sorted(arr1 + arr2)\n\n    # check if k is within the length of the sorted array\n    if k <= len(sorted_arr):\n        return sorted_arr[k-1]\n\n    return None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    sorted_arr = sorted(arr1 + arr2)\n    return sorted_arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(list1, list2, k):\n    combined_list = sorted(list1 + list2)\n    if k <= len(combined_list):\n        return combined_list[k - 1]\n    else:\n        return \"Kth element does not exist\"", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # merging two arrays\n    arr = arr1 + arr2\n    # sort array\n    arr.sort()\n    # return kth element\n    return arr[k - 1]", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 90.45454545454545, "dps_norm": 98.0, "pass@1": 53.0, "profiled": [{"solution": "def reverse_words(s):\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    words = input_string.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    # This function splits the input string into words, reverse the order of the words,\n    # then join them back together with a space between each word.\n    words = input_str.split()\n    words = words[::-1]\n    output_str = ' '.join(words)\n    return output_str", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    return \" \".join(input_str.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    words = input_str.split()\n    reversed_words = words[::-1]\n    output_str = ' '.join(reversed_words)\n    return output_str", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"Reverse words in a string\"\"\"\n    # Split the string into a list of words\n    words = input_string.split()\n    \n    # Reverse the order of the words\n    words.reverse()\n    \n    # Join the words back into a string\n    output_string = ' '.join(words)\n    \n    return output_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    words = input_string.split()\n    words = words[::-1]\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    return ' '.join(string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    return \" \".join(input_string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    return ' '.join(input_str.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(reversed(words))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(input_string):\n    words = input_string.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(input_string):\n    # Splitting the string into list of words\n    words = input_string.split()\n    # Reversing the order of words and joining them back into a string\n    output_string = ' '.join(words[::-1])\n    return output_string", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 49.951690821256044, "dps_norm": 60.0, "pass@1": 15.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    #Check if k is not greater than the length of the list\n    if k <= len(input_list):\n        del input_list[k-1]\n    return input_list", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # if k is greater than the length of list, simply return the list.\n    if k > len(lst):\n        return lst\n    else:\n        # remove the k'th element\n        del lst[k-1]\n        return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    return [value for index, value in enumerate(lst, start=1) if index != k]", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(input_list, k):\n    # if the list is empty or k is out of range, return the original list\n    if not input_list or k > len(input_list):\n        return input_list\n    else:\n        # create a copy of the list\n        result = input_list[:]\n        # remove the k'th element\n        result.pop(k-1)\n        return result", "matching_cluster_idx": 4}, {"solution": "def remove_kth_element(lst, k):\n    # check if k is valid\n    if k <= 0 or k > len(lst):\n        return lst\n\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    if k > len(input_list):\n        return \"Error: k is greater than the length of the list\"\n    else:\n        return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Function to remove kth element from the input list.\n\n    Parameters:\n    input_list (list): a list of elements\n    k (int): the position of the element to be removed (1-indexed)\n\n    Returns:\n    list: a list with the kth element removed\n    \"\"\"\n    # Validate the inputs\n    if not isinstance(input_list, list) or not all(isinstance(i, int) for i in input_list):\n        raise ValueError('input_list must be a list of integers')\n    if not isinstance(k, int) or k <= 0 or k > len(input_list):\n        raise ValueError('k must be an integer between 1 and the length of the input_list')\n\n    # Remove the kth element from the list\n    output_list = input_list[:k-1] + input_list[k:]\n    return output_list", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    return [value for index, value in enumerate(lst, start=1) if index != k]", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Validate input\n    if not isinstance(lst, list) or not isinstance(k, int) or k <= 0 or k > len(lst):\n        raise ValueError(\"Invalid input.\")\n\n    # Remove k'th element\n    new_lst = lst[:k - 1] + lst[k:]\n    return new_lst", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, column_index):\n    return max(row[column_index] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Take the nth element of each sublist, store in a new list\n    nth_elements = [sublist[n] for sublist in matrix]\n    # Return the maximum of the new list\n    return max(nth_elements)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Function to return max of n'th column\n    :param matrix: list of lists\n    :param n: column number\n    :return: max of n'th column\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Use list comprehension to create a new list with n'th elements of each sublist\n    nth_column = [sublist[n] for sublist in matrix]\n    # Use built-in max function to find the maximum value\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Return max of nth column in the matrix.\"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function takes a matrix represented as a list of lists and an index n.\n    It returns the max of the n'th column of the matrix.\n    \"\"\"\n    column = [row[n] for row in matrix]\n    return max(column)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 64.02777777777777, "dps_norm": 71.25, "pass@1": 91.0, "profiled": [{"solution": "def replace_spaces(s):\n    return_string = ''\n    for c in s:\n        if c.isspace():\n            return_string += '_'\n        elif c == '_':\n            return_string += ' '\n        else:\n            return_string += c\n    return return_string", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(string):\n    \"\"\"Function to replace spaces with underscores and vice versa in a given string\"\"\"\n    new_string = ''\n    for char in string:\n        if char == ' ':\n            new_string += '_'\n        elif char == '_':\n            new_string += ' '\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(s):\n    if \" \" in s:\n        s = s.replace(\" \", \"_\")\n    elif \"_\" in s:\n        s = s.replace(\"_\", \" \")\n    return s", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    # Check if input string contains whitespace\n    if ' ' in input_string:\n        # If contains whitespace, replace with underscore\n        output_string = input_string.replace(' ', '_')\n    # Else, check if input string contains underscore\n    elif '_' in input_string:\n        # If contains underscore, replace with whitespace\n        output_string = input_string.replace('_', ' ')\n    # If input string does not contain any underscore or whitespace, return it as it is\n    else:\n        return input_string\n    return output_string", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    result = ''\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    # Replace spaces with underscore\n    if ' ' in input_string:\n        replaced = input_string.replace(' ', '_')\n    # Replace underscore with spaces\n    elif '_' in input_string:\n        replaced = input_string.replace('_', ' ')\n    # If no spaces or underscore present return original string\n    else:\n        replaced = input_string\n    return replaced", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    This function replaces spaces with underscores and underscores with spaces in a given string.\n\n    :param string: input string\n    :return: modified string\n    \"\"\"\n    \n    # Create an empty string for the result\n    result = \"\"\n\n    # Iterate through each character in the input string\n    for char in string:\n        # If the character is a space, add an underscore to the result\n        if char == ' ':\n            result += '_'\n        # If the character is an underscore, add a space to the result\n        elif char == '_':\n            result += ' '\n        # Otherwise, add the character as is to the result\n        else:\n            result += char\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(input_string):\n    if \" \" in input_string:\n        return input_string.replace(\" \", \"_\")\n    elif \"_\" in input_string:\n        return input_string.replace(\"_\", \" \")\n    else:\n        return input_string", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def replace_spaces(text):\n    # Replace spaces with underscore if no underscore present in text\n    if '_' not in text:\n        return text.replace(' ', '_')\n    else:\n        # Replace underscore with space if underscore is present in text\n        return text.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function replaces whitespaces with underscore and vice versa in the given string\n    \"\"\"\n    if \" \" in s:\n        return s.replace(\" \", \"_\")\n    elif \"_\" in s:\n        return s.replace(\"_\", \" \")\n    else:\n        return s", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    # First, we check if the string contains a whitespace\n    if ' ' in s:\n        # If it does, we replace whitespaces with underscores\n        s = s.replace(' ', '_')\n    else:\n        # If it doesn't, we replace underscores with spaces\n        s = s.replace('_', ' ')\n    return s", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    # Check if the string contains whitespaces\n    if ' ' in input_string:\n        # Replace whitespaces with underscore\n        return input_string.replace(' ', '_')\n    else:\n        # Replace underscores with whitespace\n        return input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    # Determine if whitespace should be replaced with underscore ('_') or vice versa\n    # by counting the number of each character in the string\n    underscore_count = s.count('_')\n    space_count = s.count(' ')\n    \n    # If more underscores than spaces, replace underscores with spaces\n    if underscore_count > space_count:\n        return s.replace('_', ' ')\n    # If more spaces than underscores, replace spaces with underscores\n    else:\n        return s.replace(' ', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_str):\n    output_str = input_str.replace(' ', '_') if ' ' in input_str else input_str.replace('_', ' ')\n    return output_str", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    if '_' in input_string:\n        return input_string.replace('_', ' ')\n    else:\n        return input_string.replace(' ', '_')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(string):\n    # check if there's a whitespace in the string\n    if ' ' in string:\n        # replace whitespaces with an underscore\n        return string.replace(' ', '_')\n    else:\n        # replace underscores with a whitespace\n        return string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    \"\"\" \n    This function replaces spaces with underscores and vice versa in a given string.\n    \n    Arguments:\n    s {string} -- input string\n    \n    Returns:\n    string -- modified string\n    \"\"\"\n    \n    # define a helper function that checks if the character is a space or underscore\n    def is_space_or_underscore(c):\n        return c == ' ' or c == '_'\n    \n    # check if the input string is empty\n    if not s:\n        return s\n    \n    # create a list of characters from the input string\n    chars = list(s)\n    \n    # check each character in the string\n    for i in range(len(chars)):\n        # if the character is a space or underscore, swap it\n        if is_space_or_underscore(chars[i]):\n            chars[i] = '_' if chars[i] == ' ' else ' '\n    \n    # join the characters back into a string and return it\n    return ''.join(chars)", "matching_cluster_idx": 0}, {"solution": "def replace_spaces(s):\n    # Check if the string contains whitespaces\n    if ' ' in s:\n        # Replace whitespaces with underscore\n        return s.replace(' ', '_')\n    else:\n        # If no whitespaces, replace underscore with whitespace\n        return s.replace('_', ' ')", "matching_cluster_idx": 7}]}, "Mbpp/632": {"dps": 90.28142589118198, "dps_norm": 95.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(lst):\n    # Create two lists, one with zeros and another with non-zeros\n    zeros = [i for i in lst if i == 0]\n    non_zeros = [i for i in lst if i != 0]\n    \n    # Return the concatenation of the two lists\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of zeros\n    zero_count = lst.count(0)\n    \n    # Remove all zeros from list\n    lst = [element for element in lst if element != 0]\n    \n    # Add the number of zeros to the end of the list\n    lst.extend([0]*zero_count)\n    \n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [non_zero for non_zero in lst if non_zero!=0] + [zero for zero in lst if zero==0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    count = lst.count(0)\n    lst = [i for i in lst if i != 0]\n    lst.extend([0]*count)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Count the zeros\n    zero_count = arr.count(0)\n    \n    # Remove all zeros from the list\n    while 0 in arr:\n        arr.remove(0)\n\n    # Add the zeros at the end of the list\n    arr.extend([0]*zero_count)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def move_zero(list):\n    no_zeros = [i for i in list if i != 0]\n    zeros = [i for i in list if i == 0]\n    return no_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    result = [i for i in input_list if i!=0]\n    result += [0] * input_list.count(0)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    return [i for i in arr if i!=0] + [i for i in arr if i==0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # filter zero elements from the list and then extend the list with zero elements\n    return [i for i in arr if i != 0] + [i for i in arr if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    result = [i for i in lst if i!=0]\n    result += [0]*lst.count(0)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    zero_lst = [i for i in lst if i != 0]\n    zero_lst.extend([0] * lst.count(0))\n    return zero_lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [num for num in lst if num != 0] + [num for num in lst if num == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    This function moves all zeroes to the end of the list.\n    \n    Parameters:\n    arr (list): a list of numbers\n\n    Returns:\n    list: the list after moving zeroes to the end\n    \"\"\"\n    \n    # Count the number of zeros\n    count = arr.count(0)\n    \n    # Remove all zeros from the list\n    while 0 in arr: arr.remove(0)\n\n    # Extend the list with zeros\n    arr.extend([0]*count)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def move_zero(nums):\n    # list comprehension is used to create a new list\n    # that includes all non-zero elements\n    # then we simply add the appropriate number of zeroes to the end\n    return [num for num in nums if num != 0] + [0] * nums.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # list comprehension to separate zeroes from non-zeroes \n    # then concatenates both lists\n    return [i for i in nums if i!=0] + [i for i in nums if i==0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Using list comprehension to separate zeros and non-zeros\n    return [non_zero for non_zero in lst if non_zero!=0] + [zero for zero in lst if zero==0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    # Count the number of zeros in the list\n    zero_count = input_list.count(0)\n    \n    # Remove all zeros from the list\n    input_list = [value for value in input_list if value != 0]\n    \n    # Extend the list with the counted number of zeros\n    input_list.extend([0]*zero_count)\n    \n    return input_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # count number of zeros\n    zero_count = lst.count(0)\n    # remove all zeros from the list\n    lst = [i for i in lst if i != 0]\n    # append zeros at the end of the list\n    lst.extend([0]*zero_count)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    count = lst.count(0)\n    lst = [value for value in lst if value != 0]\n    lst.extend([0]*count)\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    return [num for num in arr if num != 0] + [num for num in arr if num == 0]", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/644": {"dps": 74.65425531914893, "dps_norm": 76.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    #Reverse the array from index 0 to k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(input_list, k):\n    # Reverse the sublist from index 0 to k\n    input_list[:k] = reversed(input_list[:k])\n    return input_list", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(input_array, k):\n    return input_array[:k][::-1] + input_array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Function to reverse an array up to a given position\n    \"\"\"\n    # reverse array upto k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # slicing the array from 0 to k and reverse it. \n    # After that, append the rest of the array from k to end.\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Python slicing is the easiest way to reverse the array up to k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    return arr[:K][::-1] + arr[K:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    This function takes in a list and an integer as input. The function then slices the list upto the integer,\n    reverses the slice, and then concatenates the reversed slice with the remaining elements of the list.\n    \n    Parameters:\n    arr (list): The list to be reversed up to position k\n    k (int): The position up to which the list is to be reversed\n\n    Returns:\n    list: The reversed list upto a given position.\n    \"\"\"\n    \n    # Slice the list upto k, reverse the slice and concatenate the reversed slice with the remaining list\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 93.84615384615384, "dps_norm": 98.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    This function adds a dictionary to the tuple.\n    :param tup: tuple\n    :param dic: dictionary\n    :return: tuple\n    \"\"\"\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    This function adds a dictionary to a tuple.\n    \n    Parameters:\n    t (tuple): the initial tuple\n    d (dict): the dictionary to be added\n    \n    Returns:\n    tuple: a new tuple consisting of the elements of the initial tuple and the dictionary\n    \"\"\"\n    return t + (d,)\nt = (4, 5, 6)\nd = {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3}", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    This function adds a dictionary to the tuple.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\" \n    Function to add a dictionary to the tuple\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tuple_input, dict_input):\n    return tuple_input + (dict_input,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    # Convert the tuple to a list\n    temp = list(tup)\n    # Append the dictionary to the list\n    temp.append(dic)\n    # Convert the list back to a tuple\n    result = tuple(temp)\n    # Return the resulting tuple\n    return result", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # convert tuple to list\n    list_temp = list(input_tuple)\n    \n    # append the dictionary to the list\n    list_temp.append(input_dict)\n    \n    # convert the list back to tuple\n    output_tuple = tuple(list_temp)\n    \n    return output_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 75.71721311475409, "dps_norm": 75.0, "pass@1": 16.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    result = []\n    is_in_quotes = False\n    word = ''\n    for char in s:\n        if char == '\"':\n            is_in_quotes = not is_in_quotes\n            if not is_in_quotes:\n                result.append(word)\n                word = ''\n        elif is_in_quotes:\n            word += char\n    return result", "matching_cluster_idx": 2}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_str):\n    return re.findall(r'\"(.*?)\"', input_str)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    pattern = re.compile('\"([^\"]*)\"')\n    return pattern.findall(input_string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"Extract values between quotation marks in the given string.\"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall(r'\"(.*?)\"', string)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 6}]}, "Mbpp/732": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def replace_specialchar(input_string):\n    output_string = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return output_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(str):\n    return str.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    input_string = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    return string.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    return input_str.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':')\n    s = s.replace(',', ':')\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    # Replaces spaces, commas, and dots with a colon.\n    return input_str.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':')\n    s = s.replace(',', ':')\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    string = string.replace(' ', ':')\n    string = string.replace(',', ':')\n    string = string.replace('.', ':')\n    return string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':')\n    s = s.replace(',', ':')\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(str):\n    str = str.replace(\" \", \":\")\n    str = str.replace(\",\", \":\")\n    str = str.replace(\".\", \":\")\n    return str", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # replace all occurrences of spaces, commas, or dots with a colon\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    output_string = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return output_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    output_string = input_string.replace(\" \",\":\").replace(\",\",\":\").replace(\".\",\":\")\n    return output_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    output_string = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return output_string", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 83.63636363636364, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"Convert the given tuple to a key-value dictionary using adjacent elements.\"\"\"\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\" \n    Function to convert tuple to dictionary.\n    \n    Parameters:\n        input_tuple (tuple): Input tuple\n    \n    Returns:\n        dict: Dictionary created from the tuple\n    \"\"\"\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tpl):\n    return {tpl[i]: tpl[i+1] for i in range(0, len(tpl), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 91.60958904109589, "dps_norm": 94.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def check_none(t):\n    \"\"\"\n    This function checks if the tuple `t` has any None values.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    This function takes a tuple as input and returns True if the tuple contains any None value, else it returns False.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 4}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 4}, {"solution": "def check_none(data):\n    return None in data", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"This function checks if the given tuple has any None value or not.\"\"\"\n    return None in t", "matching_cluster_idx": 4}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 4}, {"solution": "def check_none(my_tuple):\n    return None in my_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n    :param tup: Tuple to check\n    :return: True if the tuple contains None, False otherwise\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"Return True if None is in the given tuple, else False.\"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 4}, {"solution": "def check_none(t):\n    \"\"\"\n    This function checks if the given tuple has any None value or not.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 4}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 59.625850340136054, "dps_norm": 65.0, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    # Convert the tuple to a list.\n    tup_list = list(tup)\n    # Extend the original list with the contents of the tuple.\n    lst.extend(tup_list)\n    # Return the modified list.\n    return lst", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(list_a, tuple_b):\n    return list_a + list(tuple_b)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_val, tuple_val):\n    return list_val + list(tuple_val)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    # convert tuple to list\n    tuple_list = list(input_tuple)\n    \n    # extend the initial list by the list form the tuple\n    input_list.extend(tuple_list)\n    \n    # return the extended list\n    return input_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"Add a tuple to a list.\"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(list_to_add_to, tuple_to_add):\n    list_to_add_to.extend(tuple_to_add)\n    return list_to_add_to", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"Function to add a tuple to a list\"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(list_a, tuple_b):\n    # Convert the tuple to a list, then concatenate with original list.\n    list_b = list(tuple_b)\n    list_a.extend(list_b)\n    return list_a", "matching_cluster_idx": 3}, {"solution": "def add_tuple(list_input, tuple_input):\n    return list_input + list(tuple_input)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_arg, tuple_arg):\n    # This function adds a tuple to a list\n    return list_arg + list(tuple_arg)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_to, tuple_to_add):\n    return list_to + list(tuple_to_add)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_val, tuple_val):\n    \"\"\"\n    Function to add a tuple to a list.\n    \n    Parameters:\n        list_val (list): The original list\n        tuple_val (tuple): The tuple to be added to the list\n        \n    Returns:\n        list: The list with the tuple added\n    \"\"\"\n    return list_val + list(tuple_val)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    This function adds the given tuple to the given list.\n    :param input_list: list of integers\n    :param input_tuple: tuple of integers\n    :return: a new list that is a result of adding the tuple to the list\n    \"\"\"\n    input_list.extend(input_tuple)\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tpl):\n    # add tuple to the list using the extend method\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(list_in, tuple_in):\n    return list_in + list(tuple_in)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_input, tuple_input):\n    # Convert the tuple to a list\n    tuple_list = list(tuple_input)\n    \n    # Extend the input list with the elements of the tuple\n    list_input.extend(tuple_list)\n    \n    return list_input", "matching_cluster_idx": 3}]}, "Mbpp/753": {"dps": 49.328859060402685, "dps_norm": 62.5, "pass@1": 96.0, "profiled": [{"solution": "def min_k(records, k):\n    records.sort(key=lambda x: x[1])\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    return sorted(tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(lst, k):\n    # Sort the list by the second element of each tuple\n    sorted_lst = sorted(lst, key=lambda x: x[1])\n    \n    # Return the first k elements of sorted list\n    return sorted_lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # use the inbuilt 'sorted' function to sort the tuples by the second element\n    # use [:k] to get the first 'k' elements from the sorted list\n    return sorted(tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuples_list, k):\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tup_list, k):\n    sorted_list = sorted(tup_list, key=lambda x: x[1])\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort the list of tuples based on the second item of each tuple \n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    # Return the first 'k' elements of the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(lst, k):\n    lst.sort(key = lambda x: x[1])\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    tuples.sort(key=lambda x: x[1])\n    return tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    # Sort the tuple list based on the second element of each tuple\n    sorted_list = sorted(lst, key=lambda x: x[1])\n    \n    # Return the first k elements of sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tup_list, k):\n    # sort the tuple list by the second item of the tuple\n    sorted_list = sorted(tup_list, key=lambda x: x[1])\n    # return the first 'k' items of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuples, k):\n    # Sort the tuples by the second element (i.e., the number)\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    \n    # Return the first k tuples\n    return sorted_tuples[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuple_list, k):\n    # sort the list based on the second element of each tuple\n    tuple_list.sort(key=lambda x: x[1])\n    # return the first k elements of the sorted list\n    return tuple_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort tuple list by the second element of each tuple and then slice first k elements\n    return sorted(tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(lst, k):\n    \"\"\"\n    Function to find minimum k records from tuple list.\n    :param lst: Tuple List\n    :param k: Number of minimum records to return\n    :returns: List of k minimum records\n    \"\"\"\n    # sort the list by the second element of each tuple\n    sorted_list = sorted(lst, key=lambda x: x[1])\n\n    # return the first k elements of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuples_list, k):\n    sorted_tuples_list = sorted(tuples_list, key=lambda x: x[1])\n    return sorted_tuples_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(lst, k):\n    # sort the list in increasing order of the second element of each tuple\n    lst.sort(key=lambda x: x[1])\n\n    # return the first k elements of the sorted list\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of records based on the second item in each tuple.\n    records.sort(key=lambda x: x[1])\n    \n    # Return the first k items of sorted list.\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    return sorted(tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}]}, "Mbpp/754": {"dps": 87.06896551724138, "dps_norm": 87.5, "pass@1": 47.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    common = []\n    for i in range(min(len(l1),len(l2),len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common.append(l1[i])\n    return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # A list to store common elements\n    common_elements = []\n\n    # The zip function is used to iterate over three lists simultaneously\n    for i, (e1, e2, e3) in enumerate(zip(l1, l2, l3)):\n        # Checking if the elements are the same and the indices are the same\n        if e1 == e2 == e3:\n            common_elements.append(e1)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1),len(l2),len(l3))):\n        if (l1[i] == l2[i] == l3[i]):\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1),len(l2),len(l3))): # To avoid index error, we limit the iteration based on the shortest list length\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common = []\n    for i, j, k in zip(l1, l2, l3):\n        if i == j == k:\n            common.append(i)\n    return common", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n            \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_list = [e1 for e1, e2, e3 in zip(l1, l2, l3) if e1 == e2 == e3]\n    return common_list", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"This function finds common elements under the same index in three lists\"\"\"\n    common_list = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_list.append(l1[i])\n    return common_list", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))): # Find the common index among the three lists\n        if l1[i] == l2[i] == l3[i]: # If the elements at the same index are the same\n            common_elements.append(l1[i]) # Append it to the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    The function accepts three lists and returns a list with common elements at the same index in these lists.\n    \"\"\"\n    common_elements = []\n    \n    # Determine the minimum length among the lists to avoid index errors.\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        # Check if an element at index i is the same in all lists.\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # zip the lists to have each tuple contain the elements at the same index\n    zipped_lists = list(zip(l1, l2, l3))\n\n    # the common_elements list will store the elements that are the same at the same index in all three lists\n    common_elements = []\n\n    # iterate over the zipped list to check the equality of elements at each index\n    for elems in zipped_lists:\n        # if all elements in the tuple are the same, that element is common\n        if len(set(elems)) == 1:\n            common_elements.append(elems[0])\n\n    return common_elements", "matching_cluster_idx": 3}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [e1 for e1, e2, e3 in zip(l1, l2, l3) if e1 == e2 == e3]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    common = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common.append(l1[i])\n    return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common = []\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            common.append(a)\n    return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 86.15044247787611, "dps_norm": 94.16666666666667, "pass@1": 34.0, "profiled": [{"solution": "def second_smallest(numbers):\n    unique_numbers = list(set(numbers)) # Remove duplicate numbers\n    unique_numbers.sort() # Sort the numbers\n    if len(unique_numbers) < 2: # If the list contains less than 2 unique numbers\n        return None\n    else:\n        return unique_numbers[1] # Return the second smallest number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums)) # Remove any duplicate numbers\n    nums.sort() # Sort the numbers in ascending order\n    if len(nums) < 2:\n        return None\n    else:\n        return nums[1] # Return the second smallest number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))  # remove duplicates\n    nums.sort()  # sort the list\n    if len(nums) < 2:\n        return None\n    else:\n        return nums[1]  # return the second element which is the second smallest", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    \"\"\"Find the second smallest number in a list.\"\"\"\n    if len(nums) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in nums:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    unique_numbers = list(set(numbers))\n    unique_numbers.sort()\n    return unique_numbers[1] if len(unique_numbers) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Initialise the smallest and second smallest \n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in lst:\n        # If current element is smaller than smallest \n        if num < smallest:\n            # Then update the second smallest \n            second_smallest = smallest\n            # And update the smallest\n            smallest = num\n        # If current element is in between smallest \n        # And second smallest\n        elif num < second_smallest and num != smallest:\n            # Then update the second_smallest\n            second_smallest = num\n\n    # In case when there is no second_smallest\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 4}, {"solution": "def second_smallest(nums):\n    if len(nums)<2:\n        return None\n    smallest = min(nums)\n    nums = [x for x in nums if x != smallest]\n    second_smallest = min(nums) if nums else None\n    return second_smallest", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))  # remove duplicates\n    nums.sort()\n    return nums[1] if len(nums) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    unique_lst = list(set(lst))\n    unique_lst.sort()\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # check if the list has less than two elements\n    if len(numbers) < 2:\n        return None\n\n    # initialize the smallest and second smallest numbers\n    smallest = second_smallest_number = float('inf')\n\n    for num in numbers:\n        # skip the current number if it is larger than the second smallest number\n        if num > second_smallest_number:\n            continue\n        # update the smallest number if a smaller number is found\n        elif num < smallest:\n            second_smallest_number = smallest\n            smallest = num\n        # otherwise update the second smallest number if a smaller number is found\n        elif num < second_smallest_number and num != smallest:\n            second_smallest_number = num\n    \n    return second_smallest_number if second_smallest_number != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))  # remove duplicates\n    nums.sort()  # sort in ascending order\n    if len(nums) < 2:\n        return None\n    else:\n        return nums[1]  # return the second smallest number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))\n    nums.sort()\n    return nums[1] if len(nums) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))\n    nums.sort()\n    return nums[1] if len(nums) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))  # remove duplicates\n    nums.sort()  # sort list\n    if len(nums) >= 2:\n        return nums[1]  # return second element\n    else:\n        return None  # if the list has less than 2 distinct numbers", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    numbers = list(set(numbers))  # remove duplicates\n    numbers.sort()\n    try:\n        return numbers[1]\n    except IndexError:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))  # remove duplicates\n    nums.sort()\n    if len(nums) < 2:\n        return None\n    else:\n        return nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Put the numbers in a set to remove duplicates and sort in ascending order\n    nums = sorted(set(nums))\n    if len(nums) < 2:\n        return None  # return None if less than 2 unique numbers exist\n    return nums[1]  # return the second number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    unique_nums = list(set(nums))\n    unique_nums.sort()\n    return unique_nums[1] if len(unique_nums) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    nums = list(set(nums))  # remove duplicates\n    nums.sort()  # sort the list in ascending order\n    if len(nums) < 2:  # if the list has less than two elements\n        return None  # return None\n    else:\n        return nums[1]  # return the second element", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the second smallest number in that list.\n    If the list has less than 2 elements, it returns None.\n    \"\"\"\n    # If the list has less than 2 elements, return None\n    if len(numbers) < 2:\n        return None\n\n    # Initialize the smallest and second smallest with the largest possible integer\n    smallest = second_smallest = float('inf')\n\n    # Traverse the list\n    for num in numbers:\n        # If the current number is smaller than the smallest number,\n        # then update the second smallest with the value of the smallest,\n        # and update the smallest with the current number\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        # If the current number is in between the smallest and the second smallest,\n        # then update the second smallest with the current number\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    # If the second smallest remains as initialized,\n    # then there was no second distinct number\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 4}]}, "Mbpp/757": {"dps": 63.64485981308412, "dps_norm": 18.46153846153846, "pass@1": 93.0, "profiled": [{"solution": "def count_reverse_pairs(lst):\n    return sum(1 for i in range(len(lst)) for j in range(i+1, len(lst)) if lst[i] == lst[j][::-1] or lst[j] == lst[i][::-1])", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(input_list):\n    count = 0\n    for i in range(len(input_list)):\n        for j in range(i+1, len(input_list)):\n            if input_list[i] == input_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(input_list):\n    pair_count = 0\n    for i in range(len(input_list)):\n        for j in range(i+1, len(input_list)):\n            if input_list[i][::-1] == input_list[j] or input_list[j][::-1] == input_list[i]:\n                pair_count += 1\n    return pair_count", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    return sum(1 for i in range(len(lst)) for j in range(i+1, len(lst)) if lst[i] == lst[j][::-1] or lst[j] == lst[i][::-1])", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(input_list):\n    count = 0\n    for i in range(len(input_list)):\n        for j in range(i+1, len(input_list)):\n            if input_list[i][::-1] == input_list[j] or input_list[j][::-1] == input_list[i]:\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(input_list):\n    count = 0\n    for i in range(len(input_list)):\n        for j in range(i+1, len(input_list)):\n            if input_list[i] == input_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(input_list):\n    count = 0\n    for i in range(len(input_list)):\n        for j in range(i + 1, len(input_list)):\n            if input_list[i] == input_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(input_list):\n    pair_count = 0\n    for i in range(len(input_list)):\n        for j in range(i+1, len(input_list)):\n            if input_list[i] == input_list[j][::-1]:\n                pair_count += 1\n    return pair_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i][::-1] == lst[j] or lst[j][::-1] == lst[i]:\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    pair_counter = 0\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                pair_counter += 1\n    return pair_counter", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1] or lst[j] == lst[i][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(lst):\n    return sum(1 for i in range(len(lst)) for j in range(i + 1, len(lst)) if lst[i] == lst[j][::-1])", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i, string1 in enumerate(string_list):\n        for string2 in string_list[i+1:]:\n            if string1 == string2[::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    pairs = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                pairs += 1\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(s_list):\n    count = 0\n    for i in range(len(s_list)):\n        for j in range(i+1, len(s_list)):\n            if s_list[i] == s_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    pair_count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                pair_count += 1\n    return pair_count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 81.87258687258687, "dps_norm": 81.25, "pass@1": 99.0, "profiled": [{"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    dic = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in dic:\n            dic[sublist_tuple] += 1\n        else:\n            dic[sublist_tuple] = 1\n    return dic", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist not in result:\n            result[tuple_sublist] = 1\n        else:\n            result[tuple_sublist] += 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    output = {}\n    for sublist in lst:\n        # Convert list to tuple for hashing purposes\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in output:\n            output[sublist_tuple] += 1\n        else:\n            output[sublist_tuple] = 1\n    return output", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    dict_result = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in dict_result:\n            dict_result[sublist_tuple] += 1\n        else:\n            dict_result[sublist_tuple] = 1\n    return dict_result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    This function counts the number of occurrences of sublists within a main list.\n    It converts sublists to tuples to ensure immutability, and use a dictionary to count occurrences.\n    \"\"\"\n    \n    # convert all lists to tuples\n    lst_tuples = [tuple(sublist) for sublist in lst]\n    \n    # create an empty dictionary\n    dict_sublists = {}\n    \n    # iterate over the list of tuples\n    for tpl in lst_tuples:\n        # if the tuple is not in the dictionary, add it with a value of 1\n        # if it is in the dictionary, increment the value by 1\n        if tpl not in dict_sublists:\n            dict_sublists[tpl] = 1\n        else:\n            dict_sublists[tpl] += 1\n            \n    # return the dictionary\n    return dict_sublists", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result_dict:\n            result_dict[tuple_sublist] += 1\n        else:\n            result_dict[tuple_sublist] = 1\n    return result_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize empty dictionary\n    result = {}\n\n    # Go through every list (sub_lst) in the list (lst)\n    for sub_lst in lst:\n        # Convert each list to a tuple\n        tpl = tuple(sub_lst)\n        \n        # If the tuple is not yet in the dictionary, add it and initialize its value to 1\n        # If the tuple is already in the dictionary, increment its value by 1\n        if tpl not in result:\n            result[tpl] = 1\n        else:\n            result[tpl] += 1\n\n    # Return the resulting dictionary\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        # convert list to tuple because lists are not hashable and cannot be keys in a dictionary\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    dict_counter = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in dict_counter:\n            dict_counter[tuple_sublist] += 1\n        else:\n            dict_counter[tuple_sublist] = 1\n    return dict_counter", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Converting each sublist to a tuple and creating a dictionary\n    # where keys are tuples and values are their counts\n    return {tuple(i): lst.count(i) for i in lst}", "matching_cluster_idx": 3}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    result = {}\n    for sublist in input_list:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for l in lst:\n        t = tuple(l)\n        if t in result:\n            result[t] += 1\n        else:\n            result[t] = 1\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 81.0, "profiled": [{"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"Check if a list of numbers contains only one distinct element.\"\"\"\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    # Converts the list to a set.\n    # In Python, a set only holds unique elements.\n    # Thus, if the length of the set is 1, the original list only contains one distinct element.\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    \"\"\"\n    This function checks if a list contains only one distinct element.\n    \n    Parameters:\n    num_list (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    This function checks whether a list of numbers contains only one distinct element or not.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(list):\n    return len(set(list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(num_list):\n    return len(set(num_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    This function checks whether a list contains only one distinct element or not.\n    :param lst: A list of numbers.\n    :return: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(list):\n    return len(set(list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n    ctr = 0\n    for char in str1:\n        if char.isdigit():\n            ctr += 1\n    return ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    return sum(c.isdigit() for c in str)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_str):\n    count = sum(c.isdigit() for c in input_str)\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for i in input_string:\n        if i.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = sum(1 for char in input_string if char.isdigit())\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_str):\n    return sum(c.isdigit() for c in input_str)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_str):\n    return sum(c.isdigit() for c in input_str)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = sum(c.isdigit() for c in s)\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    This function takes in a string and returns the count of digits in that string.\n    \"\"\"\n    return sum(c.isdigit() for c in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = sum(1 for char in input_string if char.isdigit())\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 79.11214953271028, "dps_norm": 65.83333333333334, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(l):\n    return [(l[i], l[i+1]) for i in range(len(l)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i + 1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i + 1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i + 1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i + 1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}]}, "Mbpp/775": {"dps": 75.67999999999999, "dps_norm": 52.857142857142854, "pass@1": 91.0, "profiled": [{"solution": "def odd_position(nums):\n    for i in range(len(nums)):\n        if i % 2 != 0 and nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        # only check for odd indexes\n        if i % 2 != 0:\n            # check if the element on the odd index is also odd\n            if lst[i] % 2 == 0:\n                return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(nums):\n    for i in range(len(nums)):\n        if i % 2 != 0 and nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(nums):\n    # check every odd indexed element\n    for i in range(1, len(nums), 2):\n        # if the element at odd index is not odd\n        if nums[i] % 2 == 0:\n            # return False and stop checking\n            return False\n    # If the function hasn't returned yet, all odd-indexed elements are odd\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(input_list):\n    for i in range(1, len(input_list), 2):\n        if input_list[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(l):\n    for i in range(1, len(l), 2):\n        if l[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(l):\n    for i in range(len(l)):\n        if i % 2 != 0 and l[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(num % 2 == 1 for num in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list using step size of 2, starting at index 1\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd position is even\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # check each item in list if its index is odd and the item itself is even\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i%2 != 0 and lst[i]%2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(numbers):\n    for i in range(len(numbers)):\n        if i % 2 != 0 and numbers[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"Check whether every odd index contains odd number.\"\"\"\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    # Check if the element in the odd position is odd\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/781": {"dps": 95.8267716535433, "dps_norm": 83.0, "pass@1": 98.0, "profiled": [{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if n // i == i:\n                count += 1\n            else: \n                # Otherwise count both\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            # In case of a divisor pair like (2, 4)\n            if i == n // i:\n                count += 1\n            else: # (2, 5) for number 10\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, add only once\n            if i == (n // i):\n                count += 1\n            else: # Otherwise add twice\n                count += 2\n\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    divisor_count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_count += 1\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n/i == i:  # If divisors are equal, count only once\n                count += 1\n            else:  # Otherwise, count both divisors\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if n / i == i:\n                count = count + 1\n            else:\n                count = count + 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if n // i != i else 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, count only one\n            if n / i == i:\n                count += 1\n            else: # Otherwise count both\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            count += 2\n        if i*i == n:\n            count -= 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    cnt = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            cnt += 1\n    return cnt % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n / i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if n / i == i:\n                count = count + 1\n            else:\n                count = count + 2\n    if count % 2 == 0:\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    divisors_count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors_count += 2 if i != n // i else 1\n    return divisors_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if i == n/i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function returns whether the count of divisors for a given number is even or not.\n    \n    Args:\n    n (int): the number to be checked\n\n    Returns:\n    bool: whether the count of divisors is even\n    \"\"\"\n    div_count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal then add only one\n            if n / i == i:\n                div_count += 1\n            else:  # Otherwise add both\n                div_count += 2\n\n    return div_count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(num):\n    \"\"\"\n    This function receives a number and returns whether the count of its divisors is even.\n    \"\"\"\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\" \n    Function to check whether the count of divisors is even\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count = count + 1\n            else:\n                count = count + 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_all_spaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(str):\n    return str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all spaces from the input string and return the result.\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 95.0, "profiled": [{"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = float('-inf')\n    max_list = None\n    for sublist in lst:\n        sublist_sum = sum(sublist)\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n            max_list = sublist\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Use the max function with the sum function as key\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    list_of_lists (list): A list of lists of integers.\n\n    Returns:\n    list: The list whose sum of elements is the highest.\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    max_list = max(list_of_lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # using max function with key as sum for getting the list with max sum of elements\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    This function checks if a given tuple contains the specified value.\n    :param t: a tuple of numbers\n    :param k: the value to check for\n    :return: True if the value is in the tuple; False otherwise\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple, k):\n    return k in tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}]}}}
