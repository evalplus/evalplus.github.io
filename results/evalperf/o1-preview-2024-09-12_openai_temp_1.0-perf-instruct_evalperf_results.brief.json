{"date": "2024-11-04 07:43", "config": {"n_samples": 50, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 85.24709950585509, "dps_norm": 82.909473447037, "pass@1": 87.54237288135593}, "eval": {"HumanEval/9": {"dps": 76.29337539432177, "dps_norm": 76.66666666666667, "pass@1": 96.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum elements found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    curr_max = None\n    for number in numbers:\n        if curr_max is None or number > curr_max:\n            curr_max = number\n        result.append(curr_max)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until\n    the given moment in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of the rolling maximum elements found up to each point\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum elements found until each moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until each given moment\n    in the sequence.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        List[int]: A list where each element is the maximum of all elements up to that index in the input list.\n        \n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until each moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until each moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of the maximum element found up to each position in the sequence.\n\n    Args:\n        numbers (List[int]): The list of integers to process.\n\n    Returns:\n        List[int]: A list containing the rolling maximums.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for n in numbers:\n        if n > current_max:\n            current_max = n\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_so_far = float('-inf')\n    result = []\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until each moment\n    in the sequence.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        List[int]: A list where each element is the maximum of all elements up to that index.\n        \n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n        >>> rolling_max([5, 1, 2, 6, 4])\n        [5, 5, 5, 6, 6]\n        >>> rolling_max([])\n        []\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}, {"solution": "def rolling_max(numbers):\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found up to each point in the sequence.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: A list where each element is the maximum of all elements up to that position in the input list.\n\n    Example:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until each moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_so_far = float('-inf')\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_so_far = float('-inf')\n    result = []\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum elements found until each moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for number in numbers:\n        current_max = max(current_max, number)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 45.52325581395348, "dps_norm": 55.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i+1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if any two numbers in the list are closer to each other than the given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers to bring close numbers adjacent\n    sorted_numbers = sorted(numbers)\n    # Iterate through the sorted numbers and check adjacent differences\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # First, sort the list to bring close elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Then, iterate through the sorted list and check adjacent pairs\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    # Sort the list to bring close elements next to each other\n    numbers_sorted = sorted(numbers)\n    # Check adjacent pairs for closeness\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i+1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i + 1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if any two numbers in the list are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        threshold (float): The threshold distance.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i + 1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i + 1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if any two numbers in the list are closer to each other than the given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if any two numbers in the list are closer to each other than the given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False  # No elements to compare\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if any two numbers in the list are closer to each other than the given threshold.\n    \n    Args:\n        numbers: A list of floating-point numbers.\n        threshold: The threshold distance.\n        \n    Returns:\n        True if any two numbers are closer than the threshold, False otherwise.\n        \n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if any two numbers in the given list are closer to each other than\n    the given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to bring close numbers adjacent to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i + 1] - sorted_numbers[i]) < threshold:\n            return True  # Found a pair closer than the threshold\n    return False  # No such pair found", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i + 1] - numbers_sorted[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        raise ValueError(\"List must contain at least one number.\")\n    mean = sum(numbers) / n\n    mad = sum(abs(x - mean) for x in numbers) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate the Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and the mean:\n        MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of numerical values.\n    \n    Returns:\n        float: The mean absolute deviation of the input numbers.\n    \n    Raises:\n        ValueError: If the input list is empty.\n    \n    Example:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty\")\n\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    x_mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - x_mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate the Mean Absolute Deviation\n    around the mean of this dataset.\n\n    The Mean Absolute Deviation (MAD) is the average absolute difference between each\n    element and the mean of the dataset:\n    MAD = (1/n) * sum(|x_i - mean| for x_i in numbers)\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    x_mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - x_mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        raise ValueError(\"Cannot compute mean absolute deviation of an empty list\")\n    mean = sum(numbers) / n\n    mad = sum(abs(x - mean) for x in numbers) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0  # Alternatively, you can raise a ValueError here\n    mean = sum(numbers) / n\n    mad = sum(abs(x - mean) for x in numbers) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate the Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a center point (mean in this case):\n    \n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0.0 if the list is empty to avoid division by zero\n    \n    x_mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - x_mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list 'numbers' must not be empty.\")\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate the Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and the mean:\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers must not be empty.\")\n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport sys\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n    mean = sum(numbers) / n\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate the Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation (MAD) is the average absolute difference between each\n    element and the mean of the dataset:\n        MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of numerical values.\n\n    Returns:\n        float: The mean absolute deviation of the numbers.\n\n    Example:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0.0 if the list is empty to avoid division by zero\n\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # or raise an exception if preferred\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        raise ValueError(\"The list of numbers is empty\")\n    mean_value = sum(numbers) / n\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    x_mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - x_mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 45.73643410852713, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) it consists of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) it consists of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}]}, "HumanEval/20": {"dps": 81.53753026634382, "dps_norm": 97.22222222222223, "pass@1": 98.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to bring closest elements next to each other\n    numbers_sorted = sorted(numbers)\n    # Initialize the minimum difference and the closest pair\n    min_diff = abs(numbers_sorted[1] - numbers_sorted[0])\n    closest_pair = (min(numbers_sorted[0], numbers_sorted[1]), max(numbers_sorted[0], numbers_sorted[1]))\n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(numbers_sorted) - 1):\n        diff = abs(numbers_sorted[i+1] - numbers_sorted[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers_sorted[i], numbers_sorted[i+1])\n    # Return the pair in order (smaller number, larger number)\n    return (min(closest_pair[0], closest_pair[1]), max(closest_pair[0], closest_pair[1]))", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    # Initialize the minimum difference and the closest pair\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    min_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            min_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate over the sorted list\n    for i in range(len(sorted_numbers) - 1):\n        a, b = sorted_numbers[i], sorted_numbers[i+1]\n        diff = b - a\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (a, b)\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"At least two numbers are required.\")\n\n    # Sort the numbers to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list and find the minimum difference\n    for i in range(len(sorted_numbers) - 1):\n        a, b = sorted_numbers[i], sorted_numbers[i + 1]\n        diff = b - a  # Since the list is sorted, b >= a\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (a, b)\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        a = sorted_numbers[i]\n        b = sorted_numbers[i + 1]\n        diff = abs(a - b)\n        if diff < min_diff:\n            min_diff = diff\n            result = (a, b)\n\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"At least two elements are required\")\n\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    min_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (sorted_numbers[i], sorted_numbers[i+1])\n\n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    numbers_sorted = sorted(numbers)\n    min_diff = float('inf')\n    min_pair = (numbers_sorted[0], numbers_sorted[1])\n    \n    for i in range(len(numbers_sorted) - 1):\n        current = numbers_sorted[i]\n        next_num = numbers_sorted[i + 1]\n        diff = next_num - current\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (current, next_num)\n    \n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n    # Sort the numbers\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    min_pair = (sorted_numbers[0], sorted_numbers[1])\n    for i in range(len(sorted_numbers) - 1):\n        a, b = sorted_numbers[i], sorted_numbers[i + 1]\n        diff = abs(b - a)\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (a, b)\n    return min_pair", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    # Sort the numbers to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    min_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list and find the minimum difference\n    for i in range(len(sorted_numbers) - 1):\n        a, b = sorted_numbers[i], sorted_numbers[i + 1]\n        diff = b - a  # Since the list is sorted, b >= a\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (a, b)\n\n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    # Sort the numbers to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate over the sorted list and find the minimal difference\n    for i in range(len(sorted_numbers) - 1):\n        a, b = sorted_numbers[i], sorted_numbers[i + 1]\n        diff = b - a\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (a, b)\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n\n    # Sort the list to bring closest numbers next to each other\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list to find the minimal difference\n    for i in range(len(sorted_numbers) - 1):\n        current = sorted_numbers[i]\n        next_num = sorted_numbers[i + 1]\n        diff = next_num - current\n\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (current, next_num)\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to bring closest elements next to each other\n    nums_sorted = sorted(numbers)\n    min_diff = float('inf')\n    min_pair = (nums_sorted[0], nums_sorted[1])  # Initialize with the first pair\n\n    # Iterate over the sorted list and find the minimum difference\n    for i in range(len(nums_sorted) - 1):\n        a, b = nums_sorted[i], nums_sorted[i + 1]\n        diff = b - a\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (a, b)\n\n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n\n    # Sort the numbers to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    min_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list to find the minimum difference\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"At least two numbers are required\")\n    \n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    min_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the numbers to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list and find the pair with the minimum difference\n    for i in range(len(sorted_numbers) - 1):\n        x, y = sorted_numbers[i], sorted_numbers[i + 1]\n        diff = y - x\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (x, y)\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    # Sort the list to bring closest numbers next to each other\n    sorted_numbers = sorted(numbers)\n    \n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])  # Initialize with first pair\n\n    # Iterate through the sorted list to find the minimum difference\n    for i in range(len(sorted_numbers) - 1):\n        a, b = sorted_numbers[i], sorted_numbers[i + 1]\n        diff = abs(b - a)\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (a, b)\n\n    return closest_pair", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    min_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        a, b = sorted_numbers[i], sorted_numbers[i + 1]\n        diff = abs(b - a)\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (a, b)\n\n    return min_pair", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    for i in range(1, len(sorted_numbers)):\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to bring closest elements next to each other\n    numbers_sorted = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (numbers_sorted[0], numbers_sorted[1])\n\n    # Iterate through the sorted list and find the minimum difference\n    for i in range(len(numbers_sorted) - 1):\n        a, b = numbers_sorted[i], numbers_sorted[i + 1]\n        diff = abs(b - a)\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (a, b)\n\n    return closest_pair", "matching_cluster_idx": 7}]}, "HumanEval/24": {"dps": 96.22448979591837, "dps_norm": 75.625, "pass@1": 88.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    max_divisor = 1\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            d1 = i\n            d2 = n // i\n            if d1 != n and d1 > max_divisor:\n                max_divisor = d1\n            if d2 != n and d2 > max_divisor:\n                max_divisor = d2\n    return max_divisor", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No proper divisors for n <= 1\n\n    max_divisor = 1\n    for d in range(1, int(n ** 0.5) + 1):\n        if n % d == 0:\n            complement = n // d\n            if complement != n and complement > max_divisor:\n                max_divisor = complement\n            if d != n and d > max_divisor:\n                max_divisor = d\n    return max_divisor", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors for numbers less than or equal to 1\n    import math\n    for i in range(2, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            other = n // i\n            if other != n:\n                return other  # Largest proper divisor found\n            else:\n                return i  # n is a perfect square\n    return 1  # n is prime, so the largest proper divisor is 1", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors for n <= 1\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return n // i  # Largest divisor found\n    return 1  # n is prime, so the largest divisor is 1", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    if n <= 2:\n        return 1  # For n=1 or n=2, the largest proper divisor is 1\n    if n % 2 == 0:\n        return n // 2  # If n is even, n/2 is the largest proper divisor\n    for i in range(3, int(n**0.5)+1, 2):  # Check odd divisors up to sqrt(n)\n        if n % i == 0:\n            return n // i  # Return the corresponding largest proper divisor\n    return 1  # If no divisors found, n is prime and the largest proper divisor is 1", "matching_cluster_idx": 6}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(27)\n    9\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n % 2 == 0:\n        return n // 2  # The largest divisor is half of n if n is even\n    max_divisor = int(n ** 0.5) + 1  # Only need to check up to the square root of n\n    for i in range(3, max_divisor, 2):  # Check only odd divisors\n        if n % i == 0:\n            return n // i  # Found the smallest factor, so n divided by it is the largest divisor\n    return 1  # n is prime, so the largest proper divisor is 1", "matching_cluster_idx": 7}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    max_proper_divisor = 1\n    for k in range(1, int(n ** 0.5) + 1):\n        if n % k == 0:\n            d1, d2 = k, n // k\n            if d1 < n and d1 > max_proper_divisor:\n                max_proper_divisor = d1\n            if d2 < n and d2 > max_proper_divisor:\n                max_proper_divisor = d2\n    return max_proper_divisor", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n > 1, find the largest number that divides n evenly, smaller than n.\n    Returns None if n <= 1.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(1)\n    None\n    \"\"\"\n    if n <= 1:\n        return None  # No proper divisors for n <= 1\n    import math\n    max_divisor = 1  # 1 is a divisor of every integer\n    limit = int(math.isqrt(n))\n    for i in range(1, limit + 1):\n        if n % i == 0:\n            divisor_pair = (i, n // i)\n            for d in divisor_pair:\n                if d < n and d > max_divisor:\n                    max_divisor = d\n    return max_divisor", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    divisors = set()\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    divisors.discard(n)  # Remove the number itself to find the proper divisor\n    return max(divisors) if divisors else 1  # Return 1 if no proper divisor found", "matching_cluster_idx": 5}, {"solution": "import random\nimport math\ndef is_prime(n):\n    \"\"\"Miller-Rabin primality test.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0:\n        return False\n\n    # Write n - 1 as 2^s * d\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n\n    # Deterministic bases for n < 3,317,444,400,000,000,000\n    bases = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n\n    for a in bases:\n        if a >= n:\n            continue\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\ndef pollards_rho(n):\n    \"\"\"Pollard's Rho algorithm to find a non-trivial factor of n.\"\"\"\n    if n % 2 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    if n % 5 == 0:\n        return 5\n\n    while True:\n        c = random.randrange(1, n)\n        f = lambda x: (pow(x, 2, n) + c) % n\n        x, y, d = 2, 2, 1\n        while d ==1:\n            x = f(x)\n            y = f(f(y))\n            d = math.gcd(abs(x - y), n)\n        if d != n:\n            return d\ndef largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    if is_prime(n):\n        return 1\n    else:\n        # Find a non-trivial factor p of n\n        p = pollards_rho(n)\n        q = n // p\n        # The largest proper divisor is the maximum of p and n // p\n        return max(p, q)", "matching_cluster_idx": 7}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(49)\n    7\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1  # 1 has no proper divisors, so we return 1 by convention\n    largest = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            # Check the divisor i\n            if i != n:\n                largest = max(largest, i)\n            # Check the corresponding divisor n // i\n            d = n // i\n            if d != n:\n                largest = max(largest, d)\n        i += 1\n    return largest", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    import math\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    divisors.discard(n)\n    return max(divisors)", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1  # The largest divisor of 1 is 1\n    if n % 2 == 0:\n        return n // 2  # For even n, n//2 is the largest proper divisor\n\n    # For odd n, check for divisors starting from 3 up to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return n // i  # Return the largest proper divisor found\n\n    return 1  # If no divisors found, n is prime, so the largest proper divisor is 1", "matching_cluster_idx": 6}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"Find the largest proper divisor of n (the largest number less than n that divides n evenly).\n\n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest proper divisor of n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(100)\n        50\n        >>> largest_divisor(13)\n        1\n    \"\"\"\n    if n <= 1:\n        return 0  # No proper divisors for n <= 1\n\n    max_divisor = 1  # Start with the minimal proper divisor\n    upper_limit = int(n ** 0.5) + 1  # Only need to check up to the square root of n\n\n    for i in range(2, upper_limit):\n        if n % i == 0:\n            other_divisor = n // i\n\n            # Check if 'other_divisor' is a proper divisor less than n\n            if other_divisor != n and other_divisor > max_divisor:\n                max_divisor = other_divisor\n\n            # Check if 'i' is greater than current 'max_divisor'\n            if i > max_divisor:\n                max_divisor = i\n\n    return max_divisor", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1.\")\n    # For even numbers, the largest divisor smaller than n is n // 2\n    if n % 2 == 0:\n        return n // 2\n    # For odd numbers, check divisors from n // 2 down to 1\n    for d in range(n // 2, 0, -1):\n        if n % d == 0:\n            return d", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return 1  # The only divisor of 1 is 1 itself\n\n    max_divisor = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            other_divisor = n // i\n            if other_divisor < n:\n                max_divisor = max(max_divisor, other_divisor)\n            if i < n:\n                max_divisor = max(max_divisor, i)\n    return max_divisor", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    if n <= 1:\n        return 0  # No proper divisors for numbers less than or equal to 1\n\n    max_divisor = 1\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            complement = n // i\n            if complement != n and complement > max_divisor:\n                max_divisor = complement\n            if i != n and i > max_divisor:\n                max_divisor = i\n    return max_divisor", "matching_cluster_idx": 5}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    max_divisor = 1  # Initialize the maximum divisor found\n    for i in range(1, int(n ** 0.5) + 1):  # Loop from 1 to sqrt(n)\n        if n % i == 0:  # If i is a divisor of n\n            divisor1 = i\n            divisor2 = n // i  # The corresponding pair divisor\n\n            # Check first divisor\n            if divisor1 < n and divisor1 > max_divisor:\n                max_divisor = divisor1\n\n            # Check second divisor\n            if divisor2 < n and divisor2 > max_divisor:\n                max_divisor = divisor2\n\n    return max_divisor", "matching_cluster_idx": 5}]}, "HumanEval/26": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 92.0, "profiled": [{"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [x for x in numbers if counts[x] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [x for x in numbers if counts[x] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the frequency of each number\n    freq = {}\n    for num in numbers:\n        freq[num] = freq.get(num, 0) + 1\n\n    # Collect numbers that appear exactly once, maintaining order\n    result = []\n    for num in numbers:\n        if freq[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    from collections import Counter\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [x for x in numbers if counts[x] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    for num in numbers:\n        count[num] = count.get(num, 0) + 1\n\n    result = []\n    for num in numbers:\n        if count[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep the order of the elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = Counter(numbers)\n    result = [number for number in numbers if frequency[number] == 1]\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    from collections import Counter\n    counts = Counter(numbers)\n    # Build a list of numbers that occur only once, preserving order\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [x for x in numbers if counts[x] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [x for x in numbers if counts[x] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [x for x in numbers if counts[x] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 81.45569620253164, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return True   # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return False  # Exclude multiples of 2 and 3\n\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w      # This skips even numbers and multiples of 3\n        w = 6 - w   # Alternates between adding 2 and 4 (i.e., 5,7,11,13,17,...)\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        # Use deterministic Miller-Rabin test\n        d = n - 1\n        s = 0\n        while d % 2 == 0:\n            d >>= 1\n            s += 1\n        # Witnesses for deterministic test\n        if n < 1373653:\n            witnesses = [2, 3]\n        elif n < 25326001:\n            witnesses = [2, 3, 5]\n        elif n < 3215031751:\n            witnesses = [2, 3, 5, 7]\n        elif n < 2152302898747:\n            witnesses = [2, 3, 5, 7, 11]\n        else:\n            witnesses = [2, 3, 5, 7, 11, 13]\n        for a in witnesses:\n            if a >= n:\n                continue\n            x = pow(a, d, n)\n            if x == 1 or x == n - 1:\n                continue\n            for _ in range(s - 1):\n                x = pow(x, 2, n)\n                if x == n - 1:\n                    break\n            else:\n                return False\n        return True", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False  # 1 and numbers less than 1 are not prime\n    elif n <= 3:\n        return True   # 2 and 3 are prime numbers\n    elif n % 2 == 0 or n % 3 == 0:\n        return False  # Exclude multiples of 2 and 3\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False  # Found a divisor, not a prime\n        i += w  # Increment i by 2 or 4 alternately to check for 6k \u00b1 1\n        w = 6 - w  # Switch between adding 2 and 4\n    return True  # No divisors found, n is prime", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return False  # eliminate multiples of 2 and 3\n\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w  # this alternates w between 2 and 4 (checking 6k \u00b1 1)\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n%2 == 0 or n%3 == 0:\n        return False\n    i = 5\n    while i*i <= n:\n        if n%i == 0 or n%(i+2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2  # This helps alternate checks between i and i + 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w  # Toggle between adding 2 and 4 (to check i += 2, i += 4 alternately)\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0:\n        return False\n    # Write n-1 as 2^s * d\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    # Use deterministic Miller-Rabin primality test\n    if n < 1373653:\n        witnesses = [2, 3]\n    elif n < 25326001:\n        witnesses = [2, 3, 5]\n    elif n < 3215031751:\n        witnesses = [2, 3, 5, 7]\n    elif n < 2152302898747:\n        witnesses = [2, 3, 5, 7, 11]\n    elif n < 3474749660383:\n        witnesses = [2, 3, 5, 7, 11, 13]\n    elif n < 341550071728321:\n        witnesses = [2, 3, 5, 7, 11, 13, 17]\n    else:\n        witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    for a in witnesses:\n        if a >= n:\n            continue\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0:\n        return False\n\n    # Deterministic Miller-Rabin primality test\n    # Suitable for n < 3,317,444,400,000,000,000 using known witness sets\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n\n    # Select witness bases depending on the range of n\n    if n < 1373653:\n        bases = [2, 3]\n    elif n < 9080191:\n        bases = [31, 73]\n    elif n < 4759123141:\n        bases = [2, 7, 61]\n    elif n < 1122004669633:\n        bases = [2, 13, 23, 1662803]\n    elif n < 2152302898747:\n        bases = [2, 3, 5, 7, 11]\n    elif n < 3474749660383:\n        bases = [2, 3, 5, 7, 11, 13]\n    elif n < 341550071728321:\n        bases = [2, 3, 5, 7, 11, 13, 17]\n    else:\n        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n\n    for a in bases:\n        if a >= n:\n            continue\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    # Eliminate multiples of 2 and 3\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    # Check for divisibility by numbers of the form 6k \u00b1 1 up to sqrt(n)\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w  # toggles w between 2 and 4\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return n == 2 or n == 3\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w  # Alternate steps between 2 and 4 to check 6k \u00b1 1\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 97.36111111111111, "dps_norm": 82.72727272727272, "pass@1": 100.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it\n    l_prime = l[:]\n    # Get the indices divisible by 3\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract the elements at those indices\n    elements = [l[i] for i in indices]\n    # Sort the extracted elements\n    elements.sort()\n    # Place the sorted elements back into their original positions\n    for idx, val in zip(indices, elements):\n        l_prime[idx] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three (where index % 3 == 0),\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    indices_to_sort = [i for i in range(len(l)) if i % 3 == 0]\n    values_to_sort = [l[i] for i in indices_to_sort]\n    sorted_values = sorted(values_to_sort)\n    l_out = l.copy()\n    for idx, val in zip(indices_to_sort, sorted_values):\n        l_out[idx] = val\n    return l_out", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Copy the original list to avoid modifying it\n    l_prime = l[:]\n    \n    # Find indices divisible by 3\n    indices = list(range(0, len(l), 3))\n    \n    # Extract values at those indices\n    values = [l[i] for i in indices]\n    \n    # Sort the extracted values\n    values.sort()\n    \n    # Replace the values at the indices divisible by 3 with the sorted values\n    for i, val in zip(indices, values):\n        l_prime[i] = val\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find indices divisible by 3\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract values at those indices\n    values = [l[i] for i in indices]\n    # Sort the values\n    sorted_values = sorted(values)\n    # Create a copy of l to avoid modifying the original list\n    result = l.copy()\n    # Replace the values at the indices with sorted values\n    for idx, val in zip(indices, sorted_values):\n        result[idx] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    values = [l[i] for i in indices]\n    sorted_values = sorted(values)\n    l_copy = l.copy()\n    for i, v in zip(indices, sorted_values):\n        l_copy[i] = v\n    return l_copy", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices\n    that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find indices divisible by 3\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract the values at those indices\n    divisible_values = [l[i] for i in divisible_indices]\n    # Sort the extracted values\n    divisible_values.sort()\n    # Create a copy of the original list to maintain immutability\n    sorted_list = l.copy()\n    # Replace the values at the divisible indices with the sorted values\n    for idx, val in zip(divisible_indices, divisible_values):\n        sorted_list[idx] = val\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it\n    l_prime = l.copy()\n\n    # Find indices divisible by 3\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n\n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n\n    # Sort the extracted values\n    values_to_sort.sort()\n\n    # Place the sorted values back into their original positions\n    for index, value in zip(divisible_by_three_indices, values_to_sort):\n        l_prime[index] = value\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_prime = l.copy()\n    indices_div_by_three = [i for i in range(len(l)) if i % 3 == 0]\n    values_to_sort = [l[i] for i in indices_div_by_three]\n    values_to_sort.sort()\n    for idx, i in enumerate(indices_div_by_three):\n        l_prime[i] = values_to_sort[idx]\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l at the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    indices_to_sort = [i for i in range(len(l)) if i % 3 == 0]\n    values_to_sort = [l[i] for i in indices_to_sort]\n    values_to_sort.sort()\n    l_prime = l.copy()\n    for idx, val in zip(indices_to_sort, values_to_sort):\n        l_prime[idx] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    indices = list(range(0, len(l), 3))\n    elements = [l[i] for i in indices]\n    elements.sort()\n    l_copy = l.copy()\n    for i, e in zip(indices, elements):\n        l_copy[i] = e\n    return l_copy", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices\n    that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Copy the original list to avoid modifying it\n    result = l.copy()\n    # Collect indices divisible by 3 (0-based indexing)\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract values at these indices\n    values = [l[i] for i in indices]\n    # Sort the extracted values\n    values.sort()\n    # Replace the values at the original indices with the sorted values\n    for idx, val in zip(indices, values):\n        result[idx] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l = l.copy()\n    l[::3] = sorted(l[::3])\n    return l", "matching_cluster_idx": 10}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find indices divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract values at those indices\n    values = [l[i] for i in indices]\n    # Sort the extracted values\n    sorted_values = sorted(values)\n    # Create a new list to hold the result\n    l_new = l[:]\n    # Replace the values at the indices with the sorted values\n    for idx, val in zip(indices, sorted_values):\n        l_new[idx] = val\n    return l_new", "matching_cluster_idx": 8}, {"solution": "def sort_third(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Copy the original list to avoid modifying it\n    l_prime = l.copy()\n\n    # Find indices divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n\n    # Extract elements at those indices\n    elements = [l[i] for i in indices]\n\n    # Sort the extracted elements\n    sorted_elements = sorted(elements)\n\n    # Place the sorted elements back into the list at the same indices\n    for idx, val in zip(indices, sorted_elements):\n        l_prime[idx] = val\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Collect indices divisible by 3\n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Collect elements at those indices\n    third_elements = [l[i] for i in third_indices]\n    # Sort the elements\n    sorted_elements = sorted(third_elements)\n    # Create result list as a copy of l\n    result = l.copy()\n    # Replace elements at indices divisible by 3 with sorted elements\n    for idx, val in zip(third_indices, sorted_elements):\n        result[idx] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find indices divisible by 3\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract values at those indices\n    values = [l[i] for i in indices]\n    # Sort the extracted values\n    sorted_values = sorted(values)\n    # Create a copy of the original list\n    l_prime = l[:]\n    # Replace values at indices divisible by 3 with sorted values\n    for idx, val in zip(indices, sorted_values):\n        l_prime[idx] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_prime = l[:]\n    # Find indices divisible by 3\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract values at these indices and sort them\n    sorted_values = sorted(l[i] for i in indices)\n    # Place sorted values back into their original positions\n    for idx, val in zip(indices, sorted_values):\n        l_prime[idx] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three,\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find indices divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract values at these indices\n    values_to_sort = [l[i] for i in indices]\n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    # Create a copy of the original list to store the result\n    l_prime = l.copy()\n    # Assign the sorted values back to their original positions\n    for i, val in zip(indices, sorted_values):\n        l_prime[i] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    values = [l[i] for i in indices]\n    sorted_values = sorted(values)\n    l_prime = l.copy()\n    for idx, val in zip(indices, sorted_values):\n        l_prime[idx] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    indices_div_by_3 = [i for i in range(len(l)) if i % 3 == 0]\n    values_at_indices = [l[i] for i in indices_div_by_3]\n    sorted_values = sorted(values_at_indices)\n    l_prime = l.copy()\n    for idx, val in zip(indices_div_by_3, sorted_values):\n        l_prime[idx] = val\n    return l_prime", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 98.70967741935483, "dps_norm": 88.57142857142857, "pass@1": 96.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    i, j = 11, 13\n    count = 0\n    while i < n or j < n:\n        if i == j and i < n:\n            num = i\n            i += 11\n            j += 13\n        elif (i < j or j >= n) and i < n:\n            num = i\n            i += 11\n        elif j < n:\n            num = j\n            j += 13\n        else:\n            break\n        # Count the number of times '7' appears in num\n        temp = num\n        while temp > 0:\n            if temp % 10 == 7:\n                count += 1\n            temp //= 10\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    numbers = set(range(11, n, 11)).union(range(13, n, 13))\n    return sum(str(number).count('7') for number in numbers)", "matching_cluster_idx": 6}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def count_digit_7_in_multiples(step):\n        return sum(str(k).count('7') for k in range(step, n, step))\n    count_from_11 = count_digit_7_in_multiples(11)\n    count_from_13 = count_digit_7_in_multiples(13)\n    count_from_143 = count_digit_7_in_multiples(143)\n    return count_from_11 + count_from_13 - count_from_143", "matching_cluster_idx": 6}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    total_count = 0\n    numbers = set(range(11, n, 11)) | set(range(13, n, 13))\n    for x in numbers:\n        total_count += str(x).count('7')\n    return total_count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    # Count '7's in multiples of 11 less than n\n    for k in range(1, (n - 1) // 11 + 1):\n        num = k * 11\n        count += str(num).count('7')\n    # Count '7's in multiples of 13 less than n\n    for k in range(1, (n - 1) // 13 + 1):\n        num = k * 13\n        count += str(num).count('7')\n    # Subtract '7's counted twice in multiples of both 11 and 13 (i.e., multiples of 143)\n    for k in range(1, (n - 1) // 143 + 1):\n        num = k * 143\n        count -= str(num).count('7')\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count_11 = 0\n    count_13 = 0\n    count_143 = 0\n\n    # Count '7's in multiples of 11 less than n\n    for i in range(1, (n - 1) // 11 + 1):\n        num = i * 11\n        count_11 += str(num).count('7')\n\n    # Count '7's in multiples of 13 less than n\n    for i in range(1, (n - 1) // 13 + 1):\n        num = i * 13\n        count_13 += str(num).count('7')\n\n    # Count '7's in multiples of both 11 and 13 (i.e., multiples of 143) less than n\n    for i in range(1, (n - 1) // 143 + 1):\n        num = i * 143\n        count_143 += str(num).count('7')\n\n    # Total count is sum of counts from multiples of 11 and 13, minus the overlap\n    total_count = count_11 + count_13 - count_143\n    return total_count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    numbers_11 = set(range(0, n, 11))\n    numbers_13 = set(range(0, n, 13))\n    numbers = numbers_11.union(numbers_13)\n    \n    count = 0\n    for i in numbers:\n        count += str(i).count('7')\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    total = sum(str(i).count('7') for i in range(11, n, 11))\n    total += sum(str(i).count('7') for i in range(13, n, 13) if i % 11 != 0)\n    return total", "matching_cluster_idx": 6}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    numbers = set(range(11, n, 11)).union(range(13, n, 13))\n    count = 0\n    for number in numbers:\n        count += str(number).count('7')\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # Generate all multiples of 11 less than n\n    multiples_of_11 = range(11, n, 11)\n    # Generate all multiples of 13 less than n\n    multiples_of_13 = range(13, n, 13)\n    # Combine the multiples into a set to avoid duplicates\n    numbers = set(multiples_of_11).union(multiples_of_13)\n    # Count the number of times digit '7' appears in these numbers\n    count = sum(str(num).count('7') for num in numbers)\n    return count", "matching_cluster_idx": 6}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    total_count = 0\n\n    # Process multiples of 11 less than n\n    for k in range(1, (n - 1) // 11 + 1):\n        x = k * 11\n        total_count += str(x).count('7')\n\n    # Process multiples of 13 less than n, avoiding duplicates (numbers divisible by both 11 and 13)\n    for k in range(1, (n - 1) // 13 + 1):\n        x = k * 13\n        if x % 143 == 0:\n            continue  # Skip numbers divisible by both 11 and 13 to avoid duplicates\n        total_count += str(x).count('7')\n\n    return total_count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    total = 0\n    nums = set()\n\n    # Add multiples of 11 less than n to the set\n    for i in range(n // 11 + 1):\n        k = i * 11\n        if k < n:\n            nums.add(k)\n\n    # Add multiples of 13 less than n to the set\n    for i in range(n // 13 + 1):\n        k = i * 13\n        if k < n:\n            nums.add(k)\n\n    # Count the number of times '7' appears in the numbers\n    for num in nums:\n        total += str(num).count('7')\n\n    return total", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    multiples_11 = {11 * i for i in range(1, (n - 1) // 11 + 1)}\n    multiples_13 = {13 * i for i in range(1, (n - 1) // 13 + 1)}\n    numbers = multiples_11.union(multiples_13)\n    total_sevens = sum(str(num).count('7') for num in numbers)\n    return total_sevens", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def count_sevens_in(num):\n        return str(num).count('7')\n    \n    total_sevens = 0\n\n    max_k11 = (n - 1) // 11\n    max_k13 = (n - 1) // 13\n    max_k143 = (n - 1) // 143  # 11*13 = 143\n\n    # Count '7's in multiples of 11\n    for k in range(1, max_k11 + 1):\n        num = k * 11\n        total_sevens += count_sevens_in(num)\n    \n    # Count '7's in multiples of 13\n    for k in range(1, max_k13 + 1):\n        num = k * 13\n        total_sevens += count_sevens_in(num)\n    \n    # Subtract '7's counted twice in multiples of 143 (since they are divisible by both 11 and 13)\n    for k in range(1, max_k143 + 1):\n        num = k * 143\n        total_sevens -= count_sevens_in(num)\n    \n    return total_sevens", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # Helper function to count occurrences of digit '7' in a number\n    def count_digit_seven(number):\n        count = 0\n        while number > 0:\n            if number % 10 == 7:\n                count += 1\n            number //= 10\n        return count\n\n    total_count = 0\n\n    # Count occurrences in multiples of 11\n    max_multiple_of_11 = (n - 1) // 11\n    for k in range(1, max_multiple_of_11 + 1):\n        number = 11 * k\n        total_count += count_digit_seven(number)\n\n    # Count occurrences in multiples of 13\n    max_multiple_of_13 = (n - 1) // 13\n    for k in range(1, max_multiple_of_13 + 1):\n        number = 13 * k\n        total_count += count_digit_seven(number)\n\n    # Subtract occurrences in multiples of both 11 and 13 (i.e., 143) to avoid double-counting\n    max_multiple_of_143 = (n - 1) // 143\n    for k in range(1, max_multiple_of_143 + 1):\n        number = 143 * k\n        total_count -= count_digit_seven(number)\n\n    return total_count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    n_str = str(n - 1)\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count(pos, mod11, mod13, tight):\n        if pos == len(n_str):\n            if mod11 == 0 or mod13 == 0:\n                return (1, 0)  # (number of valid numbers, total count of digit '7's)\n            else:\n                return (0, 0)\n        else:\n            limit_digit = int(n_str[pos]) if tight else 9\n            total_numbers = 0\n            total_sevens = 0\n            for d in range(0, limit_digit + 1):\n                new_tight = tight and (d == limit_digit)\n                new_mod11 = (mod11 * 10 + d) % 11\n                new_mod13 = (mod13 * 10 + d) % 13\n                count_numbers_next, count_sevens_next = count(\n                    pos + 1, new_mod11, new_mod13, new_tight\n                )\n                total_numbers += count_numbers_next\n                if d == 7:\n                    total_sevens += count_numbers_next + count_sevens_next\n                else:\n                    total_sevens += count_sevens_next\n            return (total_numbers, total_sevens)\n\n    total_numbers, total_sevens = count(0, 0, 0, True)\n    return total_sevens", "matching_cluster_idx": 6}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    numbers_11 = range(11, n, 11)\n    numbers_13 = range(13, n, 13)\n    numbers = set(numbers_11) | set(numbers_13)\n    return sum(str(number).count('7') for number in numbers)", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    numbers = set(range(0, n, 11)).union(range(0, n, 13))\n    total_sevens = sum(str(num).count('7') for num in numbers)\n    return total_sevens", "matching_cluster_idx": 6}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    total_count = 0\n    for i in range(11, n, 11):\n        total_count += str(i).count('7')\n    for i in range(13, n, 13):\n        if i % 11 != 0:\n            total_count += str(i).count('7')\n    return total_count", "matching_cluster_idx": 5}]}, "HumanEval/37": {"dps": 95.18003273322422, "dps_norm": 90.5, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = range(0, len(l), 2)\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    l_prime = l.copy()\n    for idx, i in enumerate(even_indices):\n        l_prime[i] = even_values[idx]\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    l_prime = l[:]\n    l_prime[::2] = sorted(l[::2])\n    return l_prime", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the values at even indices\n    even_indices = range(0, len(l), 2)\n    even_values = [l[i] for i in even_indices]\n\n    # Sort the even-indexed values\n    even_values.sort()\n\n    # Create a copy of the original list\n    sorted_list = l[:]\n\n    # Replace the values at even indices with the sorted values\n    for i, val in zip(even_indices, even_values):\n        sorted_list[i] = val\n\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = range(0, len(l), 2)\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    result = l.copy()\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = list(range(0, len(l), 2))\n    even_elements = [l[i] for i in even_indices]\n    sorted_even_elements = sorted(even_elements)\n    result = l[:]\n    for idx, val in zip(even_indices, sorted_even_elements):\n        result[idx] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values at the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Collect the indices of even positions\n    even_indices = range(0, len(l), 2)\n    # Extract the values at even indices\n    even_values = [l[i] for i in even_indices]\n    # Sort the even-indexed values\n    sorted_evens = sorted(even_values)\n    # Create a copy of the original list to preserve odd-indexed values\n    result = l.copy()\n    # Replace the values at even indices with the sorted values\n    for idx, val in zip(even_indices, sorted_evens):\n        result[idx] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = range(0, len(l), 2)\n    even_values = [l[i] for i in even_indices]\n    sorted_even_values = sorted(even_values)\n    l_prime = l.copy()\n    for idx, val in zip(even_indices, sorted_even_values):\n        l_prime[idx] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    sorted_even = sorted(even_indices)\n    \n    l_prime = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(sorted_even[even_idx])\n            even_idx += 1\n        else:\n            l_prime.append(l[i])\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = range(0, len(l), 2)\n    even_values = [l[i] for i in even_indices]\n    even_values_sorted = sorted(even_values)\n    result = l.copy()\n    for i, v in zip(even_indices, even_values_sorted):\n        result[i] = v\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the values at even indices\n    even_indices = range(0, len(l), 2)\n    even_values = [l[i] for i in even_indices]\n    # Sort the even-indexed values\n    even_values.sort()\n    # Reconstruct the list with sorted even-indexed values\n    result = l.copy()\n    for idx, val in zip(even_indices, even_values):\n        result[idx] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = range(0, len(l), 2)\n    even_values = sorted(l[i] for i in even_indices)\n    l_prime = l.copy()\n    for idx, i in enumerate(even_indices):\n        l_prime[i] = even_values[idx]\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract values at even indices\n    even_indices = range(0, len(l), 2)\n    even_values = [l[i] for i in even_indices]\n\n    # Sort the even-indexed values\n    even_values.sort()\n\n    # Create a copy of the original list to avoid modifying it\n    result = l[:]\n\n    # Replace the values at even indices with the sorted values\n    for i, val in zip(even_indices, even_values):\n        result[i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = range(0, len(l), 2)\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    even_iter = iter(even_values)\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(next(even_iter))\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = range(0, len(l), 2)\n    even_values = sorted(l[i] for i in even_indices)\n    l_prime = l.copy()\n    for i, val in zip(even_indices, even_values):\n        l_prime[i] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    evens = l[::2]\n    sorted_evens = sorted(evens)\n    res = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            res.append(sorted_evens[even_idx])\n            even_idx += 1\n        else:\n            res.append(l[i])  # Keep original value at odd indices\n    return res", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_values = l[::2]\n    sorted_even = sorted(even_values)\n    it = iter(sorted_even)\n    result = []\n    for idx, val in enumerate(l):\n        if idx % 2 == 0:  # even index\n            result.append(next(it))\n        else:\n            result.append(val)\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = list(range(0, len(l), 2))\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    l_prime = l.copy()\n    for idx, val in zip(even_indices, even_values):\n        l_prime[idx] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices_elements = l[::2]\n    even_indices_sorted = sorted(even_indices_elements)\n    result = []\n    even_sorted_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_sorted[even_sorted_index])\n            even_sorted_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_elements)\n    # Initialize the result list and a pointer for sorted_even\n    result = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Replace with sorted even element\n            result.append(sorted_even[even_idx])\n            even_idx += 1\n        else:\n            # Keep the original element at odd index\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract values at even indices and sort them\n    even_vals = sorted(l[i] for i in range(len(l)) if i % 2 == 0)\n    even_iter = iter(even_vals)\n    # Build the resulting list\n    result = [\n        next(even_iter) if i % 2 == 0 else l[i] \n        for i in range(len(l))\n    ]\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 60.0, "profiled": [{"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Efficiently compute 2^n mod p using built-in pow with three arguments\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n //= 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 92.487922705314, "dps_norm": 73.75, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(ch for ch in text if ch not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return text.translate(str.maketrans('', '', vowels))", "matching_cluster_idx": 6}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return ''.join(c for c in text if c.lower() not in 'aeiou')", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join([c for c in text if c not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    VOWELS = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in VOWELS)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(c for c in text if c not in vowels)", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    import random\n\n    def is_prime(n, k=5):\n        \"\"\"Return True if n is a prime number using the Miller-Rabin primality test.\"\"\"\n        if n <= 1:\n            return False\n        elif n <= 3:\n            return True\n        elif n % 2 == 0:\n            return False\n\n        # Write n-1 as 2^s * d\n        s = 0\n        d = n - 1\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n\n        # Witness loop\n        for _ in range(k):\n            a = random.randrange(2, n - 1)\n            x = pow(a, d, n)\n            if x == 1 or x == n - 1:\n                continue\n            for __ in range(s - 1):\n                x = pow(x, 2, n)\n                if x == n - 1:\n                    break\n            else:\n                return False\n        return True\n\n    def gcd(a, b):\n        \"\"\"Compute the greatest common divisor using Euclid's algorithm.\"\"\"\n        while b:\n            a, b = b, a % b\n        return a\n\n    def pollards_rho(n):\n        \"\"\"Pollard's Rho algorithm for integer factorization.\"\"\"\n        if n % 2 == 0:\n            return 2\n        if n % 3 == 0:\n            return 3\n        if n % 5 == 0:\n            return 5\n        if n % 7 == 0:\n            return 7\n        if n % 11 == 0:\n            return 11\n        if n % 13 == 0:\n            return 13\n\n        # Function for the sequence\n        def f(x, c, n):\n            return (pow(x, 2, n) + c) % n\n\n        for c in [1, 3, 5, 7, 11, 13]:\n            x, y, d = 2, 2, 1\n            while d == 1:\n                x = f(x, c, n)\n                y = f(f(y, c, n), c, n)\n                d = gcd(abs(x - y), n)\n            if d != n:\n                return d\n        return None\n\n    def find_largest_prime_factor(n):\n        \"\"\"Recursively find the largest prime factor of n.\"\"\"\n        if is_prime(n):\n            return n\n        factor = pollards_rho(n)\n        if factor is None or factor == n:\n            return n\n        else:\n            factor1 = find_largest_prime_factor(factor)\n            factor2 = find_largest_prime_factor(n // factor)\n            return max(factor1, factor2)\n\n    return find_largest_prime_factor(n)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    from math import gcd\n    import random\n\n    def is_prime(n, k=5):\n        \"\"\"Miller-Rabin primality test with k rounds.\"\"\"\n        if n <= 1:\n            return False\n        elif n <= 3:\n            return True\n        elif n % 2 == 0:\n            return False\n        # Write n-1 as 2^s * d\n        d = n - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        # Witness loop\n        for _ in range(k):\n            a = random.randrange(2, n - 1)\n            x = pow(a, d, n)\n            if x == 1 or x == n - 1:\n                continue\n            for __ in range(s - 1):\n                x = pow(x, 2, n)\n                if x == n - 1:\n                    break\n            else:\n                return False\n        return True\n\n    def pollards_rho(n):\n        \"\"\"Pollard's Rho algorithm for integer factorization.\"\"\"\n        if n % 2 == 0:\n            return 2\n        if is_prime(n):\n            return n\n        while True:\n            x = random.randrange(2, n)\n            y = x\n            c = random.randrange(1, n)\n            d = 1\n            while d == 1:\n                x = (pow(x, 2, n) + c) % n\n                y = (pow(y, 2, n) + c) % n\n                y = (pow(y, 2, n) + c) % n\n                d = gcd(abs(x - y), n)\n                if d == n:\n                    break\n            if d != n:\n                return d\n\n    largest_prime = 0\n    stack = [n]\n\n    while stack:\n        m = stack.pop()\n        if m <= 1:\n            continue\n        if is_prime(m):\n            if m > largest_prime:\n                largest_prime = m\n            continue\n        else:\n            factor = pollards_rho(m)\n            stack.append(factor)\n            stack.append(m // factor)\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = None\n    # Remove factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    # Now n is odd\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    # If n is still greater than 1, then n is prime\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = None\n\n    # Remove factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n        else:\n            factor += 2\n\n    # If n is now greater than 2, it is prime\n    if n > 2:\n        largest_factor = n\n\n    return int(largest_factor)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Remove the factor 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # n must be odd at this point\n    factor = 3\n    max_factor = n ** 0.5\n    while n > 1 and factor <= max_factor:\n        if n % factor == 0:\n            largest_factor = factor\n            n //= factor\n            max_factor = n ** 0.5\n        else:\n            factor += 2\n\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    max_prime = None\n\n    # Remove any factors of 2 first\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n\n    # Now n is odd. Start testing odd factors.\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            max_prime = factor\n            n //= factor\n        factor += 2\n\n    # If n is now greater than 2, then n itself is a prime number\n    if n > 2:\n        max_prime = n\n\n    return int(max_prime)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    max_prime = -1\n\n    # Remove all factors of 2\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n\n    # Now n is odd, check for odd factors\n    import math\n    for i in range(3, int(math.isqrt(n)) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n //= i\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n\n    return max_prime", "matching_cluster_idx": 8}, {"solution": "import random\nimport math\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(n, k=5):\n        \"\"\"Use Miller-Rabin primality test to check if n is prime.\"\"\"\n        if n <= 1:\n            return False\n        elif n <= 3:\n            return True\n        elif n % 2 == 0:\n            return False\n\n        # Write n - 1 as 2^s * d\n        d = n - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        \n        # Perform k rounds of testing\n        for _ in range(k):\n            a = random.randrange(2, n - 1)\n            x = pow(a, d, n)\n            if x == 1 or x == n - 1:\n                continue\n            for _ in range(s - 1):\n                x = pow(x, 2, n)\n                if x == n - 1:\n                    break\n            else:\n                return False\n        return True\n\n    def pollards_rho(n):\n        \"\"\"Pollard's rho algorithm for integer factorization.\"\"\"\n        if n % 2 == 0:\n            return 2\n        if n % 3 == 0:\n            return 3\n\n        while True:\n            c = random.randrange(1, n)\n            f = lambda x: (pow(x, 2, n) + c) % n\n            x, y, d = 2, 2, 1\n            while d == 1:\n                x = f(x)\n                y = f(f(y))\n                d = math.gcd(abs(x - y), n)\n            if d != n:\n                return d\n\n    if n <= 1:\n        return None\n    if is_prime(n):\n        return n\n    else:\n        factors = []\n        stack = [n]\n        while stack:\n            m = stack.pop()\n            if m <= 1:\n                continue\n            if is_prime(m):\n                factors.append(m)\n                continue\n            d = pollards_rho(m)\n            if d == m:\n                # Failed to factor further, treat m as prime\n                factors.append(m)\n            else:\n                stack.append(d)\n                stack.append(m // d)\n        return max(factors)", "matching_cluster_idx": 8}, {"solution": "import random\ndef gcd(a, b):\n    \"\"\"Compute the greatest common divisor of a and b.\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\ndef is_prime(n, k=5):\n    \"\"\"Miller-Rabin primality test to check if n is probably prime.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0:\n        return False\n\n    # Write n as (2^s)*d + 1\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n\n    # Perform k rounds of testing\n    for _ in range(k):\n        a = random.randrange(2, n - 1)\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for __ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False  # Composite\n    return True  # Probably prime\ndef pollards_rho(n):\n    \"\"\"Pollard's Rho algorithm for integer factorization.\"\"\"\n    if n % 2 == 0:\n        return 2\n    if is_prime(n):\n        return n\n    while True:\n        c = random.randrange(1, n)\n        f = lambda x: (pow(x, 2, n) + c) % n\n        x, y, d = 2, 2, 1\n        while d == 1:\n            x = f(x)\n            y = f(f(y))\n            d = gcd(abs(x - y), n)\n        if d == n:\n            continue  # Retry with a different c\n        if is_prime(d):\n            return d\n        else:\n            return pollards_rho(d)  # Factor further if d is composite\ndef factor(n):\n    \"\"\"Factorize n into its prime factors using Pollard's Rho algorithm.\"\"\"\n    factors = []\n    stack = [n]\n    while stack:\n        n = stack.pop()\n        if n <= 1:\n            continue\n        if is_prime(n):\n            factors.append(n)\n            continue\n        d = pollards_rho(n)\n        if d == n:\n            # Retry factoring n\n            stack.append(n)\n            continue\n        stack.append(d)\n        stack.append(n // d)\n    return factors\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factors = factor(n)\n    return max(factors)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    max_prime = -1\n    # Remove any factors of 2\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    # Now n is odd\n    p = 3\n    while p * p <= n:\n        while n % p == 0:\n            max_prime = p\n            n //= p\n        p += 2\n    if n > 1 and n > max_prime:\n        max_prime = n\n    return max_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    max_prime = None\n    # Remove factors of 2\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    # Check odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            max_prime = factor\n            n //= factor\n        factor += 2\n    # If remaining n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    return int(max_prime)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    max_prime = None\n\n    # Divide out the factor of 2\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n\n    # Now, n must be odd. We can test odd factors starting from 3.\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            max_prime = i\n            n //= i\n        i += 2\n\n    # If n is a prime number greater than 2, then n itself is the largest prime factor.\n    if n > 2:\n        max_prime = n\n\n    return max_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    import math\n    import random\n\n    def is_prime(n):\n        if n <= 3:\n            return n > 1\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        w = 2\n        while i * i <= n:\n            if n % i == 0:\n                return False\n            i += w\n            w = 6 - w\n        return True\n\n    def pollards_rho(n):\n        if n % 2 == 0:\n            return 2\n        if n % 3 == 0:\n            return 3\n        if n % 5 == 0:\n            return 5\n        while True:\n            c = random.randrange(1, n)\n            f = lambda x: (x * x + c) % n\n            x, y, d = 2, 2, 1\n            while d == 1:\n                x = f(x)\n                y = f(f(y))\n                d = math.gcd(abs(x - y), n)\n            if d != n:\n                return d\n\n    max_prime = None\n    stack = [n]\n    while stack:\n        m = stack.pop()\n        if m <= 1:\n            continue\n        if is_prime(m):\n            if max_prime is None or m > max_prime:\n                max_prime = m\n            continue\n        factor = pollards_rho(m)\n        stack.extend([factor, m // factor])\n\n    return max_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    max_prime = -1\n\n    # Remove all the 2s from n\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n\n    # n must be odd at this point\n    i = 3\n    while i * i <= n:\n        # While i divides n, remove i and update max_prime\n        while n % i == 0:\n            max_prime = i\n            n //= i\n        i += 2  # Only consider odd numbers\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n\n    return int(max_prime)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = None\n    # Remove any factors of 2 first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    # Now, n must be odd. Start checking from 3 onwards\n    factor = 3\n    max_factor = n ** 0.5  # We only need to check up to the square root of n\n    while n > 1 and factor <= max_factor:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n            max_factor = n ** 0.5  # Update max_factor since n has changed\n        factor += 2  # Only check odd numbers\n    if n > 1:\n        # If n is a prime number greater than 2\n        largest_factor = n\n    return int(largest_factor)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    max_prime = -1\n\n    # Remove all factors of 2\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n\n    # n must be odd at this point, so skip even numbers\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            max_prime = i\n            n //= i\n        i += 2\n\n    # If n is a prime number greater than 2, then n itself is the largest prime factor\n    if n > 2:\n        max_prime = n\n\n    return int(max_prime)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    last_factor = None\n\n    # Remove factors of 2\n    while n % 2 == 0:\n        last_factor = 2\n        n = n // 2\n\n    # Now n is odd. We can test for factors from 3 upwards.\n    factor = 3\n    max_factor = n ** 0.5\n    while n > 1 and factor <= max_factor:\n        while n % factor == 0:\n            last_factor = factor\n            n = n // factor\n            max_factor = n ** 0.5  # Since n has decreased, recompute max_factor\n        factor += 2  # Only test odd factors\n\n    # If n is still greater than 1, then n is a prime number larger than last_factor\n    if n > 1:\n        last_factor = n\n\n    return int(last_factor)", "matching_cluster_idx": 8}, {"solution": "import random\ndef is_prime(n, k=5):\n    \"\"\"Check if n is a prime number using the Miller-Rabin primality test.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0:\n        return False\n\n    # Write n-1 as 2^s * d where d is odd\n    s = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        s += 1\n\n    # Witness loop\n    for _ in range(k):\n        a = random.randrange(2, n - 1)\n        x = pow(a, d, n)\n\n        if x == 1 or x == n - 1:\n            continue\n\n        for __ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False  # Composite\n    return True  # Probably prime\ndef gcd(a, b):\n    \"\"\"Compute the greatest common divisor of a and b.\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\ndef pollards_rho(n):\n    \"\"\"Find a non-trivial factor of n using Pollard's Rho algorithm.\"\"\"\n    if n % 2 == 0:\n        return 2\n    if is_prime(n):\n        return n\n    while True:\n        c = random.randrange(1, n)\n        f = lambda x: (pow(x, 2, n) + c) % n\n        x, y, d = 2, 2, 1\n        while d == 1:\n            x = f(x)\n            y = f(f(y))\n            d = gcd(abs(x - y), n)\n        if d != n:\n            return d\ndef largest_prime_factor(n):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    if is_prime(n):\n        return n\n    max_prime = 0\n    factors = [n]\n    while factors:\n        n = factors.pop()\n        if n <= 1:\n            continue\n        if is_prime(n):\n            if n > max_prime:\n                max_prime = n\n            continue\n        factor = pollards_rho(n)\n        factors.extend([factor, n // factor])\n    return max_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def gcd(a, b):\n        \"\"\"Compute the greatest common divisor of a and b.\"\"\"\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_prime(n, k=5):\n        \"\"\"Use Miller-Rabin primality test to check if n is prime.\"\"\"\n        import random\n        if n <= 3:\n            return n == 2 or n == 3\n        if n % 2 == 0:\n            return False\n\n        # Write n-1 as 2^s * d\n        s = 0\n        d = n - 1\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n\n        # Witness loop\n        for _ in range(k):\n            a = random.randrange(2, n - 1)\n            x = pow(a, d, n)  # Compute a^d % n\n            if x == 1 or x == n - 1:\n                continue\n            for __ in range(s - 1):\n                x = pow(x, 2, n)\n                if x == n - 1:\n                    break\n            else:\n                return False\n        return True\n\n    def pollards_rho(n):\n        \"\"\"Pollard's Rho algorithm to find a non-trivial factor of n.\"\"\"\n        import random\n        if n % 2 == 0:\n            return 2\n        if n % 3 == 0:\n            return 3\n        if n % 5 == 0:\n            return 5\n        while True:\n            c = random.randrange(1, n)\n            f = lambda x: (pow(x, 2, n) + c) % n\n            x, y, d = 2, 2, 1\n            while d == 1:\n                x = f(x)\n                y = f(f(y))\n                d = gcd(abs(x - y), n)\n            if d != n:\n                return d\n\n    max_factor = 1\n\n    def factor(n):\n        nonlocal max_factor\n        if n <= 1:\n            return\n        if is_prime(n):\n            if n > max_factor:\n                max_factor = n\n            return\n        d = pollards_rho(n)\n        factor(d)\n        factor(n // d)\n\n    factor(n)\n    return max_factor", "matching_cluster_idx": 8}, {"solution": "import random\nimport math\ndef is_prime(n, k=5):  # number of iterations\n    \"\"\"Miller-Rabin primality test\"\"\"\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0:\n        return False\n    # write n-1 as 2^s * d\n    s = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        s += 1\n    for _ in range(k):\n        a = random.randrange(2, n - 1)\n        x = pow(a, d, n)\n        if x == 1 or x == n -1:\n            continue\n        for _ in range(s -1):\n            x = pow(x, 2, n)\n            if x == n -1:\n                break\n        else:\n            return False\n    return True\ndef pollards_rho(n):\n    \"\"\"Pollard's Rho Algorithm to find a non-trivial factor of n\"\"\"\n    if n % 2 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    if is_prime(n):\n        return n\n    while True:\n        c = random.randrange(1, n)\n        f = lambda x: (pow(x, 2, n) + c) % n\n        x, y, d = 2, 2, 1\n        while d == 1:\n            x = f(x)\n            y = f(f(y))\n            d = math.gcd(abs(x - y), n)\n        if d != n:\n            return d\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    max_prime = None\n\n    def factor(n):\n        nonlocal max_prime\n        if n == 1:\n            return\n        if is_prime(n):\n            if max_prime is None or n > max_prime:\n                max_prime = n\n            return\n        d = pollards_rho(n)\n        factor(d)\n        factor(n // d)\n\n    factor(n)\n    return max_prime", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 40.259740259740255, "dps_norm": 49.375, "pass@1": 98.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = set('aeiou')\n    count = 0\n    for i, c in enumerate(s):\n        if c in vowels:\n            count += 1\n        elif c == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = 'aeiou'\n    count = 0\n    for i, c in enumerate(s):\n        if c in vowels:\n            count += 1\n        elif c == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    count = 0\n    for i, c in enumerate(s):\n        if c in 'aeiou':\n            count += 1\n        elif c == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    vowels = 'aeiou'\n    s = s.lower()\n    for idx, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and idx == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = set('aeiou')\n    count = 0\n    for idx, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and idx == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiou')\n    s = s.lower()\n    count = 0\n    for i, c in enumerate(s):\n        if c in vowels:\n            count += 1\n        elif c == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    count = 0\n    vowels = set('aeiou')\n    for i, c in enumerate(s):\n        if c in vowels:\n            count += 1\n        elif c == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    count = 0\n    for i, ch in enumerate(s):\n        if ch in 'aeiou':\n            count += 1\n        elif ch == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    return sum(1 for i, c in enumerate(s) if c in 'aeiou' or (c == 'y' and i == len(s)-1))", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    count = 0\n    vowels = set('aeiou')\n    for idx, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and idx == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    total = 0\n    length = len(s)\n    for i, c in enumerate(s):\n        if c in 'aeiou':\n            total += 1\n        elif c == 'y' and i == length - 1:\n            total += 1\n    return total", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"happy\")\n    2\n    >>> vowels_count(\"yellow\")\n    2\n    >>> vowels_count(\"dry\")\n    1\n    >>> vowels_count(\"rhythmy\")\n    1\n    >>> vowels_count(\"bcd\")\n    0\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"aeiou\")\n    5\n    >>> vowels_count(\"AEIOU\")\n    5\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"YELL\")\n    1\n    >>> vowels_count(\"SPY\")\n    1\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"yappy\")\n    2\n    \"\"\"\n    s = s.lower()\n    vowels = set('aeiou')\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Examples:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"bcdfg\")\n    0\n    >>> vowels_count(\"AEIOUY\")\n    6\n    >>> vowels_count(\"why\")\n    0\n    >>> vowels_count(\"yellow\")\n    2\n    >>> vowels_count(\"mystery\")\n    1\n    >>> vowels_count(\"SYZYGY\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"sky\")\n    0\n    >>> vowels_count(\"gym\")\n    0\n    >>> vowels_count(\"crypt\")\n    0\n    >>> vowels_count(\"b\")\n    0\n    >>> vowels_count(\"E\")\n    1\n    >>> vowels_count(\"Happy\")\n    1\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    \"\"\"\n    s = s.lower()\n    count = 0\n    vowels = set('aeiou')\n    for idx, ch in enumerate(s):\n        if ch in vowels:\n            count += 1\n        elif ch == 'y' and idx == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = 'aeiou'\n    count = 0\n    for i, c in enumerate(s):\n        if c in vowels:\n            count += 1\n        elif c == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    for i, ch in enumerate(s):\n        if ch in vowels:\n            count += 1\n        elif ch == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"crypt\")\n    1\n    >>> vowels_count(\"AEIOUY\")\n    6\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"bcd\")\n    0\n    >>> vowels_count(\"y\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    \"\"\"\n    s = s.lower()\n    vowels = set('aeiou')\n    count = 0\n    for i, c in enumerate(s):\n        if c in vowels:\n            count += 1\n        elif c == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    s = s.lower()\n    vowels = 'aeiou'\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s_lower = s.lower()\n    count = 0\n    VOWELS = set('aeiou')\n    length = len(s_lower)\n    for i, c in enumerate(s_lower):\n        if c in VOWELS:\n            count += 1\n        elif c == 'y' and i == length -1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = set('aeiou')\n    count = 0\n    for i, c in enumerate(s):\n        if c in vowels:\n            count += 1\n        elif c == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    s = s.lower()\n    for i, c in enumerate(s):\n        if c in 'aeiou':\n            count += 1\n        elif c == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    if len1 < len2:\n        return lst1\n    elif len2 < len1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n    \n    if the two lists have the same number of chars, return the first list.\n    \n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n    \n    If the two lists have the same number of chars, return the first list.\n    \n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars1 > total_chars2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 < total2:\n        return lst1\n    elif total1 > total2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all the strings of the list less than the other list.\n    \n    If the two lists have the same number of chars, return the first list.\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 89.67821782178217, "dps_norm": 57.5, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Sum the even elements at odd indices\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    return sum(x for idx, x in enumerate(lst) if idx % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Sum the even elements at odd indices\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for idx in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[idx] % 2 == 0:          # Check if the element is even\n            total += lst[idx]          # Add to total if even\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for idx, x in enumerate(lst) if idx % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 10.0, "profiled": []}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for column_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, column_index))\n    # Sort coordinates by row ascending and column descending within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coords = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                coords.append((i, j))\n    # Sort the coordinates by row in ascending order,\n    # and columns in descending order within each row\n    coords.sort(key=lambda t: (t[0], -t[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix; however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coords = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where the value x is located in the current row\n        columns_with_x = [col_index for col_index, value in enumerate(row) if value == x]\n        # Append the coordinates to the list\n        for col_index in columns_with_x:\n            coords.append((row_index, col_index))\n    # Sort the coordinates by row in ascending order and columns in descending order within each row\n    coords.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    positions = {}\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                if row_index not in positions:\n                    positions[row_index] = []\n                positions[row_index].append(col_index)\n    result = []\n    for row_index in sorted(positions.keys()):\n        columns = sorted(positions[row_index], reverse=True)\n        for col_index in columns:\n            result.append((row_index, col_index))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coords = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value equals x in the current row\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Append the coordinates to the list\n        for col_idx in cols:\n            coords.append((row_idx, col_idx))\n    # Sort coordinates: first by row in ascending order, then by column in descending order\n    coords.sort(key=lambda t: (t[0], -t[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    similar to a matrix, but each row may have a different number of columns.\n    Given lst and integer x, find all occurrences of x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...], where each tuple represents\n    the coordinate (row_index, column_index), starting from 0.\n    Sort the coordinates first by rows in ascending order.\n    Within each row, sort the columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where x occurs in the current row\n        cols = [col_index for col_index, value in enumerate(row) if value == x]\n        \n        # Sort the column indices in descending order\n        cols.sort(reverse=True)\n        \n        # Add the coordinates to the result list\n        for col_index in cols:\n            result.append((row_index, col_index))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    res = []\n    for row_idx, row in enumerate(lst):\n        # Find column indices where x occurs\n        col_indices = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Sort column indices in descending order\n        col_indices.sort(reverse=True)\n        # Append coordinates to result\n        for col_idx in col_indices:\n            res.append((row_idx, col_idx))\n    return res", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. Unlike matrices, however,\n    each row may contain a different number of columns.\n    Given lst and integer x, find all occurrences of x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] where\n    each tuple represents the coordinates (row, column), starting from 0.\n    Sort the coordinates first by rows in ascending order.\n    Within each row, sort the columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    res = []\n    for i, row in enumerate(lst):\n        xs = [j for j, val in enumerate(row) if val == x]\n        xs.sort(reverse=True)\n        res.extend((i, j) for j in xs)\n    return res", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Dictionary to hold the columns for each row where x is found\n    coords_dict = {}\n    # Iterate through each row with its index\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where x occurs in the current row\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        if cols:\n            # Sort the columns in descending order and store them\n            coords_dict[row_idx] = sorted(cols, reverse=True)\n    # Prepare the final list of coordinates\n    coords = []\n    # Iterate over the rows in ascending order\n    for row_idx in sorted(coords_dict.keys()):\n        # Get the sorted columns for the current row\n        cols = coords_dict[row_idx]\n        # Append each coordinate (row_idx, col_idx)\n        for col_idx in cols:\n            coords.append((row_idx, col_idx))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coords = []\n    for row_index, row in enumerate(lst):\n        cols_in_row = [col_index for col_index, value in enumerate(row) if value == x]\n        if cols_in_row:\n            cols_in_row.sort(reverse=True)\n            for col_index in cols_in_row:\n                coords.append((row_index, col_index))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    row_to_cols = {}\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                if i not in row_to_cols:\n                    row_to_cols[i] = []\n                row_to_cols[i].append(j)\n    result = []\n    for row in sorted(row_to_cols.keys()):\n        cols = row_to_cols[row]\n        cols.sort(reverse=True)\n        for col in cols:\n            result.append((row, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix; however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    # Sort coordinates by row (ascending), then by column (descending within the same row)\n    coordinates.sort(key=lambda t: (t[0], -t[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix; however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    # Sort coordinates first by row in ascending order,\n    # then by columns in descending order within each row\n    coordinates.sort(key=lambda t: (t[0], -t[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coords = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where x occurs in the current row\n        col_indices = [col_index for col_index, value in enumerate(row) if value == x]\n        # Sort column indices in descending order\n        col_indices.sort(reverse=True)\n        # Append coordinates to the list\n        for col_index in col_indices:\n            coords.append((row_index, col_index))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    positions = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                positions.append((row_index, col_index))\n    # Sort positions: first by row ascending, then by column descending within each row\n    positions.sort(key=lambda t: (t[0], -t[1]))\n    return positions", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data as nested lists,\n    which is similar to a matrix; however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    # Iterate over each row with its index\n    for i, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        cols = [j for j, value in enumerate(row) if value == x]\n        # Sort the columns in descending order\n        cols.sort(reverse=True)\n        # Append the coordinates to the result list\n        for j in cols:\n            result.append((i, j))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given 2-dimensional data as nested lists, where each row may contain a different number of columns.\n    Given lst and integer x, find all occurrences of x in the list and return a list of tuples [(x1, y1), (x2, y2), ...],\n    where each tuple is a coordinate (row, column), starting with 0.\n    Sort the coordinates first by rows in ascending order.\n    Then, for each row, sort the columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    positions = []\n    for r, row in enumerate(lst):\n        cols_with_x = [c for c, val in enumerate(row) if val == x]\n        if cols_with_x:\n            cols_with_x.sort(reverse=True)\n            for c in cols_with_x:\n                positions.append((r, c))\n    return positions", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    positions = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices in the current row where the value equals x\n        cols_with_x = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Append positions to the list\n        for col_idx in cols_with_x:\n            positions.append((row_idx, col_idx))\n    # Sort positions:\n    #   - First by row index in ascending order\n    #   - Then by column index in descending order\n    positions.sort(key=lambda pos: (pos[0], -pos[1]))\n    return positions", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        cols_with_x = [col_index for col_index, value in enumerate(row) if value == x]\n        for col_index in cols_with_x:\n            coordinates.append((row_index, col_index))\n\n    # Sort coordinates by row ascending, then column descending\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n\n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find columns where x occurs in current row\n        col_indices = [col_idx for col_idx, value in enumerate(row) if value == x]\n        # Sort columns in descending order\n        col_indices.sort(reverse=True)\n        # Append coordinates to result\n        for col_idx in col_indices:\n            result.append((row_idx, col_idx))\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.70103092783506, "dps_norm": 31.42857142857143, "pass@1": 78.0, "profiled": [{"solution": "def encrypt(s):\n    result = ''\n    for c in s:\n        if c.isalpha():\n            shifted_ord = ord(c) + 4\n            if shifted_ord > ord('z'):\n                shifted_ord -= 26\n            result += chr(shifted_ord)\n        else:\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for c in s:\n        if 'a' <= c <= 'z':\n            pos = ord(c) - ord('a')\n            new_pos = (pos + 4) % 26\n            new_c = chr(new_pos + ord('a'))\n            result += new_c\n        else:\n            result += c  # Non-lowercase characters are left unchanged\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    return ''.join(\n        chr(((ord(c) - ord('a') + 4)%26)+ord('a')) if 'a' <= c <= 'z' else c\n        for c in s\n    )", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for c in s:\n        if 'a' <= c <= 'z':\n            shifted = chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n            result += shifted\n        else:\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    \"\"\"\n    result = ''\n    for ch in s:\n        if 'a' <= ch <= 'z':\n            # Shift character by 4 and wrap around using modulo operator\n            result += chr((ord(ch) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= ch <= 'Z':\n            result += chr((ord(ch) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            # Non-alphabetic characters remain unchanged\n            result += ch\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for c in s:\n        if 'a' <= c <= 'z':\n            shifted = chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n            result += shifted\n        else:\n            result += c  # Non-alphabetic characters are unchanged\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for c in s:\n        if c.islower() and c.isalpha():\n            shifted = (ord(c) - ord('a') + 4) % 26 + ord('a')\n            result += chr(shifted)\n        else:\n            result += c  # Non-lowercase letters remain unchanged\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 positions\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result += shifted\n        else:\n            # Leave non-lowercase characters unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the string by shifting each letter forward by 4 positions in the alphabet.\"\"\"\n    from string import ascii_lowercase\n    shifted = ascii_lowercase[4:] + ascii_lowercase[:4]  # Shifted alphabet by 4 places\n    table = str.maketrans(ascii_lowercase, shifted)\n    return s.translate(table)", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = ''\n    for c in s:\n        if c.islower():\n            # Shift each character by 4 positions (2 multiplied by 2)\n            shifted_pos = (ord(c) - ord('a') + 4) % 26\n            encrypted += chr(shifted_pos + ord('a'))\n        else:\n            # Keep non-lowercase characters unchanged\n            encrypted += c\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    res = ''\n    for c in s:\n        if 'a' <= c <= 'z':\n            shifted = chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n            res += shifted\n        else:\n            res += c\n    return res", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = ''\n    for c in s:\n        if 'a' <= c <= 'z':\n            shifted = chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n            encrypted += shifted\n        else:\n            encrypted += c\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    shift = 2 * 2  # Shift letters by 4 positions\n    for c in s:\n        if c.islower():\n            # Calculate the shifted character\n            shifted = chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n            result += shifted\n        else:\n            # Keep the character as is if it's not a lowercase letter\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for c in s:\n        if 'a' <= c <= 'z':\n            shifted = chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n            result += shifted\n        else:\n            result += c  # Keep the character as is if it's not a lowercase letter\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for c in s:\n        if c.isalpha() and c.islower():\n            shifted_ord = ord(c) + 4  # Shift by 2 multiplied by 2 places\n            if shifted_ord > ord('z'):\n                shifted_ord -= 26  # Wrap around if past 'z'\n            result += chr(shifted_ord)\n        else:\n            result += c  # Non-lowercase letters remain unchanged\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 2 * 2  # Shifting by 2 multiplied by 2 places, which is 4\n    result = ''\n    for c in s:\n        if c.islower():\n            # Calculate the new character with wrapping around 'z' to 'a'\n            new_char = chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n            result += new_char\n        else:\n            result += c  # Leave non-lowercase characters unchanged\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for c in s:\n        if 'a' <= c <= 'z':\n            # Shift the character by 4 positions, wrapping around using modulo 26\n            offset = (ord(c) - ord('a') + 4) % 26\n            new_c = chr(ord('a') + offset)\n            result += new_c\n        else:\n            # Non-lowercase characters are left unchanged (if any)\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by shifting each lowercase letter 4 positions forward in the alphabet.\n    Wraps around after 'z' back to 'a'.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for c in s:\n        if 'a' <= c <= 'z':\n            # Calculate shifted character with wrap-around\n            shifted_index = (ord(c) - ord('a') + 4) % 26\n            new_char = chr(ord('a') + shifted_index)\n            result += new_char\n        else:\n            # Keep non-lowercase characters unchanged\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for char in s:\n        if 'a' <= char <= 'z':\n            shifted_ord = ord('a') + (ord(char) - ord('a') + 4) % 26\n            result += chr(shifted_ord)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    return ''.join(\n        chr((ord(c) - ord('a') + 4) % 26 + ord('a')) if 'a' <= c <= 'z' else c\n        for c in s\n    )", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 27.17898832684825, "dps_norm": 34.583333333333336, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            if num != smallest:\n                second_smallest = smallest\n                smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 3}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    min1 = min(unique_elements)\n    unique_elements.remove(min1)\n    return min(unique_elements)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    smallest = None\n    second_smallest = None\n    seen = set()\n\n    for number in lst:\n        if number in seen:\n            continue\n        seen.add(number)\n        if smallest is None or number < smallest:\n            second_smallest = smallest\n            smallest = number\n        elif number > smallest and (second_smallest is None or number < second_smallest):\n            second_smallest = number\n\n    return second_smallest", "matching_cluster_idx": 1}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    smallest = None\n    second_smallest = None\n\n    for num in lst:\n        if smallest is None or num < smallest:\n            if smallest is not None and num != smallest:\n                second_smallest = smallest\n            smallest = num\n        elif num != smallest and (second_smallest is None or num < second_smallest):\n            second_smallest = num\n\n    return second_smallest", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_numbers = set(lst)\n    if len(unique_numbers) < 2:\n        return None\n    first_min = min(unique_numbers)\n    unique_numbers.remove(first_min)\n    second_min = min(unique_numbers)\n    return second_min", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    min1 = None\n    min2 = None\n    seen = set()\n    for num in lst:\n        if num in seen:\n            continue\n        seen.add(num)\n        if min1 is None or num < min1:\n            min2 = min1\n            min1 = num\n        elif min2 is None or num < min2:\n            min2 = num\n    return min2", "matching_cluster_idx": 1}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)\n    min1 = min2 = None\n    for x in unique_elements:\n        if min1 is None or x < min1:\n            min2 = min1\n            min1 = x\n        elif min1 != x and (min2 is None or x < min2):\n            min2 = x\n    return min2", "matching_cluster_idx": 1}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"    \n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    else:\n        smallest = min(unique_elements)\n        unique_elements.remove(smallest)\n        second_smallest = min(unique_elements)\n        return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    sorted_elements = sorted(unique_elements)\n    return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    min1 = None\n    min2 = None\n    for x in lst:\n        if min1 is None or x < min1:\n            if x != min1:\n                min2 = min1\n            min1 = x\n        elif x != min1 and (min2 is None or x < min2):\n            min2 = x\n    return min2", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    min1 = None\n    min2 = None\n    seen = set()\n\n    for val in lst:\n        if val in seen:\n            continue  # Skip duplicates\n        seen.add(val)\n\n        if min1 is None or val < min1:\n            min2 = min1\n            min1 = val\n        elif val != min1 and (min2 is None or val < min2):\n            min2 = val\n\n    return min2", "matching_cluster_idx": 1}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    smallest = None\n    second_smallest = None\n\n    for num in lst:\n        if smallest is None or num < smallest:\n            if num != smallest:\n                second_smallest = smallest\n            smallest = num\n        elif num != smallest and (second_smallest is None or num < second_smallest):\n            second_smallest = num\n\n    return second_smallest", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    first_min = second_min = None\n\n    for num in lst:\n        if first_min is None or num < first_min:\n            if num != first_min:\n                second_min = first_min\n            first_min = num\n        elif num != first_min and (second_min is None or num < second_min):\n            second_min = num\n\n    return second_min", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_numbers = set(lst)\n    if len(unique_numbers) < 2:\n        return None\n\n    min1 = None\n    min2 = None\n\n    for number in unique_numbers:\n        if min1 is None or number < min1:\n            min2 = min1\n            min1 = number\n        elif min2 is None or number < min2:\n            min2 = number\n\n    return min2", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    min1 = None\n    min2 = None\n    for x in lst:\n        if min1 is None or x < min1:\n            if min1 is not None and x != min1:\n                min2 = min1\n            min1 = x\n        elif x != min1:\n            if min2 is None or x < min2:\n                min2 = x\n    return min2", "matching_cluster_idx": 2}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.remove(min(unique_elements))\n    return min(unique_elements)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    else:\n        sorted_elements = sorted(unique_elements)\n        return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    min1 = float('inf')\n    min2 = float('inf')\n    for x in lst:\n        if x < min1:\n            min2 = min1\n            min1 = x\n        elif min1 < x < min2:\n            min2 = x\n    if min2 == float('inf'):\n        return None\n    else:\n        return min2", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    min1 = float('inf')  # Initialize the smallest number\n    min2 = float('inf')  # Initialize the second smallest number\n\n    for num in lst:\n        if num < min1:\n            min2 = min1  # Update second smallest\n            min1 = num   # Update smallest\n        elif min1 < num < min2:\n            min2 = num   # Update second smallest\n\n    if min2 == float('inf'):\n        return None\n    else:\n        return min2", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    min1 = min2 = None\n    for x in lst:\n        if min1 is None or x < min1:\n            if x != min1:\n                min2 = min1\n                min1 = x\n        elif x != min1 and (min2 is None or x < min2):\n            min2 = x\n    return min2", "matching_cluster_idx": 2}]}, "HumanEval/113": {"dps": 99.06693711967546, "dps_norm": 68.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        num_odd_digits = sum(1 for c in s if int(c) % 2 == 1)\n        num_str = str(num_odd_digits)\n        message = \"the number of odd elements in the string i of the input.\"\n        replaced_message = message.replace('i', num_str)\n        output.append(replaced_message)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    sentence = \"the number of odd elements in the string i of the input.\"\n    res = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 == 1)\n        number = str(count)\n        s_modified = sentence.replace('i', number)\n        res.append(s_modified)\n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    res = []\n    for number_string in lst:\n        count_odd = sum(1 for c in number_string if int(c) % 2 == 1)\n        template = \"the number of odd elements in the string i of the input.\"\n        s = template.replace('i', str(count_odd))\n        res.append(s)\n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    template = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 == 1)\n        count_str = str(count)\n        output = ''.join(count_str if c == 'i' else c for c in template)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    template = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 == 1)\n        result = template.replace('i', str(count))\n        output.append(result)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        n_odd = sum(1 for c in s if int(c) % 2 == 1)\n        n_str = str(n_odd)\n        # The template sentence\n        sentence = \"the number of odd elements in the string i of the input.\"\n        # Replace all occurrences of 'i' with the number of odd digits\n        sentence_modified = sentence.replace('i', n_str)\n        result.append(sentence_modified)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    sentence = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        count = sum(1 for ch in s if int(ch) % 2 == 1)\n        new_sentence = sentence.replace('i', str(count))\n        result.append(new_sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    base = 'the number of odd elements in the string i of the input.'\n    for s in lst:\n        count_odd = sum(1 for c in s if int(c) % 2 == 1)\n        new_str = ''.join(str(count_odd) if c == 'i' else c for c in base)\n        output.append(new_str)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    base_string = 'the number of odd elements in the string i of the input.'\n    for s in lst:\n        num_odds = sum(1 for c in s if int(c) % 2 == 1)\n        replaced_string = base_string.replace('i', str(num_odds))\n        output.append(replaced_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    sentence = \"the number of odd elements in the string i of the input.\"\n    res = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        replaced_sentence = sentence.replace('i', str(count))\n        res.append(replaced_sentence)\n    return res", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    sentence = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        n = sum(1 for c in s if int(c) % 2 == 1)\n        output_str = sentence.replace('i', str(n))\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    base_sentence = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        n_odd = sum(1 for ch in s if int(ch) % 2 == 1)\n        replaced_sentence = ''.join(str(n_odd) if c == 'i' else c for c in base_sentence)\n        result.append(replaced_sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    template_sentence = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        n = sum(1 for c in s if int(c) % 2 == 1)\n        out_sentence = ''.join(str(n) if c == 'i' else c for c in template_sentence)\n        output.append(out_sentence)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    template = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        n_odd = sum(1 for c in s if c in '13579')\n        result = template.replace('i', str(n_odd))\n        output.append(result)\n    return output", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should be the sentence:\n    \"the number of odd elements in the string i of the input.\"\n    with all instances of 'i' replaced by the number of odd digits in the corresponding input string.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', '11111111'])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    base_string = 'the number of odd elements in the string i of the input.'\n    for s in lst:\n        count = sum(1 for ch in s if int(ch) % 2 == 1)\n        modified_string = base_string.replace('i', str(count))\n        output.append(modified_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    res = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        n_odd = sum(1 for c in s if int(c) % 2 == 1)\n        # Original template string\n        template = 'the number of odd elements in the string i of the input.'\n        # Replace all 'i's in the template with the count of odd digits\n        transformed = ''.join(str(n_odd) if c == 'i' else c for c in template)\n        res.append(transformed)\n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    base = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        # Count the number of odd digits in the current string\n        count = sum(int(ch) % 2 for ch in s)\n        # Replace all 'i's in the base string with the count\n        modified_str = ''.join(str(count) if ch == 'i' else ch for ch in base)\n        result.append(modified_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    default_text = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        count_odd = sum(1 for c in s if int(c) % 2 == 1)\n        replacement = str(count_odd)\n        new_text = ''.join(replacement if c == 'i' else c for c in default_text)\n        output.append(new_text)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', '11111111'])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    template = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for c in s if int(c) % 2 == 1)\n        # Replace every 'i' in the template with the count\n        count_str = str(count)\n        new_sentence = ''.join(count_str if c == 'i' else c for c in template)\n        output.append(new_sentence)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    base_sentence = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        # Count the number of odd digits in the string\n        num_odds = sum(1 for c in s if int(c) % 2 == 1)\n        num_str = str(num_odds)\n        # Replace all 'i's in the base sentence with num_str\n        modified_sentence = ''.join([num_str if ch == 'i' else ch for ch in base_sentence])\n        output.append(modified_sentence)\n    return output", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 45.348837209302324, "dps_norm": 49.0, "pass@1": 98.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def compute_balance_min(s):\n        balance = 0\n        min_balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -= 1\n            else:\n                # Should not occur as per problem statement\n                pass\n            min_balance = min(min_balance, balance)\n        return balance, min_balance\n\n    s1, s2 = lst[0], lst[1]\n    b1, m1 = compute_balance_min(s1)\n    b2, m2 = compute_balance_min(s2)\n    \n    # Check s1 + s2\n    net_balance1 = b1 + b2\n    min_prefix1 = min(m1, b1 + m2)\n    if net_balance1 == 0 and min_prefix1 >= 0:\n        return 'Yes'\n    \n    # Check s2 + s1\n    net_balance2 = b2 + b1\n    min_prefix2 = min(m2, b2 + m1)\n    if net_balance2 == 0 and min_prefix2 >= 0:\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for ch in s:\n            if ch == '(':\n                count += 1\n            elif ch == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n\n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def get_net_and_min_balance(s):\n        balance = 0\n        min_balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -= 1\n            if balance < min_balance:\n                min_balance = balance\n        return balance, min_balance\n\n    # Compute net balance and minimum prefix balance for both strings\n    net_balances = []\n    min_balances = []\n    for s in lst:\n        net_b, min_b = get_net_and_min_balance(s)\n        net_balances.append(net_b)\n        min_balances.append(min_b)\n\n    # Check both concatenation orders\n    for i, j in [(0, 1), (1, 0)]:\n        net_s = net_balances[i] + net_balances[j]\n        min_s = min(min_balances[i], net_balances[i] + min_balances[j])\n        if net_s == 0 and min_s >= 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -=1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def get_total_and_min_cumulative(s):\n        total = 0  # net balance of parentheses\n        min_cumulative = 0  # minimal cumulative sum during scanning\n        cumulative = 0\n        for c in s:\n            if c == '(':\n                cumulative += 1\n            else:\n                cumulative -= 1\n            if cumulative < min_cumulative:\n                min_cumulative = cumulative\n        total = cumulative\n        return total, min_cumulative\n\n    s1, s2 = lst\n    t1, m1 = get_total_and_min_cumulative(s1)\n    t2, m2 = get_total_and_min_cumulative(s2)\n\n    # Check if the total balance is zero\n    if t1 + t2 != 0:\n        return 'No'\n\n    # Check if concatenating s1 + s2 results in a balanced string\n    ms1_s2 = min(m1, t1 + m2)\n    if ms1_s2 >= 0:\n        return 'Yes'\n\n    # Check if concatenating s2 + s1 results in a balanced string\n    ms2_s1 = min(m2, t2 + m1)\n    if ms2_s1 >= 0:\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        counter = 0\n        for char in s:\n            if char == '(':\n                counter += 1\n            elif char == ')':\n                counter -= 1\n                if counter < 0:\n                    return False\n        return counter == 0\n\n    s1, s2 = lst\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    def is_balanced(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    def process(s):\n        balance = 0\n        min_balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -= 1\n            min_balance = min(min_balance, balance)\n        return balance, min_balance\n\n    # Process both strings\n    balance1, min_balance1 = process(s1)\n    balance2, min_balance2 = process(s2)\n\n    # Check s1 + s2\n    total_balance = balance1 + balance2\n    min_prefix_balance = min(min_balance1, balance1 + min_balance2)\n    if total_balance == 0 and min_prefix_balance >= 0:\n        return 'Yes'\n\n    # Check s2 + s1\n    total_balance = balance2 + balance1\n    min_prefix_balance = min(min_balance2, balance2 + min_balance1)\n    if total_balance == 0 and min_prefix_balance >= 0:\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def compute_tot_min_bal(s):\n        tot_bal = 0    # Total balance of the string\n        min_bal = 0    # Minimum cumulative balance\n        cur_bal = 0    # Current cumulative balance\n\n        for c in s:\n            if c == '(':\n                cur_bal += 1\n            elif c == ')':\n                cur_bal -= 1\n            else:\n                # Should not happen as per problem statement\n                pass\n            if cur_bal < min_bal:\n                min_bal = cur_bal\n        tot_bal = cur_bal\n        return tot_bal, min_bal\n\n    s1, s2 = lst[0], lst[1]\n\n    # Compute total balance and minimal cumulative balance for s1 and s2\n    tot_bal1, min_bal1 = compute_tot_min_bal(s1)\n    tot_bal2, min_bal2 = compute_tot_min_bal(s2)\n\n    # Check for s1 + s2\n    total_balance = tot_bal1 + tot_bal2\n    min_cum_balance_s1_s2 = min(min_bal1, tot_bal1 + min_bal2)\n\n    valid_s1_s2 = (total_balance == 0) and (min_cum_balance_s1_s2 >= 0)\n\n    # Check for s2 + s1\n    total_balance = tot_bal2 + tot_bal1\n    min_cum_balance_s2_s1 = min(min_bal2, tot_bal2 + min_bal1)\n\n    valid_s2_s1 = (total_balance == 0) and (min_cum_balance_s2_s1 >= 0)\n\n    if valid_s1_s2 or valid_s2_s1:\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n\n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def preprocess(s):\n        balance = 0\n        min_balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -=1\n            # Update the minimal balance\n            if balance < min_balance:\n                min_balance = balance\n        return (min_balance, balance)\n\n    s1, s2 = lst[0], lst[1]\n    s_data = []\n    for s in [s1, s2]:\n        min_balance, final_balance = preprocess(s)\n        s_data.append({'min_balance': min_balance, 'final_balance': final_balance})\n\n    possible = False\n    # Check s1 + s2\n    min_balance_concat = min(s_data[0]['min_balance'], s_data[0]['final_balance'] + s_data[1]['min_balance'])\n    final_balance_concat = s_data[0]['final_balance'] + s_data[1]['final_balance']\n    if min_balance_concat >= 0 and final_balance_concat == 0:\n        possible = True\n\n    # Check s2 + s1\n    min_balance_concat = min(s_data[1]['min_balance'], s_data[1]['final_balance'] + s_data[0]['min_balance'])\n    final_balance_concat = s_data[1]['final_balance'] + s_data[0]['final_balance']\n    if min_balance_concat >= 0 and final_balance_concat == 0:\n        possible = True\n\n    return 'Yes' if possible else 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def compute_balance(s):\n        balance = 0\n        min_balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -=1\n            else:\n                pass  # Shouldn't happen as per problem description\n            min_balance = min(min_balance, balance)\n        return balance, min_balance  # t_tot and t_min\n\n    s1 = lst[0]\n    s2 = lst[1]\n\n    # Compute total balance and minimal prefix balance for s1 and s2\n    t_tot1, t_min1 = compute_balance(s1)\n    t_tot2, t_min2 = compute_balance(s2)\n\n    # Check s1 + s2\n    t_tot_12 = t_tot1 + t_tot2\n    t_min_12 = min(t_min1, t_tot1 + t_min2)\n    if t_tot_12 == 0 and t_min_12 >= 0:\n        return 'Yes'\n\n    # Check s2 + s1\n    t_tot_21 = t_tot2 + t_tot1\n    t_min_21 = min(t_min2, t_tot2 + t_min1)\n    if t_tot_21 == 0 and t_min_21 >= 0:\n        return 'Yes'\n\n    # If neither ordering results in a good string\n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else: # c == ')'\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    orders = [(0, 1), (1, 0)]\n    for o in orders:\n        s = lst[o[0]] + lst[o[1]]\n        if is_balanced(s):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        count = 0\n        for ch in s:\n            if ch == '(':\n                count += 1\n            else:  # ch == ')'\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:  # c == ')'\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def compute_balances(s):\n        total_balance = 0\n        min_balance = 0\n        current_balance = 0\n        for ch in s:\n            if ch == '(':\n                current_balance += 1\n            elif ch == ')':\n                current_balance -= 1\n            else:\n                # Invalid character, should not happen as per problem statement\n                pass\n            min_balance = min(min_balance, current_balance)\n        total_balance = current_balance\n        return total_balance, min_balance\n\n    s1, s2 = lst\n    # Compute total_balance and min_balance for each string\n    tb1, mb1 = compute_balances(s1)\n    tb2, mb2 = compute_balances(s2)\n    \n    # Check concatenation s1 + s2\n    total_balance_1 = tb1 + tb2\n    min_balance_1 = min(mb1, mb2 + tb1)\n    if min_balance_1 >= 0 and total_balance_1 == 0:\n        return 'Yes'\n    \n    # Check concatenation s2 + s1\n    total_balance_2 = tb2 + tb1\n    min_balance_2 = min(mb2, mb1 + tb2)\n    if min_balance_2 >= 0 and total_balance_2 == 0:\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance +=1\n            elif char == ')':\n                balance -=1\n            # At any point, if balance is negative, parentheses are unbalanced\n            if balance < 0:\n                return False\n        return balance == 0  # Balanced if balance is zero at the end\n\n    from itertools import permutations\n\n    # Generate all possible concatenations of the two strings in different orders\n    for order in permutations(lst):\n        combined = ''.join(order)\n        if is_balanced(combined):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def get_stats(s):\n        balance = 0\n        min_balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:  # c == ')'\n                balance -= 1\n            min_balance = min(min_balance, balance)\n        return min_balance, balance\n\n    s1, s2 = lst[0], lst[1]\n\n    # Get stats for s1 and s2\n    min1, bal1 = get_stats(s1)\n    min2, bal2 = get_stats(s2)\n\n    # Check both possible concatenations\n    # First s1 + s2\n    total_bal = bal1 + bal2\n    min_combined = min(min1, bal1 + min2)\n    if total_bal == 0 and min_combined >= 0:\n        return 'Yes'\n\n    # Now s2 + s1\n    total_bal = bal2 + bal1\n    min_combined = min(min2, bal2 + min1)\n    if total_bal == 0 and min_combined >= 0:\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def compute_balance(s):\n        balance = 0\n        min_balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:  # c == ')'\n                balance -= 1\n            min_balance = min(min_balance, balance)\n        total_balance = balance  # total balance of the string\n        return min_balance, total_balance\n\n    s1, s2 = lst[0], lst[1]\n    # Compute minimal prefix balance and total balance for both strings\n    mpb1, tb1 = compute_balance(s1)\n    mpb2, tb2 = compute_balance(s2)\n\n    # Check s1 + s2\n    tb12 = tb1 + tb2\n    mpb12 = min(mpb1, tb1 + mpb2)\n    if tb12 == 0 and mpb12 >= 0:\n        return 'Yes'\n\n    # Check s2 + s1\n    tb21 = tb2 + tb1\n    mpb21 = min(mpb2, tb2 + mpb1)\n    if tb21 == 0 and mpb21 >= 0:\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    # Try both possible concatenations\n    for order in [lst, lst[::-1]]:\n        s = ''.join(order)\n        if is_balanced(s):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 52.241379310344826, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "def maximum(arr, k):\n    import heapq\n    return sorted(heapq.nlargest(k, arr))", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list\n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    return sorted(heapq.nlargest(k, arr))", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Examples:\n\n    Example 1:\n    Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\n    Example 2:\n    Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\n    Example 3:\n    Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    desc_sorted_arr = sorted(arr, reverse=True)\n    # Take the first k elements\n    max_k_elements = desc_sorted_arr[:k]\n    # Return the sorted list of these elements in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    import heapq\n    return sorted(heapq.nlargest(k, arr))", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    import heapq\n    k_largest = heapq.nlargest(k, arr)\n    return sorted(k_largest)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Handle the case when k is 0\n    if k == 0:\n        return []\n    # Sort the array in descending order\n    arr_sorted_desc = sorted(arr, reverse=True)\n    # Take the first k elements (the largest k numbers)\n    k_largest = arr_sorted_desc[:k]\n    # Return the sorted list of the k largest numbers in ascending order\n    return sorted(k_largest)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order to get largest elements first\n    arr_desc = sorted(arr, reverse=True)\n    # Select the first k elements\n    k_max_elements = arr_desc[:k]\n    # Sort the selected elements in ascending order as required\n    return sorted(k_max_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    else:\n        sorted_arr = sorted(arr)\n        max_k_numbers = sorted_arr[-k:]\n        return sorted(max_k_numbers)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    import heapq\n    return sorted(heapq.nlargest(k, arr))", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    import heapq\n    return sorted(heapq.nlargest(k, arr))", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    largest_k = heapq.nlargest(k, arr)\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    import heapq\n    if k == 0:\n        return []\n    k_largest = heapq.nlargest(k, arr)\n    return sorted(k_largest)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    import heapq\n    max_k_elements = heapq.nlargest(k, arr)\n    return sorted(max_k_elements)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return [] if k == 0 else sorted(arr)[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    import heapq\n    return sorted(heapq.nlargest(k, arr))", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    counts = [0] * 2001  # For numbers from -1000 to 1000\n    for num in arr:\n        counts[num + 1000] += 1  # Shift index to handle negative numbers\n    result = []\n    for index in range(2000, -1, -1):  # Traverse from highest to lowest\n        while counts[index] > 0 and len(result) < k:\n            result.append(index - 1000)  # Shift back to original number\n            counts[index] -= 1\n    result.sort()  # Sort the k maximum numbers in ascending order\n    return result", "matching_cluster_idx": 1}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    elif k >= len(arr):\n        return sorted(arr)\n    else:\n        import heapq\n        heap = arr[:k]\n        heapq.heapify(heap)\n        for num in arr[k:]:\n            if num > heap[0]:\n                heapq.heappushpop(heap, num)\n        return sorted(heap)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    arr_sorted = sorted(arr)\n    return arr_sorted[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    import heapq\n    # Get the k largest elements\n    max_k = heapq.nlargest(k, arr)\n    # Return the sorted list of these elements\n    return sorted(max_k)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if not (0 <= k <= len(arr)):\n        raise ValueError('k must be in the range 0 to len(arr)')\n    return sorted(heapq.nlargest(k, arr))", "matching_cluster_idx": 3}]}, "HumanEval/121": {"dps": 86.72645739910314, "dps_norm": 65.71428571428572, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 == 1)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for x in lst[::2] if x % 2 == 1)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 == 1)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 == 1)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for idx, x in enumerate(lst) if idx % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[idx] for idx in range(0, len(lst), 2) if lst[idx] % 2 == 1)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for idx, x in enumerate(lst) if idx % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 46.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resultant list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may not assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    sorted_strings = sorted(even_length_strings, key=lambda s: (len(s), s))\n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulting list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length ascending, then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list: first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by ascending length and alphabetically for same length\n    sorted_list = sorted(even_length_strings, key=lambda s: (len(s), s))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulting list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may NOT assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and alphabetically for same length\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    lst_even = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and then alphabetically\n    lst_sorted = sorted(lst_even, key=lambda s: (len(s), s))\n    return lst_sorted", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n\n    If two words have the same length, sort the list alphabetically.\n\n    The function should return a list of strings in sorted order.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort by length, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and alphabetically for same lengths\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort by length ascending, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda s: (len(s), s))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resultant list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word,\n    and you should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort by length (ascending), then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word,\n    and you should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and then alphabetically\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(even_length_words, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by the length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word,\n    and you should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length ascending and alphabetically for words with the same length\n    sorted_list = sorted(even_length_strings, key=lambda s: (len(s), s))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings, removes the ones with odd lengths,\n    and returns the sorted list based on length and alphabetically.\n\n    The list is sorted first by the length of each word in ascending order.\n    If two words have the same length, they are sorted alphabetically.\n\n    Args:\n        lst (list of str): A list of strings.\n\n    Returns:\n        list of str: The sorted list with strings of even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and then alphabetically\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_strings", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 89.11016949152543, "dps_norm": 95.625, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # Numbers less than or equal to 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3 are not prime (except 2 and 3)\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return True  # Divisible by i, not a prime number\n        i += w\n        w = 6 - w  # Toggle between adding 2 and 4 (checks 6k \u00b1 1)\n    return False  # No divisors found, n is prime", "matching_cluster_idx": 6}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # Numbers less than 2 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False  # Number is prime if no divisors found", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # Numbers less than or equal to 1 are not prime\n    if n == 2:\n        return False  # 2 is prime\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True  # Divisible by a number other than 1 and itself\n    return False  # Number is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number n is not a prime number.\n    Returns True if n is not prime, False if n is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # Numbers less than or equal to 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3 means n is not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True  # Divisible by i or i + 2 means n is not prime\n        i += 6\n    return False  # No divisors found, n is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False  # n is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # All other even numbers are not prime\n\n    sqrt_n = int(n**0.5) + 1  # Only need to check up to the square root of n\n    for i in range(3, sqrt_n, 2):  # Check only odd divisors\n        if n % i == 0:\n            return True  # n is divisible by i, so it's not prime\n    return False  # No divisors found, n is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number n is not a prime number.\n    Returns True if n is not prime, False if n is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # Numbers less than 2 are not prime\n    if n == 2:\n        return False  # 2 is prime\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True  # Divisible by a number other than 1 and itself\n    return False  # No divisors found, n is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Return True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if n is not a prime number, False if n is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # Numbers less than or equal to 1 are not prime\n    if n == 2:\n        return False  # 2 is prime\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):  # Test only odd divisors\n        if n % i == 0:\n            return True  # n is divisible by i, so n is not prime\n    return False  # No divisors found, n is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not a prime number, False if it is prime.\"\"\"\n    if n <= 1:\n        return True  # Numbers less than or equal to 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3 means not prime\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return True  # Divisible by i means not prime\n        i += w\n        w = 6 - w  # Alternate between adding 2 and 4\n    return False  # Number is prime", "matching_cluster_idx": 6}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # Numbers less than or equal to 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Divisible by 2 or 3 means n is not prime\n\n    # Check for factors up to the square root of n\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return True  # Found a factor, n is not prime\n        i += w\n        w = 6 - w  # Alternate between steps of 2 and 4\n    return False  # No factors found, n is prime", "matching_cluster_idx": 6}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # Numbers less than 2 are not prime\n    if n == 2:\n        return False  # 2 is prime\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return True  # Divisible by a number other than 1 and itself\n        i += 2\n    return False  # No divisors found, number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True   # Multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True  # Divisible by i or i+2\n        i += 6\n    return False  # Number is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if n is not a prime number, False if n is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True  # n is divisible by i or i + 2\n        i += 6\n    return False  # n is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # Numbers less than or equal to 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True  # Divisible by i or i + 2 means not prime\n        i += 6\n    return False  # Number is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if n is not a prime number, False if n is prime.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return True\n        i += w\n        w = 6 - w\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # Numbers less than 2 are not prime\n    if n == 2:\n        return False  # 2 is prime\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime number", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def heap_queue_largest(lst, n):\n    import heapq\n    if n >= len(lst):\n        return sorted(lst, reverse=True)\n    min_heap = lst[:n]\n    heapq.heapify(min_heap)\n    for num in lst[n:]:\n        if num > min_heap[0]:\n            heapq.heapreplace(min_heap, num)\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(lst, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    import heapq\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(lst, n):\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(lst, n):\n    import heapq\n    return sorted(heapq.nlargest(n, lst), reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    return sorted(heapq.nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(lst, n):\n    import heapq\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    if n <= 0:\n        return []\n    min_heap = []\n    for num in nums:\n        if len(min_heap) < n:\n            heapq.heappush(min_heap, num)\n        else:\n            if num > min_heap[0]:\n                heapq.heapreplace(min_heap, num)\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 92.94665234514858, "dps_norm": 67.89473684210526, "pass@1": 38.0, "profiled": [{"solution": "def find_Rotations(s):\n    \"\"\"\n    Returns the minimum number of rotations (greater than 0) required to get the same string.\n\n    :param s: The input string to be analyzed.\n    :return: The minimal number of rotations required to return to the original string.\n    \"\"\"\n    def compute_lps(s):\n        \"\"\"\n        Computes the Longest Proper Prefix which is also Suffix (LPS) array used in KMP algorithm.\n\n        :param s: The input string.\n        :return: The LPS array.\n        \"\"\"\n        n = len(s)\n        lps = [0] * n  # LPS array to hold the longest prefix suffix values for substring\n        length = 0     # length of the previous longest prefix suffix\n        i = 1\n\n        while i < n:\n            if s[i] == s[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]  # Also, note that we do not increment i here\n                else:\n                    lps[i] = 0\n                    i += 1\n        return lps\n\n    n = len(s)\n    lps = compute_lps(s)\n    p = n - lps[-1]\n    # Check if the string can be constructed by repeating a substring of length p\n    if p != n and n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The minimal number of rotations required to get the same string.\n    \"\"\"\n    n = len(s)\n    pi = [0] * n  # Prefix function array for KMP algorithm\n\n    # Build the prefix function\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j > 0 and s[i] != s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n\n    # The minimal period of the string\n    p = n - pi[-1]\n\n    # If the string can be constructed by repeating its minimal period\n    if n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j > 0 and s[i] != s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n    period = n - pi[-1]\n    if n % period == 0:\n        return period\n    else:\n        return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    lps = [0]*n\n    # Build the longest prefix suffix (lps) array\n    for i in range(1, n):\n        length = lps[i-1]\n        while length > 0 and s[i] != s[length]:\n            length = lps[length -1]\n        if s[i] == s[length]:\n            length += 1\n        lps[i] = length\n    p = n - lps[-1]\n    # If s is made up of repeating substring of length p\n    if n % p == 0 and s == s[:p]*(n//p):\n        return p\n    else:\n        return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    l = len(s)\n    ss = s + s\n    idx = ss.find(s, 1)  # Start searching from index 1 to avoid the original string at index 0\n    if idx == -1 or idx >= l:\n        return l\n    else:\n        return idx", "matching_cluster_idx": 7}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest proper prefix which is also suffix\n\n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # Length of the previous longest prefix suffix\n    i = 1\n\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n                # Do not increment 'i' here\n            else:\n                lps[i] = 0\n                i += 1\n\n    # Find the minimal period\n    p = n - lps[-1]\n\n    # Check if the string can be constructed by repeating the substring of length 'p'\n    if n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix array\n\n    # Preprocess the pattern (calculate lps[] array)\n    length = 0  # length of the previous longest prefix suffix\n    i = 1\n\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n                # We do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n\n    # The minimal period is n - lps[-1]\n    p = n - lps[-1]\n\n    # If the string can be constructed by repeating its period\n    if p != n and n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    idx = (s + s).find(s, 1, -1)\n    return len(s) if idx == -1 else idx", "matching_cluster_idx": 8}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get back the original string `s`.\n    \"\"\"\n    n = len(s)\n    # Create a new string by concatenating s to itself\n    ss = s + s\n    # Find the first occurrence of s in ss starting from position 1\n    idx = ss.find(s, 1, -1)\n    if idx == -1:\n        return n\n    else:\n        return idx", "matching_cluster_idx": 8}, {"solution": "def compute_lps(s):\n    n = len(s)\n    lps = [0] * n  # lps[0] is always 0\n    length = 0  # length of the previous longest prefix suffix\n    i = 1\n\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                # Also, note that we do not increment i here\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\ndef find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (>0) required\n    to get the same string.\n    \"\"\"\n    n = len(s)\n    lps = compute_lps(s)\n    period = n - lps[-1]\n    # If period divides the length of s, return period\n    # else, return n (full rotation needed)\n    if n % period == 0:\n        return period\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n    assert find_Rotations(\"aaaa\") == 1\n    \"\"\"\n    n = len(s)\n    for p in range(1, n):\n        rotated = s[p:] + s[:p]\n        if rotated == s:\n            return p\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(s)\n    # Build the longest proper prefix which is also a suffix array (lps)\n    lps = [0]*n\n    length = 0  # length of the previous longest prefix suffix\n\n    # lps[0] is always 0, so we start from i = 1\n    i = 1\n    while i < n:\n        if s[i] == s[length]:\n            length +=1\n            lps[i] = length\n            i +=1\n        else:\n            if length != 0:\n                length = lps[length -1]\n                # Note: we do not increment i here\n            else:\n                lps[i] = 0\n                i +=1\n\n    # The length of the smallest repeating substring\n    p = n - lps[-1]\n\n    # If n is a multiple of (n - lps[n-1]), then p is the minimal rotation\n    if n % p == 0:\n        return p\n    else:\n        return n  # The string doesn't repeat, so the minimal rotation is the full length", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Returns the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest prefix suffix array\n    length = 0  # length of the previous longest prefix suffix\n\n    # Build the lps array\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    # The minimal period\n    p = n - lps[-1]\n    if n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(s)\n    pi = [0] * n  # Prefix function array\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j > 0 and s[i] != s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n    p = n - pi[-1]  # Minimal period\n    if n % p == 0:\n        return p\n    else:\n        return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    pi = [0] * n  # prefix function array\n\n    for i in range(1, n):\n        k = pi[i - 1]\n        while k > 0 and s[k] != s[i]:\n            k = pi[k - 1]\n        if s[k] == s[i]:\n            k += 1\n        pi[i] = k\n\n    # The minimal period is the length of the string minus the last value of the prefix function\n    p = n - pi[-1]\n    if n % p == 0 and s == s[:p] * (n // p):\n        return p\n    else:\n        return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string `s`.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix array\n    length = 0  # Length of the previous longest prefix suffix\n\n    # Build the LPS array\n    i = 1\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n                # No increment of i here\n            else:\n                lps[i] = 0\n                i += 1\n\n    # Calculate the minimal period\n    p = n - lps[-1]\n    if p == n:\n        return n  # The string does not repeat a smaller substring\n    if n % p == 0 and s == s[:p] * (n // p):\n        return p  # The string is constructed by repeating its minimal period substring\n    else:\n        return n  # The entire string is the minimal rotation period", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n  # Longest Prefix Suffix array\n    length = 0     # Length of the previous longest prefix suffix\n\n    # Build the LPS array\n    i = 1\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    # Calculate the minimum number of rotations\n    period = n - lps[-1]\n    if period != n and n % period == 0:\n        return period\n    else:\n        return n", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(s)\n    lps = compute_lps(s)\n    lps_last = lps[-1]\n    period = n - lps_last\n    if period != 0 and n % period == 0:\n        return period\n    else:\n        return n\ndef compute_lps(s):\n    \"\"\"\n    Computes the Longest Prefix Suffix (LPS) array used in KMP algorithm.\n    \"\"\"\n    n = len(s)\n    lps = [0] * n\n    length = 0  # length of the previous longest prefix suffix\n\n    for i in range(1, n):\n        while length > 0 and s[i] != s[length]:\n            length = lps[length - 1]\n\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n        else:\n            lps[i] = 0\n\n    return lps", "matching_cluster_idx": 6}]}, "Mbpp/11": {"dps": 41.577060931899645, "dps_norm": 63.888888888888886, "pass@1": 96.0, "profiled": [{"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    if first == -1:\n        # Character c not found in the string\n        return s\n    last = s.rfind(c)\n    if first == last:\n        # Character c occurs only once\n        return s[:first] + s[first+1:]\n    else:\n        # Remove the character at the first occurrence\n        s_new = s[:first] + s[first+1:]\n        # Adjust the last index since the string is now shorter by one character\n        last_adjusted = last - 1 if last > first else last\n        # Remove the character at the adjusted last occurrence\n        s_new = s_new[:last_adjusted] + s_new[last_adjusted+1:]\n        return s_new", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    last = s.rfind(c)\n    if first == -1:\n        # Character not found, return original string\n        return s\n    l = list(s)\n    if first == last:\n        # Only one occurrence, remove it\n        l.pop(first)\n    else:\n        # Remove last occurrence first to avoid index shift\n        l.pop(last)\n        l.pop(first)\n    return ''.join(l)", "matching_cluster_idx": 1}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Remove the first and last occurrence of character c from string s.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to remove.\n\n    Returns:\n    str: The string after removing the first and last occurrence of c.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n    if first == -1:\n        # Character c not found in string s\n        return s\n    elif first == last:\n        # Character c occurs only once\n        return s[:first] + s[first+1:]\n    else:\n        # Remove first and last occurrence of c\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of ch from the string s.\n    \"\"\"\n    first_idx = s.find(ch)\n    if first_idx == -1:\n        return s  # character not found\n    last_idx = s.rfind(ch)\n    indices_to_remove = {first_idx, last_idx}\n    return ''.join(c for idx, c in enumerate(s) if idx not in indices_to_remove)", "matching_cluster_idx": 0}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Remove the first and last occurrence of character c from string s.\n    \"\"\"\n    first = s.find(c)\n    if first == -1:\n        # Character not found in the string\n        return s\n    last = s.rfind(c)\n    if first == last:\n        # Character occurs only once; remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Remove the first and last occurrence\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The original string.\n    ch (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of ch removed.\n    \"\"\"\n    try:\n        first = s.index(ch)\n    except ValueError:\n        # Character not found; return the original string\n        return s\n\n    last = s.rindex(ch)\n    # Collect indices to remove (first and last occurrences)\n    idx_to_remove = sorted(set([first, last]), reverse=True)\n    s_list = list(s)\n    # Remove characters at collected indices\n    for idx in idx_to_remove:\n        s_list.pop(idx)\n    return ''.join(s_list)", "matching_cluster_idx": 1}, {"solution": "def remove_Occ(s, c):\n    first_pos = s.find(c)\n    last_pos = s.rfind(c)\n\n    # If the character is not found, return the original string\n    if first_pos == -1:\n        return s\n\n    # Convert the string to a list for easy modification\n    s_list = list(s)\n\n    # Remove the last occurrence first to avoid index shift\n    if first_pos != last_pos:\n        s_list.pop(last_pos)\n    s_list.pop(first_pos)\n\n    # Join the list back into a string and return\n    return ''.join(s_list)", "matching_cluster_idx": 1}, {"solution": "def remove_Occ(s, ch):\n    first = s.find(ch)\n    last = s.rfind(ch)\n    if first == -1:\n        # Character not found, return the string as is\n        return s\n    elif first == last:\n        # Character occurs only once, remove that occurrence\n        return s[:first] + s[first+1:]\n    else:\n        # Remove first occurrence\n        s = s[:first] + s[first+1:]\n        # Adjust the last occurrence index after removal\n        last -= 1\n        # Remove last occurrence\n        s = s[:last] + s[last+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    if first == -1:\n        return s\n    last = s.rfind(c)\n    if first == last:\n        # c occurs only once\n        return s[:first] + s[first+1:]\n    else:\n        # c occurs more than once\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    If the character occurs only once, remove it.\n    If the character does not occur, return the original string.\n    \"\"\"\n    try:\n        first_index = s.index(char)\n    except ValueError:\n        # Character not found in the string\n        return s\n    last_index = s.rindex(char)\n    # Convert string to list for mutable operations\n    result = list(s)\n    # Remove last occurrence first to not affect the index of the first occurrence\n    result.pop(last_index)\n    if first_index != last_index:\n        # Remove first occurrence\n        result.pop(first_index)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def remove_Occ(s, ch):\n    \"\"\"\n    Write a python function to remove first and last occurrence of a given character from the string.\n    assert remove_Occ(\"hello\", \"l\") == \"heo\"\n    \"\"\"\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n\n    if first_index == -1:\n        # Character not found; return the original string\n        return s\n\n    # Create a set of indices to remove\n    indices_to_remove = {first_index, last_index}\n\n    # Build a new string excluding the characters at the specified indices\n    result = ''.join(c for i, c in enumerate(s) if i not in indices_to_remove)\n\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_Occ(s, ch):\n    idx_first = s.find(ch)\n    if idx_first == -1:\n        return s\n    idx_last = s.rfind(ch)\n    if idx_first == idx_last:\n        # ch occurs only once\n        return s[:idx_first] + s[idx_first+1:]\n    else:\n        # Remove both first and last occurrence\n        return s[:idx_first] + s[idx_first+1:idx_last] + s[idx_last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first_index = s.find(ch)\n    if first_index == -1:\n        return s  # Character not found, return original string\n    last_index = s.rfind(ch)\n    if first_index == last_index:\n        # Only one occurrence, remove it\n        return s[:first_index] + s[first_index+1:]\n    else:\n        # Remove character at last_index first\n        s = s[:last_index] + s[last_index+1:]\n        # Then remove character at first_index\n        s = s[:first_index] + s[first_index+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    f = s.find(c)\n    if f == -1:\n        return s\n    l = s.rfind(c)\n    indices_to_remove = {f, l}\n    return ''.join([s[i] for i in range(len(s)) if i not in indices_to_remove])", "matching_cluster_idx": 0}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Write a python function to remove first and last occurrence of a given character from the string.\n    \"\"\"\n    first_index = s.find(c)\n    if first_index == -1:\n        # Character not found in the string; return the original string\n        return s\n    last_index = s.rfind(c)\n    if first_index == last_index:\n        # Character occurs only once; remove it\n        s = s[:first_index] + s[first_index+1:]\n    else:\n        # Remove character at last_index first to avoid index shifting\n        s = s[:last_index] + s[last_index+1:]\n        # Remove character at first_index\n        s = s[:first_index] + s[first_index+1:]\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The string after removing the first and last occurrence of the character.\n    \"\"\"\n    first_idx = s.find(char)\n    if first_idx == -1:\n        # Character not found; return the original string\n        return s\n    last_idx = s.rfind(char)\n    if first_idx == last_idx:\n        # Character occurs only once; remove it once\n        return s[:first_idx] + s[first_idx+1:]\n    else:\n        # Remove both first and last occurrences\n        return s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    if first == -1:\n        # Character not found, return the original string\n        return s\n    last = s.rfind(c)\n    # Remove the first and last occurrence of the character\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    last = s.rfind(c)\n    if first == -1:\n        # c not found in s, return s as is\n        return s\n    elif first == last:\n        # c occurs only once, remove it\n        return s[:first] + s[first+1:]\n    else:\n        # Remove the first occurrence\n        s = s[:first] + s[first+1:]\n        # Adjust the last index since the string is now shorter\n        last = last - 1\n        # Remove the last occurrence\n        s = s[:last] + s[last+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    first = s.find(c)\n    if first == -1:\n        return s  # Character not found\n    last = s.rfind(c)\n    positions_to_remove = {first, last}\n    # Build a new string excluding the first and last occurrence of c\n    result = ''.join([s[i] for i in range(len(s)) if i not in positions_to_remove])\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_Occ(s, ch):\n    try:\n        first = s.index(ch)\n    except ValueError:\n        # Character not found; return the original string\n        return s\n    last = s.rindex(ch)\n    if first == last:\n        # Remove the single occurrence of the character\n        return s[:first] + s[first+1:]\n    else:\n        # Remove first and last occurrences\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Write a function to sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(mat, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    return sorted(mat, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 26.0, "profiled": [{"solution": "def text_lowercase_underscore(s):\n    import re\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with underscores, and False otherwise.\n    \"\"\"\n    pattern = r'^([a-z]+_)*[a-z]+$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    import re\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    import re\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore,\n    and False otherwise.\n    \"\"\"\n    import re\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Write a function that returns True if the input string contains sequences of lowercase letters\n    joined with underscores and False otherwise.\n    Example:\n    assert text_lowercase_underscore(\"aab_cbbbc\") == True\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with underscores, and False otherwise.\n    \n    Parameters:\n    input_string (str): The string to evaluate.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.match(pattern, input_string))", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 75.25252525252526, "dps_norm": 86.0, "pass@1": 98.0, "profiled": [{"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Returns True if there are duplicates in the list 'arr', False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to determine if the array of integers contains any duplicates.\n    Returns True if any duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    assert test_duplicate([1,2,3,4,5])==False\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Returns True if there are duplicates in the array, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Returns True if the list 'nums' contains any duplicate elements, False otherwise.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks whether the given array contains any duplicates.\n\n    Parameters:\n    arr (list of int): The list of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The array of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True  # Duplicate found\n        seen.add(num)\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Returns True if the array contains any duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 88.38461538461539, "dps_norm": 93.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    :param lst: List of numbers\n    :return: The smallest number in the list\n    \"\"\"\n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"Find the smallest number in a list.\"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    smallest = lst[0]\n    for num in lst[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numeric values.\n\n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function returns the smallest number in a list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    smallest = lst[0]\n    for num in lst[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List is empty\")\n\n    smallest = lst[0]\n    for num in lst[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    min_value = lst[0]\n    for num in lst[1:]:\n        if num < min_value:\n            min_value = num\n    return min_value", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [tpl for tpl in tuples_list if all(x % k == 0 for x in tpl)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [tup for tup in tuples_list if all(x % k == 0 for x in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Args:\n        tuple_list (list of tuples): The list of tuples to be checked.\n        k (int): The divisor.\n\n    Returns:\n        list of tuples: Tuples with all elements divisible by k.\n    \"\"\"\n    return [tup for tup in tuple_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list of tuples): The list of tuples to filter.\n    k (int): The divisor to check divisibility.\n\n    Returns:\n    list of tuples: A list containing tuples from tuple_list where all elements are divisible by k.\n    \"\"\"\n    # Using list comprehension to collect tuples satisfying the condition\n    return [tup for tup in tuple_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [tup for tup in lst if all(num % k == 0 for num in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Finds and returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    lst (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples from lst where every element is divisible by k.\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    return [tup for tup in lst if all(x % k == 0 for x in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    return [t for t in list_of_tuples if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k from the given list of tuples.\n\n    Parameters:\n    list_of_tuples (list of tuples): The list containing tuples of integers.\n    k (int): The divisor to check divisibility.\n\n    Returns:\n    list of tuples: A list containing tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in list_of_tuples if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst_of_tuples, k):\n    return [t for t in lst_of_tuples if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 68.75, "dps_norm": 82.85714285714286, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    from collections import Counter\n    return dict(Counter(lst))", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    from collections import Counter\n    return dict(Counter(lst))", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    from collections import Counter\n    return dict(Counter(lst))", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency count of each element in the input list.\n\n    :param lst: List of elements to count frequencies\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        freq_dict[item] = freq_dict.get(item, 0) + 1\n    return freq_dict", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    from collections import Counter\n    return dict(Counter(lst))", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        freq_dict[item] = freq_dict.get(item, 0) + 1\n    return freq_dict", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    # Use Counter to count frequencies efficiently\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    from collections import Counter\n    return dict(Counter(lst))", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        freq_dict[item] = freq_dict.get(item, 0) + 1\n    return freq_dict", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    from collections import Counter\n    return dict(Counter(lst))", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency count of each element in the list.\n    \"\"\"\n    from collections import Counter\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 4}]}, "Mbpp/90": {"dps": 79.51219512195122, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"Returns the length of the longest word in the list.\"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list 'words'.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the list.\n\n    Args:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list 'words'.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list of words.\n    If the list is empty, returns 0.\n    \"\"\"\n    return max((len(word) for word in words), default=0)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    :param word_list: List of words (strings).\n    :return: Length of the longest word.\n    \"\"\"\n    return max((len(word) for word in word_list), default=0)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Returns the length of the longest word in the list 'words'.\"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list of words.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Parameters:\n    words (list of str): A list containing words as strings.\n\n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list of words.\n    If the list is empty, returns 0.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Parameters:\n    words (list of str): List containing words to evaluate.\n\n    Returns:\n    int: Length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    \"\"\"\n    Returns the length of the longest word in the list.\n    \n    Parameters:\n    word_list (list of str): A list of words.\n    \n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Find the length of the longest word in a list of words.\"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Given a list of words, return the length of the longest word.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)\nwords = [\"python\", \"PHP\", \"bigdata\"]", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.04878048780488, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n\n    Parameters:\n    lst (list): A list of tuples where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Parameters:\n    lst (list): A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n    The first value of the tuple with the smallest second value.\n\n    Example:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    if not lst:\n        return None  # Return None if the list is empty\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n\n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(input_list):\n    min_tuple = min(input_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 94.16666666666666, "dps_norm": 95.0, "pass@1": 98.0, "profiled": [{"solution": "def divisor(n):\n    if n == 1:\n        return 1  # 1 has only one divisor\n    factors = {}\n    i = 2\n    while i * i <= n:\n        count = 0\n        while n % i == 0:\n            n //= i\n            count += 1\n        if count > 0:\n            factors[i] = count\n        i += 1\n    if n > 1:\n        factors[n] = 1  # n is a prime number greater than sqrt(original n)\n    num_divisors = 1\n    for exponent in factors.values():\n        num_divisors *= (exponent + 1)\n    return num_divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square root counts only once\n            else:\n                count += 2  # Count both divisors\n        i += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of the given integer n.\n    \"\"\"\n    from math import isqrt\n\n    if n == 0:\n        return 0  # Zero has infinitely many divisors in theory\n    n = abs(n)\n    divisors = 1\n    count = 0\n\n    # Count the number of times 2 divides n\n    while n % 2 == 0:\n        n //= 2\n        count += 1\n    divisors *= (count + 1)\n\n    # Check for odd divisors\n    p = 3\n    while p <= isqrt(n) + 1:\n        count = 0\n        while n % p == 0:\n            n //= p\n            count += 1\n        if count > 0:\n            divisors *= (count + 1)\n        p += 2\n\n    # If n is a prime number greater than 2\n    if n > 1:\n        divisors *= 2\n\n    return divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the integer n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    if n == 1:\n        return 1\n\n    num_divisors = 1\n    remaining = n\n    i = 2\n\n    while i * i <= remaining:\n        exponent = 0\n        while remaining % i == 0:\n            exponent += 1\n            remaining //= i\n        num_divisors *= (exponent + 1)\n        i += 1\n\n    if remaining > 1:\n        # Remaining number is a prime\n        num_divisors *= 2\n\n    return num_divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the integer n.\n    \"\"\"\n    if n == 0:\n        return float('inf')  # Zero has infinitely many divisors\n    n = abs(n)\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1  # Perfect square\n            else:\n                count += 2  # Pair of divisors\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    from math import isqrt\n    num_divisors = 1\n    # Handle the factor 2 separately\n    count = 0\n    while n % 2 == 0:\n        count += 1\n        n //= 2\n    num_divisors *= (count + 1)\n    # Check for all odd potential factors\n    p = 3\n    while p <= isqrt(n):\n        if n % p == 0:\n            count = 0\n            while n % p == 0:\n                count += 1\n                n //= p\n            num_divisors *= (count + 1)\n        p += 2\n    # If n is a prime number greater than 2\n    if n > 1:\n        num_divisors *= 2\n    return num_divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of positive divisors of the integer n.\n    \"\"\"\n    if n == 0:\n        return 0  # Zero has infinitely many divisors; returning 0 for practical purposes.\n    n = abs(n)  # Ensure n is non-negative\n    count = 0\n    sqrt_n = int(n ** 0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1  # Perfect square root counted once\n            else:\n                count += 2  # Pair of divisors found\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once (perfect square)\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive integer divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n\n    i = 2\n    factors = {}\n    temp_n = n  # Keep the original value of n for debugging if needed.\n\n    # Factorization using trial division up to sqrt(n)\n    while i * i <= n:\n        count = 0\n        while n % i == 0:\n            n //= i\n            count += 1\n        if count > 0:\n            factors[i] = count\n        i += 1\n\n    # If n is a prime number greater than 1\n    if n > 1:\n        factors[n] = 1\n\n    # Compute the number of divisors\n    num_divisors = 1\n    for exponent in factors.values():\n        num_divisors *= (exponent + 1)\n\n    return num_divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    n = abs(n)\n    if n == 0:\n        return 0  # Zero has infinitely many divisors.\n    if n == 1:\n        return 1\n    divisor_count = 1\n    i = 2\n    while i * i <= n:\n        count = 0\n        while n % i == 0:\n            n //= i\n            count += 1\n        if count > 0:\n            divisor_count *= (count + 1)\n        i += 1\n    if n > 1:\n        divisor_count *= 2\n    return divisor_count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \"\"\"\n    n = abs(n)\n    if n == 0:\n        return 0  # Alternatively, raise an exception if 0 is not acceptable\n    exponents = []\n    i = 2\n    while i * i <= n:\n        exp = 0\n        while n % i == 0:\n            n //= i\n            exp += 1\n        if exp > 0:\n            exponents.append(exp)\n        i += 1\n    if n > 1:\n        exponents.append(1)\n    total_divisors = 1\n    for exp in exponents:\n        total_divisors *= (exp + 1)\n    return total_divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive integer divisors of n.\n    \"\"\"\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i == n // i:\n                count += 1  # i is the square root of n, count only once\n            else:\n                count += 2  # Count both i and n // i as divisors\n        i += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    i = 2\n    count = {}\n    while i * i <= n:\n        exp = 0\n        while n % i == 0:\n            n //= i\n            exp += 1\n        if exp > 0:\n            count[i] = exp\n        i += 1\n    if n > 1:\n        count[n] = 1\n    num_divisors = 1\n    for exp in count.values():\n        num_divisors *= (exp + 1)\n    return num_divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of a given integer n.\n    \"\"\"\n    from math import isqrt\n    if n == 0:\n        return 0  # Zero has infinitely many divisors; return 0 for practical purposes\n    n = abs(n)  # Consider absolute value for negative integers\n    num_divisors = 1\n    i = 2\n    while i <= isqrt(n):\n        exponent = 0\n        while n % i == 0:\n            n //= i\n            exponent += 1\n        num_divisors *= (exponent + 1)\n        i += 1\n    if n > 1:\n        num_divisors *= 2  # n is a prime number greater than sqrt of original n\n    return num_divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of n.\n    \"\"\"\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            # If divisors are equal, count only once (perfect square)\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n        i += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    count = 1\n    i = 2\n    num = n\n    while i * i <= num:\n        exponent = 0\n        while num % i == 0:\n            num //= i\n            exponent += 1\n        count *= exponent + 1\n        i += 1\n    if num > 1:\n        count *= 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    sqrt_n = int(n ** 0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    num_divisors = 1\n    i = 2\n    while i * i <= n:\n        exponent = 0\n        while n % i == 0:\n            n = n // i\n            exponent += 1\n        num_divisors *= (exponent + 1)\n        i += 1\n    if n > 1:\n        num_divisors *= 2\n    return num_divisors", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    import math\n    if n == 0:\n        return float('inf')  # Zero has infinitely many divisors\n    n = abs(n)  # Consider absolute value for negative integers\n    count = 0\n    sqrt_n = int(math.isqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square root counts only once\n            else:\n                count += 2  # Pair of divisors: i and n // i\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive integer divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    def prime_factors(n):\n        factors = {}\n        # Remove factors of 2\n        count = 0\n        while n % 2 == 0:\n            count += 1\n            n //= 2\n        if count > 0:\n            factors[2] = count\n\n        # Check odd numbers up to sqrt(n)\n        i = 3\n        while i * i <= n:\n            if n % i == 0:\n                count = 0\n                while n % i == 0:\n                    count += 1\n                    n //= i\n                factors[i] = count\n            i += 2\n\n        # If n is a prime number greater than 2\n        if n > 1:\n            factors[n] = 1\n\n        return factors\n\n    factors = prime_factors(n)\n    num_divisors = 1\n    for exponent in factors.values():\n        num_divisors *= (exponent + 1)\n    return num_divisors", "matching_cluster_idx": 6}]}, "Mbpp/97": {"dps": 99.7094017094017, "dps_norm": 89.375, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(lists):\n    frequencies = {}\n    for sublist in lists:\n        for item in sublist:\n            frequencies[item] = frequencies.get(item, 0) + 1\n    return frequencies", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    from collections import defaultdict\n    freq_dict = defaultdict(int)\n    # Iterate through each sublist and count frequencies\n    for sublist in list_of_lists:\n        for item in sublist:\n            freq_dict[item] += 1\n    return dict(freq_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    from collections import Counter\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    freq_counter = Counter(flat_list)\n    return dict(freq_counter)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    from collections import Counter\n    flattened_list = [item for sublist in lists for item in sublist]\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    freq_dict = {}\n    for sublist in lists:\n        for item in sublist:\n            freq_dict[item] = freq_dict.get(item, 0) + 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequencies = {}\n    for lst in list_of_lists:\n        for item in lst:\n            frequencies[item] = frequencies.get(item, 0) + 1\n    return frequencies", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    from collections import Counter\n    flattened = [item for sublist in list_of_lists for item in sublist]\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    \"\"\"\n    Given a list of lists, return a dictionary with the frequency of each element.\n    \"\"\"\n    from collections import Counter\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n    # Count the frequency of each element\n    freq_dict = dict(Counter(flat_list))\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    from collections import Counter\n    return dict(Counter(item for sublist in lists for item in sublist))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    from collections import Counter\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n        nested_list (list of lists): The input list containing sublists of integers.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    from collections import Counter\n\n    # Flatten the list of lists\n    flat_list = [item for sublist in nested_list for item in sublist]\n\n    # Count the frequency of each element\n    frequency_dict = dict(Counter(flat_list))\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    from collections import Counter\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    # Use Counter to count the frequency of each element\n    freq_dict = dict(Counter(flat_list))\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Given a list of lists, this function returns a dictionary with the frequency of each element\n    in the flattened list.\n    \"\"\"\n    freq_dict = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            freq_dict[item] = freq_dict.get(item, 0) + 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists_of_lists):\n    \"\"\"\n    This function takes a list of lists, flattens it into a single list,\n    and returns a dictionary with the frequency count of each element.\n    \"\"\"\n    from collections import Counter\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in lists_of_lists for item in sublist]\n    # Use Counter to get the frequency of each element\n    frequency_dict = dict(Counter(flat_list))\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    freq_dict = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            freq_dict[item] = freq_dict.get(item, 0) + 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Given a list of lists, return a dictionary with the frequency of each element in the flattened list.\n    \"\"\"\n    from collections import Counter\n    from itertools import chain\n    return dict(Counter(chain.from_iterable(lists)))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(nested_lists):\n    counts = Counter()\n    for sublist in nested_lists:\n        counts.update(sublist)\n    return dict(counts)", "matching_cluster_idx": 7}, {"solution": "def frequency_lists(lists):\n    freq = {}\n    for sublist in lists:\n        for item in sublist:\n            freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    from collections import Counter\n    counts = Counter()\n    for sublist in lists:\n        counts.update(sublist)\n    return dict(counts)", "matching_cluster_idx": 7}]}, "Mbpp/106": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_param, tuple_param):\n    return tuple_param + tuple(list_param)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of tup followed by the elements of lst.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Append the given list to the given tuple and return a new tuple.\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n\n    Args:\n        lst (list): The list to append.\n        tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n        tuple: A new tuple containing elements of the original tuple followed by elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of the list `lst` to the tuple `tpl` and returns a new tuple.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple, returning a new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 35.06024096385542, "dps_norm": 68.18181818181819, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef merge_sorted_list(l1, l2, l3):\n    \"\"\"Merge three lists into a single sorted list.\"\"\"\n    l1.sort()\n    l2.sort()\n    l3.sort()\n    return list(heapq.merge(l1, l2, l3))", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \"\"\"\n    return sorted(lst1 + lst2 + lst3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    import heapq\n    # First, sort each list individually\n    sorted_list1 = sorted(list1)\n    sorted_list2 = sorted(list2)\n    sorted_list3 = sorted(list3)\n    # Then, merge the sorted lists efficiently\n    return list(heapq.merge(sorted_list1, sorted_list2, sorted_list3))", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    import heapq\n    # First, sort each of the individual lists\n    sorted_list1 = sorted(list1)\n    sorted_list2 = sorted(list2)\n    sorted_list3 = sorted(list3)\n    # Then, merge the sorted lists into a single sorted list\n    merged_list = list(heapq.merge(sorted_list1, sorted_list2, sorted_list3))\n    return merged_list", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    # Sort each list individually\n    l1_sorted = sorted(l1)\n    l2_sorted = sorted(l2)\n    l3_sorted = sorted(l3)\n    \n    # Now merge the sorted lists\n    merged_list = []\n    i = j = k = 0\n    len1, len2, len3 = len(l1_sorted), len(l2_sorted), len(l3_sorted)\n    \n    while i < len1 or j < len2 or k < len3:\n        vals = []\n        if i < len1:\n            vals.append((l1_sorted[i], 'l1'))\n        if j < len2:\n            vals.append((l2_sorted[j], 'l2'))\n        if k < len3:\n            vals.append((l3_sorted[k], 'l3'))\n        min_val, list_id = min(vals)\n        merged_list.append(min_val)\n        if list_id == 'l1':\n            i += 1\n        elif list_id == 'l2':\n            j +=1\n        else:  # 'l3'\n            k +=1\n    return merged_list", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    result = list1 + list2 + list3\n    result.sort()\n    return result", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    import heapq\n    return list(heapq.merge(sorted(l1), sorted(l2), sorted(l3)))", "matching_cluster_idx": 5}, {"solution": "import heapq\ndef merge_sorted_list(list1, list2, list3):\n    # First, sort each input list\n    sorted_list1 = sorted(list1)\n    sorted_list2 = sorted(list2)\n    sorted_list3 = sorted(list3)\n    \n    # Use heapq.merge to efficiently merge the sorted lists\n    merged_list = list(heapq.merge(sorted_list1, sorted_list2, sorted_list3))\n    return merged_list", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(a, b, c):\n    import heapq\n    # First, sort each list\n    a = sorted(a)\n    b = sorted(b)\n    c = sorted(c)\n    # Prepare data structures\n    result = []\n    heap = []\n    lists = [a, b, c]\n    # Initialize heap with first element from each list\n    for idx, lst in enumerate(lists):\n        if lst:  # list is not empty\n            heapq.heappush(heap, (lst[0], idx, 0))  # (value, list_index, element_index)\n    # Now, keep popping from heap and pushing next element\n    while heap:\n        value, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(value)\n        # If there is a next element in the same list, push it onto heap\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_value = lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_value, list_idx, elem_idx + 1))\n    return result", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    import heapq\n    # Sort each list individually\n    l1_sorted = sorted(l1)\n    l2_sorted = sorted(l2)\n    l3_sorted = sorted(l3)\n    # Merge the sorted lists efficiently\n    return list(heapq.merge(l1_sorted, l2_sorted, l3_sorted))", "matching_cluster_idx": 5}, {"solution": "import heapq\ndef merge_sorted_list(list1, list2, list3):\n    # First, sort each input list individually\n    sorted_list1 = sorted(list1)\n    sorted_list2 = sorted(list2)\n    sorted_list3 = sorted(list3)\n\n    # Use heapq.merge to efficiently merge the sorted lists\n    merged_iterable = heapq.merge(sorted_list1, sorted_list2, sorted_list3)\n\n    # Convert the merged iterable into a list\n    merged_list = list(merged_iterable)\n    \n    return merged_list", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # First, sort each individual list\n    list1.sort()\n    list2.sort()\n    list3.sort()\n    \n    # Use heapq.merge to efficiently merge the sorted lists\n    from heapq import merge\n    return list(merge(list1, list2, list3))", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    import heapq\n    # List of all input lists\n    lists = [list1, list2, list3]\n    # Sort each list\n    for lst in lists:\n        lst.sort()\n    # Initialize a heap\n    heap = []\n    # Push the first element of each list onto the heap\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    result = []\n    # Merge the lists\n    while heap:\n        value, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(value)\n        next_elem_idx = elem_idx + 1\n        if next_elem_idx < len(lists[list_idx]):\n            next_value = lists[list_idx][next_elem_idx]\n            heapq.heappush(heap, (next_value, list_idx, next_elem_idx))\n    return result", "matching_cluster_idx": 5}, {"solution": "import heapq\ndef merge_sorted_list(list1, list2, list3):\n    # First, sort each individual list\n    list1.sort()\n    list2.sort()\n    list3.sort()\n    # Merge the sorted lists into a single sorted list\n    return list(heapq.merge(list1, list2, list3))", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Sort each list individually\n    list1_sorted = sorted(list1)\n    list2_sorted = sorted(list2)\n    list3_sorted = sorted(list3)\n    # Merge the three sorted lists efficiently\n    return merge_three_sorted_lists(list1_sorted, list2_sorted, list3_sorted)\ndef merge_three_sorted_lists(list1, list2, list3):\n    result = []\n    i = j = k = 0\n    len1, len2, len3 = len(list1), len(list2), len(list3)\n    while i < len1 or j < len2 or k < len3:\n        values = []\n        if i < len1:\n            values.append((list1[i], 'list1'))\n        if j < len2:\n            values.append((list2[j], 'list2'))\n        if k < len3:\n            values.append((list3[k], 'list3'))\n        min_value, origin = min(values)\n        result.append(min_value)\n        if origin == 'list1':\n            i += 1\n        elif origin == 'list2':\n            j += 1\n        else:  # origin == 'list3'\n            k += 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    \"\"\"Merge three lists into a single sorted list.\"\"\"\n    return sorted(l1 + l2 + l3)", "matching_cluster_idx": 10}, {"solution": "import heapq\ndef merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \"\"\"\n    # Sort each list individually\n    sorted_list1 = sorted(list1)\n    sorted_list2 = sorted(list2)\n    sorted_list3 = sorted(list3)\n\n    # Use heapq.merge to efficiently merge the sorted lists\n    merged_list = list(heapq.merge(sorted_list1, sorted_list2, sorted_list3))\n    \n    return merged_list", "matching_cluster_idx": 5}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    return sorted(l1 + l2 + l3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \"\"\"\n    # Combine all three lists\n    merged_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 91.56923076923077, "dps_norm": 86.875, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find common elements in given nested lists.\n    Args:\n        nested_lists (List[List[Any]]): A list of lists containing elements.\n    Returns:\n        List[Any]: A list of common elements present in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    # Initialize the common elements set with the first list\n    common_elements = set(nested_lists[0])\n    # Intersect with each subsequent list's elements\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    # Start with the set of elements from the first list\n    common_elements = set(nested_lists[0])\n    # Iteratively compute the intersection with each list\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    return set.intersection(*map(set, nested_lists))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    :param nested_lists: List of lists containing elements.\n    :return: A set of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Start with the set of elements from the first list\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the rest of the lists and compute the intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Parameters:\n    nested_lists (list of lists): The input nested lists.\n\n    Returns:\n    list: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n    # Iterate through the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        # Early exit if there are no common elements\n        if not common_elements:\n            break\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n    # Iterate over the rest of the lists and take intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    # Start with the set of the first list\n    common_elements = set(nested_lists[0])\n    # Intersect with the sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n    \"\"\"\n    if not lists:\n        return []\n    # Start with the set of elements from the first list\n    common_elements = set(lists[0])\n    # Iterate over the rest of the lists, updating the set of common elements\n    for lst in lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if there are no common elements\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Parameters:\n        nested_lists (list of lists): A list containing multiple lists of integers.\n\n    Returns:\n        list: A list of integers that are common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list converted to a set\n    common_elements = set(nested_lists[0])\n\n    # Intersect with the sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return list(common_elements)\nnested_lists = [\n    [12, 18, 23, 25, 45],\n    [7, 12, 18, 24, 28],\n    [1, 5, 8, 12, 15, 16, 18]\n]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    # Initialize the common elements with the first list converted to a set\n    common_elements = set(nested_lists[0])\n    # Iterate over the remaining lists and perform set intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    # Return the list of common elements\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    from functools import reduce\n    common_elements = reduce(set.intersection, map(set, nested_lists))\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    return list(set.intersection(*map(set, lists)))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    # Find the intersection of all sets created from the nested lists\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Args:\n        nested_lists (list of lists): A list containing sublists of integers.\n\n    Returns:\n        list: A list of common elements found in all sublists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common elements set with the first sublist\n    common_elements = set(nested_lists[0])\n\n    # Intersect with the next sublists\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    Parameters:\n    lists (list of lists): A list containing multiple lists of elements.\n    \n    Returns:\n    list: A list of elements that are common to all nested lists.\n    \"\"\"\n    if not lists:\n        return []\n    result_set = set(lists[0])\n    for lst in lists[1:]:\n        result_set &= set(lst)\n    return list(result_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n    \"\"\"\n    # Initialize the common elements set with the first list\n    common_elements = set(nested_lists[0])\n    # Iterate over the remaining lists and update the common elements\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    # Initialize the set with the elements of the first list\n    common_elements = set(nested_lists[0])\n    # Iterate through the remaining lists and update the common elements\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n        # Early exit if there are no common elements\n        if not common_elements:\n            return []\n    # Return the common elements as a list\n    return list(common_elements)", "matching_cluster_idx": 7}]}, "Mbpp/123": {"dps": 99.8320895522388, "dps_norm": 93.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    assert amicable_numbers_sum(999)==504\n    \"\"\"\n    # Initialize the list to store sum of proper divisors for each number\n    sum_divisors = [0] * (n + 1)\n    \n    # Calculate sum of proper divisors for each number up to n\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n    \n    # Use a set to store amicable numbers to avoid duplicates\n    amicable_numbers = set()\n    \n    # Identify amicable numbers\n    for i in range(2, n + 1):\n        s = sum_divisors[i]\n        if s != i and s <= n and sum_divisors[s] == i:\n            amicable_numbers.add(i)\n            amicable_numbers.add(s)\n    \n    # Return the sum of all amicable numbers found\n    return sum(amicable_numbers)", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    assert amicable_numbers_sum(999)==504\n    \"\"\"\n    s = [0] * (n + 1)  # Sum of proper divisors for each number\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            s[j] += i\n    total = 0\n    for i in range(2, n + 1):\n        j = s[i]\n        if j > i and j <= n and s[j] == i:\n            total += i + j\n    return total", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Returns the sum of all amicable numbers from 1 to n inclusive.\n    \"\"\"\n    # Initialize a list to hold the sum of proper divisors\n    div_sums = [0] * (n + 1)\n    # Calculate sum of proper divisors for each number\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            div_sums[j] += i\n    total = 0\n    # Find amicable numbers\n    for a in range(1, n + 1):\n        b = div_sums[a]\n        if b > a and b <= n:\n            if div_sums[b] == a:\n                total += a + b\n    return total", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    sum_divs = [0] * (n + 1)\n    # Compute sum of proper divisors for each number up to n\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divs[j] += i\n\n    amicable_numbers = set()\n    for i in range(2, n + 1):\n        s_i = sum_divs[i]\n        # Check if s_i is a candidate for an amicable number\n        if s_i > i and s_i <= n:\n            # Verify if s_i forms an amicable pair with i\n            if sum_divs[s_i] == i:\n                amicable_numbers.add(i)\n                amicable_numbers.add(s_i)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(N):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    assert amicable_numbers_sum(999)==504\n    \"\"\"\n    limit = 2 * N  # Extend limit to cover possible amicable pairs where b > N\n    sum_divisors = [0] * (limit)\n    \n    # Compute sum of proper divisors for each number up to 'limit'\n    for i in range(1, limit // 2):\n        for j in range(i * 2, limit, i):\n            sum_divisors[j] += i\n    \n    amicable_numbers = set()\n    # Find amicable numbers up to N\n    for a in range(2, N + 1):\n        b = sum_divisors[a]\n        if b != a and b < limit and sum_divisors[b] == a:\n            amicable_numbers.add(a)\n    \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    if n == 1:\n        return 0\n    s = 1  # 1 is a proper divisor of every n > 1\n    max_divisor = int(n ** 0.5)\n    for i in range(2, max_divisor + 1):\n        if n % i == 0:\n            s += i\n            quotient = n // i\n            if quotient != i:  # Avoid adding the square root twice for perfect squares\n                s += quotient\n    return s\ndef amicable_numbers_sum(N):\n    # Calculate sum of proper divisors for each number up to N\n    sum_divisors = {}\n    for num in range(1, N + 1):\n        sum_divisors[num] = sum_of_proper_divisors(num)\n    \n    amicable_numbers = set()\n    # Check for amicable numbers\n    for a in range(1, N + 1):\n        b = sum_divisors[a]\n        if b != a and b in sum_divisors and sum_divisors[b] == a:\n            amicable_numbers.add(a)\n            # Note: We only add 'a' because 'b' will be checked in its own iteration if b <= N\n    \n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_of_proper_divisors(num):\n        total = 1\n        p = 2\n        temp = num\n        while p * p <= temp and temp > 1:\n            if temp % p == 0:\n                sum_powers = p\n                temp //= p\n                while temp % p == 0:\n                    sum_powers *= p\n                    temp //= p\n                total *= (sum_powers * p - 1) // (p - 1)\n            if p == 2:\n                p = 3\n            else:\n                p += 2\n        if temp > 1:\n            total *= temp + 1\n        return total - num\n\n    LIMIT = n * 2  # Adjust as needed\n    sdiv = [0] * (LIMIT + 1)\n    for i in range(1, LIMIT // 2 + 1):\n        for j in range(2 * i, LIMIT + 1, i):\n            sdiv[j] += i\n\n    amicable_numbers = set()\n    for i in range(2, n + 1):\n        s = sdiv[i]\n        if s != i:\n            if s <= LIMIT:\n                if sdiv[s] == i:\n                    amicable_numbers.update([i, s])\n            else:\n                s_sdiv = sum_of_proper_divisors(s)\n                if s_sdiv == i:\n                    amicable_numbers.update([i, s])\n\n    return sum([num for num in amicable_numbers if num <= n])", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    \"\"\"\n    # Initialize sums of proper divisors for each number up to limit\n    divisors_sums = [0] * (limit + 1)\n    for i in range(1, limit // 2 + 1):\n        for j in range(2 * i, limit + 1, i):\n            divisors_sums[j] += i\n\n    # Identify amicable numbers\n    amicable_numbers = set()\n    for a in range(2, limit + 1):\n        b = divisors_sums[a]\n        if b != a and b <= limit and divisors_sums[b] == a:\n            amicable_numbers.add(a)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 13}, {"solution": "def sum_proper_divisors(n):\n    if n == 1:\n        return 0\n    s = 1\n    sqrt_n = int(n ** 0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            s += i\n            other = n // i\n            if other != i:\n                s += other\n    return s\ndef amicable_numbers_sum(N):\n    sum_div = {}\n    total = 0\n    for a in range(2, N+1):\n        if a not in sum_div:\n            sum_div[a] = sum_proper_divisors(a)\n        b = sum_div[a]\n        if b != a:\n            if b not in sum_div:\n                sum_div[b] = sum_proper_divisors(b)\n            if sum_div[b] == a:\n                total += a\n    return total", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    if n == 1:\n        return 0\n    s = 1\n    sqrt_n = int(n ** 0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            s += i\n            d = n // i\n            if d != i:\n                s += d\n    return s\ndef amicable_numbers_sum(n):\n    amicable = set()\n    for a in range(2, n + 1):\n        b = sum_of_proper_divisors(a)\n        if b > a and b <= n:\n            if sum_of_proper_divisors(b) == a:\n                amicable.update([a, b])\n    return sum(amicable)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    s = [0] * (n + 1)  # Sum of proper divisors for each number\n    # Calculate sum of proper divisors for each number up to n\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            s[j] += i\n    \n    total = 0\n    # Find amicable numbers and sum them\n    for a in range(2, n + 1):\n        b = s[a]\n        if b > a and b <= n:\n            if s[b] == a:\n                total += a + b  # Add both numbers in the amicable pair\n    return total", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    limit = n * 2\n    sum_divisors = [0] * (limit + 1)\n    for i in range(1, limit + 1):\n        for j in range(i * 2, limit + 1, i):\n            sum_divisors[j] += i\n    amicable_numbers = set()\n    for i in range(2, n + 1):\n        j = sum_divisors[i]\n        if j != i and j <= limit:\n            if sum_divisors[j] == i:\n                amicable_numbers.add(i)\n                if j <= n:\n                    amicable_numbers.add(j)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    \"\"\"\n    # Initialize list to store sum of proper divisors\n    sum_divisors = [0] * (n + 1)\n    \n    # Calculate sum of proper divisors for each number up to n\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n    \n    total = 0\n    # Find and sum amicable numbers\n    for a in range(2, n + 1):\n        b = sum_divisors[a]\n        if b > a and b <= n:\n            if sum_divisors[b] == a:\n                total += a + b\n    return total", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    assert amicable_numbers_sum(999)==504\n    \"\"\"\n    def sum_of_proper_divisors(num):\n        div_sum = 1  # Start with 1, since 1 is a proper divisor of any num > 1\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                div_sum += i\n                other_divisor = num // i\n                if other_divisor != i:\n                    div_sum += other_divisor\n        return div_sum\n    \n    divisor_sums = {}\n    for i in range(2, n + 1):\n        divisor_sums[i] = sum_of_proper_divisors(i)\n        \n    amicable_sum = 0\n    for a in range(2, n + 1):\n        b = divisor_sums[a]\n        # Check if b is valid and within the range and not equal to a\n        if b != a and b <= n and b in divisor_sums:\n            if divisor_sums[b] == a:\n                # To avoid adding duplicates, add only if a < b\n                if a < b:\n                    amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(N):\n    s = [0] * (N+1)\n    # Compute sum of proper divisors for each number up to N\n    for i in range(1, N//2+1):\n        for j in range(2*i, N+1, i):\n            s[j] += i\n    total = 0\n    for i in range(1, N+1):\n        a = s[i]\n        if a > i and a <= N and s[a] == i:\n            total += i + a\n    return total", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    assert amicable_numbers_sum(999) == 504\n    \"\"\"\n    # Initialize an array to hold the sum of proper divisors for each number up to n\n    s = [0] * (n + 1)\n    \n    # Compute the sum of proper divisors for each number\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            s[j] += i\n    \n    total = 0\n    # Find amicable numbers and sum them up\n    for i in range(2, n + 1):\n        j = s[i]\n        if j != i and j <= n and s[j] == i:\n            total += i\n    return total", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    assert amicable_numbers_sum(999)==504\n    \"\"\"\n    # Initialize a list to store the sum of proper divisors for each number up to n\n    sum_of_divisors = [0] * (n + 1)\n\n    # Calculate the sum of proper divisors for each number\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_of_divisors[j] += i\n\n    # Set to store amicable numbers to avoid duplicates\n    amicable_numbers = set()\n\n    # Identify amicable numbers within the range\n    for i in range(2, n + 1):\n        s = sum_of_divisors[i]\n        if s > i and s <= n:\n            if sum_of_divisors[s] == i:\n                amicable_numbers.add(i)\n                amicable_numbers.add(s)\n\n    # Return the sum of all amicable numbers found\n    return sum(amicable_numbers)", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    sum_of_proper_divisors = [0] * (n + 1)\n    # Calculate sum of proper divisors for each number up to n\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_of_proper_divisors[j] += i\n    amicable_sum = 0\n    for a in range(2, n + 1):\n        b = sum_of_proper_divisors[a]\n        if b > a and b <= n and sum_of_proper_divisors[b] == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Returns the sum of all amicable numbers from 1 to n.\n    \"\"\"\n    # Set the limit to at least 2 * n to account for potential amicable pairs beyond n\n    limit = n * 2\n    # Initialize an array to store the sum of proper divisors for each number up to the limit\n    sum_divisors = [0] * (limit + 1)\n    \n    # Calculate the sum of proper divisors for each number\n    for i in range(1, limit // 2 + 1):\n        for j in range(2 * i, limit + 1, i):\n            sum_divisors[j] += i\n\n    total = 0\n    # Find and sum amicable numbers up to n\n    for a in range(1, n + 1):\n        b = sum_divisors[a]\n        # Check if a and b form an amicable pair\n        if b != a and b <= limit and sum_divisors[b] == a:\n            total += a\n    return total", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    s = 1\n    sqrt_n = int(n**0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            s += i\n            other_div = n // i\n            if other_div != i:\n                s += other_div\n    if n == 1:\n        s = 0\n    return s\ndef amicable_numbers_sum(n):\n    amicable_numbers = set()\n    sum_divisors = {}\n\n    for i in range(2, n + 1):\n        sum_div_i = sum_of_proper_divisors(i)\n        sum_divisors[i] = sum_div_i\n\n    for i in range(2, n + 1):\n        sum_div_i = sum_divisors[i]\n\n        if sum_div_i != i:\n            if sum_div_i in sum_divisors:\n                sum_div_j = sum_divisors[sum_div_i]\n            else:\n                sum_div_j = sum_of_proper_divisors(sum_div_i)\n                sum_divisors[sum_div_i] = sum_div_j\n\n            if sum_div_j == i and sum_div_i <= n:\n                amicable_numbers.add(i)\n                amicable_numbers.add(sum_div_i)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, s):\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    \"\"\"Find words longer than n characters in a given string s.\"\"\"\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    \"\"\"\n    Finds and returns a list of words that are longer than n characters from the given string s.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the sentence that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    sentence (str): The sentence to extract words from.\n\n    Returns:\n    List[str]: A list of words longer than n characters.\n\n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    words = s.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    \"\"\"\n    Returns a list of words from the string `s` that are longer than `n` characters.\n\n    :param n: Integer, the minimum number of characters a word must have to be included in the result.\n    :param s: String, the input string containing words separated by spaces.\n    :return: List of words longer than `n` characters.\n    \"\"\"\n    # Split the string into words and filter words longer than n characters\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n    assert long_words(3, \"python is a programming language\") == ['python', 'programming', 'language']\n    \"\"\"\n    words = s.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n    \n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): The string containing words to be filtered.\n    \n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    \"\"\"\n    Returns words that are longer than n characters from a given string s.\n\n    Parameters:\n    n (int): The minimum length of words to find.\n    s (str): The string containing words to evaluate.\n\n    Returns:\n    list: A list of words from s that are longer than n characters.\n    \"\"\"\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n    \"\"\"\n    # Split the input string into individual words\n    words = s.split()\n    # Use a list comprehension to select words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, input_string):\n    words = input_string.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    return [word for word in s.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    words = s.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 52.05498866213152, "dps_norm": 93.7037037037037, "pass@1": 36.0, "profiled": [{"solution": "def magic_square_test(mat):\n    n = len(mat)\n    if n == 0 or any(len(row) != n for row in mat):\n        return False\n    \n    # Calculate the sum of the first row to use as reference\n    magic_sum = sum(mat[0])\n    \n    # Check the sum of each row\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(mat[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(mat[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(mat[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if the matrix is square\n    if not all(len(row) == n for row in matrix):\n        return False\n\n    # Calculate the magic constant (sum of the first row)\n    magic_constant = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    This function checks whether a given square matrix is a magic square.\n    A magic square is a grid where the sum of every row, every column, and the two main diagonals are all equal.\n    \n    Parameters:\n    matrix (list of lists): The square matrix to test.\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    # Check that matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Compute the magic sum from the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of columns\n    for col in range(n):\n        column_sum = 0\n        for row in range(n):\n            column_sum += matrix[row][col]\n        if column_sum != magic_sum:\n            return False\n    \n    # Check main diagonal sum\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check secondary diagonal sum\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Check if the matrix is non-empty and square\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the sum of the first row as the magic sum\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given square matrix is a magic square.\n\n    Args:\n        matrix (list of lists of int): The square matrix to test.\n\n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    # Check if the matrix is empty or not square\n    if not matrix or not matrix[0]:\n        return False\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic constant (sum of the first row)\n    magic_const = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_const:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_const:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_const:\n        return False\n\n    # Check sum of the anti-diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_const:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0:\n        return False\n    # Check if each row has the same length as n (square matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        # The matrix is not square\n        return False\n\n    # Calculate the magic constant using the sum of the first row\n    magic_constant = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n\n    # All checks passed; it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if matrix is empty or not square\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False\n    magic_constant = sum(matrix[0])\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    # Check sum of main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    # Check sum of anti-diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Compute the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n    \n    # Check sum of main diagonal\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    if diag1_sum != magic_sum:\n        return False\n    \n    # Check sum of the other diagonal\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag2_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if the matrix is square\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of the anti-diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0:\n        return False  # Empty matrix cannot be a magic square\n\n    # Check if all rows have the same length as n\n    for row in matrix:\n        if len(row) != n:\n            return False  # Not a square matrix\n\n    # Calculate the magic sum using the sum of the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of opposite diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if the matrix is square (NxN)\n    if not all(len(row) == n for row in matrix):\n        return False\n    # Calculate the magic constant using the sum of the first row\n    magic_sum = sum(matrix[0])\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    # Check sum of the anti-diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if the matrix is square\n    if any(len(row) != n for row in matrix):\n        return False\n\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if matrix is square\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Returns True if the given square matrix is a magic square, False otherwise.\n    A magic square is a square matrix where the sums of the numbers in each row,\n    each column, and both main diagonals are all the same.\n    \"\"\"\n    n = len(matrix)\n    # Check if matrix is not empty and is square\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n\n    # Check sum of main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True\nmatrix = [\n    [7, 12, 1, 14],\n    [2, 13, 8, 11],\n    [16, 3, 10, 5],\n    [9, 6, 15, 4]\n]", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if the matrix is square\n    if any(len(row) != n for row in matrix):\n        return False\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    # Check the sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    # Check the sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0:\n        return False\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n    # Calculate the magic constant (sum of the first row)\n    magic_constant = sum(matrix[0])\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    # Check the sum of each column\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_constant:\n            return False\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    # Check the sum of the anti-diagonal\n    if sum(matrix[i][n - i - 1] for i in range(n)) != magic_constant:\n        return False\n    return True", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 88.23991031390135, "dps_norm": 78.33333333333333, "pass@1": 72.0, "profiled": [{"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    max_count = max(counts.values())\n    # Find the item(s) with the maximum count\n    max_items = [item for item, count in counts.items() if count == max_count]\n    # Return one of the items with the maximum count (you can decide how to handle ties)\n    return max_items[0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    # Return the item with maximum frequency\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list.\n    \"\"\"\n    from collections import Counter\n    count = Counter(lst)\n    # Find the item(s) with the maximum frequency\n    max_count = max(count.values())\n    max_items = [item for item, freq in count.items() if freq == max_count]\n    # In case of multiple items with the same max frequency, return the first one encountered\n    for item in lst:\n        if item in max_items:\n            return item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    max_count = max(counts.values())\n    max_items = [k for k, v in counts.items() if v == max_count]\n    return max_items[0]  # Return the first item among those with max frequency", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    return Counter(lst).most_common(1)[0][0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in the given list.\n    If multiple items have the same maximum frequency, return any one of them.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    most_common_element = counts.most_common(1)[0][0]\n    return most_common_element", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The list of items.\n\n    Returns:\n    The item with the maximum frequency.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    max_item = max(counts, key=lambda x: counts[x])\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    max_count = max(counts.values())\n    # Return the first item with the maximum frequency\n    for item in lst:\n        if counts[item] == max_count:\n            return item", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Write a function to find the item with maximum frequency in a given list.\n    \"\"\"\n    from collections import Counter\n    count = Counter(lst)\n    max_count = max(count.values())\n    # Get all items with the maximum frequency\n    items_with_max_count = [item for item, freq in count.items() if freq == max_count]\n    # Return one of them (e.g., the first one)\n    return items_with_max_count[0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    max_item = max(count.items(), key=lambda x: x[1])[0]\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(nums):\n    from collections import Counter\n    counts = Counter(nums)\n    max_freq = max(counts.values())\n    # Return the item with the maximum frequency\n    for num, freq in counts.items():\n        if freq == max_freq:\n            return num", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counter = Counter(lst)\n    max_item = counter.most_common(1)[0][0]\n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with maximum frequency in the given list.\n\n    Parameters:\n    lst (list): The list to analyze.\n\n    Returns:\n    The item with the highest frequency.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    max_count = max(counts.values())\n    for item, count in counts.items():\n        if count == max_count:\n            return item  # Return the first item with maximum frequency", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    max_item = max(counts, key=counts.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for item in lst:\n        counts[item] = counts.get(item, 0) + 1\n    max_item = max(counts, key=counts.get)\n    return max_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": 86.29032258064515, "dps_norm": 88.75, "pass@1": 82.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Handle division by zero if all elements are zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero if all elements are zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero if all elements are zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Handle division by zero if there are no non-zero elements\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero when there are no non-zero elements\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(nums):\n    zeros = nums.count(0)\n    nonzeros = len(nums) - zeros\n    if nonzeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / nonzeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    count_zero = 0\n    count_non_zero = 0\n    for num in arr:\n        if num == 0:\n            count_zero += 1\n        else:\n            count_non_zero += 1\n    if count_non_zero == 0:\n        return float('inf')  # Avoid division by zero\n    return count_zero / count_non_zero", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Adjust as needed for cases with no non-zero elements\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Handle division by zero when there are no non-zero elements\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(lst):\n    zeroes = lst.count(0)\n    non_zeroes = len(lst) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # or return 0 if you prefer\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero when there are no non-zero elements\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Handle division by zero if all elements are zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero if all elements are zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = non_zeroes = 0\n    for x in arr:\n        if x == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    zeros = 0\n    non_zeros = 0\n    for x in arr:\n        if x == 0:\n            zeros += 1\n        else:\n            non_zeros += 1\n    if non_zeros == 0:\n        return float('inf')  # Handle division by zero if all elements are zero\n    return zeros / non_zeros", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(array):\n    zeros = array.count(0)\n    non_zeros = len(array) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Handle division by zero if all elements are zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}]}, "Mbpp/140": {"dps": 87.18944099378882, "dps_norm": 84.375, "pass@1": 98.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single list of numbers.\n    \"\"\"\n    return [item for sublist in list_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    return [item for sublist in list_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(nested_list):\n    return [item for sublist in nested_list for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(data):\n    return set().union(*data)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(nested_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n        nested_lists (list of lists or tuples): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    # Use set comprehension to flatten and collect unique elements\n    return {element for sublist in nested_lists for element in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst_of_lists):\n    \"\"\"\n    Flatten a list of lists/tuples into a single list of numbers.\n    \"\"\"\n    return [item for sublist in lst_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    return [item for sublist in list_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    return [item for sublist in list_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst_of_lists):\n    return [item for sublist in lst_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Write a function to flatten the list of lists into a single set of numbers.\n    \"\"\"\n    from itertools import chain\n    return list(chain.from_iterable(list_of_lists))", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \"\"\"\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n    \"\"\"\n    for element in nested_list:\n        if isinstance(element, (list, tuple)):\n            yield from extract_singly(element)\n        else:\n            yield element\n\n# Test case\nassert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([1, 3, 4, 5, 7])", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    return [item for sublist in list_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Write a function to flatten the list of lists into a single set of numbers.\n    \"\"\"\n    return [item for sublist in nested_list for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_lists):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \"\"\"\n    return set().union(*nested_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists into a single list of numbers.\n    \"\"\"\n    return [number for sublist in nested_list for number in sublist]", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 98.41269841269842, "dps_norm": 50.0, "pass@1": 98.0, "profiled": [{"solution": "def pancake_sort(arr):\n    arr = arr.copy()  # Make a copy to avoid modifying the original list\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..size-1]\n        max_index = arr.index(max(arr[0:size]))\n        if max_index != size - 1:\n            # If max element is not at the beginning, flip it to the front\n            if max_index != 0:\n                arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            # Flip the max element to its correct position\n            arr[:size] = arr[:size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    res = arr[:]\n    n = len(res)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in res[0..curr_size-1]\n        max_index = res.index(max(res[:curr_size]))\n        if max_index != curr_size - 1:\n            # Move maximum number to front if it's not already at front\n            if max_index != 0:\n                # Flip res[0..max_index]\n                res[:max_index+1] = res[:max_index+1][::-1]\n            # Flip res[0..curr_size-1]\n            res[:curr_size] = res[:curr_size][::-1]\n    return res", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    A = arr.copy()\n    n = len(A)\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in A[0..curr_size-1]\n        max_idx = A.index(max(A[0:curr_size]))\n        if max_idx != curr_size - 1:\n            # Flip the subarray A[0..max_idx]\n            A[:max_idx + 1] = A[:max_idx + 1][::-1]\n            # Flip the subarray A[0..curr_size-1]\n            A[:curr_size] = A[:curr_size][::-1]\n    return A", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Make a copy of the list to avoid modifying the original list\n    A = arr.copy()\n    n = len(A)\n    # Start from the whole array and reduce the size each time\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in A[0..curr_size-1]\n        max_index = A.index(max(A[:curr_size]))\n        # Move the maximum element to the end of the current array if it's not already there\n        if max_index != curr_size - 1:\n            # Flip the maximum element to the front if it's not already at the front\n            if max_index != 0:\n                A[:max_index + 1] = reversed(A[:max_index + 1])\n            # Flip it to its correct position\n            A[:curr_size] = reversed(A[:curr_size])\n    return A", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_idx = arr.index(max(arr[:curr_size]))\n        if max_idx != curr_size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_idx != 0:\n                # Flip the sub-array arr[0..max_idx]\n                arr[:max_idx+1] = arr[:max_idx+1][::-1]\n            # Flip the sub-array arr[0..curr_size-1] to bring the maximum element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to sort.\n\n    Returns:\n    list: A new sorted list.\n    \"\"\"\n    n = len(arr)\n    arr = arr.copy()  # Make a copy to avoid modifying the original list\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_index = arr.index(max(arr[:curr_size]))\n        if max_index != curr_size - 1:\n            # Flip the sublist arr[0..max_index]\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            # Flip the sublist arr[0..curr_size-1]\n            arr[:curr_size] = arr[:curr_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    A = arr[:]  # Make a copy to avoid modifying the original list\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in A[0..size-1]\n        max_index = A.index(max(A[:size]))\n        if max_index != size - 1:\n            # If max element is not at the first position, flip it to the front\n            if max_index != 0:\n                A[:max_index+1] = reversed(A[:max_index+1])\n            # Flip the max element to its correct position at the end of the current list\n            A[:size] = reversed(A[:size])\n    return A", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    arr = arr.copy()  # To avoid modifying the original list\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        mi = arr.index(max(arr[0:curr_size]))\n        if mi != curr_size - 1:\n            # Flip the prefix with maximum element to bring it to the front\n            arr[:mi+1] = arr[:mi+1][::-1]\n            # Now move the maximum element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    arr = arr[:]  # Make a shallow copy to avoid modifying the original list\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:curr_size]\n        max_index = arr.index(max(arr[:curr_size]))\n        if max_index != curr_size - 1:\n            # Flip the subarray arr[0:max_index+1] to bring the max element to the front\n            arr[:max_index+1] = reversed(arr[:max_index+1])\n            # Flip the subarray arr[0:curr_size] to move the max element to its correct position\n            arr[:curr_size] = reversed(arr[:curr_size])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    arr = arr.copy()  # Make a copy to avoid modifying the original list\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the current subarray\n        max_idx = arr.index(max(arr[0:curr_size]))\n        if max_idx != curr_size - 1:\n            # Flip the maximum number to the front if it's not already there\n            if max_idx != 0:\n                # Flip arr[0..max_idx]\n                arr[:max_idx+1] = reversed(arr[:max_idx+1])\n            # Flip it to its correct position\n            arr[:curr_size] = reversed(arr[:curr_size])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_index = arr.index(max(arr[:curr_size]))\n        if max_index != curr_size - 1:\n            # Flip the sub-array arr[0..max_index]\n            arr[:max_index+1] = arr[:max_index+1][::-1]\n            # Flip the sub-array arr[0..curr_size-1]\n            arr[:curr_size] = arr[:curr_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_index = arr.index(max(arr[:curr_size]))\n        if max_index != curr_size - 1:\n            # Flip the array from 0 to max_index\n            arr[:max_index+1] = arr[:max_index+1][::-1]\n            # Flip the array from 0 to curr_size-1\n            arr[:curr_size] = arr[:curr_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    n = len(lst)\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in lst[0..curr_size-1]\n        max_index = lst.index(max(lst[0:curr_size]))\n        if max_index != curr_size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_index != 0:\n                # Flip lst[0..max_index]\n                lst[:max_index+1] = lst[:max_index+1][::-1]\n            # Flip lst[0..curr_size-1] to move the maximum element to its final position\n            lst[:curr_size] = lst[:curr_size][::-1]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:curr_size]\n        max_index = arr.index(max(arr[0:curr_size]))\n        if max_index != curr_size - 1:\n            # Flip the sub-array from 0 to max_index\n            arr[:max_index+1] = arr[:max_index+1][::-1]\n            # Flip the sub-array from 0 to curr_size\n            arr[:curr_size] = arr[:curr_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_index = arr.index(max(arr[0:curr_size]))\n        if max_index != curr_size - 1:\n            # Flip the subarray from 0 to max_index\n            arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            # Flip the subarray from 0 to curr_size - 1\n            arr[:curr_size] = reversed(arr[:curr_size])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_idx = arr.index(max(arr[0:curr_size]))\n        if max_idx != curr_size - 1:\n            # Flip the maximum number to the beginning if it's not already there\n            if max_idx != 0:\n                arr[:max_idx+1] = reversed(arr[:max_idx+1])\n            # Flip it to its correct position\n            arr[:curr_size] = reversed(arr[:curr_size])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n    \"\"\"\n    arr = arr[:]  # Make a copy to avoid modifying the original list\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_idx = arr.index(max(arr[0:curr_size]))\n        if max_idx != curr_size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_idx != 0:\n                arr[:max_idx+1] = arr[:max_idx+1][::-1]\n            # Flip the maximum element to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    arr = arr.copy()\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_idx = arr.index(max(arr[0:curr_size]))\n        if max_idx != curr_size - 1:\n            # Flip the maximum number to the front if it's not already there\n            if max_idx != 0:\n                arr[:max_idx+1] = arr[:max_idx+1][::-1]\n            # Flip it to its correct position in the array\n            arr[:curr_size] = arr[:curr_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    result = arr.copy()  # Make a copy to avoid modifying the original list\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion of the list\n        max_index = result.index(max(result[:curr_size]))\n        if max_index != curr_size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                result[:max_index+1] = result[:max_index+1][::-1]\n            # Flip it to its correct position in the sorted portion\n            result[:curr_size] = result[:curr_size][::-1]\n    return result", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to sort.\n\n    Returns:\n    list: A new sorted list.\n    \"\"\"\n    arr = arr.copy()\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_idx = arr.index(max(arr[0:curr_size]))\n        if max_idx != curr_size - 1:\n            # Flip the maximum number to beginning if it's not already at the first position\n            if max_idx != 0:\n                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            # Flip it to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 99.19999999999999, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for num in lst:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count +=1\n\n    even_pairs = even_count * (even_count -1) //2\n    odd_pairs = odd_count * (odd_count -1) //2\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(arr):\n    \"\"\"\n    Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    assert find_even_pair([5, 4, 7, 2, 1]) == 4\n    \"\"\"\n    even_count = sum(1 for x in arr if x % 2 == 0)\n    odd_count = len(arr) - even_count\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count -1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    # Count the number of even and odd numbers in the list\n    even_count = sum(1 for x in lst if x % 2 == 0)\n    odd_count = len(lst) - even_count\n    # Pairs of even numbers xor to even\n    even_pairs = even_count * (even_count - 1) // 2\n    # Pairs of odd numbers xor to even\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    # Total pairs that xor to even\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \"\"\"\n    count_even = sum(1 for x in lst if x % 2 == 0)\n    count_odd = len(lst) - count_even\n\n    # Number of ways to choose 2 even numbers\n    even_pairs = count_even * (count_even - 1) // 2\n    # Number of ways to choose 2 odd numbers\n    odd_pairs = count_odd * (count_odd - 1) // 2\n\n    total_pairs = even_pairs + odd_pairs\n    return total_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(arr):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    Two integers XOR to an even number if both are even or both are odd.\n\n    :param arr: List of integers\n    :return: Number of pairs where arr[i] ^ arr[j] is even (i < j)\n    \"\"\"\n    even_count = sum(1 for x in arr if x % 2 == 0)\n    odd_count = sum(1 for x in arr if x % 2 != 0)\n    # Number of ways to choose 2 even numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    # Number of ways to choose 2 odd numbers\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(arr):\n    \"\"\"\n    Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    even_count = sum(1 for x in arr if x % 2 == 0)\n    odd_count = len(arr) - even_count\n    total_pairs = (even_count * (even_count - 1) // 2) + (odd_count * (odd_count - 1) // 2)\n    return total_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    :param nums: List of integers.\n    :return: Number of pairs where the XOR is even.\n    \"\"\"\n    even_count = sum(1 for x in nums if x % 2 == 0)\n    odd_count = len(nums) - even_count\n    # Pairs with both numbers even or both numbers odd will have an even XOR\n    return (even_count * (even_count - 1) // 2) + (odd_count * (odd_count - 1) // 2)", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    # Count the number of even and odd numbers in the list\n    even_count = sum(1 for x in lst if x % 2 == 0)\n    odd_count = len(lst) - even_count\n    \n    # The number of pairs where both numbers are even\n    even_pairs = even_count * (even_count - 1) // 2\n    # The number of pairs where both numbers are odd\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    # Total pairs that XOR to an even number are the sum of even-even and odd-odd pairs\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    count_even = sum(1 for x in lst if x % 2 == 0)\n    count_odd = len(lst) - count_even\n    return (count_even * (count_even - 1) // 2) + (count_odd * (count_odd - 1) // 2)", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    assert find_even_pair([5, 4, 7, 2, 1]) == 4\n    \"\"\"\n    even_count = sum(1 for x in nums if x % 2 == 0)\n    odd_count = len(nums) - even_count\n    # Pairs where both numbers are even\n    even_pairs = even_count * (even_count - 1) // 2\n    # Pairs where both numbers are odd\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    # Total pairs with even XOR\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for num in lst:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count * (even_count - 1)) // 2 + (odd_count * (odd_count - 1)) // 2", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Parameters:\n    nums (list of int): The list of integers.\n\n    Returns:\n    int: The number of pairs where the xor of the pair is even.\n    \"\"\"\n    c_even = sum(1 for x in nums if x % 2 == 0)\n    c_odd = len(nums) - c_even\n    # Pairs of even numbers (even ^ even = even)\n    even_pairs = c_even * (c_even - 1) // 2\n    # Pairs of odd numbers (odd ^ odd = even)\n    odd_pairs = c_odd * (c_odd - 1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \"\"\"\n    count_even = sum(1 for num in nums if num % 2 == 0)\n    count_odd = len(nums) - count_even\n    # Pairs where both numbers are even\n    even_pairs = count_even * (count_even - 1) // 2\n    # Pairs where both numbers are odd\n    odd_pairs = count_odd * (count_odd - 1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    cnt_even = sum(1 for x in lst if x % 2 == 0)\n    cnt_odd = len(lst) - cnt_even\n    return cnt_even * (cnt_even - 1) // 2 + cnt_odd * (cnt_odd - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    even_count = sum(1 for x in lst if x % 2 == 0)\n    odd_count = len(lst) - even_count\n    # Pairs of even numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    # Pairs of odd numbers\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    A pair's xor is even if both numbers are both even or both odd.\n    \"\"\"\n    n_even = sum(1 for x in lst if x % 2 == 0)\n    n_odd = len(lst) - n_even\n    return (n_even * (n_even - 1) // 2) + (n_odd * (n_odd - 1) // 2)", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list nums that XOR to an even number.\n    The XOR of two integers is even if both are even or both are odd.\n    \"\"\"\n    count_even = 0\n    count_odd = 0\n    for num in nums:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    # Number of ways to choose 2 even numbers\n    pairs_even = count_even * (count_even - 1) // 2\n    # Number of ways to choose 2 odd numbers\n    pairs_odd = count_odd * (count_odd - 1) // 2\n    total_pairs = pairs_even + pairs_odd\n    return total_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    even_count = 0  # Count of even numbers\n    odd_count = 0   # Count of odd numbers\n\n    # Count the number of even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    # The number of pairs from even numbers and odd numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n\n    # Total pairs that XOR to an even number are pairs of even-even and odd-odd numbers\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    even_count = sum(1 for x in lst if x % 2 == 0)\n    odd_count = len(lst) - even_count\n    return (even_count * (even_count - 1)) // 2 + (odd_count * (odd_count - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    # Count the number of even and odd numbers in the list\n    even_count = sum(1 for x in lst if x % 2 == 0)\n    odd_count = len(lst) - even_count  # Remaining are odd\n    \n    # Pairs of even numbers XOR to even\n    even_pairs = even_count * (even_count - 1) // 2\n    # Pairs of odd numbers XOR to even\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    # Total pairs that XOR to even\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 88.0, "profiled": [{"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, low, high):\n    \"\"\"\n    Write a function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    return sum(lst[low:high+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Returns the sum of numbers in a list within a range specified by two indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index.\n    end_idx (int): The ending index.\n\n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Returns the sum of the elements in lst from index start to index end (inclusive).\n    \"\"\"\n    return sum(lst[start:end+1])\nlst = [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12]", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Returns the sum of elements in lst between start_idx and end_idx inclusive.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Returns the sum of numbers in lst from start_idx to end_idx inclusive.\n\n    Parameters:\n        lst (list): The list of numbers.\n        start_idx (int): The starting index (inclusive).\n        end_idx (int): The ending index (inclusive).\n\n    Returns:\n        int/float: Sum of elements from start_idx to end_idx.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"Returns the sum of numbers in the list from index 'start' to index 'end' inclusive.\"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Returns the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start (int): The starting index.\n    end (int): The ending index.\n\n    Returns:\n    int: The sum of the numbers from index 'start' to index 'end' inclusive.\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    return sum(lst[start_idx:end_idx+1])\nlst = [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12]", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Returns the sum of the elements in lst from start_idx to end_idx inclusive.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index.\n    end_idx (int): The ending index.\n\n    Returns:\n    int or float: The sum of the specified range in the list.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Returns the sum of numbers in lst between start_idx and end_idx inclusive.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index of the range.\n    end_idx (int): The ending index of the range.\n\n    Returns:\n    int: The sum of the numbers in the specified range.\n\n    Example:\n    >>> sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10)\n    29\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Returns the sum of elements in lst from start_idx to end_idx inclusive.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of elements in lst from start_index to end_index (inclusive).\n    \"\"\"\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in 'lst' from 'start_index' to 'end_index' (inclusive).\n    \"\"\"\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Returns the sum of numbers in the list 'lst' from 'start_idx' to 'end_idx' inclusive.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Write a function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Sums the elements of a list from start_idx to end_idx (inclusive).\n\n    Parameters:\n    lst (list): The list of numbers.\n    start_idx (int): The starting index.\n    end_idx (int): The ending index.\n\n    Returns:\n    int: The sum of the specified range of elements in the list.\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 92.75193798449612, "dps_norm": 92.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"Remove the characters which have odd index values of a given string.\"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"Remove characters with odd index values from the given string.\"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values of a given string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values of a given string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values of a given string.\n\n    :param s: Input string\n    :return: String with characters at even indices\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(s, c):\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    # Replace blank spaces with the specified character\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces all blank spaces in the string `s` with the character `c`.\n\n    Parameters:\n    s (str): The original string.\n    c (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by `c`.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the input string 's' with the specified character 'char'.\n    \n    Parameters:\n    s (str): The original string.\n    char (str): The character to replace spaces with.\n    \n    Returns:\n    str: The modified string with spaces replaced by 'char'.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replace all blank spaces in the string `s` with the character `char`.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces blank spaces in the string s with the character c.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces blank spaces in the string s with character c and returns the modified string.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replace all blank spaces in the string `s` with the character `char`.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces all blank spaces in the string s with character c.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to replace spaces with.\n\n    Returns:\n    str: The resulting string with spaces replaced by c.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces blank spaces in the string s with the character c, and returns the new string.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces blank spaces in the string s with the character c.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces blank spaces in the string s with the character c.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 88.44827586206897, "dps_norm": 86.5, "pass@1": 74.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    memo = {}\n\n    def dfs(prev, pos):\n        if pos > n:\n            return 1  # A valid sequence is found\n        if (prev, pos) in memo:\n            return memo[(prev, pos)]\n        min_next = 2 * prev\n        if min_next > m:\n            memo[(prev, pos)] = 0  # No valid sequence can be formed further\n            return 0\n        total = 0\n        # Since next values double at least, we can explore them exponentially\n        next_val = min_next\n        while next_val <= m:\n            total += dfs(next_val, pos + 1)\n            next_val += 1  # Alternatively, you can adjust the increment to optimize further\n        memo[(prev, pos)] = total\n        return total\n\n    total_sequences = 0\n    # Possible starting values are from 1 to m\n    for start in range(1, m + 1):\n        total_sequences += dfs(start, 2)\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(prev, pos):\n        if pos > n:\n            return 1\n        # Minimum value for the next element\n        next_min = 2 * prev\n        # If the minimum possible next value exceeds m, no further sequences can be formed\n        if next_min > m:\n            return 0\n        # Number of possible next elements\n        count = m - next_min + 1\n        # Total sequences by considering all possible next elements\n        total = 0\n        for next_val in range(next_min, m + 1):\n            total += count_sequences(next_val, pos + 1)\n        return total\n\n    # Total sequences by considering all possible starting values\n    total_sequences = 0\n    # The maximum possible starting value for a_1\n    max_start = m // (2 ** (n - 1))\n    for start in range(1, max_start + 1):\n        total_sequences += count_sequences(start, 2)\n    return total_sequences", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of sequences of length n such that each element is a positive integer,\n    is greater than or equal to twice the previous element, and is less than or equal to m.\n    \"\"\"\n    if n == 0 or m == 0:\n        return 0\n\n    dp = [1] * (m + 1)  # dp[prev_element] = number of sequences ending with prev_element\n\n    for _ in range(1, n):  # Build sequences of length n\n        cs = [0] * (m + 1)  # Cumulative sum array\n        total = 0\n        for k in range(1, m + 1):\n            total += dp[k]\n            cs[k] = total\n\n        new_dp = [0] * (m + 1)\n        for k in range(1, m + 1):\n            prev_max = k // 2\n            new_dp[k] = cs[prev_max]\n        dp = new_dp\n\n    return sum(dp[1:])", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def dfs(x, pos):\n        if pos == n:\n            # Reached the desired sequence length\n            return 1\n        total = 0\n        min_next = max(2 * x, 1)\n        max_next = m\n        # Generate possible next elements\n        for next_x in range(min_next, max_next + 1):\n            total += dfs(next_x, pos + 1)\n        return total\n\n    total_sequences = 0\n    # Possible starting elements\n    for x1 in range(1, m + 1):\n        total_sequences += dfs(x1, 1)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [ [0] * (m + 2) for _ in range(n + 2) ]  # Extra space to avoid index errors\n    for s_i in range(1, m + 1):\n        dp[n][s_i] = 1\n    for depth in range(n -1, 0, -1):\n        prefix_sums = [0] * (m + 2)  # Extra space for ease of calculation\n        # Build prefix sums from the end to the start\n        for s_i in range(m, 0, -1):\n            prefix_sums[s_i] = prefix_sums[s_i + 1] + dp[depth + 1][s_i]\n        for s_i in range(1, m + 1):\n            min_next = 2 * s_i\n            if min_next > m:\n                dp[depth][s_i] = 0\n            else:\n                dp[depth][s_i] = prefix_sums[min_next]\n    total_sequences = sum(dp[1][1:m+1])\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [ [0] * (m +1) for _ in range(n +2)]\n    for prev in range(1, m +1):\n        dp[n][prev] = 1\n    for pos in range(n -1, 0, -1):\n        cum = [0] * (m +2)\n        for prev in range(m, 0, -1):\n            cum[prev] = cum[prev +1] + dp[pos +1][prev]\n        for prev in range(1, m +1):\n            low = 2 * prev\n            if low > m:\n                dp[pos][prev] = 0\n            else:\n                dp[pos][prev] = cum[low]\n    total_sequences = sum(dp[1][prev] for prev in range(1, m +1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [ [0]*(m+1) for _ in range(n+1) ]  # dp[i][x] = number of sequences of length i ending with x\n    prefix_sum = [ [0]*(m+1) for _ in range(n+1) ]  # prefix_sum[i][x] = sum of dp[i][1] to dp[i][x]\n\n    # Initialize the base case: sequences of length 1\n    for x in range(1, m+1):\n        dp[1][x] = 1\n\n    # Compute prefix sums for dp[1]\n    prefix_sum[1][0] = 0\n    for x in range(1, m+1):\n        prefix_sum[1][x] = prefix_sum[1][x-1] + dp[1][x]\n\n    # Build the DP table\n    for i in range(2, n+1):\n        prefix_sum[i][0] = 0\n        for x in range(1, m+1):\n            k = x // 2  # Previous element must be less than or equal to x // 2\n            dp[i][x] = prefix_sum[i-1][k]\n            prefix_sum[i][x] = prefix_sum[i][x-1] + dp[i][x]\n\n    # Total sequences are the sum of all sequences of length n\n    total_sequences = sum(dp[n][1:])\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [ [0] * (m + 2) for _ in range(n + 2) ]\n    for x in range(1, m + 1):\n        dp[n][x] = 1  # Base case\n\n    for i in range(n - 1, 0, -1):\n        cumulative_sums = [0] * (m + 2)\n        cumulative_sums[m + 1] = 0\n        for x in range(m, 0, -1):\n            cumulative_sums[x] = dp[i + 1][x] + cumulative_sums[x + 1]\n\n        for x in range(1, m + 1):\n            if 2 * x <= m:\n                dp[i][x] = cumulative_sums[2 * x]\n            else:\n                dp[i][x] = 0\n\n    total_sequences = sum(dp[1][1:m + 1])\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(current_value, remaining_length):\n        if remaining_length == 0:\n            return 1\n        min_next = 2 * current_value\n        if min_next > m:\n            return 0\n        max_next = m\n        total = 0\n        # Since the next element can be any value from min_next to m,\n        # and the sequence must be strictly non-decreasing (as each element is at least double),\n        # we can iterate over possible next elements efficiently.\n        for next_value in range(min_next, max_next + 1):\n            total += count_sequences(next_value, remaining_length - 1)\n        return total\n\n    total_sequences = 0\n    # Iterate over all possible starting values\n    for starting_value in range(1, m + 1):\n        total_sequences += count_sequences(starting_value, n - 1)\n\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    \"\"\"\n    dp_prev = [1] * (m + 1)  # Initialize dp for sequences of length 1\n    for l in range(2, n + 1):\n        dp_sum = [0] * (m + 2)\n        # Compute cumulative sums from m down to 1\n        for k in range(m, 0, -1):\n            dp_sum[k] = dp_prev[k] + dp_sum[k + 1]\n        dp_curr = [0] * (m + 1)\n        # Calculate the number of sequences of length l starting from k\n        for k in range(1, m + 1):\n            next_k = 2 * k\n            if next_k > m:\n                dp_curr[k] = 0\n            else:\n                dp_curr[k] = dp_sum[next_k]\n        dp_prev = dp_curr  # Update dp_prev for the next iteration\n    total_sequences = sum(dp_prev[1:])\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n\n    from collections import defaultdict\n\n    positions = [{} for _ in range(n)]\n\n    # For position 0, sequences starting with each number from 1 to m\n    positions[0] = {i: 1 for i in range(1, m+1)}  # prev_value : count\n\n    for pos in range(1, n):\n        prev_values = positions[pos -1]  # dict of prev_value: count\n        current_values = defaultdict(int)\n\n        for prev_value, count in prev_values.items():\n            min_next = 2 * prev_value\n            if min_next > m:\n                continue\n            max_next = m\n            # Since next_value >= 2 * prev_value and <= m\n            # All next_values in the range [min_next, m] are valid\n            # Total number of next_values: m - min_next +1\n            # They all inherit the count from prev_value\n            total_next_values = m - min_next +1\n            current_values[min_next] += count  # Start from min_next\n            if total_next_values >1:\n                # Need to distribute count to all next_values\n                # But since they all have the same count, we can accumulate\n                # Or we can update counts individually (below is safe but may be slower)\n                for next_value in range(min_next +1, m+1):\n                    current_values[next_value] += count\n\n        positions[pos] = current_values\n\n        if not current_values:\n            break  # No more sequences possible\n\n    total_sequences = sum(positions[n -1].values()) if positions[n -1] else 0\n\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    # Precompute the maximum starting value of a1.\n    # Because ai >= 2 * a_{i-1}, the minimal value of ai at position i is a1 * (2 ** (i - 1))\n    # So, to have a sequence of length n, a1 must be <= m // (2 ** (n - 1))\n    max_a1 = m // (1 << (n - 1))\n    total_sequences = 0\n\n    @lru_cache(None)\n    def dfs(prev_value, pos):\n        if pos == n:\n            return 1  # Reached sequence of length n\n        min_ai = 2 * prev_value\n        if min_ai > m:\n            return 0  # Cannot proceed further\n        total = 0\n        # Since prev_value increases exponentially, the number of unique prev_values is small\n        for ai in range(min_ai, m + 1):\n            total += dfs(ai, pos + 1)\n        return total\n\n    for a1 in range(1, max_a1 + 1):\n        total_sequences += dfs(a1, 1)\n\n    return total_sequences", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of sequences of length n, where each element\n    is a positive integer greater than or equal to twice the previous element,\n    and less than or equal to m.\n    \"\"\"\n    # Edge case: if n is 0 or m is less than 1, there are no sequences\n    if n == 0 or m < 1:\n        return 0\n\n    # Initialize the dynamic programming table\n    dp = [[0] * (m + 1) for _ in range(n)]\n    # Base case: For sequences of length 1, there's 1 sequence for each value from 1 to m\n    for curr in range(1, m + 1):\n        dp[0][curr] = 1\n\n    # Build the DP table\n    for i in range(1, n):\n        # Compute the prefix sums for dp[i - 1] to optimize computation\n        prefix_sums = [0] * (m + 1)\n        prefix_sums[0] = 0\n        for curr in range(1, m + 1):\n            prefix_sums[curr] = prefix_sums[curr - 1] + dp[i - 1][curr]\n\n        # Update dp[i] using the optimized formula\n        for curr in range(1, m + 1):\n            prev_limit = curr // 2\n            dp[i][curr] = prefix_sums[prev_limit]\n\n    # Sum up the sequences of length n\n    total_sequences = sum(dp[n - 1][1:])\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [ [0]*(m+2) for _ in range(n+1) ]  # dp[k][x]: sequences of length k starting with x\n    # Base case: sequences of length n with any starting value x\n    for x in range(1, m+1):\n        dp[n][x] = 1\n\n    # Build dp table from length n-1 down to 1\n    for k in range(n-1, 0, -1):\n        # Compute cumulative sums of dp[k+1] to optimize the inner loop\n        cumsum = [0]*(m+2)\n        for x in range(m, 0, -1):\n            cumsum[x] = dp[k+1][x] + cumsum[x+1]\n        # Calculate dp[k][x] using cumsum to avoid O(m) inner loop\n        for x in range(1, m+1):\n            start = 2 * x\n            if start > m:\n                dp[k][x] = 0\n            else:\n                dp[k][x] = cumsum[start]\n    # Total number of sequences is the sum of dp[1][x] for all valid starting x\n    total_sequences = sum(dp[1][x] for x in range(1, m+1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n    import sys\n    sys.setrecursionlimit(1 << 25)\n\n    @lru_cache(maxsize=None)\n    def dfs(pos, prev):\n        if pos == n:\n            return 1\n        total = 0\n        min_curr = 2 * prev\n        if min_curr > m:\n            return 0\n        max_curr = m\n        total += max_curr - min_curr + 1\n        total_sequences = 0\n        for next_val in range(min_curr, max_curr +1):\n            total_sequences += dfs(pos + 1, next_val)\n        return total_sequences\n\n    total_sequences = 0\n    for first in range(1, m +1):\n        total_sequences += dfs(1, first)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [1] * (m + 1)  # Base case for sequences of length n\n    for _ in range(n - 1):\n        new_dp = [0] * (m + 2)\n        cumulative_sum = [0] * (m + 2)\n        # Compute cumulative sums\n        for v in range(1, m + 1):\n            cumulative_sum[v] = cumulative_sum[v - 1] + dp[v]\n        # Update dp for sequences of length i\n        for v in range(1, m + 1):\n            if 2 * v > m:\n                new_dp[v] = 0\n            else:\n                new_dp[v] = cumulative_sum[m] - cumulative_sum[2 * v - 1]\n        dp = new_dp\n    return sum(dp[1:m + 1])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    memo = {}\n    def count_sequences(pos, prev_value):\n        # Base case: if we've built a sequence of length n, count it\n        if pos > n:\n            return 1\n        # Memoization check\n        if (pos, prev_value) in memo:\n            return memo[(pos, prev_value)]\n        total = 0\n        # The next value must be at least twice the previous and at most m\n        min_next_value = 2 * prev_value\n        if min_next_value > m:\n            memo[(pos, prev_value)] = 0\n            return 0\n        max_next_value = m\n        # Recursively count sequences for all possible next values\n        for next_value in range(min_next_value, max_next_value + 1):\n            total += count_sequences(pos + 1, next_value)\n        memo[(pos, prev_value)] = total\n        return total\n    # Initial sequences can start with any value from 1 to m\n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(2, start_value)\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    from sys import setrecursionlimit\n    setrecursionlimit(1 << 25)  # Increase recursion limit if needed\n    memo = {}\n\n    def f(x, l):\n        if l == n:\n            # If we've reached the required length, return 1 sequence\n            return 1\n        if (x, l) in memo:\n            # Return memoized result if available\n            return memo[(x, l)]\n        total = 0\n        for y in range(2 * x, m + 1):\n            # For each valid next element, add the number of sequences starting from it\n            total += f(y, l + 1)\n        memo[(x, l)] = total  # Memoize the result\n        return total\n\n    total_sequences = 0\n    for x in range(1, m + 1):\n        # Start sequences with all possible starting elements\n        total_sequences += f(x, 1)\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(pos, prev_value):\n        if pos == n:\n            # Reached the required length\n            return 1\n        total = 0\n        # Next value must be at least twice the prev_value and less than or equal to m\n        # Since prev_value can be 0 when starting, we handle the initial case separately\n        start = 2 * prev_value if prev_value > 0 else 1\n        for next_value in range(start, m + 1):\n            total += count_sequences(pos + 1, next_value)\n        return total\n\n    # We start with position 0 and previous value 0 (to handle starting value)\n    return count_sequences(0, 0)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n,\n    such that each element is a positive integer and is greater than or equal to twice the previous element but less\n    than or equal to m.\n    \"\"\"\n    import bisect\n\n    dp = {}  # dp[level][x]: number of sequences of length 'level' starting with x\n    x_values = {}  # x_values[level]: sorted list of x's at level 'level'\n\n    # Initialize level 1\n    dp[1] = [1] * (m + 1)  # dp[1][x] = 1 for x from 1 to m\n    x_values[1] = list(range(1, m + 1))\n\n    max_level = n\n\n    for level in range(2, max_level + 1):\n        dp_prev = dp[level - 1]\n        x_values_prev = x_values[level - 1]\n\n        # Prepare dp[level] and x_values[level]\n        dp_current = {}\n        x_values_current = []\n        dp_values = []\n        xs = []\n\n        # Build prefix sums over dp_prev\n        # We need to map x_values_prev to dp_prev[x]\n        dp_prev_values = [dp_prev[x] for x in x_values_prev]\n        # Build cumulative sums in reverse order for efficient calculation\n        cum_sums = [0] * (len(dp_prev_values) + 1)\n        for i in range(len(dp_prev_values) - 1, -1, -1):\n            cum_sums[i] = dp_prev_values[i] + cum_sums[i + 1]\n\n        for x in range(1, m + 1):\n            min_y = 2 * x\n            idx = bisect.bisect_left(x_values_prev, min_y)\n            if idx >= len(x_values_prev):\n                continue  # No y >= 2x exists in x_values_prev\n            dp_x = cum_sums[idx]\n            if dp_x == 0:\n                continue\n            dp_current[x] = dp_x\n            x_values_current.append(x)\n            dp_values.append(dp_x)\n            xs.append(x)\n\n        if not dp_current:\n            break  # No more sequences possible at this level\n        dp[level] = dp_current\n        x_values[level] = x_values_current\n\n    # Sum up the total number of sequences of length n\n    total_sequences = sum(dp.get(max_level, {}).values())\n    return total_sequences", "matching_cluster_idx": 9}]}, "Mbpp/240": {"dps": 53.048780487804876, "dps_norm": 68.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(lst1, lst2):\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    If list1 is empty, returns list2.\n    \"\"\"\n    if not list1:\n        return list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \"\"\"\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with the elements of lst2.\n    \"\"\"\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list_a, list_b):\n    \"\"\"\n    Replace the last element of list_a with the elements of list_b.\n    \"\"\"\n    return list_a[:-1] + list_b", "matching_cluster_idx": 5}, {"solution": "def replace_list(l1, l2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    return l1[:-1] + l2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with the elements of list2.\n    \n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The first list, whose last element will be replaced.\n    list2 (list): The second list, whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n\n    Example:\n    >>> replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8])\n    [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with the elements of lst2.\n    \"\"\"\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with all elements from lst2.\n    \"\"\"\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n    Example:\n    assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(l1, l2):\n    \"\"\"\n    Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    return l1[:-1] + l2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements of list2.\n\n    Parameters:\n    list1 (list): The original list whose last element will be replaced.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    return list1[:-1] + list2", "matching_cluster_idx": 5}]}, "Mbpp/251": {"dps": 53.47701149425288, "dps_norm": 71.11111111111111, "pass@1": 98.0, "profiled": [{"solution": "def insert_element(lst, elem):\n    return [sub_item for item in lst for sub_item in (elem, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts 'element' before each item in 'lst' and returns the new list.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    return [x for item in lst for x in (elem, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, elem):\n    return [e for item in lst for e in [elem, item]]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    return [x for pair in zip([element]*len(lst), lst) for x in pair]", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    return [x for item in lst for x in (elem, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts 'elem' before each element in 'lst' and returns the resulting list.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    return [x for item in lst for x in (elem, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n    assert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts an element before each element in the given list.\n    \n    Parameters:\n    lst (list): The original list.\n    elem: The element to insert before each item in the list.\n    \n    Returns:\n    list: A new list with the element inserted before each original item.\n    \"\"\"\n    n = len(lst)\n    result = [None] * (2 * n)\n    for i in range(n):\n        result[2 * i] = elem\n        result[2 * i + 1] = lst[i]\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts `element` before each element in `lst` and returns the resulting list.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the element 'elem' before each element in the list 'lst' and returns the resulting list.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    lst (list): The original list of elements.\n    elem (any): The element to insert before each element of the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    return [x for item in lst for x in (elem, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    return [x for item in lst for x in (element, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, elem):\n    return [item for pair in zip([elem]*len(lst), lst) for item in pair]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, elem):\n    return [e for item in lst for e in (elem, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n    assert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    \"\"\"\n    return [x for item in lst for x in (elem, item)]", "matching_cluster_idx": 5}]}, "Mbpp/256": {"dps": 97.45433789954338, "dps_norm": 89.70588235294117, "pass@1": 100.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a list to track prime numbers\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    # Implement Sieve of Eratosthenes\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            sieve[i*i:n:i] = [False] * len(sieve[i*i:n:i])\n\n    # Count the number of primes less than n\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative integer n.\n    \n    :param n: A non-negative integer\n    :return: The count of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0  # There are no prime numbers less than 2\n\n    # Initialize a list to track prime numbers\n    is_prime = [True] * n\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not prime numbers\n\n    # Use the Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            is_prime[i * i:n:i] = [False] * len(is_prime[i * i:n:i])\n\n    # Count the number of primes found\n    return sum(is_prime)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    Example:\n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 2:\n        return 0\n    # Initialize a list to track prime status of numbers from 0 to n-1\n    is_prime = [True] * n\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n\n    # Use Sieve of Eratosthenes to eliminate non-primes\n    for p in range(2, int(n ** 0.5) + 1):\n        if is_prime[p]:\n            for multiple in range(p * p, n, p):\n                is_prime[multiple] = False\n\n    # Count the number of primes less than n\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than n.\n    \"\"\"\n    if n <= 2:\n        return 0\n    # Initialize sieve: True means the number is assumed to be prime\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    # Sieve of Eratosthenes algorithm\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as non-prime\n            sieve[i*i:n:i] = [False] * len(range(i*i, n, i))\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a boolean array where index represents the number\n    # True means the number is assumed to be prime initially\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not prime numbers\n\n    # Implement Sieve of Eratosthenes\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i * i, n, i):\n                sieve[j] = False\n\n    # Count the number of primes less than n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        # There are no prime numbers less than 2\n        return 0\n    \n    # Initialize a list to track prime status of numbers from 0 to n-1\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not primes\n    \n    # Use the Sieve of Eratosthenes algorithm to identify primes\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            # Set multiples of i starting from i*i to False\n            is_prime[i*i:n:i] = [False] * len(is_prime[i*i:n:i])\n    \n    # Count and return the number of primes less than n\n    return sum(is_prime)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    # Initialize a list to track prime status of numbers from 0 to n-1\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not primes\n\n    # Use Sieve of Eratosthenes to identify primes\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for multiple in range(i * i, n, i):\n                is_prime[multiple] = False\n\n    # Count and return the number of prime numbers less than n\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to track prime status of numbers less than n\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Implement Sieve of Eratosthenes\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as not prime\n            is_prime[i*i:n:i] = [False] * len(is_prime[i*i:n:i])\n    \n    # Count and return the number of primes found\n    return sum(is_prime)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Return the number of prime numbers less than a non-negative integer n.\n    \"\"\"\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not prime numbers\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                sieve[j] = False\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not primes\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            is_prime[i*i:n:i] = [False] * len(is_prime[i*i:n:i])\n\n    return sum(is_prime)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative integer n.\n    Uses the Sieve of Eratosthenes algorithm for efficient computation.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a boolean list to track prime numbers\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    # Iterate over each number up to the square root of n\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i * i, n, i):\n                sieve[j] = False\n\n    # Count the number of primes less than n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Return the number of prime numbers less than a non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n    # Initialize a boolean array \"sieve\" of length n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    # Implement Sieve of Eratosthenes\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            # Set multiples of i starting from i*i to False\n            for j in range(i * i, n, i):\n                sieve[j] = False\n\n    # Count and return the number of primes\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\" Counts the number of prime numbers less than n \"\"\"\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n    for p in range(2, int(n ** 0.5) + 1):\n        if sieve[p]:\n            # Mark multiples of p as non-prime\n            for multiple in range(p * p, n, p):\n                sieve[multiple] = False\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for p in range(2, int(n**0.5) + 1):\n        if sieve[p]:\n            for multiple in range(p * p, n, p):\n                sieve[multiple] = False\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    # Initialize a list to track prime status of numbers from 0 to n-1\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Implement Sieve of Eratosthenes\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for multiple in range(i * i, n, i):\n                is_prime[multiple] = False\n\n    # Count and return the number of primes less than n\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 2:\n        return 0\n    upper_limit = int(n) + (1 if n > int(n) else 0)\n    is_prime = [True] * upper_limit\n    is_prime[0:2] = [False, False]  # 0 and 1 are not primes\n    for i in range(2, int(upper_limit ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, upper_limit, i):\n                is_prime[j] = False\n    # Count primes less than n\n    count = sum(1 for m in range(2, upper_limit) if is_prime[m] and m < n)\n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than n.\n    \"\"\"\n    if n <= 2:\n        return 0\n    # Initialize a list to track prime status of numbers from 0 to n-1\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not primes\n\n    # Implement Sieve of Eratosthenes\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for multiple in range(i * i, n, i):\n                is_prime[multiple] = False\n\n    # Count the number of primes less than n\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 2:\n        return 0\n    # Initialize a list to track prime numbers\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not prime numbers\n    \n    # Implement Sieve of Eratosthenes\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i * i, n, i):\n                sieve[j] = False\n                \n    # Count the number of prime numbers less than n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array where index represents number and value represents primality\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not prime numbers\n    \n    # Only need to consider factors up to the square root of n\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            # Mark multiples of i as non-prime\n            for multiple in range(i*i, n, i):\n                sieve[multiple] = False\n                \n    # Count the number of primes less than n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0], sieve[1] = False, False  # 0 and 1 are not primes\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            for multiple in range(i*i, n, i):\n                sieve[multiple] = False\n    return sum(sieve)", "matching_cluster_idx": 14}]}, "Mbpp/265": {"dps": 70.93023255813954, "dps_norm": 83.33333333333333, "pass@1": 98.0, "profiled": [{"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n lists, where each new list contains every n-th element from the original list,\n    starting from different offsets.\n\n    :param lst: The original list to split.\n    :param n: The interval at which to split the list.\n    :return: A list of n lists containing the split elements.\n    \"\"\"\n    groups = [[] for _ in range(n)]\n    for i, elem in enumerate(lst):\n        groups[i % n].append(elem)\n    return groups\nlst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n lists, where each list contains every nth element of the original list.\n\n    Parameters:\n    - lst: The list to split.\n    - n: The interval at which to split the list.\n\n    Returns:\n    - A list of n lists, containing the split elements.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for idx, elem in enumerate(lst):\n        result[idx % n].append(elem)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for index, item in enumerate(lst):\n        result[index % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Write a function that takes in a list and an integer n and splits a list for every nth element,\n    returning a list of the resulting lists.\n    assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(L, n):\n    return [L[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n lists, with elements distributed cyclically.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for idx, item in enumerate(lst):\n        result[idx % n].append(item)\n    return result\nlst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]\nlst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, where each sublist contains every nth element starting from a different offset.\n\n    Parameters:\n    lst (list): The input list to split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list containing n sublists.\n\n    Example:\n    >>> list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3)\n    [['a', 'd', 'g'], ['b', 'e'], ['c', 'f']]\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for idx, val in enumerate(lst):\n        result[idx % n].append(val)\n    return result\nlst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the list into n sublists, where each sublist contains every nth element starting from offset i (0 <= i < n).\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for idx, elem in enumerate(lst):\n        result[idx % n].append(elem)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(the_list, n):\n    result = [[] for _ in range(n)]\n    for index, element in enumerate(the_list):\n        result[index % n].append(element)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[k::n] for k in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(input_list):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Returns True if all elements in the list are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in the list are unique.\n    \n    Args:\n        lst (list): The list to check.\n        \n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in the list are unique.\n    Returns True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list of elements to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Returns True if all elements in the list are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Return True if all elements in the list are unique, False otherwise.\"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array using a modified merge sort.\n    \"\"\"\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums, 0\n        else:\n            mid = len(nums) // 2\n            left, inv_left = merge_sort(nums[:mid])\n            right, inv_right = merge_sort(nums[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        # Merge the two sorted halves and count inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # Count inversions\n                j += 1\n        # Append remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array.\n    An inversion is when arr[i] > arr[j] and i < j.\n    This function uses a modified merge sort algorithm for O(n log n) efficiency.\n    \"\"\"\n    # Make a copy of the array to avoid modifying the original array\n    arr_copy = list(arr)\n    return _merge_sort(arr_copy, 0, len(arr_copy) - 1)\ndef _merge_sort(arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        # Count inversions in the left half\n        inv_count += _merge_sort(arr, left, mid)\n        # Count inversions in the right half\n        inv_count += _merge_sort(arr, mid + 1, right)\n        # Count split inversions while merging\n        inv_count += _merge(arr, left, mid, right)\n    return inv_count\ndef _merge(arr, left, mid, right):\n    inv_count = 0\n    # Create temporary arrays\n    left_sub = arr[left:mid + 1]\n    right_sub = arr[mid + 1:right + 1]\n\n    i = 0  # Index for left_sub\n    j = 0  # Index for right_sub\n    k = left  # Index for merged array\n\n    while i < len(left_sub) and j < len(right_sub):\n        if left_sub[i] <= right_sub[j]:\n            arr[k] = left_sub[i]\n            i += 1\n        else:\n            arr[k] = right_sub[j]\n            j += 1\n            inv_count += (len(left_sub) - i)  # Count inversions\n        k += 1\n\n    # Copy any remaining elements of left_sub\n    while i < len(left_sub):\n        arr[k] = left_sub[i]\n        i += 1\n        k += 1\n\n    # Copy any remaining elements of right_sub\n    while j < len(right_sub):\n        arr[k] = right_sub[j]\n        j += 1\n        k += 1\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array arr.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0  # Base case: a single element has zero inversions\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inversions = 0\n        # Merge the two halves while counting inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inversions += len(left) - i  # Count inversions\n                j += 1\n        # Append the remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inversions\n\n    # Call the merge_sort function and return the inversion count\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Write a python function to count inversions in an array.\n    \"\"\"\n    n = len(arr)\n    temp_arr = [0]*n\n    return _mergeSort(arr, temp_arr, 0, n - 1)\ndef _mergeSort(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        # Inversion count will be sum of inversions in left-part, right-part\n        # and number of inversions in merging\n        inv_count += _mergeSort(arr, temp_arr, left, mid)\n        inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n\n        # Merge the two parts and add inversion count\n        inv_count += _merge(arr, temp_arr, left, mid, right)\n    return inv_count\ndef _merge(arr, temp_arr, left, mid, right):\n    i = left       # Starting index of left subarray\n    j = mid + 1    # Starting index of right subarray\n    k = left       # Starting index of to be sorted subarray\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # Inversion will occur\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray into temp array\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray into temp array\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for index in range(left, right + 1):\n        arr[index] = temp_arr[index]\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge(left, right):\n        i, j = 0, 0\n        inv_count = 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inv = merge_sort(arr)\n    return total_inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array using a modified merge sort algorithm.\n    \"\"\"\n    def merge_sort(arr):\n        return merge_sort_recursive(arr, 0, len(arr) - 1)\n    \n    def merge_sort_recursive(arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort_recursive(arr, left, mid)\n            inv_count += merge_sort_recursive(arr, mid + 1, right)\n            inv_count += merge(arr, left, mid, right)\n        return inv_count\n\n    def merge(arr, left, mid, right):\n        inv_count = 0\n        # Create temp arrays\n        L = arr[left:mid + 1]\n        R = arr[mid + 1:right + 1]\n        i = 0  # Index for left subarray\n        j = 0  # Index for right subarray\n        k = left  # Index for merged array\n\n        # Merge the temp arrays back into arr[left:right + 1]\n        while i < len(L) and j < len(R):\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                inv_count += (len(L) - i)  # All remaining elements in L[i:] are inversions\n                j += 1\n            k += 1\n\n        # Copy any remaining elements of L[]\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        # Copy any remaining elements of R[]\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\n        return inv_count\n\n    # Make a copy of arr to preserve the original array\n    arr_copy = list(arr)\n    return merge_sort(arr_copy)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Helper function to perform merge sort and count inversions\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0  # Base case: single element has zero inversions\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])    # Sort left half and count inversions\n        right, inv_right = merge_sort(arr[mid:])  # Sort right half and count inversions\n        merged, inv_split = merge(left, right)    # Merge two halves and count split inversions\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    # Helper function to merge two sorted arrays and count split inversions\n    def merge(left, right):\n        i = j = inv_count = 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        # Append remaining elements (no additional inversions)\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    # Call the merge_sort function and return the inversion count\n    _, inversion_count = merge_sort(arr)\n    return inversion_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            total_inversions = inv_left + inv_right + inv_split\n            return merged, total_inversions\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in the array using a modified merge sort.\n    \"\"\"\n\n    def merge_sort(arr):\n        # Base case\n        if len(arr) <= 1:\n            return arr, 0\n\n        # Split the array into two halves\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        # Sort and count inversions in the left half\n        left_sorted, left_inv = merge_sort(left)\n        # Sort and count inversions in the right half\n        right_sorted, right_inv = merge_sort(right)\n        # Merge the two halves and count cross inversions\n        merged_arr, cross_inv = merge_and_count(left_sorted, right_sorted)\n\n        # Total inversions is sum of inversions in left, right, and cross inversions\n        total_inv = left_inv + right_inv + cross_inv\n\n        return merged_arr, total_inv\n\n    def merge_and_count(left, right):\n        \"\"\"\n        Merge two sorted arrays and count the cross inversions.\n        \"\"\"\n        i = j = inversions = 0\n        merged = []\n\n        # Merge the two arrays and count inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                # All remaining elements in left[i:] will form inversions with right[j]\n                inversions += len(left) - i\n                j += 1\n\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged, inversions\n\n    # Call the merge_sort function and get the inversion count\n    _, inversion_count = merge_sort(arr)\n    return inversion_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Write a python function to count inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    This function uses a modified merge sort algorithm to count inversions efficiently in O(n log n) time.\n\n    Example:\n    assert get_Inv_Count([1, 20, 6, 4, 5]) == 5\n    \"\"\"\n\n    def merge_sort(arr):\n        # Base case: a list of zero or one elements is already sorted, no inversions\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            # Divide the array into two halves\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            # Merge the two halves and count split inversions\n            merged, inv_split = merge_and_count(left, right)\n            # Total inversions is sum of inversions in left half, right half, and split inversions\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge_and_count(left, right):\n        merged = []\n        inv_count = 0\n        i, j = 0, 0\n        # Merge the two sorted halves and count inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                # No inversion, as left[i] <= right[j]\n                merged.append(left[i])\n                i += 1\n            else:\n                # Inversion found: left[i] > right[j]\n                merged.append(right[j])\n                # All remaining elements in left[i:] will be greater than right[j]\n                inv_count += (len(left) - i)\n                j += 1\n        # Append any remaining elements\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    # Start the merge sort and inversion count\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # Count inversions\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array `arr`.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n\n    Parameters:\n    arr (list): List of integers.\n\n    Returns:\n    int: Number of inversions in the array.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst, 0  # Base case: a list of zero or one elements is sorted, with 0 inversions.\n\n        mid = len(lst) // 2\n        left, inv_left = merge_sort(lst[:mid])      # Recursively sort the left half.\n        right, inv_right = merge_sort(lst[mid:])    # Recursively sort the right half.\n\n        merged, inv_split = merge(left, right)      # Merge the two halves and count split inversions.\n\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions.\n                j += 1\n\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged, inv_count\n\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array `arr`.\n\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The total number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        left_len = len(left)\n        right_len = len(right)\n        \n        while i < left_len and j < right_len:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += left_len - i  # Count inversions\n        # Append any remaining elements\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    _, total_inv = merge_sort(arr)\n    return total_inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in the array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # Count inversions\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0  # Array is sorted, inversions are zero\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_merge = merge(left, right)\n            total_inversions = inv_left + inv_right + inv_merge\n            return merged, total_inversions\n\n    def merge(left, right):\n        i = j = inv_count = 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst, 0\n        else:\n            mid = len(lst) // 2\n            left, inv_left = merge_sort(lst[:mid])\n            right, inv_right = merge_sort(lst[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge(left, right):\n        i = j = inv_count = 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # Count inversions\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in the array\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n            \n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i +=1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j +=1\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n    \n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        i = j = inv_count = 0\n        merged = []\n        left_len = len(left)\n        while i < left_len and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += left_len - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0  # No inversions in a single-element array\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge(left, right):\n        i = j = inv_count = 0\n        merged = []\n        # Merge the two halves and count inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, count = merge_sort(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array arr.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        inv_count = 0\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inv = merge_sort(arr)\n    return total_inv", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/392": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 88.0, "profiled": [{"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Recursively compute the sum of f(n//2), f(n//3), f(n//4), f(n//5)\n    sum_parts = (\n        get_max_sum(n // 2, memo)\n        + get_max_sum(n // 3, memo)\n        + get_max_sum(n // 4, memo)\n        + get_max_sum(n // 5, memo)\n    )\n    # Take the maximum between n and the sum of the parts\n    memo[n] = max(n, sum_parts)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n == 0:\n        return 0\n    if n in memo:\n        return memo[n]\n    sum_parts = (get_max_sum(n // 2, memo) +\n                 get_max_sum(n // 3, memo) +\n                 get_max_sum(n // 4, memo) +\n                 get_max_sum(n // 5, memo))\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            memo[n] = 0\n        else:\n            memo[n] = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n        return memo[n]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def f(n):\n        if n == 0:\n            return 0\n        return max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the given equation:\n    f(n) = max( f(n//2) + f(n//3) + f(n//4) + f(n//5), n )\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def f(k):\n        if k == 0:\n            return 0\n        else:\n            # Recursively compute the maximum sum for each division\n            sum_f = f(k // 2) + f(k // 3) + f(k // 4) + f(k // 5)\n            return max(k, sum_f)\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    \n    def max_sum(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        # Recursively compute the sum of f(n//2), f(n//3), f(n//4), and f(n//5)\n        sum_parts = max_sum(n//2) + max_sum(n//3) + max_sum(n//4) + max_sum(n//5)\n        # Choose the maximum between the sum of parts and the original number\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n    \n    return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        memo[0] = 0\n        return 0\n    else:\n        sum_parts = get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo)\n        memo[n] = max(sum_parts, n)\n        return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            result = 0\n        else:\n            result = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        memo[n] = result\n        return result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        else:\n            if n == 0:\n                memo[0] = 0\n                return 0\n            else:\n                # Compute the maximum sum recursively with memoization\n                computed = max(\n                    f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n                memo[n] = computed\n                return computed\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        max_value = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        memo[n] = max_value\n        return max_value\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def helper(n):\n        if n == 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        # Recursively compute the sums for n//2, n//3, n//4, and n//5\n        sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n        # Take the maximum of the computed sum and the current n\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculates the maximum sum possible using the given equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Recursively compute the maximum sum\n    result = max(\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo),\n        n\n    )\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            return 0\n        # Recursively compute the sum and compare with n\n        res = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n        memo[n] = res\n        return res\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x == 0:\n            memo[0] = 0\n            return 0\n        sum_parts = f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5)\n        memo[x] = max(sum_parts, x)\n        return memo[x]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculate the maximum sum possible using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \"\"\"\n    memo = {}\n\n    def helper(n):\n        n = int(n)\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            memo[n] = 0\n            return 0\n        # Recursively calculate the sum of parts\n        sum_parts = (\n            helper(n // 2) +\n            helper(n // 3) +\n            helper(n // 4) +\n            helper(n // 5)\n        )\n        # Take the maximum between the sum of parts and n\n        memo[n] = max(sum_parts, n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \"\"\"\n    cache = {}\n\n    def f(n):\n        if n in cache:\n            return cache[n]\n        if n == 0:\n            return 0\n        # Compute f(n//2), f(n//3), f(n//4), f(n//5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        # Take the maximum between n and the sum of parts\n        res = max(n, sum_parts)\n        cache[n] = res\n        return res\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Recursive function with memoization to compute the maximum sum\n    using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \"\"\"\n    memo = {}\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            result = 0\n        else:\n            # Recursively compute the sum of parts\n            sum_parts = helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)\n            # Choose the maximum between the sum of parts and the original number\n            result = max(sum_parts, n)\n        memo[n] = result\n        return result\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n <= 1:\n        return n\n    if n in memo:\n        return memo[n]\n    max_sum = max(\n        get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5),\n        n\n    )\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        # Base case: when n is 0, the maximum sum is 0\n        if n == 0:\n            return 0\n        # Recursively compute the sums for n//2, n//3, n//4, and n//5\n        sum_parts = helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5)\n        # The maximum sum is either the sum of the parts or the number itself\n        res = max(sum_parts, n)\n        memo[n] = res  # Memoize the result for future reference\n        return res\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            return 0\n        # Calculate the maximum sum\n        result = max(helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5), n)\n        memo[n] = result\n        return result\n    return helper(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import Counter\n    counts = Counter(s)\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import Counter\n    counts = Counter(s)\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for c in s:\n        if char_count[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import Counter\n    counts = Counter(s)\n    for ch in s:\n        if counts[ch] == 1:\n            return ch\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    Returns the character if found, otherwise returns None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Store character counts preserving the order\n    counts = OrderedDict()\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n\n    # Find and return the first character with a count of 1\n    for char, count in counts.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import Counter\n    counts = Counter(s)\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_counts = {}\n    for c in s:\n        char_counts[c] = char_counts.get(c, 0) + 1\n    for c in s:\n        if char_counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import Counter\n    counts = Counter(s)\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Write a python function to find the first non-repeated character in a given string.\n    assert first_non_repeating_character(\"abcabc\") == None\n    \"\"\"\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import Counter\n    char_count = Counter(s)\n    for c in s:\n        if char_count[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import OrderedDict\n    counts = OrderedDict()\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    for c in counts:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import Counter\n    counts = Counter(s)\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import Counter\n    counts = Counter(s)\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for c in s:\n        if char_count[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import Counter\n    count = Counter(s)\n    for ch in s:\n        if count[ch] == 1:\n            return ch\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    Returns the character if found, otherwise returns None.\n    \"\"\"\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # First pass: Count occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Second pass: Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element (any): The element to find.\n\n    Returns:\n    bool: True if the element is in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex\ntuplex = (\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\")", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    - tuplex: The tuple to search.\n    - element: The element to find in the tuple.\n\n    Returns:\n    - True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    elem: The element to find.\n\n    Returns:\n    bool: True if elem is in tup, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 72.39130434782608, "dps_norm": 81.11111111111111, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): First sequence of elements.\n    seq2 (sequence): Second sequence of elements.\n\n    Returns:\n    bool: True if there is any overlapping element, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(s1, s2):\n    s2_set = set(s2)\n    return any(item in s2_set for item in s1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1: First sequence (list, tuple, etc.).\n    seq2: Second sequence.\n\n    Returns:\n    True if there is at least one common element between seq1 and seq2, False otherwise.\n    \"\"\"\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks whether any value in seq1 exists in seq2.\n    Returns True if there is at least one common element, False otherwise.\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): First sequence of elements.\n    seq2 (sequence): Second sequence of elements.\n\n    Returns:\n    bool: True if any element of seq1 is in seq2, False otherwise.\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    Returns True if there is at least one common element, False otherwise.\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(a, b):\n    \"\"\"Check whether any value in sequence a exists in sequence b.\"\"\"\n    set_b = set(b)\n    for element in a:\n        if element in set_b:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): First sequence of elements.\n    seq2 (sequence): Second sequence of elements.\n\n    Returns:\n    bool: True if any element is common to both sequences, False otherwise.\n    \"\"\"\n    # Convert sequences to sets for efficient lookup and perform intersection\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1: First sequence (list, tuple, etc.)\n        seq2: Second sequence (list, tuple, etc.)\n\n    Returns:\n        True if there is at least one common element between seq1 and seq2.\n        False otherwise.\n    \"\"\"\n    set2 = set(seq2)\n    for element in seq1:\n        if element in set2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(a, b):\n    return bool(set(a) & set(b))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    return any(elem in seq2 for elem in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(s1, s2):\n    s2_set = set(s2)\n    return any(item in s2_set for item in s1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"Check whether any value in seq1 exists in seq2.\"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    Returns True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    return any(item in set_seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(a, b):\n    set_b = set(b)\n    return any(item in set_b for item in a)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (sequence): First sequence to check.\n    seq2 (sequence): Second sequence to check.\n\n    Returns:\n    bool: True if any value from seq1 exists in seq2, False otherwise.\n    \"\"\"\n    set2 = set(seq2)  # Convert seq2 to a set for efficient look-up\n    return any(item in set2 for item in seq1)", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 49.135802469135804, "dps_norm": 82.85714285714286, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t):\n    \"\"\"\n    Concatenate each element of the tuple 't' using the '-' delimiter.\n    \"\"\"\n    return '-'.join(str(item) for item in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(e) for e in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tpl):\n    return '-'.join(map(str, tpl))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tuple_data, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple using the specified delimiter.\n    \"\"\"\n    return delimiter.join(str(element) for element in tuple_data)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t):\n    \"\"\"\n    Concatenates each element of the tuple with the '-' delimiter.\n\n    Parameters:\n    t (tuple): The tuple containing elements to concatenate.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return '-'.join(str(item) for item in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(e) for e in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(x) for x in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tpl):\n    return '-'.join(str(item) for item in tpl)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    \"\"\"\n    Concatenate each element of the tuple `t` using '-' as the delimiter.\n    \n    Args:\n        t (tuple): A tuple of elements to concatenate.\n        \n    Returns:\n        str: A string with each element from `t` concatenated by '-'.\n    \"\"\"\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    \"\"\"\n    Concatenate each element of a tuple by the delimiter '-'.\n    Each element is converted to a string before concatenation.\n    \"\"\"\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(e) for e in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}]}, "Mbpp/424": {"dps": 97.5812274368231, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(t):\n    \"\"\"\n    Extract the last character of each string in the tuple.\n    \"\"\"\n    return [s[-1] if s else '' for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    \"\"\"Extracts the last character of each string in the given tuple.\n\n    Args:\n        t (tuple of str): A tuple containing strings.\n\n    Returns:\n        list of str: A list containing the last character of each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(some_tuple):\n    return [s[-1] for s in some_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n    \n    :param strings: Tuple of strings\n    :return: List of last characters\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuples):\n    return [s[-1] for s in tuples]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(sometuple):\n    return [s[-1] for s in sometuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(words):\n    return [word[-1] for word in words]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extract the last character of each string in the given tuple.\"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Parameters:\n    list_of_lists (list of lists): The list of sublists to search.\n    element (any): The element to count occurrences of in sublists.\n\n    Returns:\n    int: The number of sublists that contain the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists (list of lists): The list containing sublists to check.\n        element (any): The element to search for in the sublists.\n\n    Returns:\n        int: The number of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    \"\"\"\n    Counts the number of sublists in lst that contain the element elem.\n    \n    Parameters:\n    lst (list of lists): The list containing sublists to search.\n    elem: The element to look for in the sublists.\n    \n    Returns:\n    int: The count of sublists containing elem.\n    \"\"\"\n    return sum(elem in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Parameters:\n    lst_of_lists (list of lists): The list containing sublists to be searched.\n    element: The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in lst_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    list_of_lists (list of lists): The list of sublists to search through.\n    element: The element to look for in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Parameters:\n    list_of_sublists (list): A list of sublists.\n    element: The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    return sum(element in sublist for sublist in list_of_sublists)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Write a function to count the number of sublists containing a particular element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Parameters:\n    list_of_lists (list of lists): The list containing sublists to search.\n    element (any): The element to count occurrences of in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists in lst that contain the specified element.\n\n    :param lst: List of sublists\n    :param element: Element to search for in sublists\n    :return: Number of sublists containing the element\n    \"\"\"\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Parameters:\n    list_of_lists (list of lists): The list containing sublists to check.\n    element (any): The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    \"\"\"\n    Counts the number of sublists in lst that contain elem.\n\n    Parameters:\n    lst (list of lists): The list containing sublists.\n    elem: The element to search for within sublists.\n\n    Returns:\n    int: The count of sublists containing elem.\n\n    Example:\n    >>> count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1)\n    3\n    \"\"\"\n    return sum(elem in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublst in lst if element in sublst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    return sum(1 for sublist in sublists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    return sum(element in sublist for sublist in list_of_lists)", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a large gap, then reduce the gap until it becomes zero.\n    while gap > 0:\n\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements of the sorted subarray to the right until the correct position is found.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place the element at its correct position.\n            arr[j] = temp\n\n        gap //= 2  # Reduce the gap for the next iteration.\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n    # Start with a big gap, then reduce the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements of arr[0..i-gap] that are greater than temp to one position ahead.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place temp at its correct position.\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration.\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sort the array using Shell sort algorithm and return the sorted array.\"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Loop over the gaps\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place temp at its correct position\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements of arr[0..i-gap] that are greater than temp to one position ahead\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location.\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element.\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Continue reducing the gap until it becomes 0\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Perform gapped insertion sort\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Begin with the largest gap and reduce it each iteration\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements of the subarray that are greater than temp\n            # to one position ahead to make space for temp\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place temp at its correct position\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Continuously reduce the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements of the sorted sublist to find the correct position for arr[i].\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place the element at its correct position.\n            arr[j] = temp\n\n        # Reduce the gap for the next iteration.\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n    # Continue reducing the gap until it becomes zero.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements that are gap positions apart.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place the element at its correct position.\n            arr[j] = temp\n        # Reduce the gap for the next iteration.\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements that are gap positions away.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place temp (the original arr[i]) in its correct position.\n            arr[j] = temp\n\n        # Reduce the gap for the next element.\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements of arr[0..i-gap] that are greater than temp\n            # to one position ahead of their current position\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place temp at its correct position\n            arr[j] = temp\n\n        # Reduce the gap for the next element\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize gap size\n\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements of the sorted sublist to create the correct position for arr[i]\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the shell sort algorithm.\n    Returns the sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    # Reduce the gap until it becomes zero\n    while gap > 0:\n        # Perform a gapped insertion sort\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements of the sorted segment forward to make space\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place the element at its correct position\n            arr[j] = temp\n\n        # Reduce the gap for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize gap size.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements over until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next pass\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 69.30851063829788, "dps_norm": 67.0, "pass@1": 74.0, "profiled": [{"solution": "def check_greater(array, number):\n    return all(number > x for x in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(number > x for x in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(lst, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    lst (list): A list of numbers.\n    num (int or float): The number to compare with elements of the list.\n\n    Returns:\n    bool: True if num is greater than all elements in lst, False otherwise.\n    \"\"\"\n    return all(num > x for x in lst)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, n):\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    Returns True if n is greater than all elements in arr, otherwise False.\n    \"\"\"\n    return all(n > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Returns True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for elem in arr:\n        if num <= elem:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if 'num' is greater than all elements in 'arr'.\n    Returns True if 'num' is greater than every element, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Returns True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare with the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False  # Early exit if num is not greater than an element\n    return True  # num is greater than all elements", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    return all(number > x for x in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare with elements of the array.\n\n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n    \"\"\"\n    return all(num > elem for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    return all(number > elem for elem in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the entered number is greater than all elements of the given array.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Write a function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare.\n    num (int/float): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 97.79411764705883, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices (0-based indexing), effectively keeping characters at odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Function to remove characters at odd positions in a string (1-based indexing).\n    For example, remove_odd(\"python\") == \"yhn\" because it removes characters at positions 1, 3, and 5.\n    \"\"\"\n    # Return characters at even indices (positions 2, 4, 6, ...)\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at even indices in the string s.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return ''.join(c for i, c in enumerate(s, 1) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd positions (1-based indexing) in a string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd positions removed.\n\n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Use slicing to get characters at even indices (odd positions)\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices, keeping only characters at odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd positions (1-based indexing) in the string s.\n    \"\"\"\n    return s[1::2]  # Start from the second character and take every other character", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd positions (1-based indexing) in a string.\n    Characters at positions 1, 3, 5, ... are considered odd positions.\n\n    :param s: The input string.\n    :return: A new string with characters at odd positions removed.\n    \"\"\"\n    # Starting from index 1 (second character), step by 2 to get characters at even positions\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/446": {"dps": 99.4088669950739, "dps_norm": 94.0, "pass@1": 62.0, "profiled": [{"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of all elements in 'lst' within the tuple 'tup'.\n\n    :param tup: Tuple of elements.\n    :param lst: List of elements to count in the tuple.\n    :return: Total count of occurrences.\n    \"\"\"\n    counts = Counter(tup)\n    return sum(counts[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in lst within tup.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n    \n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    counts = Counter(tup)\n    return sum(counts.get(element, 0) for element in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    from collections import Counter\n    c = Counter(tup)\n    return sum(c[item] for item in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): A tuple of elements.\n    lst (list): A list of elements to count within the tuple.\n\n    Returns:\n    int: Total count of occurrences of elements from lst in tup.\n    \"\"\"\n    from collections import Counter\n    counter = Counter(tup)\n    return sum(counter.get(x, 0) for x in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    \"\"\"\n    Counts the occurrences of all elements of my_list in my_tuple.\n\n    Parameters:\n    - my_tuple: A tuple containing elements to search within.\n    - my_list: A list of elements whose occurrences need to be counted in my_tuple.\n\n    Returns:\n    - An integer representing the total count of occurrences of elements from my_list in my_tuple.\n\n    Example:\n    >>> assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    \"\"\"\n    from collections import Counter\n\n    # Create a Counter object to count occurrences in the tuple\n    counts = Counter(my_tuple)\n\n    # Sum the counts of each element in the list, defaulting to 0 if the element is not found\n    total_occurrences = sum(counts.get(item, 0) for item in my_list)\n\n    return total_occurrences", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(tup.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements from lst in tup.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(tup)\n    return sum(counts.get(item, 0) for item in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of the elements in lst within the tuple tup.\n\n    Parameters:\n        tup (tuple): The tuple to search.\n        lst (list): The list of elements to count in the tuple.\n\n    Returns:\n        int: The total count of occurrences.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(tup)\n    return sum(counts.get(elem, 0) for elem in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(tup.count(element) for element in lst)\ntup = ('a', 'a', 'c', 'b', 'd')\nlst = ['a', 'b']", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    from collections import Counter\n    counts = Counter(tup)\n    return sum(counts[item] for item in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    from collections import Counter\n    counts = Counter(tup)\n    return sum(counts[elem] for elem in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(tup.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    counts = Counter(tup)\n    return sum(counts[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    from collections import Counter\n    counts = Counter(tup)\n    return sum(counts[element] for element in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    from collections import Counter\n    counts = Counter(tup)\n    return sum(counts[item] for item in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrence of all elements of lst in tup.\n\n    Parameters:\n    tup (tuple): The tuple to search for elements.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total number of occurrences of the list elements in the tuple.\n    \"\"\"\n    from collections import Counter\n    # Create a Counter object to count occurrences in the tuple\n    counter = Counter(tup)\n    # Sum the counts of each item in the list\n    return sum(counter[item] for item in lst)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of all elements in 'lst' within the tuple 'tup'.\n\n    Parameters:\n    tup (tuple): A tuple of elements.\n    lst (list): A list of elements to count within the tuple.\n\n    Returns:\n    int: Total count of occurrences of elements from 'lst' found in 'tup'.\n\n    Example:\n    >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n    3\n    \"\"\"\n    # Create a Counter object from the tuple for efficient counting\n    element_counts = Counter(tup)\n    \n    # Sum the counts of the specified elements in the list\n    return sum(element_counts.get(element, 0) for element in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    from collections import Counter\n    counts = Counter(tup)\n    return sum(counts[elem] for elem in lst)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(t, l):\n    \"\"\"\n    Write a python function to count the occurrence of all elements of a list in a tuple.\n    assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n    \"\"\"\n    from collections import Counter\n    c = Counter(t)\n    return sum(c[elem] for elem in l)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(my_tuple, my_list):\n    \"\"\"\n    Counts the total occurrences of all elements from my_list in my_tuple.\n\n    Parameters:\n    my_tuple (tuple): The tuple to search within.\n    my_list (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: Total count of occurrences.\n    \"\"\"\n    from collections import Counter\n    # Create a Counter object from the tuple\n    c = Counter(my_tuple)\n    # Sum the counts of each element in the list\n    return sum(c[element] for element in my_list)", "matching_cluster_idx": 4}]}, "Mbpp/451": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    Reverses each string in the given list of strings.\n    \n    Parameters:\n    lst (list of str): A list of strings to be reversed.\n\n    Returns:\n    list of str: A list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Parameters:\n    string_list (list of str): The list of strings to reverse.\n\n    Returns:\n    list of str: A new list containing each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    Write a function to reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 48.07692307692307, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a list containing the first element from each sublist in the input list.\n\n    Parameters:\n    list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_sublists):\n    return [sublist[0] for sublist in list_of_sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a list containing the first element of each sublist in the given list.\n\n    Parameters:\n    list_of_lists (list): A list of sublists.\n\n    Returns:\n    list: A list of first elements from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists if sublist]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n    \n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, a, b):\n    return s.replace(a, b)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, char_to_replace, replacement_char):\n    return s.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in the string s.\"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n    \n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with replacements.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n\n    :param s: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with replacements.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n    \n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of character 'old' with character 'new' in the string 's'.\n\n    :param s: The original string.\n    :param old: The character to be replaced.\n    :param new: The character to replace with.\n    :return: A new string with the characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 90.53691275167785, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int or float: The sum of the smallest and largest numbers in the array.\n    \"\"\"\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int or float: Sum of the largest and smallest values.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must contain at least one element.\")\n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"Input array must contain at least one element.\")\n    min_val = max_val = arr[0]\n    for num in arr[1:]:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n    \n    Parameters:\n    arr (list): A list of numeric values.\n\n    Returns:\n    numeric: The sum of the largest and smallest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array cannot be empty.\")\n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest value in the given array.\n\n    Args:\n        arr (list): A list of numbers.\n\n    Returns:\n        number: The sum of the largest and smallest numbers in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array must not be empty.\")\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"Array must not be empty\")\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Write a python function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n    \n    Args:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: The sum of the largest and smallest numbers in the array.\n    \n    Example:\n    >>> big_sum([1, 2, 3])\n    4\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array must not be empty.\")\n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not arr:\n        raise ValueError('Array must not be empty.')\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n    \"\"\"\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"The array should not be empty.\")\n    min_val = max_val = arr[0]\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return min_val + max_val", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of numbers): The input array.\n\n    Returns:\n    number: Sum of the largest and smallest numbers in arr.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array must not be empty.\")\n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the array arr.\n    Raises ValueError if arr is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must contain at least one element.\")\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return None  # or raise an exception\n    smallest = largest = arr[0]\n    for num in arr[1:]:\n        if num < smallest:\n            smallest = num\n        elif num > largest:\n            largest = num\n    return smallest + largest", "matching_cluster_idx": 3}]}, "Mbpp/477": {"dps": 95.74626865671642, "dps_norm": 97.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    result = ''\n    for c in s:\n        if 'A' <= c <= 'Z':\n            # Convert uppercase letter to lowercase by adding 32 to its ASCII code\n            result += chr(ord(c) + 32)\n        else:\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 82.78688524590164, "dps_norm": 80.9090909090909, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Write a function to extract values between quotation marks from a string.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values between double quotation marks from a string.\n\n    Parameters:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of values extracted from between the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values between double quotation marks from a string.\n\n    Parameters:\n        s (str): The input string containing values in double quotes.\n\n    Returns:\n        List[str]: A list of values extracted from within the double quotes.\n    \"\"\"\n    # Use a regular expression to find all occurrences of text within double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    \"\"\"\n    Extracts values between double quotation marks in a string.\n    \"\"\"\n    result = []\n    in_quote = False\n    current = ''\n    for char in s:\n        if char == '\"':\n            if in_quote:\n                # End of quoted string\n                result.append(current)\n                current = ''\n                in_quote = False\n            else:\n                # Start of quoted string\n                in_quote = True\n        elif in_quote:\n            current += char\n    return result", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts substrings enclosed in double quotes from the input string.\n    \n    Args:\n    s (str): The input string containing quoted substrings.\n    \n    Returns:\n    list: A list of substrings found between the double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.06172839506173, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Returns a list of numbers that occur only once in the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    Return a list of numbers that appear only once in the given list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    This function returns a list of numbers that occur exactly once in the given list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    Remove duplicate numbers from a list, returning only numbers that appear exactly once.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    Given a list of numbers, return a new list containing only the numbers that appear exactly once.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    Removes duplicate numbers from the given list.\n\n    Parameters:\n    lst (list): A list of numbers which may contain duplicates.\n\n    Returns:\n    list: A list of numbers that appear exactly once in the original list, in the same order.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    # Return numbers that appear exactly once in the list\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove numbers that appear more than once in the list.\n    Returns a list of numbers that occur exactly once.\n    \"\"\"\n    from collections import Counter\n    count = Counter(nums)\n    return [num for num in nums if count[num] == 1]", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 97.01587301587301, "dps_norm": 73.63636363636364, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    return [element for trio in zip(list1, list2, list3) for element in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(a, b, c):\n    from itertools import chain\n    return list(chain.from_iterable(zip(a, b, c)))", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(l1, l2, l3):\n    \"\"\"Interleaves three lists of the same length into a single flat list.\"\"\"\n    return [x for trio in zip(l1, l2, l3) for x in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(a, b, c):\n    return [x for triple in zip(a, b, c) for x in triple]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [x for t in zip(list1, list2, list3) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(a, b, c):\n    return [x for triplet in zip(a, b, c) for x in triplet]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [x for t in zip(list1, list2, list3) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \"\"\"\n    result = []\n    for a, b, c in zip(list1, list2, list3):\n        result.extend([a, b, c])\n    return result", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(a, b, c):\n    return [x for trio in zip(a, b, c) for x in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [item for t in zip(l1, l2, l3) for item in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(a, b, c):\n    return [x for t in zip(a, b, c) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(a, b, c):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n    a, b, c: Lists to interleave.\n\n    Returns:\n    A list containing the elements of a, b, and c interleaved.\n    \"\"\"\n    return [x for t in zip(a, b, c) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(a, b, c):\n    from itertools import chain\n    return list(chain.from_iterable(zip(a, b, c)))", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(a, b, c):\n    return [item for trio in zip(a, b, c) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [item for group in zip(l1, l2, l3) for item in group]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for trio in zip(list1, list2, list3) for val in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    return [x for trio in zip(list1, list2, list3) for x in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [x for trio in zip(l1, l2, l3) for x in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \"\"\"\n    return [element for trio in zip(list1, list2, list3) for element in trio]", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list 'arr' at the nth element and moves the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list with the first 'n' elements moved to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list with the first n elements moved to the end.\n    \"\"\"\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split the list 'arr' at the nth element and append the first part to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list with the first n elements moved to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and moves the first part to the end.\n\n    Parameters:\n    arr (list): The list to split and rearrange.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The list after splitting and rearranging.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list `arr` at index `n` and moves the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(A, n):\n    \"\"\"\n    Splits the list A at the nth element and moves the first part to the end.\n    \"\"\"\n    return A[n:] + A[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list 'arr' at the nth element and moves the first part to the end.\n    \n    Parameters:\n    arr (list): The input list to be split and rearranged.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The rearranged list after splitting and appending the first part to the end.\n    \n    Example:\n    >>> split_Arr([12,10,5,6,52,36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and moves the first part to the end.\n    \"\"\"\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list lst at the nth element and appends the first part to the end.\n    \"\"\"\n    if not lst:\n        return lst  # Handle empty list\n    \n    n = n % len(lst)  # Handle n greater than len(lst) and negative n\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and moves the first part to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and moves the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n\n    Example:\n    >>> split_Arr([12, 10, 5, 6, 52, 36], 2)\n    [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Write a python function to split a list at the nth element and add the first part to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"Converts a list to a tuple.\"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the given list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in a list.\n    \"\"\"\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Return the difference between the largest and smallest values in a list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"Returns the difference between the largest and smallest values in the list.\"\"\"\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0  # Return 0 if the list is empty\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in a given list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    Number: The difference between the largest and smallest numbers.\n\n    Example:\n    >>> big_diff([1, 2, 3, 4])\n    3\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must contain at least one number.\")\n    largest = max(lst)\n    smallest = min(lst)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list nums.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \"\"\"\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"Returns the difference between the largest and smallest values in the list nums.\"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list nums.\n    Raises a ValueError if nums is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List must contain at least one number.\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in a list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int or float: The difference between the max and min values.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 92.0, "profiled": [{"solution": "def sum_Of_product(n):\n    from math import comb\n    \"\"\"\n    Computes the sum of the products of consecutive binomial coefficients for a given n.\n    sum_{k=0}^{n-1} C(n,k) * C(n,k+1)\n\n    Uses the identity:\n    sum_{k=0}^{n-1} C(n,k)*C(n,k+1) = C(2n, n) * n / (n+1)\n\n    Args:\n    n (int): A positive integer\n\n    Returns:\n    int: The sum of the products of consecutive binomial coefficients\n    \"\"\"\n    total = comb(2 * n, n) * n // (n + 1)\n    return total", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    result = 1\n    for k in range(1, n+1):\n        result *= n + k\n        result //= k\n    return n * result // (n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    \"\"\"\n    Sum of the product of consecutive binomial coefficients is equal to comb(2n, n+1).\n    \"\"\"\n    return comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(N):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given N.\n    The sum is calculated using the formula: S(N) = N * C(2N, N) // (N + 1)\n    where C(2N, N) is the central binomial coefficient.\n\n    Parameters:\n    N (int): The input integer N.\n\n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n    return N * comb(2 * N, N) // (N + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    return comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The sum is given by the formula: sum_{k=0}^{n-1} C(n, k) * C(n, k+1) = C(2n, n-1)\n    \n    Parameters:\n    n (int): The number of total items.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n    return comb(2 * n, n - 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Returns the sum of the product of consecutive binomial coefficients for a given n.\n    That is, it computes the sum from k = 0 to n - 1 of C(n, k) * C(n, k + 1),\n    which is equal to the binomial coefficient C(2n, n + 1).\n    \"\"\"\n    def comb(n, k):\n        if k < 0 or k > n:\n            return 0\n        # Use symmetry property\n        k = min(k, n - k)\n        result = 1\n        for i in range(1, k + 1):\n            result = result * (n - k + i) // i\n        return result\n    return comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Compute sum_{k=0}^{n-1} C(n,k) * C(n,k+1) = C(2n, n+1)\n    \"\"\"\n    def combinations(n, k):\n        if k < 0 or k > n:\n            return 0\n        if k > n // 2:\n            k = n - k  # Symmetry property\n        result = 1\n        for i in range(1, k + 1):\n            result = result * (n - k + i) // i\n        return result\n\n    return combinations(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The sum is defined as:\n    sum_{k=0}^{n-1} C(n, k) * C(n, k+1) = C(2n, n - 1)\n    \n    Args:\n        n (int): The value of n for which to compute the sum.\n        \n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    import math\n    return math.comb(2 * n, n - 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Write a python function to find the sum of the product of consecutive binomial coefficients.\n\n    This function computes the sum of the products of consecutive binomial coefficients for a given positive integer n.\n    The sum is calculated as: sum_{k=0}^{n-1} C(n,k) * C(n,k+1)\n\n    It utilizes the mathematical identity that this sum equals C(2n, n-1).\n    \"\"\"\n    from math import comb  # Use comb from math module for efficient computation\n\n    # Compute and return the combination C(2n, n-1)\n    return comb(2 * n, n - 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    import math\n    return n * math.comb(2 * n, n) // (n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n    The sum is given by S(n) = C(2n, n-1), where C is the binomial coefficient.\n\n    Args:\n        n (int): The value of n.\n\n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    return comb(2 * n, n - 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Write a python function to find the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    def comb(n, k):\n        if k < 0 or k > n:\n            return 0\n        k = min(k, n-k)\n        c = 1\n        for i in range(1, k+1):\n            c = c * (n - k + i) // i\n        return c\n    return comb(2*n, n+1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    \"\"\"\n    Computes the sum of the products of consecutive binomial coefficients:\n    sum_{k=0}^{n-1} C(n, k) * C(n, k+1) = C(2n, n+1)\n\n    Parameters:\n    n (int): The upper limit of the binomial coefficients.\n\n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n\n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    return comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Returns the sum of the products of consecutive binomial coefficients for a given n.\n    The sum is calculated using the formula:\n    sum_{k=0}^{n-1} C(n,k) * C(n,k+1) = C(2n, n+1)\n    \"\"\"\n    def nCr(n, r):\n        r = min(r, n - r)\n        numer = 1\n        denom = 1\n        for i in range(1, r + 1):\n            numer *= n - r + i\n            denom *= i\n        return numer // denom\n    return nCr(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Computes the sum of the product of consecutive binomial coefficients for a given n.\n    The sum is defined as S(n) = sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    It utilizes the formula: S(n) = C(2n, n+1)\n    \"\"\"\n    def comb(n, k):\n        # Compute the binomial coefficient C(n, k)\n        if k < 0 or k > n:\n            return 0\n        k = min(k, n - k)  # Take advantage of symmetry\n        numerator = 1\n        denominator = 1\n        for i in range(1, k+1):\n            numerator *= n - (i -1)\n            denominator *= i\n        return numerator // denominator\n\n    return comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Compute the sum of the product of consecutive binomial coefficients for a given n.\n    The sum is equal to C(2n, n-1), where C is the binomial coefficient.\n    \"\"\"\n    return comb(2 * n, n - 1)", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    return n * comb(2 * n, n) // (n + 1)", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Write a python function to find the sum of the product of consecutive binomial coefficients.\n    The sum is calculated as n times the nth Catalan number.\n    The nth Catalan number is given by Catalan(n) = C(2n, n) / (n+1)\n    Where C(2n, n) is the binomial coefficient \"2n choose n\".\n    \"\"\"\n    catalan_number = math.comb(2 * n, n) // (n + 1)\n    return n * catalan_number", "matching_cluster_idx": 9}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n\n    The function computes the sum of C(n, k) * C(n, k+1) for k from 0 to n-1.\n    It utilizes the identity that this sum equals the binomial coefficient C(2n, n-1).\n\n    Parameters:\n    n (int): A positive integer representing the upper limit of the binomial coefficients.\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n    return comb(2 * n, n - 1)", "matching_cluster_idx": 9}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 95.22727272727273, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words separated by spaces in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.strip().split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.strip().split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string s.\n\n    Args:\n    s (str): A string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reversed order.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a string separated by spaces.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the words separated by spaces in the given string s.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.strip().split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 58.69565217391305, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k-th element from the list (1-based index).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list (1-based indexing).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove (1-based).\n\n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list lst. k is a 1-based index.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based position of the element to remove.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Example:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    # Check if k is within the bounds of the list\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    # Remove the k-1 indexed element (since list indices start at 0)\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list (1-indexed).\n    \n    Args:\n        lst (list): The original list of elements.\n        k (int): The position (1-indexed) of the element to remove.\n        \n    Returns:\n        list: A new list with the k'th element removed.\n    \"\"\"\n    # Ensure k is within the bounds of the list\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list.\")\n    # Return a new list without the k'th element\n    return lst[:k-1] + lst[k:]\nk = 3", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element (1-based index) from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element (1-based index) from the list.\n\n    Parameters:\n    lst (list): The input list.\n    k (int): The position (1-based) of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n\n    Example:\n    >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k-th element (1-based index) from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position (1-based) of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k-th element (1-based index) from the list and return the new list.\n\n    Parameters:\n    lst (list): The list from which to remove an element.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        # If k is out of bounds, return the original list\n        return lst[:]\n    # Return a new list without the k-th element\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based indexing).\n    Args:\n        lst (list): The original list.\n        k (int): The position of the element to remove (1-based index).\n\n    Returns:\n        list: A new list with the k-th element removed.\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based indexing).\n\n    Parameters:\n    lst (list): The original list from which to remove the element.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is not a valid index in the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list lst (1-based indexing).\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list (1-based indexing).\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n    \n    :param lst: List of elements.\n    :param k: 1-based index of the element to remove.\n    :return: A new list with the k-th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list\")\n    # Remove the k-th element (1-based index)\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n\n    Parameters:\n    lst (list): The input list.\n    k (int): The position (1-based index) of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is not a valid index for the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of range\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list (1-based indexing).\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list lst (1-based indexing)\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n    Assumes that all rows have at least n+1 elements.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists,\n    returns the maximum value of the n-th column (0-indexed).\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n    \n    Parameters:\n    matrix (list of lists): The input 2D list representing the matrix.\n    n (int): The 0-based index of the column to find the maximum in.\n    \n    Returns:\n    The maximum value in the n-th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix (list of lists), returns the maximum value from the n-th column (0-based index).\n    \"\"\"\n    return max(row[n] for row in matrix)\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix (list of lists) and an integer n, returns the maximum value from the nth column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix to search.\n    n (int): The index of the column (0-based).\n\n    Returns:\n    The maximum value found in the n-th column.\n\n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 54.44444444444443, "dps_norm": 72.5, "pass@1": 100.0, "profiled": [{"solution": "import string\ndef replace_spaces(s):\n    mapping = {ord(c): ord('_') for c in string.whitespace}\n    mapping[ord('_')] = ord(' ')\n    return s.translate(mapping)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(s):\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return ''.join('_' if c == ' ' else ' ' if c == '_' else c for c in s)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    return s.translate({ord(' '): '_', ord('_'): ' '})", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return ''.join(' ' if c == '_' else '_' if c == ' ' else c for c in s)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    return ''.join('_' if c.isspace() else (' ' if c == '_' else c) for c in s)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    table = str.maketrans(' _', '_ ')\n    return s.translate(table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string with whitespaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n    \"\"\"\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return ''.join('_' if c == ' ' else ' ' if c == '_' else c for c in s)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '\\0').replace('_', ' ').replace('\\0', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    \"\"\"\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    return ''.join('_' if c == ' ' else ' ' if c == '_' else c for c in s)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string.\n    \"\"\"\n    return s.translate(str.maketrans({' ': '_', '_': ' '}))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    return ''.join(' ' if c == '_' else ('_' if c == ' ' else c) for c in s)", "matching_cluster_idx": 2}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeros in the list to the end while maintaining the order of non-zero elements.\n    \"\"\"\n    n = len(lst)\n    pos = 0  # Position to place the next non-zero element\n    for i in range(n):\n        if lst[i] != 0:\n            lst[pos] = lst[i]\n            pos += 1\n    for i in range(pos, n):\n        lst[i] = 0\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    n = len(lst)\n    pos = 0  # Position to place the next non-zero element\n    for i in range(n):\n        if lst[i] != 0:\n            lst[pos] = lst[i]\n            pos += 1\n    for i in range(pos, n):\n        lst[i] = 0\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list 'lst' to the end while maintaining the order of non-zero elements.\n    \"\"\"\n    index = 0  # Position to place the next non-zero element\n    for num in lst:\n        if num != 0:\n            lst[index] = num\n            index += 1\n    # Fill the remaining positions with zeros\n    for i in range(index, len(lst)):\n        lst[i] = 0\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the order of non-zero elements.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeros = [x for x in lst if x == 0]\n    return non_zero + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list 'lst' to the end while maintaining the order of non-zero elements.\n    \"\"\"\n    # Filter out all non-zero elements\n    non_zero_elements = [x for x in lst if x != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Append zeroes to the end of the non-zero elements\n    return non_zero_elements + [0]*zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    idx = 0\n    for num in lst:\n        if num != 0:\n            lst[idx] = num\n            idx += 1\n    for i in range(idx, len(lst)):\n        lst[i] = 0\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the list while maintaining the order of non-zero elements.\n    \"\"\"\n    non_zero_elements = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    idx = 0  # Position to place the next non-zero element\n    for num in lst:\n        if num != 0:\n            lst[idx] = num\n            idx += 1\n    # Fill the rest of the list with zeros\n    for i in range(idx, len(lst)):\n        lst[i] = 0\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zeroes = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    non_zero_index = 0  # Pointer for the position to place the non-zero element\n    # First pass: move all non-zero elements to the front\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index] = nums[i]\n            non_zero_index += 1\n    # Second pass: fill the remaining positions with zeros\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list 'lst' to the end, maintaining the order of non-zero elements.\n    \"\"\"\n    last_non_zero = 0  # Position to place the next non-zero element\n    for i in range(len(lst)):\n        if lst[i] != 0:\n            # Swap the current element with the element at last_non_zero index\n            lst[last_non_zero], lst[i] = lst[i], lst[last_non_zero]\n            last_non_zero += 1\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros in the list 'lst' to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    lst (list): The input list of numbers.\n\n    Returns:\n    list: The list after moving all zeros to the end.\n    \"\"\"\n    # Initialize the position for the next non-zero element\n    last_non_zero = 0\n\n    # Iterate over the list\n    for current in range(len(lst)):\n        if lst[current] != 0:\n            # Swap the current element with the last non-zero element found\n            lst[last_non_zero], lst[current] = lst[current], lst[last_non_zero]\n            last_non_zero += 1  # Move to the next position\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeros = [0] * lst.count(0)\n    return non_zero + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Write a python function to move all zeroes to the end of the given list.\n    assert move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n    \"\"\"\n    j = 0  # Index of the next non-zero element\n    for num in lst:\n        if num != 0:\n            lst[j] = num\n            j += 1\n    # After all non-zero elements have been moved to the front,\n    # fill the remaining positions with zeros\n    for i in range(j, len(lst)):\n        lst[i] = 0\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    index = 0  # Position to place the next non-zero element\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[index] = nums[i]\n            index += 1\n    # Fill the remaining positions with zeros\n    for i in range(index, len(nums)):\n        nums[i] = 0\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zero_elements = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \"\"\"\n    j = 0  # Index of the next non-zero element\n    for i in range(len(lst)):\n        if lst[i] != 0:\n            lst[j] = lst[i]\n            j += 1\n    for i in range(j, len(lst)):\n        lst[i] = 0\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    pos = 0  # Position to place the next non-zero element\n    for i in range(len(lst)):\n        if lst[i] != 0:\n            lst[pos] = lst[i]\n            pos += 1\n    # Fill the rest of the list with zeros\n    for i in range(pos, len(lst)):\n        lst[i] = 0\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the list while maintaining the order of non-zero elements.\n    \"\"\"\n    non_zero_elements = []\n    zero_count = 0\n\n    for num in nums:\n        if num != 0:\n            non_zero_elements.append(num)\n        else:\n            zero_count += 1\n\n    # Append the zeros at the end\n    non_zero_elements.extend([0] * zero_count)\n    return non_zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list nums and returns the new list.\n    \"\"\"\n    result = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n    result.extend([0] * zero_count)\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/644": {"dps": 72.23404255319147, "dps_norm": 78.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of the array `arr` up to position `k`.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The number of elements from the start of the array to reverse.\n\n    Returns:\n    list: The array with the first `k` elements reversed.\n\n    Raises:\n    ValueError: If `k` is negative or not an integer.\n    \"\"\"\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    k = min(k, len(arr))  # Ensure k does not exceed the array length\n    left, right = 0, k - 1\n\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to the given position k (0-based indexing),\n    that is, reverse elements from position 0 to k-1.\n    \"\"\"\n    n = len(arr)\n    if k > n:\n        k = n\n    elif k <= 0:\n        return arr  # nothing to reverse\n    left = 0\n    right = k - 1\n\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left +=1\n        right -=1\n    return arr\narr = [1, 2, 3, 4, 5, 6]\nk = 4", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of 'arr' up to position 'k'.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The number of elements from the start of the list to reverse.\n\n    Returns:\n    list: The list with the first 'k' elements reversed.\n    \"\"\"\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to position k.\n\n    Parameters:\n    arr (list): The input array to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: A new array with elements up to position k reversed.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array `arr` up to the k-th position.\n\n    Parameters:\n    arr (list): The list to reverse.\n    k (int): The number of elements from the start of the list to reverse.\n\n    Returns:\n    list: The list with the first k elements reversed.\n\n    Example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    \"\"\"\n    Reverses the elements of arr from position 0 to K-1.\n    \n    Parameters:\n    arr (list): The input array to be modified.\n    K (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array after reversing elements up to position K.\n    \"\"\"\n    n = len(arr)\n    # Ensure K does not exceed the array length\n    K = min(K, n)\n    left = 0\n    right = K - 1\n    while left < right:\n        # Swap elements at positions left and right\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    \"\"\"\n    Reverses the elements of the array `arr` up to position `K`.\n    \n    Parameters:\n    arr (list): The input list to be partially reversed.\n    K (int): The position up to which the list should be reversed.\n\n    Returns:\n    list: A new list with elements reversed up to position `K`.\n    \"\"\"\n    return arr[:K][::-1] + arr[K:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    \"\"\"\n    Reverses the first K elements of the array `arr`.\n    \n    Parameters:\n    arr (list): The input array to be modified.\n    K (int): The number of elements from the start of the array to reverse.\n    \n    Returns:\n    list: A new array with the first K elements reversed.\n    \"\"\"\n    # Ensure that K does not exceed the array length\n    K = min(K, len(arr))\n    \n    # Reverse the first K elements and concatenate with the rest of the array\n    return arr[:K][::-1] + arr[K:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    array[:k] = array[:k][::-1]\n    return array", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    arr[:K] = arr[:K][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of the array up to position k.\n    The first k elements (from index 0 to k-1) are reversed.\n\n    :param arr: List of elements\n    :param k: Position up to which to reverse (k >= 0)\n    :return: New list with elements reversed up to position k\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array.\")\n\n    reversed_part = arr[:k][::-1]\n    remaining_part = arr[k:]\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    \"\"\"\n    Reverses elements of the array 'arr' up to position 'K'.\n\n    Parameters:\n    arr (list): The list to be modified.\n    K (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The modified list with elements reversed up to position K.\n    \"\"\"\n    arr[:K] = arr[:K][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    arr[:K] = arr[:K][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array 'arr' up to the given position 'k'.\n\n    Args:\n    arr (list): The input array to be modified.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array after reversing the elements up to position 'k'.\n    \"\"\"\n    # Reverse the elements up to position k in-place\n    left, right = 0, k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The number of elements to reverse from the start of the array.\n\n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to position k.\n\n    Parameters:\n    arr (list): The array to be modified.\n    k (int): The number of elements from the start of the array to reverse.\n\n    Returns:\n    list: The array with the first k elements reversed.\n\n    Example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    if k <= 0:\n        return arr[:]\n    arr = arr[:]  # Create a copy of the array to avoid modifying the original\n    k = min(k, len(arr))\n    arr[:k] = arr[:k][::-1]  # Reverse the first k elements\n    return arr", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array 'arr' in-place and returns the modified array.\n\n    :param arr: List[int] - The input array to be modified.\n    :param k: int - The number of elements from the start of the array to reverse.\n    :return: List[int] - The array after reversing the first k elements.\n    \"\"\"\n    left, right = 0, k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    arr[:K] = arr[:K][::-1]\n    return arr", "matching_cluster_idx": 13}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary added.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(a_tuple, a_dict):\n    return a_tuple + (a_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(some_tuple, some_dict):\n    return some_tuple + (some_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    return tup + (d,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 48.30601092896174, "dps_norm": 63.125, "pass@1": 98.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    \"\"\"\n    Write a function to extract values between quotation marks \" \" of the given string.\n    assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}]}, "Mbpp/732": {"dps": 13.895348837209303, "dps_norm": 51.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(s):\n    import re\n    return re.sub(r'[ ,\\.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    return s.translate(str.maketrans(' ,.', ':::'))", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    return s.translate(str.maketrans(' ,.', ':::'))", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(s):\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    import re\n    return re.sub(r\"[ ,.]\", ':', s)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    return s.translate(str.maketrans(' ,.', ':::'))", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(s):\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "import re\ndef replace_specialchar(s):\n    return re.sub(r'[ ,\\.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "import re\ndef replace_specialchar(s):\n    return re.sub(r'[ ,\\.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    return s.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    return s.translate(str.maketrans(' ,.', ':::'))", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    import re\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    import re\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "import re\ndef replace_specialchar(s):\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "import re\ndef replace_specialchar(s):\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return s.translate(str.maketrans(' ,.', ':::'))", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,\\.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "def replace_specialchar(s):\n    # Create a translation table mapping space, comma, and period to colon\n    translation_table = str.maketrans(' ,.', ':::')\n    # Return the translated string\n    return s.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "import re\ndef replace_specialchar(s):\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 2}, {"solution": "import re\ndef replace_specialchar(s):\n    return re.sub(r\"[ ,\\.]\", \":\", s)", "matching_cluster_idx": 2}]}, "Mbpp/740": {"dps": 95.0909090909091, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple into a dictionary by pairing adjacent elements.\n    \n    Args:\n        tup (tuple): A tuple with an even number of elements.\n        \n    Returns:\n        dict: A dictionary with keys and values from adjacent elements of the tuple.\n        \n    Example:\n        >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n        {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a dictionary by pairing adjacent elements.\n    Each pair of elements in the tuple becomes a key-value pair in the dictionary.\n    If the tuple has an odd number of elements, the last element is ignored.\n    \"\"\"\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements.\n    :param t: Tuple of elements (should be of even length).\n    :return: Dictionary with keys and values from adjacent elements of the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    it = iter(t)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    Parameters:\n    t (tuple): A tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary with keys and values from adjacent elements of the tuple.\n    \"\"\"\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tpl):\n    return dict(zip(tpl[::2], tpl[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary by pairing adjacent elements.\n    The first element becomes the key and the second becomes the value.\n    \"\"\"\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a dictionary using adjacent elements as key-value pairs.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Parameters:\n    t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary with keys and values from adjacent elements of the tuple.\n    \"\"\"\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Parameters:\n    t (tuple): A tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary with keys and values from adjacent elements in the tuple.\n    \"\"\"\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements.\n    If the tuple has an odd number of elements, the last element is ignored.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}]}, "Mbpp/744": {"dps": 88.28767123287672, "dps_norm": 91.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def check_none(my_tuple):\n    return None in my_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Checks if the given tuple contains any None values.\n\n    Parameters:\n    t (tuple): The tuple to check.\n\n    Returns:\n    bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Checks if the given tuple 't' contains any None values.\n    \n    Parameters:\n    t (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if 't' contains None, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value.\n    Returns True if None is present, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if the given tuple contains any None value.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    \n    Returns:\n    bool: True if at least one element is None, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    t (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is in the tuple, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tpl (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is in the tuple, False otherwise.\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return any(x is None for x in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return any(x is None for x in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is found in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 78.57142857142857, "dps_norm": 77.5, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The original list.\n    tup (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: A new list containing elements of the original list followed by elements of the tuple.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n    assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    \"\"\"\n    # Convert the tuple to a list and concatenate it with the original list\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: The list after adding the elements of the tuple.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n    \n    Parameters:\n    lst (list): The original list to which elements will be added.\n    tup (tuple): The tuple whose elements are to be added to the list.\n    \n    Returns:\n    list: A new list containing elements of the original list followed by elements of the tuple.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n        lst (list): The original list.\n        tpl (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n        list: The updated list with the tuple elements added.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: A new list containing elements of the original list followed by elements of the tuple.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Add the elements of the tuple 'tpl' to the list 'lst'\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n    \n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple containing elements to add to the list.\n    \n    Returns:\n    list: The list after adding the elements from the tuple.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: The new list containing elements from both the original list and the tuple.\n\n    Example:\n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds all elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tup (tuple): The tuple containing elements to add.\n\n    Returns:\n    list: The list after adding elements from the tuple.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 22.0, "profiled": [{"solution": "def min_k(lst, k):\n    return sorted(lst, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_of_tuples, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    Parameters:\n    list_of_tuples (list): A list of tuples where each tuple contains a name and a value.\n    k (int): The number of minimum records to return.\n    \n    Returns:\n    list: A list containing the k tuples with the smallest values.\n    \"\"\"\n    return sorted(list_of_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the k records with the smallest numerical values from a list of tuples.\n\n    Parameters:\n    records (list of tuple): A list where each tuple contains a name and a number.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuple: A list of the k tuples with the smallest numbers.\n\n    Example:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the k records with the minimum integer values from a list of tuples.\n\n    :param records: List of tuples (name, value)\n    :param k: Number of minimum records to return\n    :return: List of k tuples with the smallest values, sorted in ascending order of value\n    \"\"\"\n    # Sort the records based on the integer value\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    return sorted(lst, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Write a function to find the minimum k records from a list of tuples.\n    \"\"\"\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    \"\"\"\n    Write a function to find minimum k records from tuple list.\n    \"\"\"\n    return sorted(lst, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Write a function to find the minimum k records from a list of tuples.\n    Each tuple contains a name and a numeric value.\n    The function returns the k tuples with the smallest numeric values.\n\n    :param records: List[Tuple[str, int]], list of tuples with (name, value)\n    :param k: int, number of minimum records to return\n    :return: List[Tuple[str, int]], k records with minimum values\n    \"\"\"\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 92.75862068965517, "dps_norm": 91.25, "pass@1": 100.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    result = []\n    min_len = min(len(l1), len(l2), len(l3))  # Find the minimum length of the three lists\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:  # Check if elements at index i are equal in all lists\n            result.append(l1[i])      # Add the common element to the result list\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    return [v1 for v1, v2, v3 in zip(l1, l2, l3) if v1 == v2 == v3]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Returns a list of elements that are common in l1, l2, l3 at the same indices.\n    \"\"\"\n    return [e1 for e1, e2, e3 in zip(l1, l2, l3) if e1 == e2 == e3]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    min_len = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Parameters:\n    l1, l2, l3 (list): The input lists.\n\n    Returns:\n    list: A list of elements that are common to all three lists at the same index.\n    \"\"\"\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Returns a list of elements that are common to l1, l2, and l3 at the same index positions.\n    \"\"\"\n    min_length = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    assert extract_index_list([1,1,3,4,5,6,7],[0,1,2,3,4,5,7],[0,1,2,3,4,5,7])==[1,7]\n    \"\"\"\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    result = []\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            result.append(a)\n    return result", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    This function finds and returns a list of such common elements.\n    \"\"\"\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Returns a list of elements that are common to all three lists at the same index.\n    \"\"\"\n    min_length = min(len(l1), len(l2), len(l3))\n    result = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    min_length = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    min_len = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    # Find the minimum length to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    # Collect elements that are the same at the same index in all three lists\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    return [e1 for e1, e2, e3 in zip(l1, l2, l3) if e1 == e2 == e3]\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": null, "dps_norm": null, "pass@1": 18.0, "profiled": []}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 14.0, "profiled": []}, "Mbpp/758": {"dps": 75.0096525096525, "dps_norm": 79.375, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(list_of_lists):\n    counts = {}\n    for lst in list_of_lists:\n        key = tuple(lst)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    from collections import Counter\n    counts = Counter(tuple(sublist) for sublist in lst)\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n    Converts each sublist to a tuple to use as a dictionary key.\n    Returns a dictionary with tuples as keys and their counts as values.\n    \"\"\"\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef unique_sublists(some_list):\n    return dict(Counter(tuple(lst) for lst in some_list))", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    from collections import Counter\n    counts = Counter(tuple(sublist) for sublist in lst)\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    counts = {}\n    for sublist in list_of_lists:\n        t = tuple(sublist)\n        counts[t] = counts.get(t, 0) + 1\n    return counts", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Write a function to count lists within a list. The function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurrences in the original list.\n    \"\"\"\n    from collections import Counter\n    # Convert each sublist to a tuple to make it hashable\n    tuple_lists = [tuple(sublist) for sublist in list_of_lists]\n    # Count occurrences of each tuple\n    counts = Counter(tuple_lists)\n    # Return as a regular dictionary\n    return dict(counts)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(list_of_lists):\n    return dict(Counter(tuple(sublist) for sublist in list_of_lists))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Write a function to count lists within a list. The function should return a dictionary where every list\n    is converted to a tuple and the value of such tuple is the number of its occurrences in the original list.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list of lists.\n    Converts each sublist to a tuple to use as a dictionary key.\n    Returns a dictionary where keys are the tuples and values are the counts.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(tuple(sublist) for sublist in lst)\n    return dict(counts)", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    from collections import Counter\n    return dict(Counter(tuple(sublist) for sublist in lists))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist in the list.\n    Converts each sublist to a tuple to use it as a dictionary key.\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        key = tuple(sublist)  # Convert the sublist to a tuple to make it hashable\n        count_dict[key] = count_dict.get(key, 0) + 1  # Increment the count for this key\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of each sublist within a list of lists.\n    Converts sublists to tuples to use them as dictionary keys.\n\n    Parameters:\n    list_of_lists (list): A list containing sublists whose occurrences are to be counted.\n\n    Returns:\n    dict: A dictionary with tuples (converted from sublists) as keys and their counts as values.\n    \"\"\"\n    from collections import defaultdict\n\n    # Initialize a default dictionary to hold counts\n    count_dict = defaultdict(int)\n\n    # Iterate over each sublist in the input list\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        key = tuple(sublist)\n        # Increment the count for this tuple\n        count_dict[key] += 1\n\n    # Convert defaultdict back to a regular dict before returning\n    return dict(count_dict)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    from collections import Counter\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst_of_lsts):\n    count_dict = {}\n    for sublist in lst_of_lsts:\n        t = tuple(sublist)\n        count_dict[t] = count_dict.get(t, 0) + 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list_of_lists):\n    counts = {}\n    for sublist in list_of_lists:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    counts = {}\n    for sublist in lists:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Write a function to count lists within a list. The function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurrences in the original list.\n    Example:\n    unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    => {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    counts = {}\n    for sublist in list_of_lists:\n        t = tuple(sublist)\n        counts[t] = counts.get(t, 0) + 1\n    return counts", "matching_cluster_idx": 5}]}, "Mbpp/760": {"dps": 92.62773722627738, "dps_norm": 86.25, "pass@1": 100.0, "profiled": [{"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether the list contains only one distinct element.\n    :param lst: List of numbers.\n    :return: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1 and lst != []", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    if not lst:\n        return False\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if the list 'nums' contains only one distinct element.\n\n    Args:\n    nums (list): A list of numbers.\n\n    Returns:\n    bool: True if all elements are the same (and list is not empty), False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1 and len(nums) > 0", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    if not lst:\n        return True  # Assuming empty list has only one (non-existent) distinct element\n    first = lst[0]\n    for item in lst:\n        if item != first:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are the same.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same or the list is empty, False otherwise.\n    \"\"\"\n    if not lst:\n        return True  # An empty list is considered to have one distinct element\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are the same.\n\n    Args:\n        lst (list): The list of numbers to check.\n\n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are the same.\n\n    Args:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Returns True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1 and len(lst) > 0", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n    \"\"\"\n    return len(set(lst)) == 1 if lst else False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if all elements in the list are the same, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1 if lst else False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1 if lst else False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks if all elements in the list are the same.\n\n    Parameters:\n    lst (list): List of elements\n\n    Returns:\n    bool: True if all elements are the same or list is empty, False otherwise\n    \"\"\"\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks whether all elements in the list are the same.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if all elements are the same or the list is empty, False otherwise.\n    \"\"\"\n    return len(set(lst)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n\n    Returns True if all elements in the list are the same, False otherwise.\n\n    Examples:\n    >>> unique_Element([1, 1, 1])\n    True\n    >>> unique_Element([1, 2, 1])\n    False\n    \"\"\"\n    if not lst:\n        return False  # Return False for an empty list\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Counts the number of digits in the given string s.\"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The string to evaluate.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in the given string s.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Parameters:\n    s (str): The string to search for digits.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in a given string.\n\n    Parameters:\n    s (str): The string to be analyzed.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Counts the number of digit characters in the input string s.\"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Counts the number of digits in the input string s.\"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string s.\n    \n    Parameters:\n    s (str): The input string\n    \n    Returns:\n    int: The number of digits in the string\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Function to count the number of digits in a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 91.16822429906541, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in a given list.\n\n    Parameters:\n    lst (list): The input list of items.\n\n    Returns:\n    list: A list of tuples, each containing a pair of consecutive items from the input list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(L):\n    return list(zip(L[:-1], L[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}]}, "Mbpp/775": {"dps": 75.83999999999999, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n    \"\"\"\n    return all(lst[i]%2==1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every odd index in the list contains an odd number.\n\n    Parameters:\n    lst (list): List of integers.\n\n    Returns:\n    bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Returns True if every element at an odd index contains an odd number in the given list.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Returns True if every element at an odd index in lst is odd.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every odd index contains an odd number in the given list.\n\n    Parameters:\n    lst (list): List of integers.\n\n    Returns:\n    bool: True if every element at an odd index is an odd number, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"Check whether every odd index contains odd numbers in a given list.\"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    # Iterate over odd indices\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            # Element at odd index is even, so return False\n            return False\n    # All elements at odd indices are odd\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(arr):\n    return all(arr[i] % 2 == 1 for i in range(1, len(arr), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Write a python function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if every element at odd indices is odd, False otherwise.\n    \"\"\"\n    return all(n % 2 == 1 for n in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 94.0, "profiled": [{"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Write a python function to find the sum of non-repeated elements in a given list.\n    assert find_sum([1,2,3,1,1,4,5,6]) == 21\n    \"\"\"\n    # Convert the list to a set to get unique elements, then sum them up\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Function to find the sum of non-repeated elements in a given list.\n    Non-repeated elements are considered once, even if they appear multiple times in the list.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    This function finds the sum of non-repeated elements in a given list.\n    It sums each distinct element only once, regardless of how many times it appears in the list.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique elements in the given list.\n    \n    Parameters:\n    lst (list): The list of integers.\n\n    Returns:\n    int: The sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Write a python function to find the sum of non-repeated elements in a given list.\n    assert find_sum([1,2,3,1,1,4,5,6]) == 21\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"Return the sum of unique elements in the given list.\"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of the unique elements in the list.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Write a python function to find the sum of non-repeated elements in a given list.\n    assert find_sum([1,2,3,1,1,4,5,6]) == 21\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Write a python function to find the sum of non-repeated elements in a given list.\n    assert find_sum([1,2,3,1,1,4,5,6]) == 21\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique elements in the list.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 96.41732283464567, "dps_norm": 93.0, "pass@1": 100.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"Returns True if the count of divisors of n is even, False if it is odd.\"\"\"\n    root = int(n ** 0.5)\n    return root * root != n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"Check if the count of divisors of n is even.\"\"\"\n    count = 1  # Initialize count of divisors\n    i = 2  # Start checking from the smallest prime number\n    while i * i <= n:\n        exp = 0  # Exponent of the current prime factor\n        while n % i == 0:\n            n //= i\n            exp += 1\n        count *= (exp + 1)  # Update total count of divisors\n        i += 1\n    if n > 1:\n        count *= 2  # n is a prime number greater than sqrt(n)\n    return count % 2 == 0  # Check if the count is even", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the count of divisors of n is even, False otherwise.\n    \"\"\"\n    sqrt_n = int(n ** 0.5)\n    # If n is a perfect square, it has an odd number of divisors\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Returns True if the number of positive divisors of n is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    root = math.isqrt(n)\n    # If n is a perfect square, it has an odd number of divisors\n    return root * root != n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors of n is even.\n\n    Parameters:\n    n (int): The integer to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n ** 0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the number of positive divisors of n is even,\n    False if it is odd.\n    \"\"\"\n    return int(n ** 0.5) ** 2 != n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the count of divisors of n is even, False otherwise.\n    \"\"\"\n    # If n is a perfect square, it has an odd number of divisors.\n    # Otherwise, it has an even number of divisors.\n    return not (int(n ** 0.5) ** 2 == n)", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Write a python function to check whether the count of divisors is even.\n    This function returns True if the number of divisors of n is even, and False otherwise.\n    \"\"\"\n    # If n is a perfect square, it has an odd number of divisors.\n    # Otherwise, it has an even number of divisors.\n    return not (int(n ** 0.5) ** 2 == n)", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    from math import isqrt\n    # If n is a perfect square, it has an odd number of divisors.\n    # Otherwise, it has an even number of divisors.\n    return not isqrt(n) ** 2 == n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors of `n` is even.\n    Returns True if the count is even, False if odd.\n    \"\"\"\n    sqrt_n = int(n ** 0.5)\n    # If n is a perfect square, the number of divisors is odd\n    # Otherwise, it's even\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Checks whether the count of positive divisors of an integer n is even.\n    Returns True if even, False if odd.\n    \"\"\"\n    root = math.isqrt(n)\n    if root * root == n:\n        # n is a perfect square; number of divisors is odd\n        return False\n    else:\n        # n is not a perfect square; number of divisors is even\n        return True", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the number of positive divisors of n is even, False otherwise.\n    \"\"\"\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i * i == n:\n                # i and n//i are the same divisor (perfect square root)\n                count += 1\n            else:\n                # i and n//i are two different divisors\n                count += 2\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the count of divisors of n is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n ** 0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1  # Perfect square root counts only once\n            else:\n                count += 2  # Pair of divisors\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"Return True if the count of divisors of n is even, False otherwise.\"\"\"\n    root = int(n ** 0.5)\n    return root * root != n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of positive divisors of n is even.\n    Returns True if even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n**0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Return True if the count of divisors of n is even, False otherwise.\n    The count of divisors is even for all positive integers except perfect squares.\n    \"\"\"\n    sqrt_n = int(n ** 0.5)\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n    Returns True if even, False if odd.\n    \"\"\"\n    return not is_square(n)\ndef is_square(n):\n    \"\"\"\n    Check whether n is a perfect square.\n    Returns True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    low = 1\n    high = n // 2\n    while low <= high:\n        mid = (low + high) // 2\n        sq = mid * mid\n        if sq == n:\n            return True\n        elif sq < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\nn = 10", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the count of divisors of n is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n ** 0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1  # Perfect square divisor counted once\n            else:\n                count += 2  # Pair of divisors counted twice\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "import math\ndef count_divisors(n):\n    count = 0\n    sqrt_n = int(math.isqrt(n))\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            if i * i == n:\n                # Perfect square, count divisor only once\n                count += 1\n            else:\n                # Count both divisors i and n // i\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}]}, "Mbpp/800": {"dps": null, "dps_norm": null, "pass@1": 10.0, "profiled": []}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst_of_lists):\n    return max(lst_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    # Initialize variables to store the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n\n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"Returns the list with the highest sum of elements from a list of lists.\"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lsts):\n    \"\"\"\n    Write a function that returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    return max(lsts, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in list_of_lists whose sum of elements is the highest.\n\n    :param list_of_lists: A list of lists containing numerical values.\n    :return: The list with the highest sum of elements.\n    \"\"\"\n    # Use max with sum as the key function to find the list with the highest sum\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple 'tup' contains the value 'k'.\n    Returns True if k is present, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    \"\"\"Check if k is in the tuple tpl.\"\"\"\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, K):\n    \"\"\"\n    Check if the given tuple `tup` contains the element `K`.\n    Return True if `K` is in `tup`, else False.\n    \"\"\"\n    return K in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    Checks if the integer k is present in the tuple t.\n    Args:\n        t (tuple): The tuple to search.\n        k (int): The integer to find.\n    Returns:\n        bool: True if k is in t, False otherwise.\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"Check if k is in the given tuple.\n\n    Args:\n        tup (tuple): The tuple to search.\n        k: The element to find.\n\n    Returns:\n        bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    \"\"\"\n    Function to check if the given tuple contains the value k.\n\n    Args:\n    tpl (tuple): The tuple to search.\n    k: The value to search for.\n\n    Returns:\n    bool: True if k is in tpl, False otherwise.\n    \"\"\"\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple 'tup' contains the element 'k'.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The element to search for.\n\n    Returns:\n    bool: True if 'k' is in 'tup', False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}]}}}
