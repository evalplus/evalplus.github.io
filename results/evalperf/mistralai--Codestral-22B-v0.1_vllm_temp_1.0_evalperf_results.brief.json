{"date": "2024-10-19 16:32", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 82.68924330620962, "dps_norm": 79.07819827252048, "pass@1": 72.83898305084746}, "eval": {"HumanEval/9": {"dps": 69.29022082018928, "dps_norm": 63.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n\n    for i in range(1, len(numbers)):\n        result.append(max(result[i-1], numbers[i]))\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n    curr_max = float('-inf')\n\n    for num in numbers:\n        if num > curr_max:\n            curr_max = num\n        rolling_max_list.append(curr_max)\n\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    max_so_far = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_so_far:\n            max_so_far = numbers[i]\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_so_far = float('-inf')\n    result = []\n\n    for number in numbers:\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = [numbers[0]]\n\n    for number in numbers[1:]:\n        rolling_max_list.append(max(rolling_max_list[-1], number))\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(result[-1], num))\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_numbers = []\n    max_so_far = float('-inf')\n\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        rolling_max_numbers.append(max_so_far)\n\n    return rolling_max_numbers", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(result[-1], num))\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(result[-1], num))\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    else:\n        result = [numbers[0]]\n        for num in numbers[1:]:\n            result.append(max(result[-1], num))\n        return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    max_numbers = [numbers[0]]\n    for number in numbers[1:]:\n        max_numbers.append(max(max_numbers[-1], number))\n    return max_numbers", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_list = []\n    max_so_far = float('-inf')\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        max_list.append(max_so_far)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    rolling_max_list = [numbers[0]]\n    for num in numbers[1:]:\n        rolling_max_list.append(max(rolling_max_list[-1], num))\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    result = []\n    if not numbers:\n        return result\n\n    current_max = numbers[0]\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    max_num = numbers[0]\n\n    for num in numbers:\n        if num > max_num:\n            max_num = num\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    max_so_far = float('-inf')\n    result = []\n\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    max_so_far = numbers[0]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_num = numbers[0]\n    rolling_max_nums = [max_num]\n    for num in numbers[1:]:\n        max_num = max(max_num, num)\n        rolling_max_nums.append(max_num)\n\n    return rolling_max_nums", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_so_far = float('-inf')\n    rolling_max_values = []\n\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        rolling_max_values.append(max_so_far)\n\n    return rolling_max_values", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 69.01162790697674, "dps_norm": 72.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # sort the list in ascending order\n    numbers.sort()\n\n    # iterate through the list and check if difference between consecutive numbers is less than threshold\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # if no two numbers are close enough, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort() # Sort the list of numbers\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold: # If the difference between any two adjacent numbers is less than the threshold\n            return True # Return True\n    return False # If no two numbers are closer than the threshold, return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list in increasing order\n    numbers.sort()\n\n    # Iterate over the sorted list and check if any two numbers\n    # are closer to each other than the given threshold\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If no two close numbers are found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Iterate over the sorted list\n    for i in range(len(numbers) - 1):\n        # Check if the difference between two adjacent numbers is less than the threshold\n        if numbers[i + 1] - numbers[i] < threshold:\n            # If yes, return True\n            return True\n    # If no two adjacent numbers are close enough to each other, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than given threshold.\"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()  # sort the list of numbers\n    for i in range(len(numbers)-1):  # iterate through sorted list\n        if numbers[i+1] - numbers[i] < threshold:  # check if difference between consecutive elements is less than threshold\n            return True  # return True if any pair is within threshold\n    return False  # return False if no pair is within threshold", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the numbers list in ascending order\n    numbers.sort()\n\n    # Compare each pair of consecutive numbers\n    for i in range(1, len(numbers)):\n        # If the difference between a pair of numbers is smaller than the threshold\n        if numbers[i] - numbers[i - 1] < threshold:\n            # Return True as close numbers are found\n            return True\n\n    # Return False as no close numbers are found\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()  # Sort the numbers to make it easier to find close elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:  # If any two adjacent elements are closer than threshold\n            return True\n    return False  # If no two elements are closer than threshold", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, are any two numbers closer to each other than\n    the given threshold.\n    \"\"\"\n    # sort the list\n    numbers.sort()\n\n    # iterate through the sorted list\n    for i in range(1, len(numbers)):\n        # if the difference between any two adjacent numbers is less than threshold\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    # if no pair with difference less than threshold is found\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Iterate over the sorted list\n    for i in range(len(numbers) - 1):\n        # Check if any two adjacent numbers are closer to each other than the threshold\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If no such pair is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Iterate over the sorted list\n    for i in range(len(numbers) - 1):\n        # If the difference between two consecutive numbers is less than the threshold, return True\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If no two consecutive numbers are close to each other than the threshold, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}]}, "HumanEval/4": {"dps": 83.63924050632912, "dps_norm": 91.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:\n        return 0\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(number - mean) for number in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    # First, we compute the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n\n    # Now, we compute the Mean Absolute Deviation\n    mad = sum(abs(number - mean_value) for number in numbers) / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    return sum(deviations) / len(deviations)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    Args:\n    numbers (List[float]): a list of floats representing the numbers.\n\n    Returns:\n    float: the mean absolute deviation of the numbers in the list.\n\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(number - mean) for number in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    # Calculate mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    # Calculate absolute differences from the mean\n    abs_diff = [abs(num - mean) for num in numbers]\n    # Calculate Mean Absolute Deviation\n    mad = sum(abs_diff) / len(abs_diff)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    deviation_sum = sum(abs(num - mean) for num in numbers)\n    return deviation_sum / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(num - mean) for num in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean_num = sum(numbers) / len(numbers)\n    deviations = [abs(num - mean_num) for num in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    n = len(numbers)\n    mean = sum(numbers) / n\n    mad = sum(abs(num - mean) for num in numbers) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(number - mean) for number in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum([abs(number - mean) for number in numbers]) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    # Compute the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    # Compute the Mean Absolute Deviation\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n    numbers: List of float, data for calculation\n\n    Returns:\n    float, mean absolute deviation of the input list\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # compute mean\n    mean = sum(numbers) / len(numbers)\n\n    # compute the absolute differences from the mean\n    absolute_differences = [abs(number - mean) for number in numbers]\n\n    # compute the mean absolute difference (mad)\n    mad = sum(absolute_differences) / len(numbers)\n\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(number - mean) for number in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    n = len(numbers)\n    mean = sum(numbers) / n\n    mad = sum(abs(number - mean) for number in numbers) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum([abs(num - mean) for num in numbers]) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(number - mean) for number in numbers) / len(numbers)", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 92.55813953488372, "dps_norm": 93.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase\n    string = string.lower()\n\n    # Create an empty set to store distinct characters\n    distinct_chars = set()\n\n    # Iterate through each character in the string\n    for char in string:\n        # Add the character to the set\n        distinct_chars.add(char)\n\n    # Return the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # convert string to lowercase\n    string = string.lower()\n\n    # create set of unique characters in the string\n    unique_chars = set(string)\n\n    # return number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \"\"\"\n    # Convert the string to lowercase and create a set of its characters\n    distinct_chars = set(string.lower())\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # convert string to lower case and return length of set of characters\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # We convert the string to lower case to count characters case-insensitively\n    # Then we use the set data structure to remove duplicates\n    # Finally, we return the length of the set which is the count of distinct characters\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case, convert the string to a set to get unique characters,\n    # and finally return the length of this set\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase and convert it to a set to remove duplicate characters\n    distinct_characters = set(string.lower())\n    # Return the number of unique characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    distinct_chars = set(string.lower())  # Convert all characters to lower case and remove duplicates\n    return len(distinct_chars)  # Return the count of distinct characters", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    string = string.lower()\n    # Create a set of distinct characters in the string\n    distinct_chars = set(string)\n    # Return the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    distinct_characters = set(string.lower())\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    Parameters:\n    string (str): Input string\n\n    Returns:\n    int: Number of distinct characters in the input string\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    # Convert the string to lower case and remove duplicates by converting it to a set\n    distinct_chars = set(string.lower())\n\n    # Return the length of the set which represents the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    Args:\n    string (str): input string\n\n    Returns:\n    int: number of distinct characters in the string\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to a lower case to ignore case\n    lower_case_string = string.lower()\n\n    # Create an empty set to store distinct characters\n    distinct_chars = set()\n\n    # Add each character to the set\n    for char in lower_case_string:\n        distinct_chars.add(char)\n\n    # Return the size of the set, which is the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set(string.lower())  # Using set to remove duplicates, and lower() to ignore case\n    return len(distinct_chars)", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    res = (0, 0)\n\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < min_diff:\n            min_diff = numbers[i] - numbers[i - 1]\n            res = (numbers[i - 1], numbers[i])\n\n    return res", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()  # sort the list in ascending order\n    min_diff = float('inf')\n    pair = (None, None)\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < min_diff:\n            min_diff = numbers[i] - numbers[i-1]\n            pair = (numbers[i-1], numbers[i])\n    return pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    pair = (None, None)\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < min_diff:\n            min_diff = numbers[i] - numbers[i - 1]\n            pair = (numbers[i - 1], numbers[i])\n    return pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    pair = (None, None)\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            pair = (numbers[i], numbers[i+1])\n    return pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i - 1], numbers[i])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()  # sort the list in ascending order\n    min_diff = float('inf')  # initialize minimum difference to positive infinity\n    pair = (0, 0)  # initialize closest pair of elements\n    for i in range(1, len(numbers)):  # iterate over the sorted list\n        diff = numbers[i] - numbers[i-1]  # calculate the difference between the current and previous element\n        if diff < min_diff:  # if the difference is smaller than the current minimum difference\n            min_diff = diff  # update the minimum difference\n            pair = (numbers[i-1], numbers[i])  # update the closest pair of elements\n    return pair  # return the closest pair of elements", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # First, sort the list in ascending order\n    numbers.sort()\n    # Initialize smallest difference and pair\n    min_diff = float('inf')\n    min_pair = None\n    # Compare each pair of consecutive elements\n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (numbers[i], numbers[i+1])\n    # Return the pair with smallest difference\n    return min_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (numbers[0], numbers[1])\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = sys.float_info.max\n    closest_pair = (None, None)\n\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < min_diff:\n            min_diff = numbers[i] - numbers[i-1]\n            closest_pair = (numbers[i-1], numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport math\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = math.inf\n    closest_pair = (None, None)\n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    pair = (None, None)\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            pair = (numbers[i - 1], numbers[i])\n\n    return pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < min_diff:\n            min_diff = numbers[i + 1] - numbers[i]\n            result = (numbers[i], numbers[i + 1])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()  # Sort the numbers in the list\n    diff = float('inf')  # Initialize the difference to infinity\n    res = (0, 0)  # Initialize the result to (0, 0)\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < diff:\n            diff = numbers[i + 1] - numbers[i]\n            res = (numbers[i], numbers[i + 1])\n    return res", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    pair = (None, None)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            pair = (numbers[i-1], numbers[i])\n    return pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # sort the numbers\n    numbers.sort()\n\n    # initialize the closest pair as the first two numbers\n    closest_pair = (numbers[0], numbers[1])\n\n    # initialize the minimum difference as the difference of the first two numbers\n    min_diff = numbers[1] - numbers[0]\n\n    # iterate over the sorted list starting from the second number\n    for i in range(1, len(numbers) - 1):\n        # compute the difference between the current number and the next one\n        diff = numbers[i + 1] - numbers[i]\n\n        # if this difference is smaller than the current minimum difference,\n        # update the closest pair and the minimum difference\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport math\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    numbers.sort()\n    min_diff = math.inf\n    result = (None, None)\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < min_diff:\n            min_diff = numbers[i+1] - numbers[i]\n            result = (numbers[i], numbers[i+1])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < min_diff:\n            min_diff = numbers[i] - numbers[i-1]\n            result = (numbers[i-1], numbers[i])\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 61.904761904761905, "dps_norm": 22.5, "pass@1": 82.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    if n == 1 or n == 0:\n        return \"No divisors\"\n    else:\n        for i in range(n - 1, 0, -1):\n            if n % i == 0:\n                return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return \"No divisors found\"  # This will never be reached for n > 0", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return -1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return -1  # in case no such number exists, return -1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return -1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # If the number is less than 2, there are no divisors\n    if n < 2:\n        raise ValueError(\"The number must be at least 2\")\n    # Starting from the number less than n, decrementing by 1 at each step, find the first divisor\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n    n (int): A positive integer\n\n    Returns:\n    int: The largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"The number should be greater than 1\")\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Parameters:\n    n (int): the input number\n\n    Returns:\n    int: the largest divisor of n that is smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "import doctest\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n should be greater than 1\")\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Loop through numbers from n-1 down to 1\n    for i in range(n - 1, 0, -1):\n        # Check if i divides n evenly\n        if n % i == 0:\n            return i\n    # If no divisors are found, return None or appropriate error value\n    return None", "matching_cluster_idx": 1}]}, "HumanEval/26": {"dps": 74.66666666666667, "dps_norm": 75.0, "pass@1": 18.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Using a dictionary to keep track of the count of numbers\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Filter the list to only include numbers that have a count of 1\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    no_duplicates = []\n    for i in numbers:\n        if numbers.count(i) == 1:\n            no_duplicates.append(i)\n    return no_duplicates", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    # using dictionary to keep track of the frequency of each number\n    num_freq = {}\n    for num in numbers:\n        if num in num_freq:\n            num_freq[num] += 1\n        else:\n            num_freq[num] = 1\n\n    # filter out the numbers that occur more than once\n    result = [num for num in numbers if num_freq[num] == 1]\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # We create an empty dictionary to store each unique number and its count.\n    counts = {}\n\n    for number in numbers:\n        if number in counts:\n            counts[number] += 1\n        else:\n            counts[number] = 1\n\n    # Filter the list to only include numbers that occur once.\n    result = [number for number in numbers if counts[number] == 1]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Create a dictionary to count the frequency of each number\n    freq_dict = {}\n    for num in numbers:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Filter the list to include only elements that occur once\n    result = [num for num in numbers if freq_dict[num] == 1]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    num_counts = {}\n    for num in numbers:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    return [num for num in numbers if num_counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    seen = set()\n    duplicates = set()\n    unique_numbers = []\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n\n    for number in numbers:\n        if number not in duplicates:\n            unique_numbers.append(number)\n\n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Using dictionary to store elements as keys and their counts as values.\n    counts = dict()\n    for number in numbers:\n        if number in counts:\n            counts[number] += 1\n        else:\n            counts[number] = 1\n\n    # Using list comprehension to filter out elements that occur more than once.\n    result = [number for number in numbers if counts[number] == 1]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    seen = set()\n    duplicates = set(x for x in numbers if x in seen or seen.add(x))\n    return [x for x in numbers if x not in duplicates]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Create an empty dictionary to count the occurrences of each number\n    count_dict = {}\n    # Iterate over the list of numbers\n    for num in numbers:\n        # If number is already a key in the dictionary, increment its count\n        if num in count_dict:\n            count_dict[num] += 1\n        # Otherwise, add the number to the dictionary with a count of 1\n        else:\n            count_dict[num] = 1\n    # Create an empty list to store the results\n    result = []\n    # Iterate over the list of numbers\n    for num in numbers:\n        # If the count of the number in the dictionary is 1, add it to the result list\n        if count_dict[num] == 1:\n            result.append(num)\n    # Return the result list\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    result = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # using dictionary to store numbers as keys and their count as values\n    count_dict = {}\n    for number in numbers:\n        if number in count_dict:\n            count_dict[number] += 1\n        else:\n            count_dict[number] = 1\n\n    # only include numbers that occur once in the result\n    result = []\n    for number in numbers:\n        if count_dict[number] == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\"\"\"\n    # Using dictionary to record frequency of each number\n    counts = dict()\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    # Keep only numbers that occur once\n    unique_numbers = [num for num in numbers if counts[num] == 1]\n\n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    return [num for num in numbers if numbers.count(num) == 1]", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # using dictionary to hold numbers and their counts\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # creating the result list by checking count of each number\n    result = []\n    for num in numbers:\n        if count_dict[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 50.63291139240506, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i:\n            i += 2\n        else:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2:  # The smallest prime number is 2\n        return False\n    for i in range(2, int(n**0.5) + 1):  # A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2: # primes are greater than 1\n        return False\n    for i in range(2, int(n ** 0.5) + 1): # only need to check up to square root of n\n        if n % i == 0: # if n is divisible by any number up to its square root, it's not prime\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while(i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while(i * i <= n):\n        if (n % i == 0 or n % (i + 2) == 0):\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 60.27777777777778, "dps_norm": 74.54545454545455, "pass@1": 74.0, "profiled": [{"solution": "def sort_third(l: list):\n    # Get values at the indices that are divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort the values\n    divisible_by_three.sort()\n    # Replace values in the original list\n    for i, val in enumerate(divisible_by_three):\n        l[3 * i] = val\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Create a list with elements at indices divisible by 3 from input list\n    div_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the list\n    div_by_three.sort()\n    # Replace elements at indices divisible by 3 with sorted elements\n    for i in range(len(div_by_three)):\n        l[i*3] = div_by_three[i]\n    # Return updated list\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    third_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = third_elements.pop(0)\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    # Replace elements at indices divisible by 3 in the original list with sorted elements\n    for i in range(len(divisible_by_three)):\n        l[i*3] = divisible_by_three[i]\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    third_elements = sorted(l[i] for i in range(0, len(l), 3))\n    for i in range(0, len(l), 3):\n        l[i] = third_elements.pop(0)\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    # Make a new list containing only the elements at the multiples of 3\n    thirds = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n\n    # Iterate through the original list and replace elements at multiples of 3 with corresponding elements in the new sorted list\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = thirds.pop(0)\n\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    div_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    div_three_values = sorted([l[i] for i in div_three_indices])\n    for i, idx in enumerate(div_three_indices):\n        l[idx] = div_three_values[i]\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Extract every third element from the list and sort it\n    third_elements = sorted(l[::3])\n\n    # Create a copy of the input list\n    sorted_list = l.copy()\n\n    # Replace every third element in the copy with elements from the sorted list\n    for i in range(len(third_elements)):\n        sorted_list[3 * i] = third_elements[i]\n\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    div_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    div_three_elems = [l[i] for i in div_three_indices]\n    div_three_elems.sort()\n    for i, index in enumerate(div_three_indices):\n        l[index] = div_three_elems[i]\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    third_elements = sorted(l[::3])\n    for i in range(0, len(l), 3):\n        l[i] = third_elements[i // 3]\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    # extract elements at indices divisible by three\n    div_three_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    # replace elements at indices divisible by three with sorted elements\n    for i in range(0, len(l), 3):\n        l[i] = div_three_elements.pop(0)\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    # Extract the elements at indices divisible by three\n    divisible_by_three = sorted(l[i] for i in range(0, len(l), 3))\n\n    # Place the elements back into their respective indices\n    for i, elem in enumerate(divisible_by_three):\n        l[3*i] = elem\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    sorted_values = sorted([l[i] for i in divisible_by_three_indices])\n    for i, val in zip(divisible_by_three_indices, sorted_values):\n        l[i] = val\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Create a new list to store the elements at indices divisible by three\n    div_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort this list\n    div_by_three.sort()\n    # Create a new list to store the result\n    result = l.copy()\n    # Insert the sorted elements back into the result list\n    for i in range(0, len(result), 3):\n        result[i] = div_by_three.pop(0)\n    # Return the result\n    return result", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    # filter elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # sort the filtered elements\n    divisible_by_three.sort()\n    # replace the sorted elements in the original list\n    for i, elem in enumerate(divisible_by_three):\n        l[i*3] = elem\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Find indices that are divisible by three\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n\n    # Extract values from those indices\n    divisible_by_three_values = [l[i] for i in divisible_by_three_indices]\n\n    # Sort the values\n    divisible_by_three_values.sort()\n\n    # Replace the values at the divisible by three indices in the original list\n    for i in range(len(divisible_by_three_indices)):\n        l[divisible_by_three_indices[i]] = divisible_by_three_values[i]\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Create a list to store elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort the list\n    divisible_by_three.sort()\n\n    # Create a copy of the original list\n    l_new = l.copy()\n\n    # Replace elements at indices divisible by three with sorted elements\n    for i in range(len(l_new)):\n        if i % 3 == 0:\n            l_new[i] = divisible_by_three.pop(0)\n\n    return l_new", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    divisible_by_three_elements = [l[i] for i in divisible_by_three_indices]\n    divisible_by_three_elements.sort()\n\n    l_sorted = l.copy()\n    for i, index in enumerate(divisible_by_three_indices):\n        l_sorted[index] = divisible_by_three_elements[i]\n\n    return l_sorted", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # extract elements at indices divisible by three\n    third_elems = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    # replace elements at indices divisible by three with the sorted ones\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = third_elems.pop(0)\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    # Extract the values at indices divisible by three\n    div_three_vals = sorted(v for i, v in enumerate(l) if i % 3 == 0)\n    # Fill in a new list with the sorted values and the rest of the original list\n    return [div_three_vals.pop(0) if i % 3 == 0 else v for i, v in enumerate(l)]", "matching_cluster_idx": 6}]}, "HumanEval/34": {"dps": 86.41509433962264, "dps_norm": 97.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 3, 2, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_list = list(set(l))\n    unique_list.sort()\n    return unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    # Using set to remove duplicates\n    unique_elements = set(l)\n    # Converting set to list and sorting\n    sorted_unique_elements = sorted(list(unique_elements))\n    return sorted_unique_elements", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    # using set to get unique elements and then sorting them\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    # Using set to remove duplicates, then sorting and returning the list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(lst: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    # Using a set to remove duplicates because a set in Python is an unordered collection of unique elements.\n    # Then convert the set to a list and sort it.\n    return sorted(list(set(lst)))", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    # Using set to get unique elements and list to convert it back to a list\n    unique_elements = list(set(l))\n    # Sorting the list\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # convert the list to a set to remove duplicates, then convert it back to a list\n    unique_list = list(set(l))\n    # sort the list in ascending order\n    unique_list.sort()\n    return unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    Args:\n    l (list): The list of elements\n\n    Returns:\n    list: Sorted unique elements in the list\n    \"\"\"\n    # Use a set to remove duplicates and sort the list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    unique_elements = list(set(l))\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    return sorted(list(set(l)))", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 97.1774193548387, "dps_norm": 75.0, "pass@1": 70.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(11, n, 11):\n        if '7' in str(i):\n            count += str(i).count('7')\n    for i in range(13, n, 13):\n        if '7' in str(i):\n            count += str(i).count('7')\n    for i in range(143, n, 143): # To remove numbers that are counted twice\n        if '7' in str(i):\n            count -= str(i).count('7')\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(11, n, 11):\n        if '7' in str(i):\n            count += str(i).count('7')\n    for i in range(13, n, 13):\n        if '7' in str(i):\n            count += str(i).count('7')\n    for i in range(143, n, 143):  # To account for numbers that are divisible by both 11 and 13\n        if '7' in str(i):\n            count -= str(i).count('7')  # Subtract as these numbers were counted twice\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(11, n, 11):  # checks numbers divisible by 11\n        count += str(i).count('7')\n    for i in range(13, n, 13):  # checks numbers divisible by 13\n        count += str(i).count('7')\n    for i in range(143, n, 143):  # checks numbers divisible by both 11 and 13 (the least common multiple) to avoid double-counting\n        count -= str(i).count('7')\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(11, n, 11):  # iterate over multiples of 11\n        if '7' in str(i):\n            count += str(i).count('7')\n    for i in range(13, n, 13):  # iterate over multiples of 13\n        if '7' in str(i):\n            count += str(i).count('7')\n    for i in range(143, n, 143):  # iterate over common multiples of 11 and 13 to avoid double-counting\n        if '7' in str(i):\n            count -= str(i).count('7')\n    return count", "matching_cluster_idx": 5}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    # find all numbers less than n which are divisible by 11 or 13\n    divisible_numbers = [i for i in range(n) if i % 11 == 0 or i % 13 == 0]\n    # count the number of occurrences of the digit 7 in these numbers\n    count = str(divisible_numbers).count('7')\n    return count", "matching_cluster_idx": 5}]}, "HumanEval/37": {"dps": 95.94108019639934, "dps_norm": 92.0, "pass@1": 98.0, "profiled": [{"solution": "def sort_even(l: list):\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    for i in range(0, len(l), 2):\n        l[i] = evens.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_indices = sorted(l[::2])\n    return [even_indices.pop(0) if i % 2 == 0 else x for i, x in enumerate(l)]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Fetch the even elements of the list and sort it\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n\n    # Go through the list and replace even index elements with the sorted ones\n    for i in range(0, len(l), 2):\n        l[i] = evens.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract the even indexed elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n\n    # Sort the even indexed elements\n    even_elements.sort()\n\n    # Replace the even indexed elements in the original list with sorted ones\n    for i in range(0, len(l), 2):\n        l[i] = even_elements.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    # Extract the even indices elements from the list\n    evens = sorted(l[::2])\n    # Start by duplicating the input list\n    l_prime = l[:]\n    # Iterate over even indices and replace their values in the output list\n    for i in range(0, len(l), 2):\n        l_prime[i] = evens[i//2]\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_elements = sorted(l[::2])\n    l[::2] = even_elements\n    return l", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list) -> list:\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = sorted([l[i] for i in even_indices])\n    sorted_even_l = l.copy()\n    for i, val in zip(even_indices, even_values):\n        sorted_even_l[i] = val\n    return sorted_even_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    for i in range(0, len(l), 2):\n        l[i] = evens.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # separate the elements at the even indices into a new list\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    # replace the elements at the even indices in the original list with the sorted elements\n    for i in range(0, len(l), 2):\n        l[i] = even_elements.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    even_indices_values = sorted([l[i] for i in range(0, len(l), 2)])\n    for i in range(0, len(l), 2):\n        l[i] = even_indices_values.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_index_values = sorted([val for idx, val in enumerate(l) if idx % 2 == 0])\n    return [val if idx % 2 != 0 else even_index_values.pop(0) for idx, val in enumerate(l)]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_idx_values = sorted(l[::2])\n    l[::2] = even_idx_values\n    return l", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    even_values = sorted(l[::2])\n    for i in range(0, len(l), 2):\n        l[i] = even_values.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract even-index elements\n    evens = sorted(l[0::2])\n    # Put even-index elements back into their positions\n    l[0::2] = evens\n    return l", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    # Filter out even indexed elements\n    even_elements = sorted(l[::2])\n    # Replace even indexed elements with sorted elements\n    for i in range(0, len(l), 2):\n        l[i] = even_elements.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    evens = sorted(l[::2])\n    for i in range(0, len(l), 2):\n        l[i] = evens.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    even_values = sorted([l[i] for i in range(0, len(l), 2)])\n    l[::2] = even_values\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Get all even-indexed elements and sort them\n    even_elements = sorted(l[::2])\n    # Create a new list with the odd indexed elements in their place\n    result = [None] * len(l)\n    result[::2] = even_elements\n    # Fill in the rest with the elements from the original list\n    result[1::2] = l[1::2]\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    evens = sorted(l[::2]) # get the even-indexed elements and sort them\n    evens_iter = iter(evens) # create an iterator to traverse the sorted even elements\n    return [next(evens_iter) if i % 2 == 0 else val for i, val in enumerate(l)]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \"\"\"\n    # Extract all even elements\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    # Replace even elements in the original list with sorted ones\n    for i in range(0, len(l), 2):\n        l[i] = even_elements.pop(0)\n    return l", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 61.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    # compute 2^n modulo p using the built-in pow function\n    # the pow function can compute power and modulo simultaneously\n    # which is more efficient and avoids overflow for large values of n\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    The function implements exponentiation by squaring method which avoids\n    integer overflow and is more time-efficient.\n    \"\"\"\n    # Base cases\n    if p == 1:\n        return 0\n    if n == 0:\n        return 1\n\n    # Initialize result\n    result = 1\n\n    # Calculate 2^n modulo p\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent //= 2\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Using the power function pow() with 3 arguments. The third argument 'p' is used to\n    # take the modulus of the result.\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    Args:\n        n (int): Exponent of 2.\n        p (int): Modulo.\n\n    Returns:\n        int: Result of 2^n modulo p.\n    \"\"\"\n    # Using pow function with three arguments will compute (x ^ y) % z efficiently\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1 % p\n    else:\n        power = modp(n // 2, p)\n        if n % 2 == 0:\n            return (power * power) % p\n        else:\n            return ((power * power) * 2) % p", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # 2^n can be calculated as 2**n\n    # To calculate 2^n mod p, we can use the pow() function in Python which calculates (a**b)%m\n    # The pow() function handles large numbers efficiently\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if n == 0:\n        return 1 % p\n    elif n % 2 == 0:\n        half_mod = modp(n // 2, p)\n        return (half_mod * half_mod) % p\n    else:\n        return (2 * modp(n - 1, p)) % p", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Python's built-in pow function is used to calculate 2^n mod p\n    # It efficiently calculates large powers using square-and-multiply algorithm\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    # calculate 2^n modulo p\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if p == 1:\n        return 0\n    else:\n        return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    result = ''\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    # define a string containing all the vowels (both lower case and upper case)\n    vowels = 'aeiouAEIOU'\n\n    # iterate over each character in the text\n    result = ''\n    for char in text:\n        # if the character is not a vowel, add it to the result\n        if char not in vowels:\n            result += char\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    result = ''\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 20.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Remove duplicates from strings and compare the results\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings into sets of characters and compare them\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # Check if both sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # convert strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # check if two sets of characters are the same\n    if set_s0 == set_s1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert each string to a set, which removes duplicate characters\n    # Then check if two sets are equal\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # convert the strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n\n    # check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # Compare sets of characters\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Use set data structure to remove duplicates, and check for equality.\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # Check if two sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # We can check if two strings have the same characters by converting each string to a set of characters.\n    # If the sets are equal, the strings have the same characters.\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    # Convert the lists to sets\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find common elements in both sets\n    common_elements = set1.intersection(set2)\n\n    # Sort and return the common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \"\"\"\n    # converting lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # finding common elements\n    common_set = set1 & set2\n\n    # converting set to list and sorting it\n    common_list = sorted(list(common_set))\n\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    :param l1: list of elements\n    :param l2: list of elements\n    :return: list of sorted unique common elements\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \"\"\"\n    # First, we find common elements and then convert the result into a set to remove duplicates\n    common_elements = set(l1) & set(l2)\n\n    # We convert the set back into a list and sort it\n    result = sorted(list(common_elements))\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # convert lists to sets to eliminate duplicates and perform intersection operation\n    # sort the resulting set and convert back to list\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # Convert both lists into sets\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find intersection of the sets\n    common_set = set1.intersection(set2)\n\n    # Convert resultant set to list\n    common_list = list(common_set)\n\n    # Sort the list\n    common_list.sort()\n\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    # Create sets from the input lists. Sets automatically remove duplicates and have O(1) lookup time.\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Compute the intersection of the two sets. This gives us the common elements.\n    common_set = set1 & set2\n\n    # Convert the set back to a list and sort it.\n    common_list = sorted(list(common_set))\n\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    # Convert lists to sets for O(1) lookup\n    set1, set2 = set(l1), set(l2)\n    # Find intersection of two sets and sort the result\n    result = sorted(set1.intersection(set2))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # Convert lists to sets to find common elements\n    common_set = set(l1) & set(l2)\n\n    # Convert the set back to list and sort it\n    common_list = sorted(list(common_set))\n\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    This function accepts two lists, converts both into sets, finds their intersection (which gives the common elements),\n    converts the result back to a list, sorts it and returns.\n    \"\"\"\n\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # converting lists to sets for faster lookup\n    set1 = set(l1)\n    set2 = set(l2)\n    # finding the common elements\n    common_elements = set1.intersection(set2)\n    # sorting and returning as a list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \"\"\"\n    # convert lists to sets to get unique elements\n    # use intersection to get common elements\n    common_elements = list(set(l1) & set(l2))\n    # sort the list before returning\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # converting lists to sets for efficient membership testing\n    s1 = set(l1)\n    s2 = set(l2)\n    # finding common elements using intersection operation of sets\n    common_elements = s1.intersection(s2)\n    # converting set back to list for sorted operation\n    common_list = list(common_elements)\n    # sorting list in place\n    common_list.sort()\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # Convert both lists to sets and find their intersection\n    common_set = set(l1) & set(l2)\n    # Convert the intersection set to a list and sort it\n    common_list = sorted(list(common_set))\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 95.57291666666667, "dps_norm": 96.66666666666667, "pass@1": 93.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest_factor = -1\n    # Divide by 2 until n becomes odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n >>= 1  # equivalent to n /= 2\n    # n must be odd at this point so a skip of 2 can be used\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i== 0:\n            largest_factor = i\n            n = n / i\n    # this condition is to handle the case when n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    return int(largest_factor)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest = 0\n    while n % 2 == 0:\n        largest = 2\n        n //= 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest = i\n            n //= i\n    if n > 2:\n        largest = n\n    return largest", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # Start with the largest possible factor\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            # i is a factor, divide n by i\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    # Check if number is divisible by 2 and divide it until not divisible anymore\n    while n % 2 == 0:\n        max_prime = 2\n        n = n / 2\n\n    # n must be odd at this point, thus skip even numbers and check up to the square root of n\n    for i in range(3, int(n**0.5)+1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n\n    # If n is a prime number greater than 2, then n is the largest prime factor\n    if n > 2:\n        max_prime = n\n\n    return int(max_prime)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    if n < 2:\n        return None\n    for i in range(n - 1, 1, -1):\n        if n % i == 0 and is_prime(i):\n            return i\n    return None", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1  # equivalent to n /= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n /= i\n    if n > 2:\n        max_prime = n\n    return max_prime", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 56.883116883116884, "dps_norm": 54.375, "pass@1": 43.0, "profiled": [{"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    s = s.lower()\n    if s.endswith('y'):\n        return sum(1 for c in s if c in vowels) + 1\n    else:\n        return sum(1 for c in s if c in vowels)", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    # Initialize count of vowels\n    count = 0\n    # Convert the string to lowercase for uniform comparison\n    s = s.lower()\n    # Define vowels, including 'y'\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Check each character in string\n    for i in range(len(s)):\n        # If current character is a vowel or 'y' at the end, increment the count\n        if s[i] in vowels or (s[i] == 'y' and i == len(s) - 1):\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    s = s.lower()  # Convert string to lowercase\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = sum([1 for letter in s if letter in vowels])  # Count the number of vowels in the string\n    if s.endswith('y'):  # Check if the last letter is 'y' and add it to the count if true\n        count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    count = 0\n    for i in range(len(s)):\n        if s[i] in 'aeiou':\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for index, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and index == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n\n    # convert the string to lowercase\n    s = s.lower()\n\n    # iterate through the string and increase count when a vowel is found\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        # check if 'y' is at the end of the word and increase count if true\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    s = s.lower()  # convert string to lowercase to handle capitalized letters\n    vowels = 'aeiou'\n    count = 0\n    for i, letter in enumerate(s):\n        if letter in vowels:\n            count += 1\n        elif letter == 'y' and i == len(s) - 1:\n            # if letter is 'y' and it's the last letter in the word\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    count = 0\n    for i, char in enumerate(s):\n        if char in 'aeiou':\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = sum(1 for letter in s if letter in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = \"aeiou\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == \"y\" and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    # increment count for each vowel found in the word\n    count = sum(1 for letter in s.lower() if letter in vowels)\n    # if word ends in 'y', increment count\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    s = s.lower()\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels or (s[i] == 'y' and i == len(s) - 1):\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    # Convert the string to lower case to avoid handling upper case characters separately\n    s = s.lower()\n    # Initialize the count of vowels\n    count = 0\n    # Check if each character is a vowel and increment the count accordingly\n    for i in range(len(s)):\n        if s[i] in ('a', 'e', 'i', 'o', 'u'):\n            count += 1\n        # Check if 'y' is a vowel (only if it is at the end of the word)\n        elif i == len(s) - 1 and s[i] == 'y':\n            count += 1\n    # Return the count of vowels\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    # Convert input string to lowercase for easier comparison\n    s = s.lower()\n    # Define a set of vowels, including 'y'\n    vowels = set('aeiouy')\n    # Initialize a count variable to 0\n    count = 0\n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # If the character is a vowel and it is not 'y' or it is 'y' and it is the last character in the string\n        if char in vowels and (char != 'y' or i == len(s) - 1):\n            # Increment the count by 1\n            count += 1\n    # Return the final count\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    s = s.lower()\n    count = 0\n    for i, char in enumerate(s):\n        if char in 'aeiou':\n            count += 1\n        if char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    # converting the string to lowercase to make the function case-insensitive\n    s = s.lower()\n\n    # if 'y' is at the end of the word, add it to the vowels count\n    if s.endswith('y'):\n        return sum(s.count(v) for v in vowels) + 1\n\n    # else, just count the occurrences of each vowel\n    return sum(s.count(v) for v in vowels)", "matching_cluster_idx": 6}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    s = s.lower()\n    return sum(1 for c in s if c in vowels) + (1 if s.endswith('y') else 0)", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    for i, char in enumerate(s.lower()):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}]}, "HumanEval/74": {"dps": 98.14634146341463, "dps_norm": 89.44444444444444, "pass@1": 47.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum(len(s) for s in lst1)\n    len_lst2 = sum(len(s) for s in lst2)\n    return lst1 if len_lst1 <= len_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_chars_lst1 = sum(len(word) for word in lst1)\n    sum_chars_lst2 = sum(len(word) for word in lst2)\n    return lst1 if sum_chars_lst1 <= sum_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum(len(s) for s in lst1)\n    sum_lst2 = sum(len(s) for s in lst2)\n\n    if sum_lst1 <= sum_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum(len(i) for i in lst1)\n    sum_lst2 = sum(len(i) for i in lst2)\n    return lst1 if sum_lst1 <= sum_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(string) for string in lst1)\n    total_chars_lst2 = sum(len(string) for string in lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_lst1 = sum(len(str) for str in lst1)\n    sum_lst2 = sum(len(str) for str in lst2)\n    return lst1 if sum_lst1 <= sum_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(i) for i in lst1)\n    total_chars_lst2 = sum(len(i) for i in lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(i) for i in lst1)\n    sum2 = sum(len(i) for i in lst2)\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate total characters for each list\n    lst1_chars = sum(len(str) for str in lst1)\n    lst2_chars = sum(len(str) for str in lst2)\n    # Compare and return the list with fewer characters\n    return lst1 if lst1_chars <= lst2_chars else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Function that accepts two lists of strings and returns the list\n    that has total number of chars in the all strings of the list\n    less than the other list.\n    If the two lists have the same number of chars, it returns the first list.\n    '''\n    return lst1 if sum(map(len, lst1)) <= sum(map(len, lst2)) else lst2", "matching_cluster_idx": 8}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n    return lst1 if sum1 <= sum2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    return lst2 if total_chars_lst1 > total_chars_lst2 else lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(i) for i in lst1)\n    sum2 = sum(len(i) for i in lst2)\n\n    if sum1 <= sum2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_chars_lst1 = sum(len(word) for word in lst1)\n    sum_chars_lst2 = sum(len(word) for word in lst2)\n    return lst1 if sum_chars_lst1 <= sum_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    return lst1 if sum(len(word) for word in lst1) <= sum(len(word) for word in lst2) else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    total_chars_lst1 = sum(len(i) for i in lst1)\n    total_chars_lst2 = sum(len(i) for i in lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(i) for i in lst1)\n    sum2 = sum(len(i) for i in lst2)\n    return lst1 if sum1 <= sum2 else lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 85.0, "dps_norm": 51.666666666666664, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initializing the total sum to 0\n    total_sum = 0\n    # Looping through each element in the list\n    for i in range(len(lst)):\n        # If the index is odd and the element is even, add it to the total sum\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            total_sum += lst[i]\n    # Returning the total sum\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) == 2\n        add([1, 4, 2, 6, 7, 8]) == 10\n        add([1, 3, 5]) == 0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    sum_evens_odd_indices = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_evens_odd_indices += lst[i]\n    return sum_evens_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    # Filter the list by even numbers at odd indices\n    even_at_odd_indices = [num for i, num in enumerate(lst) if num % 2 == 0 and i % 2 == 1]\n    # Return the sum of the list\n    return sum(even_at_odd_indices)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Create a list comprehension with a conditional statement\n    even_at_odd_indices = [lst[i] for i in range(len(lst)) if i % 2 != 0 and lst[i] % 2 == 0]\n    # Return the sum of the even elements at odd indices\n    return sum(even_at_odd_indices)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. Add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # initialize the result to 0\n    result = 0\n    # loop over the indices and elements of the list simultaneously\n    for i, num in enumerate(lst):\n        # check if the index is odd and the number is even\n        if i % 2 != 0 and num % 2 == 0:\n            # if so, add the number to the result\n            result += num\n    # return the final result\n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(i for index, i in enumerate(lst) if index % 2 != 0 and i % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(value for index, value in enumerate(lst) if value % 2 == 0 and index % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. Add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(val for i, val in enumerate(lst) if val % 2 == 0 and i % 2 != 0)", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 95.61224489795919, "dps_norm": 98.0, "pass@1": 41.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Splitting the string into words\n    words = s.split(' ')\n    # Creating a list to hold the new words with sorted characters\n    new_words = []\n    # Looping through each word\n    for word in words:\n        # Sorting the characters in the word in ascending order\n        sorted_word = ''.join(sorted(word))\n        # Appending the sorted word to the new_words list\n        new_words.append(sorted_word)\n    # Joining the new_words list back into a string, with a space between each word\n    new_string = ' '.join(new_words)\n    # Returning the new string\n    return new_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the string into words\n    words = s.split(' ')\n\n    # Sort the characters in each word\n    sorted_words = [''.join(sorted(word)) for word in words]\n\n    # Join the words back together into a single string\n    ordered_string = ' '.join(sorted_words)\n\n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Split the string into list of words.\n    words = s.split(\" \")\n\n    # For each word, sort the characters and join them back together.\n    sorted_words = [''.join(sorted(word)) for word in words]\n\n    # Join the sorted words back into a string with space separators.\n    sorted_string = ' '.join(sorted_words)\n\n    return sorted_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the string into words\n    words = s.split(' ')\n    # For each word, sort the characters in ascending order based on ASCII value\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back into a string with spaces in between\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Split the input string into a list of words\n    words = s.split(' ')\n    # Sort each word in the list of words\n    sorted_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back into a string with space as separator\n    result = ' '.join(sorted_words)\n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # split the string into a list of words\n    words = s.split(' ')\n    # for each word, sort its characters in ascending order based on ascii value\n    for i in range(len(words)):\n        words[i] = ''.join(sorted(words[i]))\n    # join the words back into a string, separated by spaces\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # split the string into words\n    words = s.split(' ')\n\n    # sort the characters in each word\n    sorted_words = [''.join(sorted(word)) for word in words]\n\n    # join the words back together\n    sorted_s = ' '.join(sorted_words)\n\n    return sorted_s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # split the string into a list of words\n    words = s.split(' ')\n    # initialize an empty list to store the anti-shuffled words\n    anti_shuffled_words = []\n    # loop through each word in the list of words\n    for word in words:\n        # split the word into a list of letters\n        letters = list(word)\n        # sort the list of letters in ascending order based on ASCII value\n        letters.sort(key=ord)\n        # join the list of sorted letters into a string\n        sorted_word = ''.join(letters)\n        # append the sorted word to the list of anti-shuffled words\n        anti_shuffled_words.append(sorted_word)\n    # join the list of anti-shuffled words into a string, with spaces between words\n    anti_shuffled_sentence = ' '.join(anti_shuffled_words)\n    # return the anti-shuffled sentence\n    return anti_shuffled_sentence", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the string into words\n    words = s.split(' ')\n\n    # Order each word\n    ordered_words = [''.join(sorted(word)) for word in words]\n\n    # Combine the words back into a single string\n    ordered_string = ' '.join(ordered_words)\n\n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    # Sort each word and join them back together\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Join the ordered words with spaces to get the ordered sentence\n    ordered_s = ' '.join(ordered_words)\n    return ordered_s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the string into words\n    words = s.split(\" \")\n\n    # For each word, sort its characters and join them together\n    ordered_words = [''.join(sorted(word)) for word in words]\n\n    # Join the ordered words with spaces and return the result\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    shuffled_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(shuffled_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split string into words\n    words = s.split(' ')\n\n    # For each word, sort the characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n\n    # Reconstruct the string with sorted words and return\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return \" \".join([''.join(sorted(word)) for word in s.split(' ')])", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split string into words\n    words = s.split(' ')\n\n    # For each word, sort characters\n    ordered_words = [''.join(sorted(word)) for word in words]\n\n    # Join words back together\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Splitting the input string into a list of words\n    words = s.split(\" \")\n\n    # Initiating an empty list to hold ordered words\n    ordered_words = []\n\n    # Iterating over each word\n    for word in words:\n        # Splitting each word into a list of characters\n        chars = list(word)\n\n        # Sorting the characters based on their ASCII values\n        chars.sort(key=lambda x: ord(x))\n\n        # Joining the sorted characters to form the ordered word\n        ordered_word = \"\".join(chars)\n\n        # Appending the ordered word to the list\n        ordered_words.append(ordered_word)\n\n    # Joining the ordered words to form the ordered sentence\n    ordered_sentence = \" \".join(ordered_words)\n\n    return ordered_sentence", "matching_cluster_idx": 2}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    anti_shuffled_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(anti_shuffled_words)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 61.023054755043226, "dps_norm": 52.142857142857146, "pass@1": 78.0, "profiled": [{"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row[::-1]):\n            if val == x:\n                coordinates.append((i, len(row) - j - 1))\n    return sorted(coordinates, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, elem in enumerate(row[::-1]):\n            if elem == x:\n                coordinates.append((i, len(row) - 1 - j))\n    return sorted(coordinates, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find all occurrences of integer x in a given 2D list and return a list of tuples representing their coordinates.\n    Coordinates are sorted initially by rows in ascending order, and then by columns in descending order within each row.\n    \"\"\"\n    coords = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    coords.sort(key=lambda x: (x[0], -x[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                coords.append((i, j))\n    coords.sort(key = lambda coord: (coord[0], -coord[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    return sorted(sorted(coordinates, key=lambda k: k[1], reverse=True), key=lambda k: k[0])", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    return sorted(coordinates, key = lambda x: (x[0], -x[1]))", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row):\n            if col == x:\n                coordinates.append((i, j))\n    return sorted(coordinates, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    # Sort by columns in descending order\n    coordinates.sort(key=lambda coord: coord[1], reverse=True)\n    # Sort by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    coordinates.sort(key = lambda x: (x[0], -x[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        if x in row:\n            indices = [j for j, val in enumerate(row) if val == x]\n            indices.reverse()\n            coordinates.extend([(i, j) for j in indices])\n    return coordinates", "matching_cluster_idx": 5}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coords.append((i, j))\n    coords.sort(key=lambda x: (x[0], -x[1]))\n    return coords", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, elem in enumerate(row):\n            if elem == x:\n                coords.append((i, j))\n    coords.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row):\n            if col == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda t: (t[0], -t[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Create an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over the rows in the list\n    for i in range(len(lst)):\n        # Iterate over the columns in the current row\n        for j in range(len(lst[i])):\n            # If the current element equals x\n            if lst[i][j] == x:\n                # Append its coordinate to the list\n                coordinates.append((i, j))\n\n    # Sort the coordinates initially by rows in ascending order\n    # and also, sort coordinates of the row by columns in descending order\n    coordinates.sort(key = lambda x: (x[0], -x[1]))\n\n    # Return the list of coordinates\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    # create a list of coordinates (row, col) for the given integer x\n    coordinates = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    # sort the list of coordinates by rows in ascending order and then by columns in descending order\n    coordinates.sort(key=lambda tup: (tup[0], -tup[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                result.append((i, j))\n    result.sort(key = lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    coordinates.sort(key = lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n\n    # sort initially by rows in ascending order\n    coordinates.sort(key = lambda coord: coord[0])\n\n    # sort by columns in descending order for each row\n    row_coordinates = []\n    for i in range(len(coordinates)):\n        if i == 0 or coordinates[i][0] != coordinates[i-1][0]:\n            if row_coordinates:\n                row_coordinates.sort(key = lambda coord: coord[1], reverse=True)\n                coordinates[i-row_len:i] = row_coordinates\n            row_coordinates = [coordinates[i]]\n            row_len = 1\n        else:\n            row_coordinates.append(coordinates[i])\n            row_len += 1\n\n    if row_coordinates:\n        row_coordinates.sort(key = lambda coord: coord[1], reverse=True)\n        coordinates[-row_len:] = row_coordinates\n\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                coords.append((i, j))\n    return sorted(coords, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 73.0, "profiled": [{"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n\n    Example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = \"\"\n    for char in s:\n        ascii_val = ord(char)\n        if char.islower():\n            # For lowercase letters, shift down by 4 places and wrap around to 'a' if needed\n            encrypted_val = (ascii_val - ord('a') + 4) % 26 + ord('a')\n        elif char.isupper():\n            # For uppercase letters, shift down by 4 places and wrap around to 'A' if needed\n            encrypted_val = (ascii_val - ord('A') + 4) % 26 + ord('A')\n        else:\n            # For non-alphabetic characters, leave them as is\n            encrypted_val = ascii_val\n        encrypted += chr(encrypted_val)\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for letter in s:\n        # check if the character is a letter\n        if letter.isalpha():\n            # if the letter is lowercase\n            if letter.islower():\n                result += chr(((ord(letter) - 97 + 2*2) % 26) + 97)\n            # if the letter is uppercase\n            else:\n                result += chr(((ord(letter) - 65 + 2*2) % 26) + 65)\n        else:\n            result += letter\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_s = \"\"\n    for c in s:\n        if c.isalpha():\n            shift = 2 * 2\n            ascii_offset = ord('a') if c.islower() else ord('A')\n            encrypted_s += chr((ord(c) - ascii_offset + shift) % 26 + ascii_offset)\n        else:\n            encrypted_s += c\n    return encrypted_s", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = ''\n    for c in s:\n        if c.islower():\n            encrypted += chr((ord(c) - 97 + 2*2) % 26 + 97)\n        elif c.isupper():\n            encrypted += chr((ord(c) - 65 + 2*2) % 26 + 65)\n        else:\n            encrypted += c\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument\n    and returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    \"\"\"\n    # create empty string to store encrypted text\n    encrypted_text = \"\"\n    # iterate through characters in input string\n    for char in s:\n        # check if character is a letter\n        if char.isalpha():\n            # determine whether character is upper or lowercase\n            shift = 2 * 2 if char.isupper() else 2 * 2\n            # rotate character two places down the alphabet\n            encrypted_char = chr((ord(char) + shift - 65) % 26 + 65) if char.isupper() else chr((ord(char) + shift - 97) % 26 + 97)\n            # append encrypted character to encrypted text\n            encrypted_text += encrypted_char\n        else:\n            # append non-letter characters to encrypted text unchanged\n            encrypted_text += char\n    # return encrypted text\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for c in s:\n        if c.isalpha():\n            shift = 2 * 2\n            start = ord('a') if c.islower() else ord('A')\n            encrypted += chr((ord(c) - start + shift) % 26 + start)\n        else:\n            encrypted += c\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65  # ASCII value of 'a' or 'A'\n            result += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            result += char\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_str = \"\"\n    for ch in s:\n        if ch.isalpha():\n            shift = 4 if ch.islower() else 4  # rotate down by 4 places for both lower and upper case letters\n            encrypted_str += chr((ord(ch) - ord('a' if ch.islower() else 'A') + shift) % 26 + ord('a' if ch.islower() else 'A'))\n        else:\n            encrypted_str += ch  # keep non-alphabet characters as is\n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # get unicode of character, apply shift, and convert back to character\n            if char.isupper():\n                result += chr((ord(char) - 65 + 2*2) % 26 + 65)\n            else:\n                result += chr((ord(char) - 97 + 2*2) % 26 + 97)\n        else:\n            # keep non-alphabet characters unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 2 * 2\n    encrypted_s = ''\n    for char in s:\n        if char in alphabet:\n            index = (alphabet.index(char) + shift) % len(alphabet)\n            encrypted_s += alphabet[index]\n        else:\n            encrypted_s += char\n    return encrypted_s", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_string = ''\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            encrypted_string += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            encrypted_string += char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_s = \"\"\n    for char in s:\n        if char.isalpha():\n            if char.isupper():\n                encrypted_s += chr((ord(char) - 65 + 2 * 2) % 26 + 65)\n            else:\n                encrypted_s += chr((ord(char) - 97 + 2 * 2) % 26 + 97)\n        else:\n            encrypted_s += char\n    return encrypted_s", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    \"\"\"\n    result = ''\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_text = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            encrypted_text += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            encrypted_text += char\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    \"\"\"\n    result = ''\n    for char in s:\n        # ensure the character is a lowercase letter\n        if char.islower():\n            # use the 'ord' function to get the ASCII value of the character\n            # add 4 to the ASCII value and use the modulus operator to wrap around 'z'\n            result += chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        # if the character is uppercase, convert it to lowercase before encrypting\n        elif char.isupper():\n            result += chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n        # if the character is not a letter, leave it unchanged\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_text = \"\"\n    for char in s:\n        # Check if character is an alphabet\n        if char.isalpha():\n            # Convert the alphabet to ASCII and calculate the shift\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted_text += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            encrypted_text += char\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        # Check if the character is a lowercase letter\n        if char.isalpha() and char.islower():\n            # Shift the letter down by two multiplied by two places\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result += encrypted_char\n        else:\n            # If the character is not a lowercase letter, leave it as is\n            result += char\n    return result", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 59.82490272373541, "dps_norm": 50.416666666666664, "pass@1": 76.0, "profiled": [{"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    # sorting the list in ascending order\n    sorted_list = sorted(lst)\n\n    # remove duplicates from the sorted list\n    unique_list = []\n    for num in sorted_list:\n        if num not in unique_list:\n            unique_list.append(num)\n\n    # check if there is a second smallest element and return it\n    if len(unique_list) >= 2:\n        return unique_list[1]\n    else:\n        return None", "matching_cluster_idx": 0}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    if second_smallest == float('inf'):\n        return None\n    return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # First, we remove any duplicates from the list\n    lst = list(set(lst))\n\n    # Then, we sort the list\n    lst.sort()\n\n    # If the list has less than 2 elements, we return None\n    if len(lst) < 2:\n        return None\n\n    # Otherwise, we return the second element\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    smallest = float('inf')\n    next_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            next_smallest = smallest\n            smallest = num\n        elif num < next_smallest and num != smallest:\n            next_smallest = num\n\n    return None if next_smallest == float('inf') else next_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    # Check if list is long enough\n    if len(lst) < 2:\n        return None\n    # Remove duplicates\n    unique_lst = list(set(lst))\n    # Check if list with unique elements has enough numbers\n    if len(unique_lst) < 2:\n        return None\n    # Sort the list and return the second smallest number\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # first we eliminate any duplicates from the list\n    unique_lst = list(set(lst))\n    # then we sort the list\n    sorted_lst = sorted(unique_lst)\n    # if the list has less than 2 elements, return None\n    if len(sorted_lst) < 2:\n        return None\n    # otherwise, return the 2nd smallest element\n    else:\n        return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for i in lst:\n        if i < smallest:\n            second_smallest = smallest\n            smallest = i\n        elif i < second_smallest and i != smallest:\n            second_smallest = i\n\n    if second_smallest == float('inf'):\n        return None\n\n    return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    # Removing duplicates from the list\n    unique_lst = list(set(lst))\n\n    # If the list has less than 2 elements, return None\n    if len(unique_lst) < 2:\n        return None\n\n    # Sorting the list in ascending order\n    unique_lst.sort()\n\n    # Returning the 2nd element in the sorted list\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    This function returns the 2nd smallest element of the list.\n    If there is no such element, the function will return None.\n    \"\"\"\n    # Check if the list has at least two elements\n    if len(lst) < 2:\n        return None\n\n    # Initialize the smallest and second smallest elements to None\n    smallest = second_smallest = None\n\n    # Iterate over all elements in the list\n    for num in lst:\n        # If the current number is smaller than the smallest number seen so far\n        if smallest is None or num < smallest:\n            # Shift the smallest and the second smallest elements\n            second_smallest = smallest\n            smallest = num\n        # If the current number is greater than the smallest but smaller than the second smallest\n        elif smallest < num < (second_smallest if second_smallest is not None else float('inf')):\n            # Update the second smallest element\n            second_smallest = num\n\n    # If there is no second smallest element, return None\n    if second_smallest is None:\n        return None\n\n    # Otherwise, return the second smallest element\n    return second_smallest", "matching_cluster_idx": 4}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_numbers = set(lst)\n    if len(unique_numbers) < 2:\n        return None\n    else:\n        unique_numbers.remove(min(unique_numbers))\n        return min(unique_numbers)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    smallest = second_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    if second_smallest == float('inf'):\n        return None\n\n    return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    smallest = float('inf')\n    next_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            next_smallest = smallest\n            smallest = num\n        elif smallest < num < next_smallest:\n            next_smallest = num\n\n    if next_smallest == float('inf'):\n        return None\n\n    return next_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    smallest = float('inf')\n    next_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            next_smallest = smallest\n            smallest = num\n        elif num < next_smallest and num != smallest:\n            next_smallest = num\n\n    return next_smallest if next_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    # Remove duplicates from the list by converting it to a set and then back to a list\n    lst = list(set(lst))\n    # Sort the list in ascending order\n    lst.sort()\n    # If the list has less than 2 elements, return None\n    if len(lst) < 2:\n        return None\n    # Otherwise, return the second element of the list\n    else:\n        return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    next_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            next_smallest = smallest\n            smallest = num\n        elif smallest < num < next_smallest:\n            next_smallest = num\n    return None if next_smallest == float('inf') else next_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    # create a set from the list to remove duplicates, sort it in ascending order,\n    # and check if there's at least 2 elements in the set\n    sorted_set = sorted(set(lst))\n    if len(sorted_set) >= 2:\n        # if yes, return the second element\n        return sorted_set[1]\n    # otherwise, return None\n    else:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst = list(set(lst))\n    lst.sort()\n    return lst[1] if len(lst) >= 2 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # create a set from the list to eliminate duplicate elements\n    unique_lst = set(lst)\n    # check if the list contains at least 2 unique elements\n    if len(unique_lst) < 2:\n        return None\n    # remove the smallest element from the set\n    unique_lst.remove(min(unique_lst))\n    # return the smallest remaining element (which is the 2nd smallest in the original list)\n    return min(unique_lst)", "matching_cluster_idx": 5}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 73.0, "profiled": [{"solution": "def odd_count(lst):\n    output = []\n    for s in lst:\n        odd_count = sum([1 for c in s if int(c) % 2 != 0])\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    res = []\n    for string in lst:\n        count = sum(int(c) % 2 != 0 for c in string)\n        res.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return res", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        odd_numbers = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(\"the number of odd elements \" + str(odd_numbers) + \"n the str\" + str(odd_numbers) + \"ng \" + str(odd_numbers) + \" of the \" + str(odd_numbers) + \"nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        odd_cnt = sum(1 for c in s if int(c) % 2 == 1)\n        output_str = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_cnt, odd_cnt, odd_cnt, odd_cnt)\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        count = sum(int(d) % 2 for d in s)\n        output = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for string in lst:\n        count = sum(1 for char in string if int(char) % 2 != 0)\n        s = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(count, count, count, count)\n        output.append(s)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def replace_odd(s):\n        num_odd = sum(int(c) % 2 for c in s)\n        return 'the number of odd elements ' + str(num_odd) + 'n the str' + str(num_odd) + 'ng ' + str(num_odd) + ' of the ' + str(num_odd) + 'nput.'\n\n    return [replace_odd(s) for s in lst]", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i, s in enumerate(lst):\n        num_odd = sum(int(c) % 2 for c in s)\n        string_num_odd = str(num_odd)\n        output.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(string_num_odd, string_num_odd, string_num_odd, string_num_odd))\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, nums in enumerate(lst):\n        odd_count = sum(1 for num in nums if int(num) % 2 != 0)\n        statement = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(statement)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    sentence = \"the number of odd elements in the string i of the input.\"\n\n    for s in lst:\n        count = sum([1 for c in s if int(c) % 2 != 0])\n        new_sentence = sentence.replace(\"i\", str(count))\n        result.append(new_sentence)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for string in lst:\n        count = sum(1 for char in string if int(char) % 2 != 0)\n        result = \"the number of odd elements \" + str(count) + \"n the str\" + str(count) + \"ng \" + str(count) + \" of the \" + str(count) + \"nput.\"\n        output.append(result)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        count = sum(int(d) % 2 for d in s)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits,\n    return a list. Each element i of the output should be \"the number of\n    odd elements in the string i of the input.\", where all the i's are\n    replaced by the number of odd digits in the i'th string of the input.\n\n    Examples:\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    # Initialize an empty list to store the results\n    result = []\n\n    # Iterate over each string in the input list\n    for s in lst:\n        # Count the number of odd digits in the current string\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n\n        # Replace the placeholders in the template with the count of odd digits\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        result_str = template.format(odd_digits, odd_digits, odd_digits, odd_digits)\n\n        # Add the result string to the result list\n        result.append(result_str)\n\n    # Return the result list\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for string in lst:\n        odd_numbers = sum(1 for char in string if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_numbers}n the str{odd_numbers}ng {odd_numbers} of the {odd_numbers}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        num_odd = str(sum(1 for c in s if int(c) % 2 != 0))\n        text = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        result.append(text.format(num_odd, num_odd, num_odd, num_odd))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i, string in enumerate(lst):\n        num_odd = sum([1 for char in string if int(char) % 2 != 0])\n        sentence = f\"the number of odd elements {num_odd}n the str{num_odd}ng {num_odd} of the {num_odd}nput.\"\n        output.append(sentence)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        output_string = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    results = []\n    for string in lst:\n        num_odd = sum(int(char) % 2 != 0 for char in string)\n        result = f\"the number of odd elements {num_odd}n the str{num_odd}ng {num_odd} of the {num_odd}nput.\"\n        results.append(result)\n    return results", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for str_number in lst:\n        count = sum(1 for char in str_number if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "HumanEval/120": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "HumanEval/121": {"dps": 81.0762331838565, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum([lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 == 1])", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements\n    that are in even positions.\n\n    Args:\n        lst (List[int]): List of integers.\n\n    Returns:\n        int: Sum of all odd elements in even positions.\n    \"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(val for i, val in enumerate(lst) if val % 2 != 0 and i % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all the odd elements that are in even positions.\n    \"\"\"\n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(val for i, val in enumerate(lst) if val % 2 != 0 and i % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    # Initialize the sum to 0\n    sum = 0\n    # Iterate through the list with even indexes\n    for i in range(0, len(lst), 2):\n        # Check if the element at the index is odd\n        if lst[i] % 2 != 0:\n            # If it is, add it to the sum\n            sum += lst[i]\n    # Return the sum of all odd elements at even positions\n    return sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if x % 2 != 0 and i % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if x % 2 == 1 and i % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    # initialize sum variable\n    odd_sum = 0\n    # iterate over the list with indexes\n    for i in range(len(lst)):\n        # if index is even and value is odd, add it to the sum\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            odd_sum += lst[i]\n    return odd_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(val for idx, val in enumerate(lst) if val % 2 == 1 and idx % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initial sum is 0\n    result = 0\n\n    # Iterate over elements with even index\n    for i in range(0, len(lst), 2):\n\n        # Check if the element is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            result += lst[i]\n\n    # Return the sum\n    return result", "matching_cluster_idx": 4}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 99.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    filtered_lst = [i for i in lst if len(i) % 2 == 0]\n    filtered_lst.sort(key=lambda x: (len(x), x))\n    return filtered_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort by length of each word and then alphabetically\n    lst.sort(key=lambda word: (len(word), word))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    # sort the list first by length of each word and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort the list in ascending order of length and alphabetically\n    lst.sort(key=lambda word: (len(word), word))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out the strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list by length of each word and then alphabetically if two words have the same length\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort the list by the length of each word\n    # If two words have the same length, sort the list alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # deletes the strings that have odd lengths from the list\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # sort the list by length of each word and alphabetically if lengths are the same\n    lst.sort(key = lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Deleting strings with odd length\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sorting list based on length of words and alphabetically if length is equal\n    lst.sort(key=lambda word: (len(word), word))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \"\"\"\n    # delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # sort the list by length, and if two words have the same length, sort alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # delete the strings that have odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # sort the list by length of each word and then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    lst = [word for word in lst if len(word) % 2 == 0]\n    lst.sort(key=lambda word: (len(word), word))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # filter the list and remove strings with odd length\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # sort the list by the length of each word and then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out words with odd length\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort list by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # filter out strings with odd lengths\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # sort list by length of each word and then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings that have odd lengths from the list\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort the list by length of each word and then alphabetically\n    lst.sort(key=lambda word: (len(word), word))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    lst = [word for word in lst if len(word) % 2 == 0]\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Deletes strings that have odd lengths from the list\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sorts the list in ascending order by length of each word, and then alphabetically for words with same length\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings with odd lengths from the list\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the list by the length of each word in ascending order\n    # If two words have the same length, sort the list alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete strings that have odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 78.00847457627118, "dps_norm": 88.125, "pass@1": 98.0, "profiled": [{"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n == 2:\n        return False\n    elif n % 2 == 0:\n        return True\n    else:\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return True\n        return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function takes an integer n as an input and returns True if the number is not prime,\n    and False if the number is prime.\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2):\n        return True\n    return any(n % i == 0 for i in range(3, int(n**0.5) + 1, 2))", "matching_cluster_idx": 6}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n == 2:\n        return False\n    elif n % 2 == 0:\n        return True\n    i = 3\n    while i * i <= n:\n        if n % i:\n            i += 2\n        else:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not a prime number. False if it is a prime number.\"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function takes an integer as an argument and returns True if the integer is not prime, and False if the integer is prime.\n    \"\"\"\n    # 0 and 1 are not prime\n    if n < 2:\n        return True\n\n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}]}, "Mbpp/4": {"dps": 80.40955631399318, "dps_norm": 81.66666666666666, "pass@1": 95.0, "profiled": [{"solution": "def heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    import heapq  # python's built-in module that provides an implementation of the heap queue algorithm\n\n    # Convert the input list to a list of negative numbers and use heapq.nsmallest() function\n    # to find the n smallest numbers from the list. Then, convert the result back to positive numbers.\n    return [-num for num in heapq.nsmallest(n, (-num for num in nums))]", "matching_cluster_idx": 8}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    largest = heapq.nlargest(n, numbers)\n    largest.sort(reverse=True)\n    return largest", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    import heapq\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    largest_nums = heapq.nlargest(n, nums)\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use min heap with size n\n    min_heap = []\n    for number in numbers:\n        # Add the number to the heap\n        heapq.heappush(min_heap, number)\n        # If the size of the heap exceeds n, remove the smallest number\n        if len(min_heap) > n:\n            heapq.heappop(min_heap)\n\n    # The heap now contains the n largest numbers in ascending order.\n    # Use sorted function to get these numbers in descending order.\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 8}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    # Using nlargest to get the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    # Sorting in descending order\n    largest_nums.sort(reverse=True)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(lst, n):\n    import heapq\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    :param nums: List of integers.\n    :param n: Integer, number of largest integers to find.\n    :return: List of n largest integers in descending order.\n    \"\"\"\n    if n <= 0 or nums == []:\n        return []\n\n    # Keep track of the n largest numbers in a min-heap\n    largest = nums[:n]\n    heapq.heapify(largest)\n\n    for i in range(n, len(nums)):\n        if nums[i] > largest[0]:\n            heapq.heappop(largest)\n            heapq.heappush(largest, nums[i])\n\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > n:\n            heapq.heappop(heap)\n    return sorted(heap, reverse=True)", "matching_cluster_idx": 8}, {"solution": "def heap_queue_largest(nums, n):\n    \"\"\"\n    A function to find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param nums: A list of integers.\n    :param n: An integer, the number of largest integers to find.\n    :return: A list of n largest integers, in descending order.\n    \"\"\"\n    import heapq\n\n    # Push the numbers onto a min heap.\n    min_heap = []\n    for num in nums:\n        heapq.heappush(min_heap, num)\n        # If the size of the heap exceeds n, pop the smallest element.\n        if len(min_heap) > n:\n            heapq.heappop(min_heap)\n\n    # The heap now contains the n largest elements.\n    # Pop them all and return them in descending order.\n    return [heapq.heappop(min_heap) for _ in range(n)][::-1]", "matching_cluster_idx": 8}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # using heapq.nlargest function to get n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    # sort the numbers in descending order\n    largest.sort(reverse=True)\n    return largest", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(lst, n):\n    import heapq\n    return heapq.nlargest(n, lst)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers.\n\n    Args:\n    nums: list of integers\n    n: integer, number of largest integers to return\n\n    Returns:\n    list of n largest integers, sorted in descending order\n    \"\"\"\n    # Use the nlargest function from the heapq module to get the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n\n    # Sort the numbers in descending order\n    largest_nums.sort(reverse=True)\n\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 31.564625850340136, "dps_norm": 46.0, "pass@1": 15.0, "profiled": [{"solution": "def find_Rotations(s):\n    # Loop for n rotations (where n is length of the string)\n    for i in range(1, len(s)):\n        # Rotate the string by slicing it\n        rotated_string = s[i:] + s[:i]\n        # If the rotated string equals the original string\n        if rotated_string == s:\n            # Return the number of rotations\n            return i\n    # If no rotations required return the length of the string\n    return len(s)", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    # Get the length of the string\n    n = len(s)\n\n    # An array to hold the rotations of string s\n    arr = ['' for _ in range(n)]\n\n    # Fill arr[] with all rotations of s\n    for i in range(n):\n        arr[i] = s[i:n] + s[0:i]\n\n    # Return the index of first occurrence of s\n    for i in range(1, n):\n        if arr[i] == s:\n            return i\n\n    # No rotation is needed, return n which is the length of the string\n    return n", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        rotated_str = s[i:] + s[:i]\n        if rotated_str == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Function to find the minimum number of rotations (greater than 0) required to get the same string.\n    It considers the initial string and all of its rotations. For a given string, all rotations are\n    considered different unless we perform rotation equal to the length of the string.\n    \"\"\"\n    # If length of string is 1, it's the same string in all rotations\n    if len(s) == 1:\n        return 1\n    # Creating all rotations of the string and searching for the first occurence of the original string\n    for i in range(1, len(s)):\n        if s[i:] + s[:i] == s:\n            return i\n    # If the string is not found in any rotation, we return length of string\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    rotations = 0\n    for i in range(1, n):\n        rotations += 1\n        if s[i:] + s[:i] == s:\n            return rotations\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    # Length of the string\n    n = len(s)\n\n    # Iterate through possible rotations\n    for i in range(1, n):\n        # If the string equals to its rotation, return current rotation index\n        if s[i:] + s[:i] == s:\n            return i\n\n    # If no rotation was found, return -1 (or n in this case as 0 rotations is not allowed)\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(input_str: str) -> int:\n    for i in range(1, len(input_str)):\n        rotated_str = input_str[i:] + input_str[:i]\n        if rotated_str == input_str:\n            return i\n    return len(input_str)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if all(s[(i+j) % n] == s[j] for j in range(n)):\n            return i\n    return n", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    # if string is empty or has length 1, it requires 1 rotation\n    if len(s) <= 1:\n        return 1\n    # if all characters in string are the same, it requires 1 rotation\n    elif len(set(s)) == 1:\n        return 1\n    # initialize number of rotations required\n    rotations = len(s)\n    # loop through all rotations\n    for i in range(1, len(s)):\n        # rotate the string\n        s = s[-1] + s[:-1]\n        # if the rotated string is equal to the original string, return number of rotations\n        if s == s[0]*len(s):\n            rotations = i\n            break\n    return rotations", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if all(s[i-j] == s[0] for j in range(n)):\n            return i\n    return n", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    n = len(s)\n\n    # Try for all possible rotations\n    for i in range(1, n):\n        # Check if the string can be made the same by rotating it 'i' times\n        if all(s[j] == s[(j + i) % n] for j in range(n)):\n            return i\n\n    # If no rotation can make it the same\n    return n", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        if s == (s[i:] + s[:i]):\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string):\n    n = len(string)\n    for i in range(1, n):\n        if string[i:] + string[:i] == string:\n            return i\n    return n", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 52.25806451612903, "dps_norm": 79.44444444444444, "pass@1": 37.0, "profiled": [{"solution": "def remove_Occ(s, char):\n    # Find the first and last occurrence of the char\n    first = s.find(char)\n    last = s.rfind(char)\n    # If char is not in string, return string as is\n    if first == -1:\n        return s\n    # If there is only one occurrence of char, return string without char\n    if first == last:\n        return s[:first] + s[first + 1:]\n    # Return string without first and last occurrence of char\n    return s[:first] + s[first + 1:last] + s[last + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, char_to_remove):\n    # Remove first occurrence\n    output_str = input_str.replace(char_to_remove, '', 1)\n    # Remove last occurrence\n    output_str = output_str.rpartition(char_to_remove)[0] + output_str.rpartition(char_to_remove)[2]\n    return output_str", "matching_cluster_idx": 6}, {"solution": "def remove_Occ(s, ch):\n    first = s.find(ch)\n    last = s.rfind(ch)\n    if first == -1 or last == -1:\n        return s\n    elif first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Removes the first occurrence of the character from the string.\n    first_ch_removed = s.replace(ch, '', 1)\n\n    # Removes the last occurrence of the character from the string.\n    last_ch_removed = first_ch_removed[::-1].replace(ch, '', 1)[::-1]\n\n    return last_ch_removed", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(input_string: str, char: str) -> str:\n    # Remove first occurrence\n    input_string = input_string.replace(char, \"\", 1)\n    # Reverse string and remove first occurrence of char again, then reverse back to get the original string with last occurrence of char removed\n    input_string = input_string[::-1].replace(char, \"\", 1)[::-1]\n    return input_string", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(input_string: str, char: str) -> str:\n    first_occurrence = input_string.find(char)\n    last_occurrence = input_string.rfind(char)\n    if first_occurrence != -1 and last_occurrence != -1:\n        if first_occurrence == last_occurrence:\n            return input_string.replace(char, \"\", 1)\n        else:\n            return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]\n    else:\n        return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, ch):\n    # Removing the first occurrence\n    input_str = input_str.replace(ch, '', 1)\n    # Reverse string and remove first occurrence of the character again (This will be the last occurrence in the original string)\n    input_str = input_str[::-1].replace(ch, '', 1)[::-1]\n    return input_str", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, char):\n    # remove first occurrence of the character\n    s = s.replace(char, \"\", 1)\n    # reverse the string and remove first occurrence of the character\n    s = s[::-1].replace(char, \"\", 1)[::-1]\n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(string, char):\n    first = string.find(char)\n    last = string.rfind(char)\n    if first == -1 or last == -1:\n        return string\n    else:\n        return string[:first] + string[first+1:last] + string[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string: str, target_char: str) -> str:\n    \"\"\"\n    This function removes first and last occurrence of a given character from a string.\n    Args:\n        input_string (str): The original string\n        target_char (str): The character to be removed\n    Returns:\n        str: The modified string\n    \"\"\"\n    # finding the first and last occurrence index of target_char in input_string\n    first_occ = input_string.find(target_char)\n    last_occ = input_string.rfind(target_char)\n\n    # if the target_char is found in input_string\n    if first_occ != -1 and last_occ != -1:\n        # if the target_char occurs only once\n        if first_occ == last_occ:\n            return input_string[:first_occ] + input_string[first_occ+1:]\n        # if the target_char occurs more than once\n        else:\n            return input_string[:first_occ] + input_string[first_occ+1:last_occ] + input_string[last_occ+1:]\n    # if the target_char is not found in input_string\n    else:\n        return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first_occurrence = s.find(ch)\n    last_occurrence = s.rfind(ch)\n    if first_occurrence != -1 and last_occurrence != -1:\n        if first_occurrence == last_occurrence:\n            return s[:first_occurrence] + s[first_occurrence+1:]\n        elif first_occurrence == 0:\n            return s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n        elif last_occurrence == len(s)-1:\n            return s[:first_occurrence] + s[first_occurrence+1:last_occurrence]\n        else:\n            return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    else:\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, ch: str) -> str:\n    # Remove the first occurrence of the character\n    first_remove = s.replace(ch, '', 1)\n\n    # Reverse the string and remove the first occurrence of the character\n    last_remove = first_remove[::-1].replace(ch, '', 1)\n\n    # Return the reversed string, which is the original string with the last occurrence of the character removed\n    return last_remove[::-1]", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(string, char):\n    # Remove first occurrence\n    string = string.replace(char, '', 1)\n    # Reverse string and remove first occurrence again (which is the last occurrence of original string)\n    string = string[::-1].replace(char, '', 1)[::-1]\n    return string", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(string, char):\n    first_char_removed = string.replace(char, '', 1)\n    last_char_removed = first_char_removed.rsplit(char, 1)\n    return ''.join(last_char_removed)", "matching_cluster_idx": 6}, {"solution": "def remove_Occ(s, ch):\n    first_occurrence = s.find(ch)\n    if first_occurrence != -1:\n        s = s[:first_occurrence] + s[first_occurrence + 1:]\n    last_occurrence = s.rfind(ch)\n    if last_occurrence != -1:\n        s = s[:last_occurrence] + s[last_occurrence + 1:]\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(input_str, char_to_remove):\n    first_char_index = input_str.find(char_to_remove)\n    if first_char_index == -1:\n        return input_str\n    last_char_index = input_str.rfind(char_to_remove)\n    return input_str[:first_char_index] + input_str[first_char_index+1:last_char_index] + input_str[last_char_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    # find the first and last occurrence of the character\n    first_index = input_string.find(char_to_remove)\n    last_index = input_string.rfind(char_to_remove)\n\n    # replace the first and last occurrence of the character with empty string\n    if first_index != -1 and first_index != last_index:\n        return input_string[:first_index] + input_string[first_index+1:last_index] + input_string[last_index+1:]\n    elif first_index != -1 and first_index == last_index:\n        return input_string.replace(char_to_remove, '', 1)\n    else:\n        return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # check if the char exists in string\n    if char in string:\n        # remove first occurrence\n        string = string.replace(char, '', 1)\n        # reverse the string and remove the first occurrence of the character (which was the last in the original string)\n        string = string[::-1].replace(char, '', 1)[::-1]\n    return string", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, c):\n    # Remove first occurrence\n    s = s.replace(c, \"\", 1)\n    # Reverse the string, remove first occurrence and reverse back\n    s = s[::-1].replace(c, \"\", 1)[::-1]\n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, ch):\n    first = s.find(ch)\n    last = s.rfind(ch)\n\n    # if character not found\n    if first == -1:\n        return s\n\n    # if first and last occurrence is the same\n    if first == last:\n        return s[:first] + s[first+1:]\n\n    # removing the first and last occurrence\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 95.59299191374663, "dps_norm": 99.0625, "pass@1": 97.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # calculate the sum of each row and store it with the corresponding row in a list of tuples\n    matrix_sums = [(sum(row), row) for row in matrix]\n    # sort the list of tuples in ascending order according to the sum of each row\n    matrix_sums.sort()\n    # extract the sorted rows from the list of tuples\n    sorted_matrix = [row for sum, row in matrix_sums]\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    # sort the matrix based on row sums\n    matrix.sort(key=lambda row: sum(row))\n    return matrix", "matching_cluster_idx": 12}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and sort the indexes according to the sum\n    sorted_indexes = sorted(range(len(matrix)), key=lambda i: sum(matrix[i]))\n\n    # Return the matrix ordered by the sorted indexes\n    return [matrix[i] for i in sorted_indexes]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of its rows.\n\n    :param matrix: A list of lists where each inner list is a row of the matrix.\n    :return: A new list of lists with the same elements as the input, sorted as required.\n    \"\"\"\n    # Sorting the matrix based on the sum of its rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    sums = [sum(row) for row in matrix]\n    # Sort the matrix according to the row sums\n    sorted_matrix = [x for _, x in sorted(zip(sums, matrix))]\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate sum of each row\n    row_sums = [sum(row) for row in matrix]\n    # Zip sums with the corresponding rows\n    rows_with_sums = zip(row_sums, matrix)\n    # Sort by row sums\n    rows_with_sums = sorted(rows_with_sums)\n    # Extract the original rows and return\n    return [row for _, row in rows_with_sums]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # sort the matrix in ascending order according to the sum of its rows\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sorting the matrix according to the sum of its rows\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # sort the matrix by the sum of its rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # calculate the sum of each row and pair it with the original row\n    sum_matrix = [(sum(row), row) for row in matrix]\n    # sort the matrix based on the sum of each row\n    sum_matrix.sort()\n    # extract and return the sorted matrix\n    return [row for _, row in sum_matrix]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 81.09756097560975, "dps_norm": 86.875, "pass@1": 89.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    match = re.fullmatch('[a-z]+(_[a-z]+)*', input_string)\n    return match is not None", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    if not s:\n        return False\n\n    segments = s.split('_')\n    for segment in segments:\n        if not segment.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(input_string):\n    # Split the string by underscores\n    split_string = input_string.split('_')\n    # Check if each part is lowercase\n    return all(part.islower() for part in split_string)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    # split the string by underscore\n    sequences = s.split('_')\n    # check if all sequences are lowercase\n    return all(seq.islower() for seq in sequences)", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(input_string):\n    # split the input string by underscore and save it in a list\n    split_string = input_string.split('_')\n    # check if all the substrings are lowercase\n    if all(s.islower() for s in split_string):\n        # if all substrings are lowercase, return True\n        return True\n    # otherwise return False\n    return False", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(input_string):\n    \"\"\"\n    Function that returns true if the input string contains sequences of lowercase letters joined with an underscore\n    and false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    segments = input_string.split('_')\n\n    for segment in segments:\n        if not segment.islower():\n            return False\n\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(input_string):\n    \"\"\"\n    This function checks whether the input string contains sequences of lowercase letters joined with an underscore.\n\n    Parameters:\n    input_string (str): The string to check.\n\n    Returns:\n    bool: True if the input_string contains sequences of lowercase letters joined with an underscore, otherwise False.\n    \"\"\"\n    # split the string by underscore\n    sequences = input_string.split('_')\n\n    # check each sequence\n    for sequence in sequences:\n        # if any sequence is not lowercase, return False\n        if not sequence.islower():\n            return False\n\n    # if all sequences are lowercase, return True\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Checks if the input string contains sequences of lowercase letters joined with an underscore\n    if re.match(\"^[a-z]+(_[a-z]+)*$\", input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Use regex to check if the string contains sequences of lowercase letters joined with an underscore\n    if re.fullmatch(r'[a-z]+(?:_[a-z]+)*', input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    if pattern.match(input_string):\n        return True\n    return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    \"\"\"\n    Function to check if the input string contains sequences of lowercase letters joined with an underscore.\n    \"\"\"\n    # Using regex to check if the string matches the pattern\n    if re.match(\"^[a-z]+(?:_[a-z]+)*$\", input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text):\n    # Check if the input is a string\n    if not isinstance(text, str):\n        return False\n\n    # Split the input string by underscore\n    parts = text.split('_')\n\n    # Check each part\n    for part in parts:\n        # Check if the part is all lowercase\n        if not part.islower():\n            return False\n\n    # If all parts are all lowercase, return True\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(input_string):\n    # split the input string by underscore\n    parts = input_string.split('_')\n    # check if all parts are lowercase and not empty\n    for part in parts:\n        if not part.islower() or len(part) == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def text_lowercase_underscore(s):\n    parts = s.split('_')\n    for part in parts:\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # use regex to match sequences of lowercase letters joined by underscore\n    match = re.fullmatch('[a-z]+(_[a-z]+)*', input_string)\n    return match is not None", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(input_string):\n    \"\"\"\n    This function checks if the input string contains sequences of lowercase letters joined with an underscore\n    and returns True if that is the case, or False otherwise.\n    \"\"\"\n    if input_string == '':  # empty string is considered not matching the pattern\n        return False\n    parts = input_string.split('_')  # split the string by underscore\n    for part in parts:  # for each part\n        if not part.islower():  # if the part is not all lowercase letters\n            return False  # return False\n    return True  # if all parts are lowercase, return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = re.compile('^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # using regex to check if the input string contains sequences of lowercase letters joined with an underscore\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    if re.match(pattern, s):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 69.94949494949495, "dps_norm": 83.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    # use a set to store the elements in the array\n    seen = set()\n    # iterate over the array\n    for num in arr:\n        # if the element is already in the set, return True\n        if num in seen:\n            return True\n        # otherwise, add the element to the set\n        else:\n            seen.add(num)\n    # if no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    This function checks if a given array contains any duplicate element.\n    It uses the property of a set, which does not allow duplicate elements.\n    If the length of the set is less than the length of the original list,\n    it means there were some duplicate elements in the list.\n    \"\"\"\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using the property of a set, duplicate elements will be removed\n    # If the size of set is less than list, then there is a duplicate\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # convert list to set, which removes duplicates\n    # if length of the set is less than length of the list, duplicates existed\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(numbers):\n    return len(numbers) != len(set(numbers))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    # convert list to set\n    s = set(lst)\n    # compare lengths of list and set\n    if len(s) == len(lst):\n        # if lengths are equal, no duplicates found\n        return False\n    else:\n        # if lengths are unequal, duplicates found\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Create an empty set\n    unique_elements = set()\n    # Loop through each element in the array\n    for el in arr:\n        # If element is already in the set, it is a duplicate\n        if el in unique_elements:\n            return True\n        # Add element to the set\n        else:\n            unique_elements.add(el)\n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    This function takes a list of integers as input and returns True if the list contains any duplicate elements,\n    and False otherwise.\n    \"\"\"\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Create an empty set\n    s = set()\n    # Loop over the array elements\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in s:\n            return True\n        # Add the element to the set\n        s.add(num)\n    # If no duplicate is found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate element\n    :param arr: List of integers\n    :return: Boolean value (True if contains duplicates, False otherwise)\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    # Create a set from the array\n    array_set = set(array)\n\n    # If length of the array is equal to length of the set, there are no duplicates.\n    # If length of the array is not equal to length of the set, there are duplicates.\n    if len(array) == len(array_set):\n        return False\n    else:\n        return True", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 89.5, "dps_norm": 93.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    \"\"\"\n    Function to find the smallest number in a list.\n    \"\"\"\n    # Initialize the smallest number with the first element of the list\n    smallest = lst[0]\n    # Loop over the list and update the smallest number if a smaller one is found\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    # Return the smallest number found\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(num_list):\n    # Check if list is not empty\n    if not num_list:\n        raise ValueError('The list is empty')\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    # Check if list is not empty\n    if len(num_list) != 0:\n        # Assume first number in list is smallest\n        smallest = num_list[0]\n\n        # Iterate over the list\n        for num in num_list:\n            # If a smaller number is found, update the smallest\n            if num < smallest:\n                smallest = num\n\n        # After iterating through all the numbers, return the smallest number found\n        return smallest\n    else:\n        return \"List is empty\"", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Function to find the smallest number in a list.\n    :param lst: A list of numbers.\n    :return: The smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"Return the smallest number in a list.\"\"\"\n    # Assume the first number in the list is the smallest\n    min_num = numbers[0]\n\n    # Iterate over the list\n    for number in numbers:\n        # If current number is less than the assumed smallest number, replace it\n        if number < min_num:\n            min_num = number\n\n    # Return the smallest number found\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function finds the smallest number in a list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Initialize smallest number to the first element in the list\n    smallest = lst[0]\n    # Iterate over the list\n    for num in lst:\n        # If a smaller number is found, update smallest\n        if num < smallest:\n            smallest = num\n    # Return the smallest number found\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Function to find the smallest number in a list\n\n    Args:\n    numbers (list): A list of numbers\n\n    Returns:\n    int: The smallest number in the list\n    \"\"\"\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    if len(lst) == 0:\n        return None\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    This function takes a list of numbers as an argument\n    and returns the smallest number in the list.\n    \"\"\"\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    # Initialize the smallest number as the first number in the list\n    smallest = num_list[0]\n    # Iterate through the list\n    for num in num_list:\n        # If a smaller number is found, update the smallest number\n        if num < smallest:\n            smallest = num\n    # Return the smallest number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    This function finds the smallest number in a list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n    \"\"\"\n    # initial value of smallest is the first number in the list\n    smallest = numbers[0]\n    # iterate over the list\n    for num in numbers:\n        # if a smaller number is found, update smallest\n        if num < smallest:\n            smallest = num\n    # return the smallest number\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 93.0, "dps_norm": 68.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples, k):\n    # Empty list to store tuples with all elements divisible by k\n    result = []\n    # Iterate over each tuple in the input list\n    for tup in tuples:\n        # Check if all elements in the tuple are divisible by k\n        if all(elem % k == 0 for elem in tup):\n            # If yes, append it to the result list\n            result.append(tup)\n    # Return the list of tuples with all elements divisible by k\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    # Function to check if all elements of a tuple are divisible by k\n    def all_divisible(tuple_elem):\n        for ele in tuple_elem:\n            if ele % k != 0:\n                return False\n        return True\n    # Filtering tuples with all elements divisible by k\n    result = [tuple_elem for tuple_elem in tuples if all_divisible(tuple_elem)]\n    return result", "matching_cluster_idx": 7}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    # initialise an empty list to hold the matching tuples\n    matching_tuples = []\n    # iterate over the tuples\n    for t in tuples:\n        # if all elements of the tuple are divisible by k\n        if all(x % k == 0 for x in t):\n            # add the tuple to the list of matching tuples\n            matching_tuples.append(t)\n    # return the list of matching tuples\n    return matching_tuples", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Define a helper function that checks if all elements of a tuple are divisible by k\n    def all_divisible_by_k(t, k):\n        for elem in t:\n            if elem % k != 0:\n                return False\n        return True\n\n    # Use a list comprehension to filter tuples for which all elements are divisible by k\n    return [t for t in tuples_list if all_divisible_by_k(t, k)]", "matching_cluster_idx": 7}, {"solution": "def find_tuples(tuples, k):\n    return [tuple_ for tuple_ in tuples if all(element % k == 0 for element in tuple_)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = []\n    for t in tuples:\n        if all(i % k == 0 for i in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tups, k):\n    result = []\n    for tup in tups:\n        if all(i % k == 0 for i in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = []\n    for t in tuples:\n        if all(i % k == 0 for i in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = []\n    for t in tuples:\n        if all(i % k == 0 for i in t):\n            result.append(t)\n    return result\ntuples = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = []\n    for tup in tuples:\n        if all(i % k == 0 for i in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tuple_ in tuples_list:\n        if all(elem % k == 0 for elem in tuple_):\n            result.append(tuple_)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Filter the list of tuples to keep only the ones where all elements are divisible by k.\n    # all() function returns True if all elements of the iterable are true.\n    # Here we use it to check if all elements of each tuple are divisible by k.\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = []\n    for t in tuples:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [tuple_ for tuple_ in tuples if all(i % k == 0 for i in tuple_)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    # Initialize an empty dictionary\n    freq_dict = {}\n    # Iterate over the elements in the list\n    for ele in lst:\n        # If the element is already a key in the dictionary, increment its value\n        if ele in freq_dict:\n            freq_dict[ele] += 1\n        # Otherwise, add the element as a new key in the dictionary with a value of 1\n        else:\n            freq_dict[ele] = 1\n    # Return the frequency dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary\n    freq_dict = {}\n    # Iterate through list\n    for i in lst:\n        # If element is already a key in dictionary, increment its value\n        if i in freq_dict:\n            freq_dict[i] += 1\n        # If element is not a key in dictionary, add it with a value of 1\n        else:\n            freq_dict[i] = 1\n    # Return the frequency dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    This function takes a list as input and returns a dictionary where\n    keys are the unique elements from the list and values are their frequencies.\n    \"\"\"\n    freq = {}\n    for item in lst:\n        if (item in freq):\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    count_dict = {}\n    for num in input_list:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    freq_dict = {}\n    for num in input_list:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    This function takes a list as an argument and returns a dictionary\n    where keys are unique elements in the list and values are the frequency of each element.\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    freq_dict = {}\n    for num in numbers:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if (item in freq):\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 80.53658536585367, "dps_norm": 86.42857142857142, "pass@1": 43.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    A function to find the length of the longest word in a list.\n\n    Parameters:\n    words (list): a list of strings.\n\n    Returns:\n    int: the length of the longest word.\n    \"\"\"\n    # Using max function and len function\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    \"\"\"\n    Function to find the length of the longest word in a list of strings.\n    \"\"\"\n    # initialize the maximum length of the word to 0\n    max_len = 0\n    # iterate over each word in the list\n    for word in word_list:\n        # update the maximum length if the current word is longer\n        if len(word) > max_len:\n            max_len = len(word)\n    # return the maximum length found\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    longest_length = 0\n    for word in words:\n        if len(word) > longest_length:\n            longest_length = len(word)\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize maximum length as 0\n    max_len = 0\n    # Loop over each word in the list\n    for word in words:\n        # Update max_len if current word is longer\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize maximum length with 0\n    max_length = 0\n\n    # Check each word in the list\n    for word in words:\n        # If the word length is more than max_length, update max_length\n        if len(word) > max_length:\n            max_length = len(word)\n\n    # Return the maximum length of word\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    max_length = 0\n    for word in word_list:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word\n    :param words: List of words\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    max_len = 0\n    for word in word_list:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    \"\"\"Find the length of the longest word in a list of words.\"\"\"\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    \"\"\"\n    This function takes a list of words as an input and returns the length of the longest word.\n    \"\"\"\n    # initialize max_length variable with the length of the first word\n    max_length = len(word_list[0])\n\n    # iterate over the list and update max_length if the length of the current word is larger\n    for word in word_list:\n        if len(word) > max_length:\n            max_length = len(word)\n\n    # return the length of the longest word\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    return len(max(word_list, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    longest_length = 0\n    for word in words:\n        if len(word) > longest_length:\n            longest_length = len(word)\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Start by assuming the length of the first word is the longest\n    max_length = len(words[0])\n    # Then iterate over the remaining words\n    for word in words[1:]:\n        # If we find a word with a greater length, update our max_length\n        if len(word) > max_length:\n            max_length = len(word)\n    # After we've iterated over all words, return the max_length\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    \"\"\"\n    Returns the length of the longest word in a given list.\n    \"\"\"\n    if not word_list:\n        return 0\n\n    max_len = len(word_list[0])\n    for word in word_list:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize longest word length to 0\n    longest = 0\n    # Iterate through each word in the list\n    for word in words:\n        # If the length of the current word is greater than the longest found so far\n        if len(word) > longest:\n            # Update the longest word length\n            longest = len(word)\n    # Return the length of the longest word\n    return longest", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 79.5579268292683, "dps_norm": 63.0, "pass@1": 94.0, "profiled": [{"solution": "def index_minimum(lst):\n    return min(lst, key = lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    This function receives a list of tuples and returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    # The min function with a key parameter set to a function that returns the second element in a tuple can be used to find the tuple with the smallest second value.\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    # Sorting the list of tuples based on the second element in each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Returning the first value of the tuple with the smallest second value\n    return sorted_list[0][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Initialize the smallest_tuple as the first tuple in the list\n    smallest_tuple = lst[0]\n\n    # Iterate through the list and update smallest_tuple if we find a tuple with a smaller second value\n    for tup in lst:\n        if tup[1] < smallest_tuple[1]:\n            smallest_tuple = tup\n\n    # Return the first value of the tuple with the smallest second value\n    return smallest_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(lst):\n    # sort list based on second value of tuples\n    lst.sort(key = lambda x: x[1])\n    # return the first value of the first tuple\n    return lst[0][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(input_list):\n    return min(input_list, key = lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    # initialize smallest value to float('inf'), a number larger than any potential second value in the list\n    smallest_value = float('inf')\n    # initialize smallest index to None\n    smallest_index = None\n    # iterate through the tuple list\n    for i, t in enumerate(tuple_list):\n        # if the second value of the tuple is smaller than the current smallest value\n        if t[1] < smallest_value:\n            # update the smallest value and smallest index\n            smallest_value = t[1]\n            smallest_index = i\n    # return the first value of the tuple with the smallest second value\n    return tuple_list[smallest_index][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # initialize minimum value and the corresponding name\n    min_value = float('inf')\n    name = \"\"\n    # go through each tuple in the list\n    for tup in lst:\n        # if the second value of the tuple is smaller than current minimum value\n        if tup[1] < min_value:\n            # update minimum value and the corresponding name\n            min_value = tup[1]\n            name = tup[0]\n    # return the name with the smallest second value\n    return name", "matching_cluster_idx": 4}, {"solution": "def index_minimum(lst):\n    # find the tuple with the minimum second value\n    min_tuple = min(lst, key=lambda x: x[1])\n    # return the first value of this tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    min_value = min(t[1] for t in tuples)\n    for t in tuples:\n        if t[1] == min_value:\n            return t[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Start by assuming the first tuple's second element is the smallest\n    min_value = tuples_list[0][1]\n    min_index = 0\n\n    # Then iterate through the remaining tuples\n    for i in range(1, len(tuples_list)):\n        if tuples_list[i][1] < min_value:\n            min_value = tuples_list[i][1]\n            min_index = i\n\n    # Finally, return the first value of the tuple with the smallest second value\n    return tuples_list[min_index][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Sort the list of tuples based on the second element of the tuple\n    sorted_lst = sorted(lst, key=lambda x: x[1])\n    # Return the first element of the first tuple in the sorted list\n    return sorted_lst[0][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key = lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Function to return the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(list_of_tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 51.11111111111111, "dps_norm": 45.714285714285715, "pass@1": 80.0, "profiled": [{"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, increment count by one\n            if n / i == i:\n                count += 1\n            # Otherwise, increment count by two\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    This function calculates the number of divisors of a given integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1 if n // i == i else 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 85.70940170940172, "dps_norm": 78.125, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    # Count the frequency of each element\n    frequency_dict = {i: flat_list.count(i) for i in flat_list}\n    return frequency_dict", "matching_cluster_idx": 1}, {"solution": "def frequency_lists(lists):\n    # flattening the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    # initializing an empty dictionary\n    freq_dict = {}\n    # calculating frequency of each element\n    for item in flat_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    # returning the dictionary\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    return {i: flat_list.count(i) for i in flat_list}", "matching_cluster_idx": 1}, {"solution": "def frequency_lists(lists):\n    # Flattening the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n    # Counting the frequency of each element and returning as a dictionary\n    frequency_dict = {i: flattened_list.count(i) for i in flattened_list}\n    return frequency_dict", "matching_cluster_idx": 1}, {"solution": "def frequency_lists(lst):\n    frequency_dict = {}\n    for sublist in lst:\n        for num in sublist:\n            if num in frequency_dict:\n                frequency_dict[num] += 1\n            else:\n                frequency_dict[num] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    frequency_dict = {}\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n    # Count the frequency of each element in the flattened list\n    for element in flat_list:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n\n    # Create an empty dictionary\n    frequency_dict = {}\n\n    # Iterate through the flattened list\n    for item in flattened_list:\n        # If the item is not in the dictionary, add it and set the count to 1\n        if item not in frequency_dict:\n            frequency_dict[item] = 1\n        # If the item is already in the dictionary, increment the count by 1\n        else:\n            frequency_dict[item] += 1\n\n    # Return the frequency dictionary\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst_of_lst):\n    freq = {}\n    for lst in lst_of_lst:\n        for el in lst:\n            if el in freq:\n                freq[el] += 1\n            else:\n                freq[el] = 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    \"\"\"Function to find frequency of each element in a flattened list of lists.\"\"\"\n    flatten_lst = [item for sublist in lst for item in sublist]\n    freq_dict = {}\n    for item in flatten_lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst_of_lst):\n    flattened_lst = [item for sublist in lst_of_lst for item in sublist]\n    frequency_dict = {}\n    for i in flattened_lst:\n        if i in frequency_dict:\n            frequency_dict[i] += 1\n        else:\n            frequency_dict[i] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst_of_lsts):\n    freq_dict = {}\n    for sublist in lst_of_lsts:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Flatten list of lists\n    flattened = [item for sublist in lst for item in sublist]\n\n    # Count frequency of each element\n    freq = {}\n    for i in flattened:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store frequencies\n    freq_dict = {}\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    # Iterate over the flattened list\n    for i in flat_list:\n        # If the element is already in the dictionary, increment its count\n        if i in freq_dict:\n            freq_dict[i] += 1\n        # If the element is not in the dictionary, add it with count 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Create an empty dictionary to store the frequency of each element\n    freq_dict = {}\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n    # For each element in the flattened list\n    for item in flat_list:\n        # If the element is not in the dictionary, add it with a value of 1\n        if item not in freq_dict:\n            freq_dict[item] = 1\n        # If the element is already in the dictionary, increment its value by 1\n        else:\n            freq_dict[item] += 1\n    # Return the frequency dictionary\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Flatten the list of lists\n    flattened = [item for sublist in lst for item in sublist]\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for item in flattened:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst_of_lst):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst_of_lst for item in sublist]\n\n    # Find frequency of each element\n    frequency_dict = {}\n    for element in flat_list:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    frequency_dict = {}\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n    # Count frequency of each element in the flattened list\n    for elem in flat_list:\n        if elem in frequency_dict:\n            frequency_dict[elem] += 1\n        else:\n            frequency_dict[elem] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst_of_lst):\n    freq_dict = {}\n    for sublist in lst_of_lst:\n        for num in sublist:\n            if num in freq_dict:\n                freq_dict[num] += 1\n            else:\n                freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 54.70779220779221, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    \"\"\"\n    This function takes a list and a tuple as input, appends the list to the tuple and returns the result.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Function to append the given list to the given tuple.\n    \"\"\"\n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    This function appends the given list to the given tuple.\n\n    Args:\n    lst (list): The given list.\n    tpl (tuple): The given tuple.\n\n    Returns:\n    tuple: The given tuple with the list appended to it.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    This function appends the given list to the given tuples and returns the resulting tuple.\n    Args:\n    lst (list): The input list.\n    tup (tuple): The input tuple.\n    Returns:\n    tuple: The resulting tuple after appending the list to the tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    This function takes a list and a tuple as input. It returns a tuple that\n    contains all the elements from the input tuple and all the elements from\n    the input list.\n\n    Parameters:\n    lst (list): the input list.\n    tup (tuple): the input tuple.\n\n    Returns:\n    tuple: the output tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Function to append the given list to the given tuple.\n\n    Args:\n    lst (list): List of elements to be appended.\n    tup (tuple): Tuple to which list elements will be appended.\n\n    Returns:\n    tuple: Tuple with all elements from the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(given_list, given_tuple):\n    return given_tuple + tuple(given_list)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_add, tuple_to_append):\n    \"\"\"\n    Function to append the given list to the given tuple.\n\n    :param list_to_add: list of elements\n    :param tuple_to_append: tuple to which the list will be appended\n    :return: tuple with the list appended\n    \"\"\"\n    return tuple_to_append + tuple(list_to_add)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    A function to append the given list to the given tuples.\n\n    Arguments:\n    lst: The list to be appended\n    tpl: The tuple to which the list is appended\n\n    Returns:\n    A tuple with the list elements appended at the end\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Function that appends a given list to the given tuple.\n    \"\"\"\n    return input_tuple + tuple(input_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Function to append the given list to the given tuple\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Function to append a list to a tuple.\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(l, t):\n    return t + tuple(l)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    This function appends the given list to the given tuple.\n\n    Args:\n    lst: a list of elements\n    tup: a tuple of elements\n\n    Returns:\n    a tuple that includes elements from the input list and tuple\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}]}, "Mbpp/108": {"dps": 95.66265060240964, "dps_norm": 99.0909090909091, "pass@1": 80.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    # Return the sorted list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*args):\n    # Unpack the lists\n    lists = [*args]\n\n    # Use Python's built-in sorted function to merge and sort the lists\n    sorted_list = sorted([item for sublist in lists for item in sublist])\n\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def merge_sorted_list(*args):\n    # Merge multiple sorted lists into a single sorted list\n    merged_list = []\n    for lst in args:\n        merged_list += lst\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # Merge lists into a single list\n    merged_list = lst1 + lst2 + lst3\n    # Sort the merged list and return it\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists into a single list.\n    merged_list = list1 + list2 + list3\n\n    # Sort the merged list.\n    merged_list.sort()\n\n    # Return the sorted merged list.\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    # The function takes an arbitrary number of sorted lists as arguments\n    merged_list = []\n    for lst in lists:\n        merged_list.extend(lst)\n    # After merging all the lists, they are sorted and returned\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all the lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge three sorted lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    This function merges three sorted lists into a single sorted list.\n    \"\"\"\n    # merge lists into one list\n    merged_list = list1 + list2 + list3\n    # use Python's built-in sorted function to sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Use the inbuilt sorted function to merge and sort the lists\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    merged_list = sorted(l1 + l2 + l3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    # Merge the three lists\n    merged_list = l1 + l2 + l3\n    # Sort the merged list\n    merged_list.sort()\n    # Return the sorted list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # merge list1 and list2\n    merged_list = list1 + list2\n\n    # sort the merged list\n    merged_list.sort()\n\n    # merge the sorted merged_list and list3\n    merged_list = merged_list + list3\n\n    # sort the final merged list\n    merged_list.sort()\n\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # merge three lists\n    merged_list = lst1 + lst2 + lst3\n    # sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 65.32307692307693, "dps_norm": 80.625, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(lst):\n    # convert the first list to a set\n    res = set(lst[0])\n    # iterate over the remaining lists\n    for l in lst[1:]:\n        # use intersection update to keep only elements that exist in res and current list\n        res &= set(l)\n    return res", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each nested list to a set.\n    sets = [set(nested_list) for nested_list in nested_lists]\n\n    # Use intersection operation to find the common elements.\n    common_elements = sets[0].intersection(*sets)\n\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Converting first list to set\n    result = set(nested_lists[0])\n\n    # Performing intersection_update() operation on the rest of the lists\n    for sublist in nested_lists[1:]:\n        result.intersection_update(sublist)\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # convert each list to a set\n    sets = [set(lst) for lst in nested_lists]\n    # find intersection of all sets\n    common = set.intersection(*sets)\n    return common", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lst):\n    # Convert first list to set\n    res = set(lst[0])\n    # Intersect with other lists in the input list\n    for l in lst[1:]:\n        res = res.intersection(set(l))\n    # Return the resulting set of common elements\n    return res", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the first list into a set\n    common = set(lists[0])\n\n    # Iterate over the remaining lists and take the intersection with the common set\n    for lst in lists[1:]:\n        common = common.intersection(lst)\n\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find common elements in given nested lists\n    \"\"\"\n    # Use sets to get common elements\n    common_elements = set.intersection(*map(set, nested_lists))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(lists):\n    return set.intersection(*map(set, lists))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the result set as the first list in the nested lists\n    result_set = set(nested_lists[0])\n\n    # Loop through the rest of the lists in the nested list\n    for lst in nested_lists[1:]:\n        # Update the result set with the intersection of the current result set and the current list\n        result_set &= set(lst)\n\n    # Return the final result set\n    return result_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list into a set\n    common_elements = set(nested_lists[0])\n\n    # Find intersection of the first list and the rest of the lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(set(lst))\n\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    # convert the first list to a set\n    common_set = set(nested_list[0])\n\n    # loop through the rest of the lists\n    for i in range(1, len(nested_list)):\n        # find the intersection with the current list and update the common_set\n        common_set.intersection_update(nested_list[i])\n\n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize a set with elements in the first list\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the remaining lists and find intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    This function finds the common elements in the given nested lists.\n    \"\"\"\n    # Convert the first list to set\n    common_set = set(lists[0])\n\n    # Iterate over the rest of the lists\n    for lst in lists[1:]:\n        # Use intersection to get common elements\n        common_set = common_set.intersection(set(lst))\n\n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    # Convert the first list to a set\n    common_set = set(nested_list[0])\n\n    # Iterate through the rest of the lists\n    for lst in nested_list[1:]:\n        # Update the set with the intersection of the current set and the current list\n        common_set.intersection_update(lst)\n\n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lst):\n    # Convert the first list to a set\n    common_set = set(lst[0])\n\n    # Find common elements with rest of the lists\n    for sublist in lst[1:]:\n        common_set = common_set.intersection(set(sublist))\n\n    return common_set", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lst):\n    # Convert first list to set\n    common_set = set(lst[0])\n\n    # Iterate over rest of lists and find intersection\n    for sublist in lst[1:]:\n        common_set &= set(sublist)\n\n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    :param lists: A list of lists containing integers.\n    :return: A set of common elements.\n    \"\"\"\n    # Convert the first list to a set\n    common_elements = set(lists[0])\n\n    # For each of the remaining lists\n    for lst in lists[1:]:\n        # Keep only the common elements\n        common_elements.intersection_update(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the remaining lists\n    for i in range(1, len(nested_lists)):\n        # Convert the current list to a set and update common_elements\n        # to the intersection of common_elements and the current set\n        common_elements.intersection_update(set(nested_lists[i]))\n\n    # Return the final set of common elements\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lists):\n    # Use the intersection method to find common elements\n    # This method returns a set that contains only items that exist in all set inputs\n    return set.intersection(*map(set, lists))", "matching_cluster_idx": 4}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 30.0, "profiled": [{"solution": "def amicable_numbers_sum(n):\n    def divisors_sum(num):\n        result = 1\n        i = 2\n        while i * i <= num:\n            if (num % i):\n                i += 1\n            else:\n                if (i == (num/i)):\n                    result += i\n                    i += 1\n                else:\n                    result += (i + num//i)\n                    i += 1\n        return result\n\n    amicable_sum = 0\n    for i in range(1, n + 1):\n        a = divisors_sum(i)\n        b = divisors_sum(a)\n        if (b == i and a != b):\n            amicable_sum += i\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(num):\n    \"\"\"This function returns the sum of proper divisors of a number.\"\"\"\n    result = 1\n    i = 2\n    while i * i <= num:\n        if num % i:\n            i += 1\n        else:\n            if i == (num // i):\n                result = result + i\n                i += 1\n            else:\n                result = result + (i + num//i)\n                i += 1\n    return result\ndef amicable_numbers_sum(n):\n    \"\"\"This function returns the sum of all amicable numbers from 1 to n.\"\"\"\n    amicable_sum = 0\n    for i in range(2, n + 1):\n        sum1 = sum_divisors(i)\n        if (i == sum_divisors(sum1)) and (i != sum1):\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_of_proper_divisors(num):\n        # find all divisors\n        divisors = [1]\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                if num//i == i:\n                    divisors.append(i)\n                else:\n                    divisors.extend([i, num//i])\n        return sum(divisors)\n\n    amicable_numbers = []\n    for i in range(2, n+1):\n        sum_i = sum_of_proper_divisors(i)\n        if sum_i <= i:\n            continue\n        if sum_of_proper_divisors(sum_i) == i and i != sum_i and i not in amicable_numbers:\n            amicable_numbers.extend([i, sum_i])\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_divisors(num):\n        result = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                if i == (num / i):\n                    result = result + i\n                else:\n                    result = result + (i + num//i)\n        return result\n\n    result = 0\n    for i in range(2, n + 1):\n        j = sum_divisors(i)\n        if sum_divisors(j) == i and i != j:\n            result += i\n    return result", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_proper_divisors(num):\n        divisors_sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                if i == num/i:\n                    divisors_sum += i\n                else:\n                    divisors_sum += (i + num//i)\n        return divisors_sum\n\n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    # Iterate through numbers up to n\n    for i in range(1, n+1):\n        # Calculate the sum of proper divisors of i\n        sum1 = sum_of_proper_divisors(i)\n        # Calculate the sum of proper divisors of sum1\n        sum2 = sum_of_proper_divisors(sum1)\n        # Check if i is an amicable number\n        if sum2 == i and sum1 != sum2:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def find_divisors(num):\n        divisors = [1]\n        for i in range(2, int(num**0.5) + 1):\n            if num % i:\n                continue\n            if num // i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, num // i])\n        return divisors\n\n    def is_amicable(num):\n        divisors = find_divisors(num)\n        sum_divisors = sum(divisors)\n        return num != sum_divisors and sum(find_divisors(sum_divisors)) == num\n\n    amicable_numbers = [i for i in range(1, n+1) if is_amicable(i)]\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_of_divisors(num):\n        divisors = [1]\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num // i)\n        return sum(set(divisors))\n\n    def is_amicable(num):\n        sum_divisors_num = sum_of_divisors(num)\n        return sum_divisors_num != num and sum_of_divisors(sum_divisors_num) == num\n\n    amicable_sum = 0\n    for i in range(1, n + 1):\n        if is_amicable(i):\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(num):\n        sum = 1\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                if i * (num // i) == num:\n                    sum += i + num // i\n                else:\n                    sum += i\n                i += 1\n        return sum\n\n    amicable_sum = 0\n    for i in range(2, n + 1):\n        sum1 = sum_proper_divisors(i)\n        sum2 = sum_proper_divisors(sum1)\n        if i == sum2 and i != sum1:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Returns sum of proper divisors of a number.\"\"\"\n    result = 0\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == (n / i):\n                result = result + i\n            else:\n                result = result + (i + n//i)\n    return (result + 1)\ndef amicable_numbers_sum(n):\n    \"\"\"Returns the sum of all amicable numbers from 1 to n.\"\"\"\n    sum_amicable_nums = 0\n    for i in range(2, n+1):\n        sum_divisors = sum_of_proper_divisors(i)\n        if (i != sum_divisors and sum_of_proper_divisors(sum_divisors) == i):\n            sum_amicable_nums += i\n    return sum_amicable_nums", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_of_proper_divisors(number):\n        sum = 1\n        i = 2\n        while i * i <= number:\n            if number % i:\n                i += 1\n            else:\n                if i * (number // i) == number:\n                    sum = sum + i + number//i\n                else:\n                    sum = sum + i\n                i += 1\n        return sum\n\n    def is_amicable_number(number):\n        sum = sum_of_proper_divisors(number)\n        return sum != number and sum_of_proper_divisors(sum) == number\n\n    sum_amicable = 0\n    for i in range(2, n+1):\n        if is_amicable_number(i):\n            sum_amicable += i\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    if n < 2:\n        return 0\n    result = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * (n // i) == n:\n                result += i + n // i\n            else:\n                result += i\n            i += 1\n    return result\ndef amicable_numbers_sum(n):\n    amicable_sum = 0\n    for i in range(1, n + 1):\n        j = sum_of_proper_divisors(i)\n        if i == sum_of_proper_divisors(j) and i != j:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_divisors(num):\n        \"\"\"function to calculate sum of divisors of a number\"\"\"\n        result = 0\n        # note that 1 is included in the divisors\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                if i == (num / i):\n                    result += i\n                else:\n                    result += (i + num//i)\n        return result + 1\n\n    amicable_sum = 0\n    for i in range(2, n + 1):\n        sum_i = sum_divisors(i)\n        if sum_i != i and sum_divisors(sum_i) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def get_divisors(n):\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                if n/i == i:\n                    divisors.append(i)\n                else:\n                    divisors.extend([i, n//i])\n        return divisors\n\n    def is_amicable(n):\n        sum_divisors = sum(get_divisors(n))\n        if n != sum_divisors and sum(get_divisors(sum_divisors)) == n:\n            return True\n        return False\n\n    return sum(i for i in range(2, limit + 1) if is_amicable(i))", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def divisors(num):\n        sum = 1\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                if i * (num // i) == num:\n                    sum += i + num//i\n                else:\n                    sum += i\n                i += 1\n        return sum\n\n    sum_amicable = 0\n    for i in range(1, n+1):\n        j = divisors(i)\n        if i != j and divisors(j) == i:\n            sum_amicable += i\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Function to find the sum of the divisors\n    def sum_divisors(num):\n        result = 0\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                if i == num // i:\n                    result += i\n                else:\n                    result += (i + num//i)\n        return result + 1\n\n    # Initialize sum\n    total = 0\n    # Iterate up to the specified number\n    for i in range(2, n+1):\n        # Calculate sum of divisors\n        sum_div = sum_divisors(i)\n        # Check if the sum of divisors is an amicable number pair\n        if i < sum_div and sum_div <= n and sum_divisors(sum_div) == i:\n            total += i + sum_div\n\n    return total", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_divisors(num):\n        sum = 1\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                if i * (num // i) == num:\n                    sum += i + num // i\n                else:\n                    sum += i\n                i += 1\n        return sum\n\n    amicable_numbers = []\n    for i in range(1, n+1):\n        j = sum_divisors(i)\n        if sum_divisors(j) == i and i != j and i not in amicable_numbers and j not in amicable_numbers:\n            amicable_numbers.append(i)\n            amicable_numbers.append(j)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    amicable_numbers = []\n    for i in range(1, limit+1):\n        j = sum_divisors(i)\n        if i == sum_divisors(j) and i != j and i not in amicable_numbers:\n            amicable_numbers.extend([i, j])\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def divisor_sum(num):\n        if num < 1:\n            return 0\n        else:\n            sum = 1\n            i = 2\n            while i * i <= num:\n                if num % i:\n                    i += 1\n                else:\n                    if i * (num // i) == num:\n                        sum += i\n                    sum += num // i\n                    i += 1\n            return sum\n\n    sum_amicable = 0\n    for num in range(2, n+1):\n        sum1 = divisor_sum(num)\n        sum2 = divisor_sum(sum1)\n        if sum2 == num and sum1 != num:\n            sum_amicable += num\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_of_divisors(num):\n        result = 1\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                if i == (num / i):\n                    result = result + i\n                    i += 1\n                else:\n                    result = result + (i + num//i)\n                    i += 1\n        return result\n\n    amicable_numbers = set()\n    for i in range(2, n + 1):\n        if i not in amicable_numbers:\n            sum_divisors = sum_of_divisors(i)\n            if sum_divisors != i and sum_of_divisors(sum_divisors) == i:\n                amicable_numbers.add(i)\n                amicable_numbers.add(sum_divisors)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_of_proper_divisors(num):\n        if num < 2:\n            return 0\n        sum = 1\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                if i == (num / i):\n                    sum = sum + i\n                else:\n                    sum = sum + (i + num//i)\n        return sum\n    amicable_sum = 0\n    for num in range(2, n+1):\n        sum_of_divisors = sum_of_proper_divisors(num)\n        if num == sum_of_proper_divisors(sum_of_divisors) and num != sum_of_divisors:\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, text):\n    \"\"\"\n    Function to find words that are longer than n characters from a given text.\n\n    Parameters:\n    n (int): Minimum length of the words to be found.\n    text (str): Text from which the words are to be extracted.\n\n    Returns:\n    list: List of words that are longer than n characters.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Convert the input string into a list of words\n    words = word_list.split(' ')\n\n    # Use list comprehension to filter out words that are longer than n characters\n    long_word_list = [word for word in words if len(word) > n]\n\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    return [word for word in word_list.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Function to find words that are longer than n characters from a given list of words.\n\n    :param n: the minimum length of the words to be returned\n    :param words: a string containing one or more words separated by spaces\n    :return: a list of words longer than n characters\n    \"\"\"\n    # Splitting the string into a list of words\n    word_list = words.split(' ')\n\n    # Using list comprehension to filter out words that are longer than n characters\n    long_words = [word for word in word_list if len(word) > n]\n\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words based on length\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the string into list of words\n    word_list = words.split()\n\n    # Use list comprehension to get words that are longer than n characters\n    long_words_list = [word for word in word_list if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the input string into a list of words\n    words_list = words.split()\n\n    # Filter out words that are shorter than n\n    long_words_list = [word for word in words_list if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the string into a list of words\n    words = words.split()\n\n    # Use list comprehension to filter out words that are longer than n characters\n    long_words = [word for word in words if len(word) > n]\n\n    # Return the list of long words\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    words_list = words.split()\n    return [word for word in words_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Convert the text to list of words\n    words = text.split()\n    # Filter the words and return only those that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    This function takes an integer 'n' and a string 'text' as input,\n    it returns a list of words from the 'text' which are longer than 'n' characters.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # convert string to list of words\n    words = word_list.split()\n    # filter words that have length more than n\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, input_string):\n    \"\"\"\n    Function that finds words that are longer than n characters from a given string.\n\n    Args:\n        n (int): The minimum number of characters for a word to be considered long.\n        input_string (str): The string from which to find long words.\n\n    Returns:\n        list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the input string into a list of words\n    words = input_string.split(' ')\n\n    # Use list comprehension to generate a list of long words\n    long_words = [word for word in words if len(word) > n]\n\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    This function takes an integer n and a string of words separated by spaces.\n    It returns a list of words that are longer than n characters.\n\n    :param n: An integer indicating the length of the words to be found.\n    :param words: A string of words separated by spaces.\n    :return: A list of words that are longer than n characters.\n    \"\"\"\n    return [word for word in words.split(' ') if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # convert the word_list string to a list of words\n    words = word_list.split()\n    # use list comprehension to find words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Function to find words that are longer than n characters from a given list of words\n    :param n: an integer for the threshold length of words\n    :param text: a string containing words separated by spaces\n    :return: a list of words from the text that are longer than n characters\n    \"\"\"\n    # split the text into a list of words\n    words = text.split()\n    # use list comprehension to filter out words that are longer than n characters\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # split the word_list into words\n    words = word_list.split()\n\n    # filter words based on length\n    long_words = [word for word in words if len(word) > n]\n\n    return long_words", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 92.38520408163265, "dps_norm": 99.0, "pass@1": 68.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row\n    sum_row = sum(matrix[0])\n\n    # Check if all rows have the same sum\n    for i in range(1, len(matrix)):\n        if sum(matrix[i]) != sum_row:\n            return False\n\n    # Check if all columns have the same sum\n    for i in range(len(matrix)):\n        sum_col = 0\n        for j in range(len(matrix)):\n            sum_col += matrix[j][i]\n        if sum_col != sum_row:\n            return False\n\n    # Check if the main diagonal has the same sum\n    sum_diag_1 = 0\n    for i in range(len(matrix)):\n        sum_diag_1 += matrix[i][i]\n    if sum_diag_1 != sum_row:\n        return False\n\n    # Check if the secondary diagonal has the same sum\n    sum_diag_2 = 0\n    for i in range(len(matrix)):\n        sum_diag_2 += matrix[i][len(matrix) - 1 - i]\n    if sum_diag_2 != sum_row:\n        return False\n\n    # If all checks pass, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    sum_value = sum(matrix[0])\n\n    # Check sum of each row\n    for i in range(n):\n        if sum(matrix[i]) != sum_value:\n            return False\n\n    # Check sum of each column\n    for i in range(n):\n        if sum(matrix[j][i] for j in range(n)) != sum_value:\n            return False\n\n    # Check sum of main diagonal\n    if sum(matrix[i][i] for i in range(n)) != sum_value:\n        return False\n\n    # Check sum of other diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != sum_value:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Calculate the sum of the elements in the first row\n    sum_of_row = sum(mat[0])\n    # Calculate the sum of the elements in each row and compare it with the sum of the first row\n    for row in mat:\n        if sum(row) != sum_of_row:\n            return False\n    # Calculate the sum of the elements in each column and compare it with the sum of the first row\n    for col in range(len(mat[0])):\n        col_sum = sum(mat[row][col] for row in range(len(mat)))\n        if col_sum != sum_of_row:\n            return False\n    # Calculate the sum of the elements in the diagonal from top left to bottom right\n    diagonal_sum1 = sum(mat[i][i] for i in range(len(mat)))\n    # Calculate the sum of the elements in the diagonal from top right to bottom left\n    diagonal_sum2 = sum(mat[i][len(mat) - 1 - i] for i in range(len(mat)))\n    # Check if the sum of the diagonals is equal to the sum of the first row\n    if diagonal_sum1 != sum_of_row or diagonal_sum2 != sum_of_row:\n        return False\n    # If all conditions are met, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # calculate the sum of the first row\n    sum_of_first_row = sum(matrix[0])\n\n    # calculate the sum of each row and compare with the sum of first row\n    for row in matrix:\n        if sum(row) != sum_of_first_row:\n            return False\n\n    # calculate the sum of each column and compare with the sum of first row\n    for i in range(len(matrix)):\n        sum_of_column = sum(row[i] for row in matrix)\n        if sum_of_column != sum_of_first_row:\n            return False\n\n    # calculate the sum of main diagonal and compare with the sum of first row\n    main_diagonal = sum(matrix[i][i] for i in range(len(matrix)))\n    if main_diagonal != sum_of_first_row:\n        return False\n\n    # calculate the sum of secondary diagonal and compare with the sum of first row\n    secondary_diagonal = sum(matrix[i][len(matrix) - i - 1] for i in range(len(matrix)))\n    if secondary_diagonal != sum_of_first_row:\n        return False\n\n    # if all tests pass, return True\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Find the sum of first row\n    sum_of_first_row = sum(matrix[0])\n\n    # Calculate sum of remaining rows and compare with the sum_of_first_row\n    for i in range(1, len(matrix)):\n        if sum(matrix[i]) != sum_of_first_row:\n            return False\n\n    # Calculate sum of each column and compare with the sum_of_first_row\n    for i in range(len(matrix[0])):\n        col_sum = 0\n        for j in range(len(matrix)):\n            col_sum += matrix[j][i]\n        if col_sum != sum_of_first_row:\n            return False\n\n    # Calculate sum of main diagonal and compare with the sum_of_first_row\n    main_diagonal_sum = 0\n    for i in range(len(matrix)):\n        main_diagonal_sum += matrix[i][i]\n    if main_diagonal_sum != sum_of_first_row:\n        return False\n\n    # Calculate sum of secondary diagonal and compare with the sum_of_first_row\n    secondary_diagonal_sum = 0\n    for i in range(len(matrix)):\n        secondary_diagonal_sum += matrix[i][len(matrix) - i - 1]\n    if secondary_diagonal_sum != sum_of_first_row:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # calculate the sum of the first row\n    target_sum = sum(matrix[0])\n\n    # check each row sum\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # check each column sum\n    for col in zip(*matrix):\n        if sum(col) != target_sum:\n            return False\n\n    # check the main diagonal sum\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n\n    # check the anti-diagonal sum\n    if sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    sum_value = sum(matrix[0])\n    for row in matrix:\n        if sum(row) != sum_value:\n            return False\n    for col in range(n):\n        if sum(row[col] for row in matrix) != sum_value:\n            return False\n    if sum(matrix[i][i] for i in range(n)) != sum_value:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != sum_value:\n        return False\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n\n    # Check sum of rows and columns\n    for i in range(n):\n        if sum(matrix[i]) != magic_sum:\n            return False\n        if sum(matrix[j][i] for j in range(n)) != magic_sum:\n            return False\n\n    # Check sum of diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    if sum(matrix[i][n - i - 1] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n\n    # Calculating the sum of the first row\n    sum_diag = sum(matrix[0])\n\n    # Checking if all rows and columns sum up to the same value\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        col_sum = sum(matrix[j][i] for j in range(n))\n        if row_sum != sum_diag or col_sum != sum_diag:\n            return False\n\n    # Checking if the diagonals sum up to the same value\n    if sum(matrix[i][i] for i in range(n)) != sum_diag or sum(matrix[i][n-i-1] for i in range(n)) != sum_diag:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    This function checks if a given square matrix is a magic square.\n    A magic square is a square grid filled with distinct positive integers from 1 to n^2 such that the sum of the numbers in each row,\n    each column, and both main diagonals is equal.\n    \"\"\"\n\n    # Get the size of the square matrix\n    n = len(matrix)\n\n    # Get the sum of the elements in the first row\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for i in range(1, n):\n        if sum(matrix[i]) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][i]\n    if diag_sum != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][n - i - 1]\n    if diag_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Get the size of the square matrix\n    n = len(matrix)\n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    # Check the sum of each column\n    for col in range(n):\n        col_sum = sum([matrix[row][col] for row in range(n)])\n        if col_sum != magic_sum:\n            return False\n    # Check the sum of the main diagonal\n    main_diag_sum = sum([matrix[i][i] for i in range(n)])\n    if main_diag_sum != magic_sum:\n        return False\n    # Check the sum of the other diagonal\n    other_diag_sum = sum([matrix[i][n - i - 1] for i in range(n)])\n    if other_diag_sum != magic_sum:\n        return False\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # calculate the sum of first row\n    sum_of_first_row = sum(matrix[0])\n    # calculate the sum of each row and each column\n    for row in matrix:\n        if sum(row) != sum_of_first_row:\n            return False\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != sum_of_first_row:\n            return False\n    # calculate the sum of the main diagonal\n    sum_of_main_diag = sum(matrix[i][i] for i in range(len(matrix)))\n    if sum_of_main_diag != sum_of_first_row:\n        return False\n    # calculate the sum of the secondary diagonal\n    sum_of_sec_diag = sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix)))\n    if sum_of_sec_diag != sum_of_first_row:\n        return False\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row.\n    total = sum(matrix[0])\n\n    # Check the sum of each row.\n    for row in matrix:\n        if sum(row) != total:\n            return False\n\n    # Check the sum of each column.\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != total:\n            return False\n\n    # Check the sum of the main diagonal.\n    if sum(matrix[i][i] for i in range(len(matrix))) != total:\n        return False\n\n    # Check the sum of the other diagonal.\n    if sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != total:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row\n    sum_first_row = sum(matrix[0])\n    # Calculate the sum of each row and compare it to the sum of the first row\n    if not all(sum(row) == sum_first_row for row in matrix):\n        return False\n    # Calculate the sum of each column and compare it to the sum of the first row\n    if not all(sum(col) == sum_first_row for col in zip(*matrix)):\n        return False\n    # Calculate the sum of the main diagonal\n    sum_main_diag = sum(matrix[i][i] for i in range(len(matrix)))\n    # Calculate the sum of the secondary diagonal\n    sum_sec_diag = sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix)))\n    # Compare the sum of the main and secondary diagonals to the sum of the first row\n    if sum_main_diag != sum_first_row or sum_sec_diag != sum_first_row:\n        return False\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    total = sum(matrix[0])  # Calculate the sum of elements in the first row\n    # Check sum of elements in each row and column\n    for i in range(n):\n        if sum(matrix[i]) != total or sum([matrix[j][i] for j in range(n)]) != total:\n            return False\n    # Check sum of elements in the main diagonal\n    if sum([matrix[i][i] for i in range(n)]) != total:\n        return False\n    # Check sum of elements in the anti-diagonal\n    if sum([matrix[i][n-i-1] for i in range(n)]) != total:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    sum_to_compare = sum(matrix[0])\n\n    # Checking rows sum\n    for row in matrix:\n        if sum(row) != sum_to_compare:\n            return False\n\n    # Checking columns sum\n    for col in range(n):\n        if sum(row[col] for row in matrix) != sum_to_compare:\n            return False\n\n    # Checking main diagonal sum\n    if sum(matrix[i][i] for i in range(n)) != sum_to_compare:\n        return False\n\n    # Checking anti-diagonal sum\n    if sum(matrix[i][n - i - 1] for i in range(n)) != sum_to_compare:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if it's a square matrix\n    n = len(matrix)\n    if n != len(matrix[0]):\n        return False\n\n    # Calculate the sum of elements in the first row\n    sum_row = sum(matrix[0])\n\n    # Check sum of all rows\n    for i in range(1, n):\n        if sum(matrix[i]) != sum_row:\n            return False\n\n    # Check sum of all columns\n    for i in range(n):\n        col_sum = 0\n        for j in range(n):\n            col_sum += matrix[j][i]\n        if col_sum != sum_row:\n            return False\n\n    # Check sum of diagonal from top left to bottom right\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != sum_row:\n        return False\n\n    # Check sum of diagonal from top right to bottom left\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][n - i - 1]\n    if diagonal_sum != sum_row:\n        return False\n\n    # If it passes all tests, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    sum_check = sum(matrix[0])\n\n    # Check sum of each row is equal to sum_check\n    for i in range(1, n):\n        if sum(matrix[i]) != sum_check:\n            return False\n\n    # Check sum of each column is equal to sum_check\n    for i in range(n):\n        col_sum = sum(matrix[j][i] for j in range(n))\n        if col_sum != sum_check:\n            return False\n\n    # Check sum of main diagonal is equal to sum_check\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != sum_check:\n        return False\n\n    # Check sum of antidiagonal is equal to sum_check\n    antidiag_sum = sum(matrix[i][n-1-i] for i in range(n))\n    if antidiag_sum != sum_check:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # calculating the sum of elements in the first row\n    sum_first_row = sum(matrix[0])\n    # calculating the sum of elements in each row and comparing with the sum of the first row\n    for row in matrix:\n        if sum(row) != sum_first_row:\n            return False\n    # calculating the sum of elements in each column and comparing with the sum of the first row\n    for col in zip(*matrix):\n        if sum(col) != sum_first_row:\n            return False\n    # calculating the sum of elements in the first diagonal and comparing with the sum of the first row\n    sum_first_diag = sum(matrix[i][i] for i in range(len(matrix)))\n    if sum_first_diag != sum_first_row:\n        return False\n    # calculating the sum of elements in the second diagonal and comparing with the sum of the first row\n    sum_second_diag = sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix)))\n    if sum_second_diag != sum_first_row:\n        return False\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Calculate the sum of the first row\n    sum_row = sum(mat[0])\n\n    # Check if all rows sum to the same total\n    for row in mat:\n        if sum(row) != sum_row:\n            return False\n\n    # Check if all columns sum to the same total\n    for col in range(len(mat[0])):\n        sum_col = sum(mat[row][col] for row in range(len(mat)))\n        if sum_col != sum_row:\n            return False\n\n    # Check if the diagonals sum to the same total\n    sum_diag1 = sum(mat[i][i] for i in range(len(mat)))\n    sum_diag2 = sum(mat[i][len(mat) - i - 1] for i in range(len(mat)))\n    if sum_diag1 != sum_row or sum_diag2 != sum_row:\n        return False\n\n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 77.10762331838565, "dps_norm": 68.33333333333334, "pass@1": 77.0, "profiled": [{"solution": "def max_occurrences(nums):\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return max(count_dict, key=count_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    if not lst:\n        return None\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    max_count = 0\n    max_item = None\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    counts = dict()\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    return max(counts, key=counts.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    freq = {}\n    for item in lst:\n        if (item in freq):\n            freq[item] += 1\n        else:\n            freq[item] = 1\n\n    max_count = 0\n    max_item = None\n    for item, count in freq.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item in the list\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    # Find the item with maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n\n    # Return the item with maximum frequency\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n\n    max_count = 0\n    max_item = None\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create an empty dictionary to count occurrences of elements in the list\n    counts = {}\n    for item in lst:\n        # Increment the count for each element in the dictionary\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n\n    # Find the element with the maximum count\n    max_count = 0\n    max_item = None\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    max_freq = 0\n    max_item = None\n    for key, value in freq_dict.items():\n        if value > max_freq:\n            max_freq = value\n            max_item = key\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    max_freq = max(count_dict.values())\n    max_freq_items = [k for k, v in count_dict.items() if v == max_freq]\n    return max_freq_items[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to hold item frequencies\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n\n    # Find the item with maximum frequency\n    max_item = max(freq, key=freq.get)\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    counter = {}\n    for i in lst:\n        if i in counter:\n            counter[i] += 1\n        else:\n            counter[i] = 1\n    max_value = max(list(counter.values()))\n    max_keys = [k for k, v in counter.items() if v == max_value]\n    return max_keys[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    max_count = 0\n    max_item = None\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create an empty dictionary\n    dict_freq = {}\n\n    # Iterate over the list and count frequency\n    for i in lst:\n        dict_freq[i] = dict_freq.get(i, 0) + 1\n\n    # Find maximum frequency and the corresponding item\n    max_freq = max(dict_freq.values())\n    max_item = [k for k, v in dict_freq.items() if v == max_freq]\n\n    # Return the item with maximum frequency\n    return max_item[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n\n    max_count = 0\n    max_item = None\n\n    for item, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequencies of each item in the list\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n\n    # Find the item with maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in freq.items():\n        if count > max_count:\n            max_item = item\n            max_count = count\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # counts the frequency of each element in the list\n    data = Counter(lst)\n    # finds the element with maximum frequency\n    max_element = max(data, key=data.get)\n    return max_element", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # create a dictionary with item as key and its frequency as value\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    # find the item with maximum frequency\n    max_freq = 0\n    max_item = None\n    for key, value in freq_dict.items():\n        if value > max_freq:\n            max_freq = value\n            max_item = key\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    max_freq = 0\n    max_item = None\n    for item, freq in freq.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    data = Counter(lst)\n    return data.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    counts = dict()\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    max_count = 0\n    max_item = None\n    for key, value in counts.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    return max_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 3.0, "profiled": []}, "Mbpp/140": {"dps": 54.72049689440994, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set\n    single_set = set()\n\n    # Iterate through each tuple in the list of tuples\n    for tup in list_of_tuples:\n        # Iterate through each element in the tuple\n        for element in tup:\n            # Add the element to the set\n            single_set.add(element)\n\n    # Return the set of singly occurring numbers\n    return single_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    return set([item for sublist in lst for item in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst_of_lists):\n    # Initialize an empty set to store single numbers\n    single_set = set()\n\n    # Iterate over each tuple in the list of tuples\n    for sublist in lst_of_lists:\n        # Iterate over each number in the current tuple\n        for number in sublist:\n            # Add the number to the set\n            single_set.add(number)\n\n    # Return the set of single numbers\n    return single_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    singly_set = set()\n    for t in list_of_tuples:\n        for i in t:\n            singly_set.add(i)\n    return singly_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    # Initiate an empty set to store numbers\n    number_set = set()\n\n    # Loop over each tuple in the list of tuples\n    for single_tuple in list_of_lists:\n\n        # Loop over each number in the current tuple\n        for num in single_tuple:\n\n            # Add the number to the set\n            number_set.add(num)\n\n    # Return the set of numbers\n    return number_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set\n    result_set = set()\n    # Iterate through each tuple in the list of tuples\n    for tup in list_of_tuples:\n        # Iterate through each element in the tuple\n        for num in tup:\n            # Add the number to the set\n            result_set.add(num)\n    # Return the final set containing all numbers\n    return result_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to hold the single elements\n    single_elements = set()\n\n    # Iterate over each tuple in the list of tuples\n    for tup in list_of_tuples:\n        # Iterate over each element in the current tuple\n        for elem in tup:\n            # Add the current element to the set of single elements\n            single_elements.add(elem)\n\n    # Return the set of single elements\n    return single_elements", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the single elements\n    singly_extracted = set()\n\n    # Iterate through each tuple in the input list\n    for tuple_ in list_of_tuples:\n        # Iterate through each element in the current tuple\n        for element in tuple_:\n            # Add the element to the set\n            singly_extracted.add(element)\n\n    # Return the set containing the single elements\n    return singly_extracted", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Function to flatten a list of tuples into a single set of numbers.\n    \"\"\"\n    result = set()\n    for tup in list_of_tuples:\n        result.update(tup)\n    return result", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lists):\n    singly_set = set()\n    for sub_list in lists:\n        for item in sub_list:\n            singly_set.add(item)\n    return singly_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Function to flatten the list of tuples into a single set of numbers.\n    \"\"\"\n    # Initialize an empty set\n    result = set()\n\n    # Iterate through the list of tuples\n    for tuple_ in list_of_tuples:\n        # Iterate through each number in the tuple\n        for num in tuple_:\n            # Add the number to the set\n            result.add(num)\n\n    # Return the set of numbers\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(input_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns a set of unique numbers from all tuples.\n    \"\"\"\n    output_set = set()\n    for t in input_list:\n        output_set.update(t)\n    return output_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # using set to remove duplicates\n    result = set()\n    for t in list_of_tuples:\n        for i in t:\n            result.add(i)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    return set([item for tup in list_of_tuples for item in tup])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    A function to flatten a list of tuples into a single set of numbers.\n\n    Args:\n    list_of_tuples (list of tuples): A list of tuples containing numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the input list of tuples.\n    \"\"\"\n    result = set()\n    for tup in list_of_tuples:\n        for num in tup:\n            result.add(num)\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_singly(lists):\n    # Use set comprehension to extract all numbers from the list of tuples\n    return {num for tup in lists for num in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(input_list):\n    # Initialize an empty set to hold the flattened numbers\n    result = set()\n\n    # Loop over the input list of tuples\n    for tup in input_list:\n        # Loop over the numbers in each tuple\n        for num in tup:\n            # Add the number to the result set\n            result.add(num)\n\n    # Return the result set\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    return set([num for sublist in lst for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set\n    result_set = set()\n\n    # Iterate through each tuple in the list of tuples\n    for tuple_ in list_of_tuples:\n        # Add each element from the tuple to the set\n        for element in tuple_:\n            result_set.add(element)\n\n    # Return the set of numbers\n    return result_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Function to flatten the list of tuples into a set of numbers.\n    \"\"\"\n    result = set()\n    for lst in lists:\n        result.update(lst)\n    return result", "matching_cluster_idx": 7}]}, "Mbpp/141": {"dps": 61.7687074829932, "dps_norm": 40.0, "pass@1": 81.0, "profiled": [{"solution": "def pancake_sort(arr):\n    def flip(end):\n        start = 0\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    for i in range(len(arr), 1, -1):\n        max_index = arr.index(max(arr[:i]))\n        if max_index != i - 1:\n            flip(max_index)\n            flip(i - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Reverse the first n elements\n    def flip(n):\n        for i in range(n//2):\n            arr[i], arr[n-i-1] = arr[n-i-1], arr[i]\n\n    # Find the index of the maximum element in the first n elements\n    def find_max(n):\n        max_index = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        return max_index\n\n    for i in range(len(arr), 1, -1):\n        max_index = find_max(i)\n        if max_index != i-1:\n            # Move the maximum element to the beginning of the list\n            flip(max_index+1)\n            # Move the maximum element to its sorted position\n            flip(i)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    def flip(end):\n        i = 0\n        while i < end:\n            lst[i], lst[end] = lst[end], lst[i]\n            i += 1\n            end -= 1\n\n    for i in range(len(lst), 0, -1):\n        max_index = lst.index(max(lst[:i]))\n        if max_index != i - 1:\n            flip(max_index)\n            flip(i - 1)\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(end):\n        start = 0\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    for i in range(len(arr), 1, -1):\n        max_idx = arr.index(max(arr[:i]))\n        if max_idx != i - 1:\n            flip(max_idx)\n            flip(i - 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    for i in range(len(arr), 1, -1):\n        max_idx = arr.index(max(arr[:i]))\n        flip(max_idx)\n        flip(i - 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort a list of elements using the pancake sort algorithm.\n\n    :param arr: list, list of integers\n    :return: list, sorted list of integers\n    \"\"\"\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    for i in range(len(arr), 1, -1):\n        max_index = arr.index(max(arr[:i]))\n        flip(arr, max_index)\n        flip(arr, i - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    def flip(end):\n        i = 0\n        while i < end:\n            lst[i], lst[end] = lst[end], lst[i]\n            i += 1\n            end -= 1\n    for size in reversed(range(len(lst))):\n        max_idx = lst.index(max(lst[:size + 1]))\n        flip(max_idx)\n        flip(size)\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    for i in range(len(arr), 0, -1):\n        max_idx = arr.index(max(arr[:i]))\n        arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n        arr[:i] = arr[:i][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sublist, index):\n        i = 0\n        while i < index:\n            sublist[i], sublist[index] = sublist[index], sublist[i]\n            i += 1\n            index -= 1\n\n    for size in reversed(range(len(arr))):\n        max_idx = arr.index(max(arr[:size+1]))\n        flip(arr, max_idx)\n        flip(arr, size)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sublist, i):\n        return sublist[:i+1][::-1] + sublist[i+1:]\n\n    for i in range(len(arr), 1, -1):\n        max_i = arr.index(max(arr[:i]))\n        arr = flip(arr, max_i)\n        arr = flip(arr, i-1)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # define a helper function to flip the first k elements of the list\n    def flip(arr, k):\n        i = 0\n        while i < k // 2:\n            arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n            i += 1\n\n    # iterate over all elements in the list\n    for i in range(len(arr), 0, -1):\n        # find the index of the maximum element in the first i elements\n        max_idx = arr.index(max(arr[:i]))\n        # flip the first max_idx+1 elements to bring the maximum element to the first position\n        flip(arr, max_idx + 1)\n        # flip the first i elements to bring the maximum element to its final position\n        flip(arr, i)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    for i in range(len(arr), 1, -1):\n        max_idx = arr.index(max(arr[:i]))\n        if max_idx != i - 1:\n            flip(arr, max_idx)\n            flip(arr, i - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sublist, k):\n        return sublist[:k][::-1] + sublist[k:]\n\n    for size in reversed(range(len(arr))):\n        max_idx = arr.index(max(arr[:size+1]))\n        if max_idx != size:\n            arr = flip(arr, max_idx+1)\n            arr = flip(arr, size+1)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    for i in range(len(arr)):\n        max_idx = arr.index(max(arr[:len(arr) - i]))\n        arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n        arr[:len(arr) - i] = arr[:len(arr) - i][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Function to flip elements of arr from 0 to i\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    # Traverse through all array elements\n    for i in range(len(arr), 1, -1):\n        # Find index of the maximum element in arr[0..i]\n        mi = arr.index(max(arr[:i]))\n\n        # Move the maximum element to end of current i\n        # elements\n        flip(arr, mi)\n        # Move the maximum element to its correct position\n        # by reversing current i elements\n        flip(arr, i-1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(end):\n        i = 0\n        while i < end:\n            arr[i], arr[end] = arr[end], arr[i]\n            i += 1\n            end -= 1\n\n    for end in range(len(arr) - 1, 0, -1):\n        max_idx = arr.index(max(arr[:end + 1]))\n        if max_idx != end:\n            flip(max_idx)\n            flip(end)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(end):\n        start = 0\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    for i in range(len(arr), 1, -1):\n        max_idx = arr.index(max(arr[:i]))\n        if max_idx != i - 1:\n            flip(max_idx)\n            flip(i - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Define a helper function to flip the elements of the array up to the given index\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    # Perform pancake sort\n    for i in range(len(arr), 1, -1):\n        max_idx = arr.index(max(arr[:i]))\n        if max_idx != i - 1:\n            # Flip the maximum element to the end\n            flip(arr, max_idx)\n            # Flip the end element to its correct position\n            flip(arr, i - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(end):\n        start = 0\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    for i in range(len(arr), 1, -1):\n        max_index = arr.index(max(arr[:i]))\n        flip(max_index)\n        flip(i-1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(end):\n        start = 0\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    for i in range(len(arr), 1, -1):\n        max_index = arr.index(max(arr[:i]))\n        if max_index != i - 1:\n            flip(max_index)\n            flip(i - 1)\n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/166": {"dps": 94.67999999999999, "dps_norm": 52.5, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(lst):\n    # Count the number of even elements in the list\n    count_even = len([x for x in lst if x % 2 == 0])\n\n    # The total number of pairs in the list is n*(n-1)/2, where n is the length of the list\n    # This is derived from the mathematical formula for calculating the number of pairs in a set\n    total_pairs = len(lst) * (len(lst) - 1) // 2\n\n    # The number of pairs that XOR to an odd number is the total number of pairs minus the number of pairs with both elements being odd\n    # In a list of n elements, there are n - count_even elements that are odd\n    # So, there are (n - count_even) * count_even pairs with both elements being odd\n    odd_pairs = (len(lst) - count_even) * count_even\n\n    # The remaining pairs will XOR to an even number\n    return total_pairs - odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    This function counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    # Initialize counter\n    count = 0\n\n    # Loop over all pairs of integers in the list\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n\n            # Check if the xor of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n\n    # Return the number of even-xor pairs\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    # Initialize a counter for even pairs\n    count = 0\n    # Iterate over all pairs of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            # XOR the numbers and check if the result is even\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                # If the XOR is even, increment the counter\n                count += 1\n    # Return the count of even pairs\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 93.22463768115942, "dps_norm": 96.875, "pass@1": 91.0, "profiled": [{"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    # Check if the indices are within the range of the list\n    if start < 0 or start >= len(lst) or end < 0 or end >= len(lst):\n        raise ValueError(\"Indices are out of range.\")\n\n    # Use list slicing to get the sublist of numbers within the specified range and then use sum() to add them up\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_idx, end_idx):\n    # Initialize sum to 0\n    total = 0\n    # Iterate over the list from start_idx to end_idx inclusive\n    for i in range(start_idx, end_idx + 1):\n        # Add the current number to the total\n        total += num_list[i]\n    # Return the total sum\n    return total", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    :param lst: list of numbers\n    :param start_index: starting index of range\n    :param end_index: ending index of range\n    :return: sum of numbers within specified range\n    \"\"\"\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    Args:\n    lst (list of int): The list of numbers.\n    start_index (int): The starting index of the range.\n    end_index (int): The ending index of the range.\n    Returns:\n    int: The sum of numbers in the list within the given range.\n    \"\"\"\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Use list slicing to get the range of numbers and then sum them\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_idx, end_idx):\n    # Use list slicing to get the elements in the range and sum them\n    return sum(num_list[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(input_list, start_index, end_index):\n    return sum(input_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start, end):\n    return sum(num_list[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(list, start_index, end_index):\n    # Slice the list to get elements within the specified range\n    sublist = list[start_index:end_index + 1]\n    # Calculate the sum of numbers in the sublist\n    sum = 0\n    for num in sublist:\n        sum += num\n    return sum", "matching_cluster_idx": 5}, {"solution": "def sum_range_list(input_list, start, end):\n    return sum(input_list[start:end+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 80.81395348837209, "dps_norm": 56.42857142857142, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    This function takes a string as input and removes the characters which have odd index values.\n    :param s: the input string\n    :return: the input string with odd index characters removed\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    result = ''\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s: str) -> str:\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(string):\n    return string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_str):\n    result = \"\"\n    for i in range(len(input_str)):\n        if i % 2 == 0:\n            result += input_str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([ch for i, ch in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string\n    output_string = ''\n    # Iterate through each character in the input_string\n    for i in range(len(input_string)):\n        # If the index of the character is even, add it to the output_string\n        if i % 2 == 0:\n            output_string += input_string[i]\n    # Return the output_string\n    return output_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(string):\n    return ''.join([char for index, char in enumerate(string) if index % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 6}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(input_string, replace_char):\n    return input_string.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    This function takes in a string and a character, replaces blank spaces in the string\n    with the character and returns the updated string.\n    \"\"\"\n    # replace spaces with the replacement character\n    new_string = input_string.replace(' ', replacement_char)\n    return new_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    This function takes in a string and a character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    return input_string.replace(\" \", replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    return input_string.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    return input_string.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    return input_string.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, char):\n    return input_str.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, char):\n    return input_str.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 74.13793103448276, "dps_norm": 77.0, "pass@1": 20.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D table dp with dimensions (m+1)x(n+1)\n    # where dp[i][j] represents the number of possible sequences of length j such that\n    # the last element is i\n    dp = [[0]*(n+1) for _ in range(m+1)]\n\n    # Base case: when n = 1, there's only one sequence which can be formed from any element [1, m]\n    for i in range(1, m+1):\n        dp[i][1] = 1\n\n    # Iterate for length of sequence from 2 to n\n    for j in range(2, n+1):\n        # Iterate for last element of the sequence from 1 to m\n        for i in range(1, m+1):\n            # For each element i, count the number of elements that can be added before it.\n            # This can be computed by summing up the dp values for all the elements\n            # that are greater than or equal to twice of the current element and less than or equal to m.\n            for k in range(2*i, m+1):\n                dp[k][j] += dp[i][j-1]\n\n    # The total number of sequences of length n is the sum of dp values for last element from 1 to m\n    return sum(dp[i][n] for i in range(1, m+1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list to hold the number of possible sequences\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # There is only one possible sequence of length 1 for any positive integer\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Compute the number of possible sequences for each length from 2 to n\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # For each element, compute the number of possible sequences\n            # by summing up the number of possible sequences for all\n            # previous elements that satisfy the condition\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    # Return the total number of possible sequences of length n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2D dp array where dp[i][j] represents the number of sequences\n    # of length i ending with the value j.\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # A sequence of length 1 with any value from 1 to m is possible.\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n\n    # Fill the dp array using dynamic programming.\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    # The total number of sequences of length n is the sum of dp[n][j] for all j.\n    total = sum(dp[n][j] for j in range(1, m + 1))\n\n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP array\n    dp = [[0]*(m+1) for _ in range(n+1)]\n\n    # A sequence of length 1 can have m possible elements\n    for i in range(1, m+1):\n        dp[1][i] = 1\n\n    # Fill dp array using bottom-up approach\n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            for k in range(1, j+1):\n                if k*2 <= j:\n                    dp[i][j] += dp[i-1][k]\n\n    # Sum up the total possible sequences of length n\n    total_sequences = sum(dp[n][i] for i in range(1, m+1))\n\n    return total_sequences", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2-D table to store the number of possible sequences\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    # Initialize the first row of the table\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    # Iterate through the rest of the table\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    # Return the number of possible sequences\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP array\n    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n    # Base case: if n == 1, all numbers from 1 to m are valid\n    for i in range(1, m+1):\n        dp[1][i] = 1\n    # Fill DP table iteratively\n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            for k in range(j, m+1):\n                # Each number can be the next number in the sequence\n                # if it is greater than or equal to twice the previous element\n                if k >= 2*j:\n                    dp[i][k] += dp[i-1][j]\n    # The total number of valid sequences of length n is the sum of the last row\n    return sum(dp[n])", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP table with zero\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Sequences of length 1 is always 1 as each sequence element is in range [1, m]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Fill the DP table in bottom-up manner\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # For each element, find number of sequences of length i ending with value j\n            dp[i][j] = sum(dp[i - 1][k] for k in range(1, j // 2 + 1))\n\n    # Return total number of sequences of length n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # initialize a 2D DP array\n    dp = [[0]*(m+1) for _ in range(n+1)]\n    # initialize the first row\n    for i in range(1, m+1):\n        dp[1][i] = 1\n    # fill up the DP table\n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            for k in range(2*j, m+1):\n                dp[i][k] += dp[i-1][j]\n    # sum up the last row\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a matrix with all elements as 0\n    seq = [[0 for i in range(m+1)] for j in range(n+1)]\n\n    # Any number can start a sequence of 1\n    for i in range(1, m + 1):\n        seq[1][i] = 1\n\n    # For each length of the sequence\n    for length in range(2, n+1):\n        # For each possible element\n        for elem in range(1, m+1):\n            # For each previous element\n            for prev_elem in range(1, elem+1):\n                # If previous element is valid, add it to the count of sequences\n                if 2*prev_elem <= elem:\n                    seq[length][elem] += seq[length-1][prev_elem]\n\n    # Return the total number of sequences of length n\n    return sum(seq[n])", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # dp[i][j] will store the number of possible sequences\n    # of length j such that last element is i\n    dp = [[0]*n for _ in range(m+1)]\n\n    # base case: for sequence length 1, fill the dp array\n    for i in range(1, m+1):\n        dp[i][0] = 1\n\n    # fill the rest of the dp array\n    for seq_len in range(1, n):\n        for last_num in range(1, m+1):\n            for next_num in range(last_num*2, m+1):\n                dp[next_num][seq_len] += dp[last_num][seq_len-1]\n\n    # total possible sequences of length n\n    total_sequences = sum(dp[i][n-1] for i in range(1, m+1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D table to store the number of possible sequences\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # There is 1 way to form a sequence of length 1\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # For each length l from 2 to n\n    for l in range(2, n + 1):\n        # For each number j from 1 to m\n        for j in range(1, m + 1):\n            # For each previous number i from 1 to j\n            for i in range(1, j + 1):\n                if i * 2 <= j:\n                    dp[l][j] += dp[l - 1][i]\n\n    # The answer is the sum of the number of sequences for all numbers j from 1 to m of length n\n    return sum(dp[n])", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a matrix to store the number of sequences\n    # seq[i][j] is going to store count of sequences of length i ending\n    # with j.\n    seq = [[0 for _ in range(m+1)] for _ in range(n+1)]\n\n    # There is only one sequence of length 1 and ending with any number\n    # less than or equal to m.\n    for j in range(1, m+1):\n        seq[1][j] = 1\n\n    # Fill up seq[][] in bottom up manner.\n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            # For each element, find total elements that can form a sequence\n            for k in range(j, m+1):\n                if k >= 2*j:\n                    seq[i][k] += seq[i-1][j]\n\n    # Return total number of sequences of length n.\n    return sum(seq[n])", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialise a 2D array to store number of sequences\n    # dp[i][j] stores number of sequences of length i such that last element is j\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # If sequence has one element (n=1)\n    # Only one valid sequence\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n\n    # Fill dp table in bottom-up manner\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # dp[i][j] = sum of all dp[i-1][k] where k is half of j\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    # Final answer will be sum of all dp[n][i] for 1 <= i <= m\n    total_sequences = sum(dp[n])\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP table with all elements as 0\n    dp = [[0 for _ in range(m+1)] for __ in range(n+1)]\n\n    # Length of sequence is 1, so only 1 possibility to choose from\n    for i in range(1, m+1):\n        dp[1][i] = 1\n\n    # Fill up the DP table from length 2 to n\n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            # Each position in the sequence will consider a number j from 1 to m\n            # Number of possibilities will be sum of all the possibilities where the current number j is greater than or equal to twice the previous number\n            for k in range(1, j//2+1):\n                dp[i][j] += dp[i-1][k]\n\n    # Sum up all the possibilities for sequence length n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    if m < 1 or n < 1:\n        raise ValueError(\"Both m and n must be positive integers\")\n\n    dp = [[0] * (m + 1) for _ in range(n)]\n    for i in range(1, m + 1):\n        dp[0][i] = 1\n\n    for i in range(1, n):\n        for j in range(2 * i, m + 1):\n            for k in range(i, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    return sum(dp[n - 1])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a list to keep track of the total number of sequences for each element in the array\n    dp = [1] * m\n\n    # Iterate over the length of the sequence\n    for i in range(2, n + 1):\n        # Initialize a temporary list for the current length\n        temp = [0] * m\n        # Iterate over each possible element in the sequence\n        for j in range(1, m + 1):\n            # The current number of sequences is the sum of the previous elements that are less than or equal to half of the current element\n            temp[j - 1] = sum(dp[:j // 2])\n        # Update the dp list for the current length\n        dp = temp\n\n    # The total number of sequences of length n is the sum of the last element of dp\n    return sum(dp)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize the result matrix and fill the first row with 1's\n    result = [[0] * (m + 1) for _ in range(n)]\n    for i in range(1, m + 1):\n        result[0][i] = 1\n\n    # Calculate the number of possible sequences for each position\n    for i in range(1, n):\n        for j in range(1, m + 1):\n            for k in range(2 * j, m + 1):\n                result[i][k] += result[i - 1][j]\n\n    # The result is the sum of the last row in the result matrix\n    return sum(result[n - 1])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2D DP array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # If length of the sequence is 1, then there are m possible sequences\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Fill up the DP array\n    for length in range(2, n + 1):\n        for value in range(1, m + 1):\n            for prev_value in range(1, value // 2 + 1):\n                dp[length][value] += dp[length - 1][prev_value]\n\n    # Total number of sequences is sum of the last column of DP array\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += dp[n][i]\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # create a 2D dp array to store the number of possible sequences\n    dp = [[0] * (m+1) for _ in range(n+1)]\n\n    # initialize the first column with 1 because there is one possible sequence with length 1\n    for i in range(1, m+1):\n        dp[1][i] = 1\n\n    # compute the number of possible sequences for each element in the dp array\n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            for k in range(j, m+1):\n                if k >= 2*j:\n                    dp[i][k] += dp[i-1][j]\n\n    # return the number of possible sequences of length n\n    return sum(dp[n])", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize dp array with all values set to 0\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Base case: if n is 1, there are m possible sequences\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Iterate over length of the sequence from 2 to n\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # Iterate over possible values of current element of the sequence\n            for k in range(2 * j, m + 1):\n                dp[i][k] += dp[i - 1][j]\n\n    # Sum up the last row of dp array to get the total number of sequences\n    return sum(dp[n])", "matching_cluster_idx": 7}]}, "Mbpp/240": {"dps": 78.35365853658537, "dps_norm": 86.66666666666666, "pass@1": 81.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replacing the last element of the first list with the second list\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Function that takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    list1.pop()\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    if not list1:  # Check if list1 is not empty\n        return list2\n    else:\n        list1[-1:] = list2  # Replace the last element of list1 with list2\n        return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(l1, l2):\n    l1[-1:] = l2\n    return l1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    if len(lst1) > 0:\n        lst1[-1:] = lst2\n    else:\n        lst1 = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # remove the last element from the first list\n    list1 = list1[:-1]\n    # extend the first list with the elements of the second list\n    list1.extend(list2)\n    # return the modified first list\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element from list1\n    list1 = list1[:-1]\n    # Extend list1 with the elements from list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if len(list1) == 0:\n        return list2\n    else:\n        list1.pop()\n        for i in list2:\n            list1.append(i)\n        return list1", "matching_cluster_idx": 3}, {"solution": "def replace_list(list1, list2):\n    # Removes last element from the first list\n    list1.pop()\n\n    # Extends the first list with the elements from the second list\n    list1.extend(list2)\n\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element of the first list\n    list1 = list1[:-1]\n    # Add the elements of the second list to the first list\n    list1.extend(list2)\n    # Return the modified list\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    if len(list1) == 0:\n        return list2\n    else:\n        list1[-1:] = list2\n        return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # remove the last element of the first list\n    list1.pop()\n    # extend the first list with the second list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}]}, "Mbpp/251": {"dps": 61.09195402298851, "dps_norm": 70.0, "pass@1": 94.0, "profiled": [{"solution": "def insert_element(lst, elem):\n    result = []\n    for i in lst:\n        result.append(elem)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, ele):\n    result = []\n    for item in lst:\n        result.append(ele)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    \"\"\"\n    Takes in a list and an element, inserts the element before each element in the list,\n    and returns the resulting list.\n    \"\"\"\n    return [item for sublist in [[el, i] for i in lst] for item in sublist]", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elm):\n    return [val for sublist in [[elm, i] for i in lst] for val in sublist]", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, el):\n    return [val for sub in [[el, x] for x in lst] for val in sub]", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    A function that takes in a list and an element, inserts the element before each element in the list,\n    and returns the resulting list.\n    \"\"\"\n    return [i for elem in lst for i in [element, elem]]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for i in input_list:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    new_lst = []\n    for i in lst:\n        new_lst.append(elem)\n        new_lst.append(i)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, ele):\n    return [item for sublist in [[ele, i] for i in lst] for item in sublist]", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for el in lst:\n        result.append(elem)\n        result.append(el)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    new_lst = []\n    for i in lst:\n        new_lst.append(el)\n        new_lst.append(i)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    \"\"\"\n    Insert the given element before each element in the list and return the resulting list.\n\n    Parameters:\n    lst (list): The input list.\n    el: The element to insert before each element in the list.\n\n    Returns:\n    list: The resulting list.\n    \"\"\"\n    return [i for item in lst for i in (el, item)]", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    return [item for sublist in [[element, i] for i in lst] for item in sublist]", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    return [item for sublist in [[element, i] for i in lst] for item in sublist]", "matching_cluster_idx": 4}, {"solution": "def insert_element(list, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Loop through each element in the input list\n    for el in list:\n        # Append the given element and the current element in the list to the result list\n        result.append(element)\n        result.append(el)\n    # Return the result list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new empty list\n    new_lst = []\n\n    # Iterate over each element in the given list\n    for e in lst:\n        # Append the given element and then the current element to the new list\n        new_lst.append(element)\n        new_lst.append(e)\n\n    return new_lst", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 65.39954337899543, "dps_norm": 61.76470588235294, "pass@1": 50.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"\n    Checks if a number is prime.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Returns the count of prime numbers less than a given non-negative number.\n    \"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    if n > 1:\n        for num in range(2, n):\n            i = 2\n            for i in range(2, num):\n                if (num % i) == 0:\n                    break\n            else:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def is_prime(n):\n    \"\"\"\n    Checks if a number is prime\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n**0.5) + 1\n    for div in range(3, sqrt_n, 2):\n        if n % div == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2,int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2,n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Helper function that checks if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function that counts the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    A function that counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n    n (int): a non-negative number.\n\n    Returns:\n    count (int): the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n < 2:  # There are no prime numbers less than 2.\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False  # 0 and 1 are not primes.\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Function to count the number of prime numbers less than a given non-negative number.\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, num):\n            if num % i == 0:\n                is_prime = False\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function takes a non-negative integer n and returns the number of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    # Create a boolean array \"prime[0..n]\" and initialize all entries it as true.\n    # A value in prime[i] will finally be false if i is Not a prime, else true.\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        # If prime[p] is not changed, then it is a prime\n        if (prime[p] == True):\n            # Update all multiples of p\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\n    # Return the count of prime numbers less than n\n    return sum(prime[:n]) - 2 # subtract 2 as 0 and 1 are not prime", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    A function that takes in a non-negative number and returns the number of prime numbers less than the given number.\n    :param n: int, non-negative number\n    :return: int, number of primes less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n    else:\n        primes = [True for i in range(n)]\n        p = 2\n        while (p * p <= n):\n            if primes[p] == True:\n                for i in range(p * p, n, p):\n                    primes[i] = False\n            p += 1\n        prime_count = 0\n        for i in range(2, n):\n            if primes[i]:\n                prime_count += 1\n        return prime_count", "matching_cluster_idx": 12}, {"solution": "def count_Primes_nums(n):\n    \"\"\"Function to count prime numbers less than n\"\"\"\n    if n < 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for ind, val in enumerate(primes):\n        if val is True:\n            primes[ind*2::ind] = [False] * (((n - 1)//ind) - 1)\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2,int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2,n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Function to count the number of prime numbers less than a given non-negative number.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    for x in range(2, int(n ** 0.5) + 1):\n        if sieve[x]:\n            for i in range(x * x, n, x):\n                sieve[i] = False\n    return sum(sieve[2:])", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Function to return the count of prime numbers less than the given non-negative number\n    \"\"\"\n    def is_prime(num):\n        \"\"\"\n        Helper function to check if a number is prime\n        \"\"\"\n        if num <= 1:\n            return False\n        elif num <= 3:\n            return True\n        elif num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than the given non-negative number\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    primes = [True] * n\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n, p):\n                primes[i] = False\n        p += 1\n    prime_count = 0\n    for p in range(2, n):\n        if primes[p]:\n            prime_count += 1\n    return prime_count", "matching_cluster_idx": 13}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function that counts prime numbers less than the given non-negative number\"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}]}, "Mbpp/265": {"dps": 75.29069767441861, "dps_norm": 85.83333333333333, "pass@1": 96.0, "profiled": [{"solution": "def list_split(input_list, n):\n    # Create an empty list to store the resultant lists\n    result = []\n\n    # Iterate over the input_list in steps of size n\n    for i in range(n):\n        # Append the i-th element of each n-sized chunk to a new list\n        result.append(input_list[i::n])\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Create an empty list to store the resulting lists\n    result = []\n\n    # Use list slicing to split the input list\n    for i in range(n):\n        result.append(lst[i::n])\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(arr, n):\n    # Using list comprehension to split the list\n    return [arr[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Using list comprehension\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    # Create an empty list to store the result\n    result = []\n\n    # Iterate through the input_list\n    for i in range(n):\n        # For each index, create a new list that consists of every nth element starting from i\n        result.append(input_list[i::n])\n\n    # Return the result\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Use list comprehension to generate a list of the nth elements in lst\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(input_list, n):\n    # empty list to hold the resulting lists\n    result = []\n    # loop through the input_list with a step size of n\n    for i in range(n):\n        # use list slicing to get every nth element of the input_list\n        # and append it to the result list\n        result.append(input_list[i::n])\n    # return the list of resulting lists\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    A function that takes in a list and an integer n and splits the list for every nth element.\n    Returns a list of the resulting lists.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Empty list to store the resulting lists\n    result = []\n    # Loop over elements in input list\n    for i in range(n):\n        # Create a new list containing every nth element in the input list\n        new_lst = lst[i::n]\n        # Add the new list to the result list\n        result.append(new_lst)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert the list to a set\n    unique_lst = set(lst)\n    # If the size of the set is equal to the size of the list, all elements are unique\n    return len(unique_lst) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert the list to a set. Set only contains unique elements.\n    # If the lengths of the set and the list are the same, then all elements are unique.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if the elements of a given list are unique or not.\"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    This function checks if the elements of a given list are unique or not.\n\n    Parameters:\n    lst (list): A list of elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Using set to remove duplicate elements. If all elements are unique,\n    # the length of the set will be equal to the length of the list.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    This function takes a list as input and checks if all its elements are unique or not.\n\n    :param lst: list of elements\n    :return: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    A function to check if the elements of a given list are unique or not.\n    \"\"\"\n    # Use a set to remove duplicates, then compare the lengths.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    This function takes a list as an argument and returns True if all elements in the list are unique, else False.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert list into a set and compare length of the set with the original list\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Function to check if all elements in the list are unique.\n\n    Args:\n    lst: list of elements\n\n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if all elements in a list are unique.\"\"\"\n    # Convert list to a set and check if lengths are equal.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    if len(lst) == len(set(lst)):\n        return True\n    else:\n        return False", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 67.6923076923077, "dps_norm": 85.0, "pass@1": 77.0, "profiled": [{"solution": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, inv_left = merge_sort(arr[:mid])\n    right, inv_right = merge_sort(arr[mid:])\n    sorted_arr, inv_split = merge(left, right)\n\n    return sorted_arr, inv_left + inv_right + inv_split\ndef merge(left, right):\n    i = j = k = inv_count = 0\n    sorted_arr = []\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            sorted_arr.append(left[i])\n            i += 1\n        else:\n            sorted_arr.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n\n    sorted_arr.extend(left[i:])\n    sorted_arr.extend(right[j:])\n\n    return sorted_arr, inv_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv = merge_sort(arr[:mid])\n        right, right_inv = merge_sort(arr[mid:])\n        merged, split_inv = merge(left, right)\n        return merged, left_inv + right_inv + split_inv\n\n    def merge(left, right):\n        i = j = 0\n        inv_count = 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n        return merged, inv_count\n\n    sorted_arr, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"Function to count inversions in an array.\"\"\"\n    inv_count = 0\n    n = len(arr)\n\n    # Two nested loops to compare each element with every other element\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(array):\n    count = 0\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            if (array[i] > array[j]):\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def merge_sort_and_count(array):\n    if len(array) <= 1:\n        return array, 0\n\n    middle = len(array) // 2\n    left, left_count = merge_sort_and_count(array[:middle])\n    right, right_count = merge_sort_and_count(array[middle:])\n\n    i, j, k, count = 0, 0, 0, 0\n    merged = [0] * len(array)\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged[k] = left[i]\n            i += 1\n        else:\n            merged[k] = right[j]\n            j += 1\n            count += len(left) - i\n        k += 1\n\n    while i < len(left):\n        merged[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        merged[k] = right[j]\n        j += 1\n        k += 1\n\n    return merged, count + left_count + right_count\ndef get_Inv_Count(array):\n    _, count = merge_sort_and_count(array)\n    return count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array\n    \"\"\"\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_sort_and_count_inv(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left_half, left_inv = merge_sort_and_count_inv(arr[:mid])\n    right_half, right_inv = merge_sort_and_count_inv(arr[mid:])\n    sorted_arr, split_inv = merge_and_count_split_inv(left_half, right_half)\n\n    return sorted_arr, left_inv + right_inv + split_inv\ndef merge_and_count_split_inv(left_half, right_half):\n    i = j = inv_count = 0\n    sorted_arr = []\n    while i < len(left_half) and j < len(right_half):\n        if left_half[i] <= right_half[j]:\n            sorted_arr.append(left_half[i])\n            i += 1\n        else:\n            sorted_arr.append(right_half[j])\n            j += 1\n            inv_count += len(left_half) - i\n\n    while i < len(left_half):\n        sorted_arr.append(left_half[i])\n        i += 1\n\n    while j < len(right_half):\n        sorted_arr.append(right_half[j])\n        j += 1\n\n    return sorted_arr, inv_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count_inv(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort(array):\n    if len(array) <= 1:\n        return array, 0\n    else:\n        middle = len(array) // 2\n        left, left_inv = merge_sort(array[:middle])\n        right, right_inv = merge_sort(array[middle:])\n        merged, split_inv = merge(left, right)\n        return merged, left_inv + right_inv + split_inv\ndef merge(left, right):\n    result = []\n    i = j = inversions = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inversions += len(left) - i\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result, inversions\ndef get_Inv_Count(array):\n    _, inv_count = merge_sort(array)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if(arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inv_count = merge_and_count(arr[:mid])\n    right, right_inv_count = merge_and_count(arr[mid:])\n    sorted_arr, inv_count = merge(left, right)\n\n    return sorted_arr, left_inv_count + right_inv_count + inv_count\ndef merge(left, right):\n    sorted_arr = []\n    inv_count = 0\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            sorted_arr.append(left[i])\n            i += 1\n        else:\n            sorted_arr.append(right[j])\n            inv_count += len(left) - i\n            j += 1\n\n    sorted_arr.extend(left[i:])\n    sorted_arr.extend(right[j:])\n\n    return sorted_arr, inv_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def merge_sort(arr, n):\n    temp_arr = [0]*n\n    return _merge_sort(arr, temp_arr, 0, n-1)\ndef _merge_sort(arr, temp_arr, left, right):\n    inv_count = 0\n\n    if left < right:\n        mid = (left + right)//2\n        inv_count += _merge_sort(arr, temp_arr, left, mid)\n        inv_count += _merge_sort(arr, temp_arr, mid + 1, right)\n        inv_count += merge(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef merge(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n\n    return inv_count\ndef get_Inv_Count(arr):\n    return merge_sort(arr, len(arr))", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Merge sort function to split array into subarrays, count inversions\n    def merge_sort(arr):\n        if len(arr) == 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, left_inv = merge_sort(arr[:mid])\n            right, right_inv = merge_sort(arr[mid:])\n            merged, split_inv = merge(left, right)\n            return merged, left_inv + right_inv + split_inv\n\n    # Function to merge two arrays and count the number of split inversions\n    def merge(left, right):\n        i = j = inv_count = 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                # count the number of elements that are greater than right[j] in left\n                inv_count += len(left[i:])\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    return merge_sort(arr)[1]", "matching_cluster_idx": 3}, {"solution": "def mergeSort(arr, n):\n    temp_arr = [0]*n\n    return _mergeSort(arr, temp_arr, 0, n-1)\ndef _mergeSort(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right)//2\n        inv_count += _mergeSort(arr, temp_arr, left, mid)\n        inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\ndef merge(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n    return inv_count\ndef get_Inv_Count(arr):\n    return mergeSort(arr, len(arr))", "matching_cluster_idx": 5}, {"solution": "def merge_sort_inv_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inv = merge_sort_inv_count(arr[:mid])\n    right, right_inv = merge_sort_inv_count(arr[mid:])\n\n    i, j, inv_count = 0, 0, 0\n    merged = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n\n    merged += left[i:]\n    merged += right[j:]\n    inv_count += left_inv + right_inv\n    return merged, inv_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_inv_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count to 0\n    inv_count = 0\n\n    # Traverse through all array elements\n    for i in range(len(arr)):\n        # For each element, count number of elements which are on right side of it and are smaller than it.\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    # Return the total count of inversions in the array\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Merge sorting and counting the number of inversions is an efficient way to solve this problem\n    def merge_sort(arr):\n        # Base case: 0 or 1 items in array\n        if len(arr) <= 1:\n            return arr, 0\n\n        # Split array into two halves\n        mid = len(arr) // 2\n        left, left_inv = merge_sort(arr[:mid])\n        right, right_inv = merge_sort(arr[mid:])\n\n        # Merge two sorted halves and count inversions\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                # left[i] > right[j], therefore, left[i...] is greater than right[j]\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n\n        # Add remaining elements of left and right to merged list\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged, inv_count + left_inv + right_inv\n\n    # Call merge_sort on arr\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    temp = [0] * n\n    return _mergeSort(arr, temp, 0, n-1)\ndef _mergeSort(arr, temp, left, right):\n    inv_count = 0\n\n    if left < right:\n        mid = (left + right)//2\n\n        inv_count += _mergeSort(arr, temp, left, mid)\n\n        inv_count += _mergeSort(arr, temp, mid + 1, right)\n\n        inv_count += _merge(arr, temp, left, mid, right)\n\n    return inv_count\ndef _merge(arr, temp, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            i += 1\n        else:\n            temp[k] = arr[j]\n            j += 1\n\n            inv_count += (mid-i + 1)\n\n        k += 1\n\n    while i <= mid:\n        temp[k] = arr[i]\n        k += 1\n        i += 1\n\n    while j <= right:\n        temp[k] = arr[j]\n        k += 1\n        j += 1\n\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp[loop_var]\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n    An inversion in a discrete sequence of numbers is a pair of numbers in the sequence\n    that are out of order.\n    :param arr: input list\n    :return: number of inversions in the input list\n    \"\"\"\n    # Initialize a counter to count inversions\n    inv_count = 0\n    # Loop over the list\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If a pair of numbers is found out of order, increment the counter\n            if arr[i] > arr[j]:\n                inv_count += 1\n    # Return the total number of inversions\n    return inv_count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/392": {"dps": 73.47417840375587, "dps_norm": 78.84615384615384, "pass@1": 25.0, "profiled": [{"solution": "def get_max_sum(n):\n    if n <= 5:\n        return n\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 8}, {"solution": "def get_max_sum(n):\n    if n < 6:\n        return n\n    else:\n        return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "matching_cluster_idx": 8}, {"solution": "def get_max_sum(n):\n    # Define the function f(n)\n    def f(n):\n        # Initialize the base case when n is 0 or 1\n        if n == 0 or n == 1:\n            return n\n        # Use memoization to avoid computing the same subproblem multiple times\n        if n in memo:\n            return memo[n]\n        # Compute f(n) as the maximum between the sum of f(n/i) and n\n        max_sum = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n        # Store the result of f(n) in the memo dictionary to avoid future recomputation\n        memo[n] = max_sum\n        return max_sum\n    # Initialize a dictionary to store the results of f(n) for different n\n    memo = {}\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n    def f(n):\n        if n in memo:\n            return memo[n]\n        elif n < 6:\n            memo[n] = n\n            return n\n        else:\n            memo[n] = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n            return memo[n]\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization to avoid unnecessary computation\n    memo = {}\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        if n < 6:\n            memo[n] = n\n            return n\n        max_sum = max((helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5)), n)\n        memo[n] = max_sum\n        return max_sum\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization\n    memo = {}\n    def f(n):\n        if n == 0 or n == 1:\n            return n\n        if n in memo:\n            return memo[n]\n        else:\n            result = max((f(n//2) + f(n//3) + f(n//4) + f(n//5)), n)\n            memo[n] = result\n            return result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a list to store the results of the function\n    # So that we can easily get the values that have been already computed\n    f = [0] * (n + 1)\n\n    # Compute the function values\n    for i in range(1, n+1):\n        f[i] = max(f[i//2] + f[i//3] + f[i//4] + f[i//5], i)\n\n    return f[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    if n < 2:\n        return n\n    else:\n        return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    if n < 2:\n        return n\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store the computed values to avoid recomputation\n    computed_values = {0: 0, 1: 1}\n\n    # Define the function f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    def f(x):\n        if x in computed_values:\n            return computed_values[x]\n        else:\n            computed_values[x] = max(f(x//2) + f(x//3) + f(x//4) + f(x//5), x)\n            return computed_values[x]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store calculated max sums\n    max_sums = {0: 0, 1: 1}\n\n    # Define a helper function to calculate the max sum for a given number\n    def calculate_max_sum(num):\n        # Return calculated max sum if already exists\n        if num in max_sums:\n            return max_sums[num]\n        # Else, calculate max sum using the equation and store it in max_sums\n        else:\n            max_sum = max(calculate_max_sum(num//2) + calculate_max_sum(num//3) + calculate_max_sum(num//4) + calculate_max_sum(num//5), num)\n            max_sums[num] = max_sum\n            return max_sum\n\n    # Call the helper function and return the max sum for the given number\n    return calculate_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store previously calculated values\n    f_dict = {}\n\n    # Define the recursive function that calculates the maximum sum\n    def f(n):\n        # Check if the value has already been calculated\n        if n in f_dict:\n            return f_dict[n]\n        # Base case\n        elif n < 5:\n            return n\n        else:\n            # Recursive case\n            f_dict[n] = max((f(n//2) + f(n//3) + f(n//4) + f(n//5)), n)\n            return f_dict[n]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store already computed results\n    max_sum_dict = {0: 0, 1: 1}\n\n    # If the value is already computed, return it\n    if n in max_sum_dict:\n        return max_sum_dict[n]\n\n    # Calculate the maximum sum possible\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n\n    # Save the result in the dictionary for future use\n    max_sum_dict[n] = max_sum\n\n    return max_sum", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to save previously calculated values.\n    memo = {0:0, 1:1}\n\n    def f(n):\n        # Return the memoized value if it exists.\n        if n in memo:\n            return memo[n]\n\n        # Calculate the value using the formula and save it to the memoization dictionary.\n        memo[n] = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n\n        return memo[n]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n <= 5:\n        return n\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 8}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store the computed f(n) values\n    dp = {0: 0}\n\n    # Define the function f(n) using a helper function\n    def f(n):\n        # If f(n) has already been computed, return the computed value\n        if n in dp:\n            return dp[n]\n\n        # Compute f(n) using the given equation\n        dp[n] = max((f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)), n)\n        return dp[n]\n\n    # Call the helper function f(n) with the input value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store computed values\n    memo = {0: 0, 1: 1}\n\n    def f(n):\n        # Check if the value has been computed before\n        if n not in memo:\n            # Compute the value as the maximum of (f(n/2) + f(n/3) + f(n/4) + f(n/5)) and n\n            memo[n] = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n        return memo[n]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n    else:\n        return max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    This function calculates the maximum sum possible by using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    and returns the maximum sum.\n\n    Args:\n    n (int): The input integer\n\n    Returns:\n    int: The maximum sum possible\n    \"\"\"\n    # initialize a dictionary to store the calculated values\n    calc_dict = {}\n\n    # define the function f(n) recursively\n    def f(n):\n        if n == 0:\n            return 0\n        if n in calc_dict:\n            return calc_dict[n]\n        else:\n            calc_dict[n] = max((f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)), n)\n            return calc_dict[n]\n\n    # calculate and return the maximum sum\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n < 6:\n        return n\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 8}]}, "Mbpp/395": {"dps": 81.14942528735632, "dps_norm": 72.5, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    count = {}\n    for char in s:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    for char in s:\n        if count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    count = {}\n    for char in string:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n\n    for char in string:\n        if count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # Count frequency of each character\n    counts = {}\n    for char in string:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n\n    # Find the first character with frequency 1\n    for char in string:\n        if counts[char] == 1:\n            return char\n\n    # No non-repeated characters found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Function to find the first non-repeated character in a given string.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n\n    # Loop over the string to find the first non-repeated character\n    for char in s:\n        if freq[char] == 1:\n            return char\n\n    # Return None if no non-repeated character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    # Create a dictionary to store character counts\n    char_count = {}\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Check each character in the string\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeated character found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    # Create an empty dictionary to store frequency of each character\n    freq = {}\n    for char in input_string:\n        # If character is already in dictionary, increment the count by 1\n        if char in freq:\n            freq[char] += 1\n        # If character is not in dictionary, add it with a count of 1\n        else:\n            freq[char] = 1\n    # Iterate through the string again\n    for char in input_string:\n        # If frequency of the character is 1, return the character\n        if freq[char] == 1:\n            return char\n    # If no character is non-repeating, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char not in char_count:\n            char_count[char] = 1\n        else:\n            char_count[char] += 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 4}, {"solution": "def first_non_repeating_character(input_string):\n    char_count = {}\n\n    # Count the occurrences of each character\n    for char in input_string:\n        if char not in char_count:\n            char_count[char] = 0\n        char_count[char] += 1\n\n    # Find the first non-repeating character\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n\n    # Return None if no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    count = {}\n    for char in s:\n        if char not in count:\n            count[char] = 1\n        else:\n            count[char] += 1\n    for char in s:\n        if count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 4}, {"solution": "def first_non_repeating_character(input_string):\n    character_frequency = {}\n\n    # count the frequency of each character\n    for char in input_string:\n        if char not in character_frequency:\n            character_frequency[char] = 1\n        else:\n            character_frequency[char] += 1\n\n    # find the first non-repeating character\n    for char in input_string:\n        if character_frequency[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 4}, {"solution": "def first_non_repeating_character(input_string):\n    char_count = {}\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 4}, {"solution": "def first_non_repeating_character(input_string):\n    # use a dictionary to store character frequencies\n    char_freq = {}\n    for char in input_string:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # iterate through the input string and return the first non-repeated character\n    for char in input_string:\n        if char_freq[char] == 1:\n            return char\n\n    # return None if there is no non-repeated character\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Build the character count map\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # Return None if no non-repeated character found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # create a dictionary to store character frequencies\n    char_freq = {}\n    for char in string:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n    # iterate over the string to find the first non-repeating character\n    for char in string:\n        if char_freq[char] == 1:\n            return char\n    # return None if all characters are repeating\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    char_count = {}\n    for char in input_string:\n        char_count[char] = char_count.get(char, 0) + 1\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n    for c in s:\n        if count[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    This function finds and returns the first non-repeating character in a given string.\n    If there are no non-repeating characters, it returns None.\n    \"\"\"\n    # Count the frequency of each character in the string\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character that appears only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If all characters repeat, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"Find the first non-repeating character in a given string\"\"\"\n    # Create a dictionary to count the occurrence of each character in the string\n    count_dict = {}\n    for char in s:\n        if char in count_dict:\n            count_dict[char] += 1\n        else:\n            count_dict[char] = 1\n    # Find the first character that occurs only once\n    for char in s:\n        if count_dict[char] == 1:\n            return char\n    # Return None if all characters are repeated\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, x):\n    if x in t:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    if element in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n\n    :param tup: the tuple to check\n    :param elem: the element to check for\n    :return: True if element exists in tuple, False otherwise\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    if element in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, e):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n\n    Parameters:\n    t (tuple): The tuple to search.\n    e: The element to search for.\n\n    Returns:\n    bool: True if the element is in the tuple, False otherwise.\n    \"\"\"\n    return e in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    if element in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    if element in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    if elem in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Function to check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element : The element to search for.\n\n    Returns:\n    bool: True if the element is in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple, element):\n    if element in tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    if element in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    # function to check if element exists in tuple\n    if elem in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 75.09316770186335, "dps_norm": 82.22222222222223, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    # This function checks if any value in seq1 exists in seq2.\n    # It does so by converting both sequences to sets and using the intersection method.\n    # If the intersection of the two sets is not empty, that means the sequences overlap.\n\n    set1 = set(seq1)\n    set2 = set(seq2)\n\n    if set1 & set2:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Convert sequences to sets\n    set1 = set(seq1)\n    set2 = set(seq2)\n\n    # Check for intersection\n    if set1 & set2:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    A function to check whether any value in seq1 exists in seq2 or not.\n    \"\"\"\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks whether any value in a sequence exists in another sequence or not.\n    \"\"\"\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(x in seq2 for x in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(i in seq2 for i in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function to check whether any value in a sequence exists in another sequence.\n\n    Parameters:\n        seq1 (list): first sequence of numbers.\n        seq2 (list): second sequence of numbers.\n\n    Returns:\n        bool: True if any value exists in both sequences, else False.\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n\n    # Check if intersection is not empty\n    return len(set1 & set2) > 0", "matching_cluster_idx": 5}]}, "Mbpp/421": {"dps": 78.10699588477367, "dps_norm": 86.42857142857142, "pass@1": 99.0, "profiled": [{"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by the delimiter.\n    \"\"\"\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of tuple by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(str(i) for i in t)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tuple_input, delimiter='-'):\n    return delimiter.join(str(i) for i in tuple_input)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    # convert each element of the tuple to string and join them with the given delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(str(i) for i in input_tuple)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Function to concatenate each element of a tuple by the given delimiter.\n    \"\"\"\n    # Convert each element of the tuple to string and join them using delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    A function to concatenate each element of a tuple by the delimiter.\n    The function converts every element of the input tuple to string before concatenation.\n    \"\"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    # convert each element to string and join them using delimiter\n    return delimiter.join(str(i) for i in input_tuple)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    This function takes a tuple and a delimiter as arguments and returns\n    a string by concatenating each element of the tuple by the delimiter.\n    \"\"\"\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(str(i) for i in t)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    \"\"\"\n    Function to concatenate each element of tuple by the delimiter '-'.\n\n    Args:\n    t (tuple): A tuple of elements.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 51.624548736462096, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(tuple_of_strings):\n    return [string[-1] for string in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tupl):\n    return [s[-1] for s in tupl]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tupl):\n    \"\"\"\n    This function extracts only the rear index element of each string in the given tuple.\n    Args:\n    tupl: A tuple of strings\n    Returns:\n    A list of the last characters in the input tuple's strings.\n    \"\"\"\n    return [string[-1] for string in tupl]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_input):\n    return [string[-1] for string in tuple_input]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_str):\n    return [str[-1] for str in tuple_str]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(words):\n    rear_elements = [word[-1] for word in words]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tupl):\n    return [s[-1] for s in tupl]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_str):\n    return [s[-1] for s in tuple_str]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [item[-1] for item in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    result = [string[-1] for string in input_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tupl):\n    return [s[-1] for s in tupl]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    This function extracts the last character of each string in a given tuple.\n\n    Parameters:\n    tuple_of_strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string in the given tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuples):\n    # Initialize an empty list to hold the extracted characters\n    extracted = []\n\n    # Iterate over each string in the tuple\n    for word in tuples:\n        # Add the last character of the current string to the list\n        extracted.append(word[-1])\n\n    # Return the list of extracted characters\n    return extracted", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    return [string[-1] for string in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(words):\n    return [word[-1] for word in words]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(lst, elem):\n    return sum(elem in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    This function counts the number of sublists containing a particular element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    \"\"\"\n    This function counts the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list): the list of sublists\n    elem (any): the element to search for\n\n    Returns:\n    int: the number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    This function counts the number of sublists containing a particular element.\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    \"\"\"\n    Function to count the number of sublists containing a particular element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, element):\n    count = 0\n    for sublist in input_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    \"\"\"\n    Function to count the number of sublists containing a particular element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Function to count the number of sublists containing a particular element.\n    \"\"\"\n    return sum([element in sublist for sublist in list_of_lists])", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element in a list\n    \"\"\"\n    # Initialize count\n    count = 0\n\n    # Loop through each sublist\n    for sublist in lst:\n        # If element is in sublist, increment count\n        if element in sublist:\n            count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, target):\n    \"\"\"\n    Count the number of sublists that contain a particular element.\n\n    :param lst: A list of lists of integers\n    :param target: An integer\n    :return: The number of sublists containing the target integer\n    \"\"\"\n    return sum(1 for sublist in lst if target in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, elem):\n    count = 0\n    for sublist in lst:\n        if elem in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    This function counts the number of sublists containing a particular element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 81.36363636363636, "dps_norm": 55.0, "pass@1": 93.0, "profiled": [{"solution": "def shell_sort(array):\n    gap = len(array) // 2\n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # start with a big gap, then reduce the gap\n    while gap > 0:\n        # do a gapped insertion sort for this gap size.\n        # the first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap = gap // 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    # Do a gapped insertion sort for each gap size.\n    # The last gap is always 1, so this will sort the array.\n    while gap > 0:\n        # Start comparing elements at gap indices\n        for i in range(gap, n):\n            temp = arr[i]\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    gap = len(arr) // 2\n\n    # Do a gapped insertion sort for each gap size.\n    # last gap is always 1\n    while gap > 0:\n\n        # This is an insertion sort\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n    # start with a big gap, then reduce the gap\n    while gap > 0:\n        # do a gapped insertion sort for this gap size.\n        # the first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, len(array)):\n            temp = array[i]\n            # shift earlier gap-sorted elements up until the correct location for array[i] is found\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            # put temp (the original array[i]) in its correct location\n            array[j] = temp\n        # reduce gap size for next pass\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            # Shift earlier gap-sorted elements up until the correct location for `arr[i]` is found\n            j = i\n            while  j >= gap and arr[j - gap] >temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place `temp` (the original `arr[i]`) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n//2\n\n    # Do a gapped insertion sort for each gap size.\n    # Last gap is always 1, but we can't reach it.\n    while gap > 0:\n\n        # Do a insertion sort for each gap size\n        for i in range(gap, n):\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location for temp is found\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    gap = len(arr)//2\n\n    # Do a gapped insertion sort for each gap size.\n    # Last gap is always 1.\n    while gap > 0:\n\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap,len(arr)):\n\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 66.22340425531915, "dps_norm": 73.0, "pass@1": 93.0, "profiled": [{"solution": "def check_greater(arr, num):\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(num_list, num):\n    # check if number is greater than any number in the list\n    return all(i < num for i in num_list)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    for element in array:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    for el in arr:\n        if num <= el:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Function to check whether the entered number is greater than all elements of the given array.\n\n    :param array: list of integers\n    :param num: integer\n    :return: True if num is greater than all elements in array, False otherwise\n    \"\"\"\n    return all(i < num for i in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(numbers, target):\n    for number in numbers:\n        if target <= number:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function takes an array of integers and a number as input and returns True if the number is\n    greater than all elements in the array. Otherwise, it returns False.\n    \"\"\"\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    for elem in array:\n        if number <= elem:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function takes an array of numbers and a single number as input.\n    It checks whether the number is greater than all the elements in the array.\n\n    :param arr: List of numbers\n    :param num: A number\n    :return: True if the number is greater than all elements in the array, False otherwise\n    \"\"\"\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    This function checks if a given number is greater than all the elements in the array.\n    \"\"\"\n    for i in array:\n        if number <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(nums, num):\n    for i in nums:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    return all(i < num for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check whether the number is greater than all elements in the given array.\n\n    Parameters:\n    array (list): A list of numbers.\n    number (int or float): A number to compare.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num < number for num in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for elem in arr:\n        if num <= elem:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, num):\n    return all(i < num for i in array)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/446": {"dps": 96.25615763546799, "dps_norm": 62.0, "pass@1": 30.0, "profiled": [{"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrence of all elements of list in a tuple.\n\n    Args:\n    tup: A tuple to be searched\n    lst: A list of elements to be counted\n\n    Returns:\n    A count of occurrences of elements in lst in tup\n    \"\"\"\n    return sum(tup.count(i) for i in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    # Initialize count to zero\n    count = 0\n    # Loop over each element in the list\n    for element in input_list:\n        # Count the occurrence of the element in the tuple and add to the count\n        count += input_tuple.count(element)\n    # Return the total count\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(tup.count(i) for i in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Convert the tuple to a list\n    tup_as_list = list(tup)\n\n    # Initialize a counter\n    count = 0\n\n    # Loop through the elements in the list\n    for element in lst:\n        # If the element is in the tuple, increment the counter\n        if element in tup_as_list:\n            count += tup_as_list.count(element)\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tupl, lst):\n    count = 0\n    for elem in lst:\n        count += tupl.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    count = 0\n    for element in input_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_values, list_values):\n    return sum(map(tuple_values.count, list_values))", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    return sum([tup.count(i) for i in lst])", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Create a dictionary to count the occurrence of elements in the tuple\n    count_dict = {}\n    for el in tup:\n        if el in count_dict:\n            count_dict[el] += 1\n        else:\n            count_dict[el] = 1\n\n    # Count the occurrences of elements in the list that are present in the tuple\n    count = 0\n    for el in lst:\n        if el in count_dict:\n            count += count_dict[el]\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(t, lst):\n    return sum(t.count(i) for i in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, list):\n    # Initialize a counter\n    count = 0\n\n    # Iterate over elements in the list\n    for elem in list:\n\n        # For each element, count its occurrence in the tuple\n        count += tup.count(elem)\n\n    # Return the total count\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple, list):\n    count = 0\n    for element in list:\n        count += tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    return sum(input_tuple.count(element) for element in input_list)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, list):\n    return sum(tup.count(i) for i in list)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(tup.count(i) for i in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Function to count the occurrence of all elements of a list in a tuple.\n    \"\"\"\n    count = 0\n    for elem in lst:\n        count += tup.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, element_list):\n    count = 0\n    for i in element_list:\n        count += input_tuple.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize counter to 0\n    count = 0\n\n    # Iterate over the list\n    for element in lst:\n        # Count the occurrence of each element in the tuple\n        count += tup.count(element)\n\n    # Return the total count\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    This function takes a tuple and a list as input.\n    It then counts the occurrences of all the elements in the list within the tuple.\n    :param tup: tuple of elements\n    :param lst: list of elements to count occurrence of in tuple\n    :return: integer number of occurrences\n    \"\"\"\n    count = 0\n    for elem in lst:\n        count += tup.count(elem)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 85.0, "profiled": [{"solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    This function takes a string as input and returns the same string but with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Function to remove all whitespaces from the given string\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Removes all whitespaces from the given string.\n    Args:\n        s: A string to remove whitespaces from.\n    Returns:\n        A new string without any whitespaces.\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param str_list: List of string values.\n    :return: List of reversed string values.\n    \"\"\"\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [string[::-1] for string in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverse each string in a given list of string values.\n    \"\"\"\n    return [string[::-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Empty list to hold reversed strings\n    reversed_list = []\n    # Iterate over each string in the list\n    for string in string_list:\n        # Reverse the string and append to the list\n        reversed_list.append(string[::-1])\n    # Return the list of reversed strings\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"Function to reverse each string in a given list of string values.\"\"\"\n    return [string[::-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [string[::-1] for string in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    reversed_list = []\n    for string in input_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    # Reverse each string in the given list\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    This function takes a list of strings as input and returns a new list with each string reversed.\n\n    :param input_list: list of strings to reverse\n    :return: list of reversed strings\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    return [str[::-1] for str in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    # Using list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [string[::-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [string[::-1] for string in strings]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 55.86538461538461, "dps_norm": 83.0, "pass@1": 29.0, "profiled": [{"solution": "def Extract(input_list):\n    return [sublist[0] for sublist in input_list]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Using list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # The function takes a list of lists as input and returns a new list\n    # containing the first element of each sublist in the input list.\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    # Initialize an empty list to store the first element of each sublist\n    first_elements = []\n    # Iterate through each sublist in the input list\n    for sublist in list_of_lists:\n        # If the sublist is not empty, append its first element to the output list\n        if sublist:\n            first_elements.append(sublist[0])\n    # Return the list of first elements\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(input_list):\n    return [sublist[0] for sublist in input_list]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Function to get the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to get the first element of each sublist\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [i[0] for i in lst]", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 96.73170731707317, "dps_norm": 97.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    \"\"\"\n    This function replaces all occurrences of old_char in input_str with new_char.\n    Args:\n    input_str (str): the string in which characters need to be replaced.\n    old_char (str): the character to be replaced.\n    new_char (str): the character to replace with.\n    Returns:\n    str: a new string with replaced characters.\n    \"\"\"\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, new_char):\n    return input_string.replace(char_to_replace, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    This function replaces old_char with new_char in the given string s.\n    Args:\n    s (str): the string to perform replacement on\n    old_char (str): the character to replace\n    new_char (str): the character to replace with\n\n    Returns:\n    str: the string with old_char replaced by new_char\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str: str, old_char: str, new_char: str) -> str:\n    \"\"\"\n    This function takes a string and two characters as input. It replaces all instances of the second character in the string with the third character and returns the updated string.\n    \"\"\"\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Create a new string with the replaced character\n    new_s = \"\"\n    for char in s:\n        if char == old_char:\n            new_s += new_char\n        else:\n            new_s += char\n    return new_s", "matching_cluster_idx": 2}, {"solution": "def replace_char(str, char_to_replace, replacement_char):\n    return str.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str: str, old_char: str, new_char: str) -> str:\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n    :param s: input string\n    :param old_char: character to be replaced\n    :param new_char: character to replace with\n    :return: string with replaced characters\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    This function replaces all occurrences of a specified character with another specified character in the input string.\n\n    Parameters:\n    input_string (str): the string in which to make replacements\n    char_to_replace (str): the character to be replaced\n    replacement_char (str): the character that will replace char_to_replace\n\n    Returns:\n    str: the modified string\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str: str, old_char: str, new_char: str) -> str:\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return None\n    else:\n        return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function takes a list of numbers as input, finds the maximum and minimum values in the list,\n    and returns their sum.\n    \"\"\"\n    # find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n    # return the sum of the maximum and minimum values\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError('The array must not be empty')\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError('Empty array is not supported')\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    if len(array) == 0:\n        return None\n    return max(array) + min(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n\n    Args:\n    arr (list of int or float): the input array\n\n    Returns:\n    int or float: the sum of the largest and smallest value in the array\n    \"\"\"\n    if len(arr) == 0:\n        return None\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return \"Array is empty\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    # Check if the array is not empty\n    if len(arr) == 0:\n        return None\n    else:\n        # Find and return the sum of the largest and smallest values\n        return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest value in the array\n    smallest = min(arr)\n    # Find the largest value in the array\n    largest = max(arr)\n    # Return the sum of the smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"Array must not be empty.\")\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Given a list of numbers, return the sum of the largest and smallest numbers in the list.\n    \"\"\"\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def is_lower(input_str):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    input_str (str): The string to be converted to lower case.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"Converts the given string to lower case\"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    This function takes a string as input and returns the same string in lower case.\n\n    Args:\n    string (str): The string to convert to lower case.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    This function takes a string as input and returns a new string with all characters\n    converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert a given string to lower case.\n\n    Args:\n    s (str): The input string to be converted.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts a given string to lower case.\n    :param s: str\n    :return: str\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    This function takes a string as input and returns a string with all uppercase characters converted to lowercase.\n\n    Args:\n    s (str): The input string\n\n    Returns:\n    str: The input string with all uppercase characters converted to lowercase\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.98360655737706, "dps_norm": 82.72727272727272, "pass@1": 95.0, "profiled": [{"solution": "def extract_values(s):\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    This function takes a string as input and extracts the values between quotation marks.\n    It returns a list of extracted values.\n    \"\"\"\n    # The regular expression pattern \"\\\".*?\\\"\" matches any text within double quotation marks\n    pattern = r'\\\"(.*?)\\\"'\n    values = re.findall(pattern, input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extract values between quotation marks from a string.\n    :param s: string\n    :return: list of values\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    \"\"\"\n    This function extracts values between quotation marks from a string.\n    \"\"\"\n    values = []\n    # Find the first quotation mark\n    start = string.find('\"')\n    while start != -1:\n        # Find the closing quotation mark\n        end = string.find('\"', start + 1)\n        if end != -1:\n            # Extract the value and append it to the values list\n            values.append(string[start + 1:end])\n            # Continue searching from the position of the closing quotation mark\n            start = string.find('\"', end + 1)\n        else:\n            break\n    return values", "matching_cluster_idx": 10}, {"solution": "import re\ndef extract_values(input_string):\n    return re.findall('\"([^\"]*)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    values = re.findall('\"([^\"]*)\"', string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    import re\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    return re.findall('\"([^\"]*)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    values = re.findall(r'\"([^\"]*)\"', s)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_str):\n    return re.findall(r'\"([^\"]*)\"', input_str)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_str):\n    \"\"\"Extract values between quotation marks from a string.\"\"\"\n    import re\n    return re.findall('\"([^\"]*)\"', input_str)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    return re.findall('\"([^\"]*)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    values = re.findall('\"([^\"]*)\"', string)\n    return values", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/578": {"dps": 81.57142857142857, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(l1, l2, l3):\n    # Check if all lists are of the same length\n    if len(l1) == len(l2) == len(l3):\n        # Initialize an empty result list\n        result = []\n        # Iterate over elements of the input lists\n        for i in range(len(l1)):\n            # Append elements of all lists to result list in an interleaved manner\n            result.append(l1[i])\n            result.append(l2[i])\n            result.append(l3[i])\n        # Return the result list\n        return result\n    else:\n        # Raise a ValueError if input lists are not of the same length\n        raise ValueError('All input lists must be of the same length')", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for tup in zip(list1, list2, list3) for val in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all the lists have the same length\n    if len(list1) == len(list2) == len(list3):\n        # Using zip_longest function from itertools module to interleave three lists\n        return [item for sublist in zip(list1, list2, list3) for item in sublist]\n    else:\n        raise ValueError('All the input lists must have the same length.')", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for sublist in zip(list1, list2, list3) for val in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    # Check if the three lists have the same length\n    if len(lst1) == len(lst2) == len(lst3):\n        # Initialize an empty list to hold the interleaved result\n        result = []\n        # Iterate over the length of one of the list (all have the same length)\n        for i in range(len(lst1)):\n            # Append the ith element from each list to the result list\n            result.append(lst1[i])\n            result.append(lst2[i])\n            result.append(lst3[i])\n        # Return the interleaved result list\n        return result\n    else:\n        raise ValueError(\"All lists must have the same length\")", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for tup in zip(list1, list2, list3) for val in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Create an empty list to store the interleaved elements\n    interleaved_list = []\n    # Iterate over the indices of the input lists\n    for i in range(len(list1)):\n        # Add the i-th element from each list to the interleaved list\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    # Return the interleaved list\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Function to interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # check if lists are of equal length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must have the same length\")\n\n    # use zip to interleave the lists\n    interleaved = [val for sublist in zip(list1, list2, list3) for val in sublist]\n\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for pair in zip(list1, list2, list3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for triple in zip(list1, list2, list3) for val in triple]\nlist1 = [1,2,3,4,5,6,7]\nlist2 = [10,20,30,40,50,60,70]\nlist3 = [100,200,300,400,500,600,700]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = [None]*(len(list1)+len(list2)+len(list3))\n    interleaved_list[::3] = list1\n    interleaved_list[1::3] = list2\n    interleaved_list[2::3] = list3\n    return interleaved_list", "matching_cluster_idx": 9}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [val for tup in zip(l1, l2, l3) for val in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All input lists must be of the same length.\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Function to interleave 3 lists of the same length into a single flat list.\n\n    Args:\n    list1 (list): first list\n    list2 (list): second list\n    list3 (list): third list\n\n    Returns:\n    list: Interleaved list\n    \"\"\"\n    # Check if lengths of lists are the same\n    if len(list1) == len(list2) == len(list3):\n        # Initialize an empty list for the result\n        interleaved = []\n        # Loop through elements\n        for i in range(len(list1)):\n            # Append elements in interleaved manner\n            interleaved.append(list1[i])\n            interleaved.append(list2[i])\n            interleaved.append(list3[i])\n        return interleaved\n    else:\n        raise ValueError(\"Lists must be of the same length.\")", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    if len(lst1) != len(lst2) or len(lst1) != len(lst3):\n        raise ValueError(\"All lists must be of the same length.\")\n    return [val for pair in zip(lst1, lst2, lst3) for val in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    if len(list1) == len(list2) == len(list3):\n        return [value for sublist in zip(list1, list2, list3) for value in sublist]\n    else:\n        raise ValueError(\"All lists must have the same length.\")", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if lists have the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        return \"Error: The lists are not of the same length.\"\n    # Initialize an empty list to hold the result\n    result = []\n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list to the result list in order\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 44.0, "profiled": [{"solution": "def split_Arr(input_list, n):\n    # Check if n is greater than the length of the list\n    if n > len(input_list):\n        return \"Error: n is greater than the length of the list.\"\n    else:\n        # Split the list at nth element and add the first part to the end\n        return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    first_part = arr[n:]\n    second_part = arr[:n]\n    return first_part + second_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    # Add the first part to the end of the second part\n    result = second_part + first_part\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    This function takes a list and an integer n as inputs.\n    It splits the list at the nth element and adds the first part to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Splitting the list\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # Adding the first part to the end\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Slice the array at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    # Add the first part to the end\n    result = second_part + first_part\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into first part and second part\n    first_part = arr[n:]\n    second_part = arr[:n]\n\n    # Add the first part to the end of the list\n    result = first_part + second_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # split the list into first part and second part\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # add first part to the end of second part\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_arr, n):\n    # Split the input list at the nth element\n    first_part = input_arr[n:]\n    second_part = input_arr[:n]\n    # Add the first part to the end\n    result = first_part + second_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    # Check if n is out of range\n    if n < 0 or n > len(input_list):\n        raise ValueError(\"n is out of range\")\n    # Split the list and add the first part to the end\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    first_part = arr[:n]\n    second_part = arr[n:]\n    second_part.extend(first_part)\n    return second_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    first_part = arr[:n]\n    second_part = arr[n:]\n    second_part.extend(first_part)\n    return second_part", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 47.2972972972973, "dps_norm": 85.0, "pass@1": 37.0, "profiled": [{"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Function to convert a list to a tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list):\n    return tuple(list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    This function takes a list as input and returns a tuple that contains the same elements\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    A function that takes a list as input and converts it into a tuple.\n    :param lst: Input list.\n    :return: A tuple converted from the input list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    A function that takes a list as input and returns a tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(lst):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    :param lst: a list of numerical values\n    :return: the difference between the largest and smallest value in the list\n    \"\"\"\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Arguments:\n    nums: A list of integers.\n\n    Returns:\n    An integer which is the difference between the maximum and minimum value in the list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculates the difference between the largest and smallest number in a given list.\n\n    Parameters:\n    nums (list of int): The list of numbers.\n\n    Returns:\n    int: The difference between the largest and smallest number.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    # Check if the list is not empty\n    if len(lst) > 0:\n        # Return the difference between the maximum and minimum values in the list\n        return max(lst) - min(lst)\n    else:\n        # Return None if the list is empty\n        return None", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    This function calculates the difference between the largest and smallest value in a given list.\n\n    :param lst: a list of numbers\n    :return: the difference between the largest and smallest value in the list\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Check if the list is empty, return 0 in such a case\n    if len(nums) == 0:\n        return 0\n    else:\n        # Calculate the difference between the maximum and minimum values in the list\n        return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return None\n    else:\n        return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns the difference\n    between the largest and smallest number in the list.\n    \"\"\"\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(num_list):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \"\"\"\n    return max(num_list) - min(num_list)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    # Function to find the difference between largest and smallest value in a given list\n    if not lst:\n        return None\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(num_list):\n    if len(num_list) > 0:\n        return max(num_list) - min(num_list)\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"Calculate the difference between the largest and smallest values in a given list.\"\"\"\n    if not lst:\n        raise ValueError(\"The input list is empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 75.93333333333334, "dps_norm": 57.5, "pass@1": 37.0, "profiled": [{"solution": "from math import comb\ndef sum_Of_product(n):\n    # calculate the sum of the product of consecutive binomial coefficients\n    return sum(comb(n, k) * comb(n, k + 1) for k in range(n))", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    total = 0\n    for r in range(n):\n        total += math.comb(n, r) * math.comb(n, r + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "def factorial(n):\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\ndef sum_Of_product(n):\n    sum_product = 0\n    for r in range(n):\n        term = factorial(n) // (factorial(r) * factorial(n - r))\n        next_term = factorial(n) // (factorial(r + 1) * factorial(n - r - 1))\n        sum_product += term * next_term\n    return sum_product", "matching_cluster_idx": -1}, {"solution": "def sum_Of_product(n):\n    # creating a list of binomial coefficients\n    binomial_coeff = [1]\n    for k in range(1, n+1):\n        next_coeff = binomial_coeff[k-1] * (n - k + 1) // k\n        binomial_coeff.append(next_coeff)\n    # calculating the sum of the product of consecutive binomial coefficients\n    sum_of_prod = sum(binomial_coeff[i]*binomial_coeff[i+1] for i in range(n))\n    return sum_of_prod", "matching_cluster_idx": 8}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    return sum(comb(n, i)*comb(n, i+1) for i in range(n))", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    # Calculate binomial coefficients\n    binomial_coeffs = [1]\n    for i in range(n):\n        binomial_coeffs = [1] + [binomial_coeffs[j-1] + binomial_coeffs[j] for j in range(1, len(binomial_coeffs))] + [1]\n    # Calculate sum of the product of consecutive binomial coefficients\n    sum_product = sum(binomial_coeffs[i] * binomial_coeffs[i+1] for i in range(len(binomial_coeffs) - 1))\n    return sum_product", "matching_cluster_idx": 7}, {"solution": "import math\ndef sum_Of_product(n):\n    # Initialize sum variable\n    sum_val = 0\n\n    # Loop through the range of numbers up to n\n    for i in range(n):\n        # Calculate the product of consecutive binomial coefficients\n        product = math.comb(n, i) * math.comb(n, i + 1)\n\n        # Add the product to sum_val\n        sum_val += product\n\n    return sum_val", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    # calculating sum of product of consecutive binomial coefficients\n    sum = 0\n    for i in range(n):\n        sum += math.comb(n, i) * math.comb(n, i + 1)\n    return sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    def binomial_coeff(n, k):\n        # Function to calculate binomial coefficient\n        res = 1\n        if (k > n - k):\n            k = n - k\n        for i in range(0 , k):\n            res = res * (n - i)\n            res = res // (i + 1)\n        return res\n    # Calculate sum of products\n    sum_prod = 0\n    for k in range(1, n + 1):\n        sum_prod += binomial_coeff(n, k) * binomial_coeff(n, k - 1)\n    return sum_prod", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    # function to calculate binomial coefficient\n    def binomial_coeff(n, k):\n        res = 1\n        if (k > n - k):\n            k = n - k\n        for i in range(0, k):\n            res = res * (n - i)\n            res = res // (i + 1)\n        return res\n\n    # function to calculate sum of product of consecutive binomial co-efficients\n    def sum_product_coeff(n):\n        sum = 0\n        for k in range(n):\n            sum += binomial_coeff(n, k) * binomial_coeff(n, k + 1)\n        return sum\n\n    return sum_product_coeff(n)", "matching_cluster_idx": 4}, {"solution": "def binomial_coef(n, k):\n    \"\"\"Calculate binomial coefficient\"\"\"\n    if k > n - k:\n        k = n - k\n    x = 1\n    for i in range(k):\n        x = x * (n - i)\n        x = x // (i + 1)\n    return x\ndef sum_Of_product(n):\n    \"\"\"Calculate sum of the product of consecutive binomial coefficients\"\"\"\n    return sum(binomial_coef(n, k) * binomial_coef(n, k + 1) for k in range(n))", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    coef = [1]\n    for i in range(n):\n        coef = [1] + [coef[j] + coef[j+1] for j in range(len(coef)-1)] + [1]\n    return sum(coef[i]*coef[i+1] for i in range(n))", "matching_cluster_idx": 7}, {"solution": "import math\ndef sum_Of_product(n):\n    # Initialize sum\n    sum_result = 0\n\n    # Calculate sum of products\n    for k in range(n):\n        sum_result += math.comb(n, k) * math.comb(n, k + 1)\n\n    return sum_result", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    This function computes the sum of the product of consecutive binomial coefficients.\n\n    :param n: int\n    :return: int\n    \"\"\"\n    return sum(comb(n, i) * comb(n, i + 1) for i in range(n))", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    return sum(math.comb(n, i) * math.comb(n, i - 1) for i in range(1, n + 1))", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"Finds the sum of the product of consecutive binomial coefficients.\"\"\"\n    # Calculate binomial coefficients\n    C = [1]\n    for i in range(1, n+1):\n        temp = [1]\n        for j in range(1, i):\n            temp.append(C[j-1] + C[j])\n        temp.append(1)\n        C = temp\n\n    # Calculate sum of products\n    total = 0\n    for i in range(1, n+1):\n        total += C[i-1] * C[i]\n\n    return total", "matching_cluster_idx": 6}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total = 0\n    for k in range(n+1):\n        total += comb(n, k) * comb(n, k+1)\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    return sum(math.comb(n, i) * math.comb(n, i+1) for i in range(n))", "matching_cluster_idx": 5}, {"solution": "from math import factorial\ndef binomial_coefficient(n, k):\n    \"\"\"\n    Calculate binomial coefficient using factorials\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients\n    \"\"\"\n    return sum(binomial_coefficient(n, k) * binomial_coefficient(n, k+1) for k in range(n))", "matching_cluster_idx": 1}, {"solution": "import math\ndef sum_Of_product(n):\n    return sum(math.comb(n, i) * math.comb(n, i+1) for i in range(n))", "matching_cluster_idx": 5}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/604": {"dps": 94.97607655502392, "dps_norm": 98.94736842105263, "pass@1": 19.0, "profiled": [{"solution": "def reverse_words(s):\n    # split the string into a list of words\n    words = s.split()\n    # reverse the list of words\n    reversed_words = words[::-1]\n    # join the reversed words back into a string, separated by spaces\n    reversed_string = ' '.join(reversed_words)\n    # return the resulting string\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Function to reverse words separated by spaces in a given string.\n\n    :param s: A string containing words separated by spaces.\n    :return: A string with the words in reverse order, separated by spaces.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n\n    # Reverse the list of words\n    reversed_words = words[::-1]\n\n    # Join the list of words back into a string, separated by spaces\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    return ' '.join(input_str.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    # Split the string into words\n    words = input_string.split()\n    # Reverse the order of words\n    reversed_words = words[::-1]\n    # Join the words back into a string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    return ' '.join(string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Function to reverse words separated by spaces in a given string.\n\n    Args:\n    s (str): Input string\n\n    Returns:\n    str: String with reversed words\n    \"\"\"\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    return ' '.join(string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    # Split the string into words\n    words = string.split()\n\n    # Reverse the order of the words\n    reversed_words = words[::-1]\n\n    # Join the reversed words back into a string with space as separator\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    return ' '.join(input_string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # split the string into a list of words\n    words = s.split()\n    # reverse the list of words\n    reversed_words = words[::-1]\n    # join the words back into a string, with a space in between each word\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # split the string by spaces, then reverse the list, and then join the elements back with spaces\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    # Split the string into a list of words\n    words = string.split()\n    # Reverse the list\n    reversed_words = words[::-1]\n    # Join the list back into a string\n    reversed_string = ' '.join(reversed_words)\n    # Return the reversed string\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # splits the string into words using space as a separator and returns the list of words in reverse order\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    \"\"\"\n    Function to reverse words separated by spaces in a given string.\n\n    Parameters:\n    string (str): The input string to reverse.\n\n    Returns:\n    str: The reversed string.\n    \"\"\"\n    # Split the string into words and reverse the list\n    words = string.split()\n    reversed_words = words[::-1]\n\n    # Join the words back into a string and return the result\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Function to reverse words separated by spaces in a given string.\n    \"\"\"\n    words = s.split()\n    return \" \".join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    \"\"\"\n    A function to reverse words separated by spaces in a given string.\n    \"\"\"\n    return ' '.join(reversed(string.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(string):\n    # split the string into a list of words\n    words = string.split()\n    # reverse the order of words in the list\n    words = words[::-1]\n    # join the words back into a string, separated by spaces\n    reversed_string = ' '.join(words)\n    # return the reversed string\n    return reversed_string", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 83.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Function to return the maximum value in the n'th column of the given matrix.\n\n    :param matrix: A 2D list/matrix.\n    :param n: Index of the column.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists,\n    this function returns the maximum value of the n'th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # get n'th column\n    column = [row[n] for row in matrix]\n    # return max of the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the max value in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Given a matrix and column index, return maximum value in the specified column.\"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Get n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Return the max value in the n'th column of a matrix.\"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column\n    nth_column = [row[n] for row in matrix]\n    # Return the maximum value in the n-th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n\n    # Return the maximum value in the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Get the n'th column from the matrix\n    col = [row[n] for row in matrix]\n    # Return the maximum value in the column\n    return max(col)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/632": {"dps": 90.56285178236398, "dps_norm": 97.14285714285714, "pass@1": 91.0, "profiled": [{"solution": "def move_zero(num_list):\n    non_zero_list = [num for num in num_list if num != 0]\n    zero_list = [num for num in num_list if num == 0]\n    return non_zero_list + zero_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # list comprehension to exclude zeroes and join the result with all zeroes at the end.\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Function to move all zeroes to the end of the given list\n    \"\"\"\n    # Initialize an empty list to hold non-zero elements\n    new_lst = []\n    # Count number of zeros\n    count_zero = 0\n\n    # Iterate over the input list\n    for i in lst:\n        # If element is non-zero, append to new list\n        if i != 0:\n            new_lst.append(i)\n        # If element is zero, increment count\n        else:\n            count_zero += 1\n\n    # Append count of zeros to new list\n    new_lst.extend([0] * count_zero)\n\n    # Return new list\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Function to move all zeroes to the end of the given list.\n\n    Args:\n        nums (List[int]): The input list.\n\n    Returns:\n        List[int]: The modified list with all zeroes at the end.\n    \"\"\"\n    # Use list comprehension to separate zeros and non-zeros\n    non_zeros = [num for num in nums if num != 0]\n    zeros = [num for num in nums if num == 0]\n\n    # Combine non-zeros list with zeros list\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Separate list into zero and non-zero elements\n    zero_list = [num for num in num_list if num == 0]\n    non_zero_list = [num for num in num_list if num != 0]\n\n    # Concatenate the non-zero list with the zero list to achieve the desired output\n    return non_zero_list + zero_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # iterate over the list in reverse\n    for i in range(len(nums) - 1, -1, -1):\n        # if the current element is zero\n        if nums[i] == 0:\n            # remove it from the list\n            nums.pop(i)\n            # append it to the end of the list\n            nums.append(0)\n    return nums", "matching_cluster_idx": 4}, {"solution": "def move_zero(lst):\n    \"\"\"\n    This function moves all zeroes to the end of the given list.\n    \"\"\"\n    # Get all non-zero elements\n    non_zero_elements = [i for i in lst if i != 0]\n\n    # Count the number of zeroes\n    zero_count = len(lst) - len(non_zero_elements)\n\n    # Add zeroes at the end of the list\n    non_zero_elements.extend([0] * zero_count)\n\n    return non_zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    \"\"\"\n    This function takes a list of numbers as input, moves all zeroes to the end of the list,\n    and returns the modified list.\n    \"\"\"\n    # Filter out all non-zero elements\n    non_zero_elements = [x for x in num_list if x != 0]\n    # Count the number of zero elements\n    zero_count = len(num_list) - len(non_zero_elements)\n    # Extend non-zero elements with zero elements\n    non_zero_elements.extend([0] * zero_count)\n    return non_zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Separate zero and non-zero elements\n    zero_list = [num for num in num_list if num == 0]\n    non_zero_list = [num for num in num_list if num != 0]\n\n    # Combine the lists\n    return non_zero_list + zero_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # initialize a list to store the non-zero elements\n    non_zero = []\n    # initialize a list to store the zero elements\n    zero = []\n\n    # loop over the input list\n    for num in nums:\n        if num != 0:\n            # if the number is not zero, append it to the non_zero list\n            non_zero.append(num)\n        else:\n            # if the number is zero, append it to the zero list\n            zero.append(num)\n\n    # return the concatenated list of non-zero elements and zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate zeros and non-zeros into two lists\n    non_zeros = [i for i in lst if i != 0]\n    zeros = [i for i in lst if i == 0]\n    # Combine the two lists\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Function to move all zeroes to the end of the given list.\n    \"\"\"\n    # We create a copy of the given list but without zeroes\n    non_zeros = [num for num in nums if num != 0]\n    # We add zeroes to the end of this list\n    non_zeros.extend([0] * (len(nums) - len(non_zeros)))\n    return non_zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    # Initialize two empty lists to store non-zero and zero values.\n    non_zero = []\n    zero = []\n\n    # Iterate over the input list.\n    for i in input_list:\n        # If the value is zero, append it to the zero list.\n        if i == 0:\n            zero.append(i)\n        # Otherwise, append it to the non_zero list.\n        else:\n            non_zero.append(i)\n\n    # Return a new list which is a concatenation of non_zero and zero lists.\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    \"\"\"\n    This function takes a list of numbers as an input and moves all zeroes to the end of the list.\n    It works by iterating through the list, and whenever it encounters a zero, it removes the zero from the list\n    and adds it to the end. It continues this process until it has checked every element in the list.\n    \"\"\"\n    # iterate over the list in reverse order so that removing elements doesn't affect the iteration\n    for i in range(len(num_list)-1, -1, -1):\n        # if the element is zero, remove it and append it to the end of the list\n        if num_list[i] == 0:\n            num_list.append(num_list.pop(i))\n    return num_list", "matching_cluster_idx": 4}, {"solution": "def move_zero(num_list):\n    # create a new list to hold all non-zero elements\n    result = [num for num in num_list if num != 0]\n\n    # append all zeros at the end of the list\n    result.extend([0] * num_list.count(0))\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize an empty list to store non-zero elements\n    non_zero = []\n    # Iterate through the input list\n    for num in nums:\n        # If the number is non-zero, append it to the non_zero list\n        if num != 0:\n            non_zero.append(num)\n    # Append all zero elements to the end of the non_zero list\n    return non_zero + [0] * (len(nums) - len(non_zero))", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zeros = [i for i in lst if i != 0]\n    zeros = [i for i in lst if i == 0]\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Create two lists to hold non-zero and zero elements\n    non_zero_elements = [i for i in num_list if i != 0]\n    zero_elements = [i for i in num_list if i == 0]\n\n    # Combine the two lists and return\n    return non_zero_elements + zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Separate list into two lists, one with zeros and one without\n    zeros = [num for num in num_list if num == 0]\n    non_zeros = [num for num in num_list if num != 0]\n    # Concatenate the non-zeros list with the zeros list and return\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    non_zero = [num for num in num_list if num != 0]\n    zero = [num for num in num_list if num == 0]\n    return non_zero + zero", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/644": {"dps": 90.90425531914892, "dps_norm": 89.66666666666666, "pass@1": 74.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse upto a given position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[k-1::-1]\n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array upto the given position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements in array from 0 to k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k < 0 or k > len(arr):\n        raise ValueError('k is out of bounds')\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Function to reverse an array upto a given position.\n    Args:\n    arr: A list of elements.\n    k: An integer specifying the position up to which the array is to be reversed.\n    Returns:\n    A list with elements reversed upto the given position.\n    \"\"\"\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array upto the given position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(array, k):\n    # Reverse the elements from start of the array to the given position k\n    array[:k] = array[k-1::-1]\n    return array", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        return \"k is larger than the length of the array.\"\n    elif k <= 0:\n        return \"k is less than or equal to 0.\"\n    else:\n        arr[:k] = arr[k-1::-1]\n        return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(array, k):\n    # Check if k is within array bounds\n    if k < 0 or k > len(array):\n        return \"Invalid value of k\"\n    else:\n        # Reverse the array up to position k\n        return array[k-1::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    This function reverses the array upto the given position k.\n\n    Args:\n    arr : list of integers\n        The input array.\n    k : integer\n        The position upto which the array should be reversed.\n\n    Returns:\n    list of integers\n        The reversed array upto position k.\n    \"\"\"\n\n    # Reversing the array upto position k\n    arr[:k] = arr[k-1::-1]\n\n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Check if k is within bounds of the array\n    if k > len(arr) or k < 0:\n        return \"k is out of bounds\"\n\n    # Reverse elements upto position k\n    arr[:k] = arr[:k][::-1]\n\n    return arr", "matching_cluster_idx": 13}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    This function adds a dictionary to the end of a tuple.\n    The input is a tuple and a dictionary.\n    The output is a tuple with the dictionary added to the end.\n    \"\"\"\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Adding dictionary to the tuple\n    output_tuple = input_tuple + (input_dict,)\n    return output_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict):\n    return tup + (dict, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    # The function takes a tuple 't' and a dictionary 'd' as inputs, adds the dictionary to the tuple and returns the new tuple\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Function to add a dictionary to the end of a tuple.\n    The output is a tuple with the elements of the input tuple and the input dictionary in this order.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict):\n    return tup + (dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Function to add a dictionary to the tuple. The output should be a tuple.\n\n    Args:\n    input_tuple (tuple): The input tuple.\n    input_dict (dict): The input dictionary.\n\n    Returns:\n    tuple: The tuple with added dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictn):\n    return tup + (dictn,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Combine the tuple and the dictionary into a new tuple\n    output_tuple = input_tuple + (input_dict,)\n    return output_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    This function adds a dictionary to a tuple.\n\n    Args:\n    tup (tuple): The tuple to which the dictionary is to be added.\n    dic (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The tuple with the dictionary added to it.\n    \"\"\"\n    # Create a new tuple with the elements of the original tuple and the dictionary\n    new_tup = tup + (dic,)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict_add):\n    return tup + (dict_add, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    This function takes in a tuple and a dictionary, then appends the dictionary to the tuple.\n    The function returns a new tuple with the original elements followed by the dictionary.\n\n    Inputs:\n    input_tuple: tuple - The original tuple to be appended with dictionary\n    input_dict: dict - The dictionary to be appended to the tuple\n\n    Output:\n    tuple - A new tuple with the elements from the original tuple followed by the dictionary\n    \"\"\"\n    # Add the dictionary to the tuple\n    output_tuple = input_tuple + (input_dict,)\n    return output_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Function to add a dictionary to a tuple.\n    \"\"\"\n    # The '+' operator is used to concatenate the tuple with a single-item tuple containing the dictionary.\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Function to add a dictionary to the tuple.\n    :param input_tuple: The original tuple\n    :param input_dict: The dictionary to be added\n    :return: The resulting tuple\n    \"\"\"\n    return input_tuple + (input_dict, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 73.22404371584699, "dps_norm": 75.0, "pass@1": 85.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Function to extract values between quotation marks \" \" of the given string.\n\n    Args:\n        input_string (str): A string that contains values between quotation marks.\n\n    Returns:\n        A list of extracted values between quotation marks.\n\n    \"\"\"\n    return re.findall('\"([^\"]*)\"', input_string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall('\"([^\"]*)\"', string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    # Initialize empty list to store the extracted values\n    values = []\n    # Initialize start index as the index of the first quotation mark\n    start = s.find('\"')\n    # Loop until there are no more quotation marks left in the string\n    while start != -1:\n        # Find the index of the next quotation mark\n        end = s.find('\"', start + 1)\n        # If there is no next quotation mark, break the loop\n        if end == -1:\n            break\n        # Add the value between the current and next quotation marks to the list\n        values.append(s[start + 1:end])\n        # Update start index to the index after the next quotation mark\n        start = s.find('\"', end + 1)\n    # Return the list of extracted values\n    return values", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall('\"([^\"]*)\"', string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall('\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 93.17829457364341, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    This function replaces all spaces, commas, and dots in the input string with a colon.\n    :param input_string: str - the string to process\n    :return: str - the processed string\n    \"\"\"\n    # create a translation table\n    trans = str.maketrans(' ,.', ':::')\n    # use the translation table to replace characters\n    return input_string.translate(trans)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(string):\n    string = string.replace(' ', ':')\n    string = string.replace(',', ':')\n    string = string.replace('.', ':')\n    return string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    This function takes a string input and replaces all spaces, commas, and dots with a colon.\n    \"\"\"\n    # Replace spaces\n    input_string = input_string.replace(\" \", \":\")\n    # Replace commas\n    input_string = input_string.replace(\",\", \":\")\n    # Replace dots\n    input_string = input_string.replace(\".\", \":\")\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    input_string = input_string.replace(' ', ':')\n    input_string = input_string.replace(',', ':')\n    input_string = input_string.replace('.', ':')\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Using the translate() function and str.maketrans() to replace spaces, commas, and dots with a colon\n    return input_string.translate(str.maketrans(' ,.', ':::'))", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(string):\n    return string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    \"\"\"\n    This function takes an input string and replaces all occurrences of spaces, commas,\n    or dots with a colon.\n    \"\"\"\n    return input_str.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    string (str): The input string.\n\n    Returns:\n    str: The output string with replaced special characters.\n    \"\"\"\n    for char in [',', '.', ' ']:\n        if char in string:\n            string = string.replace(char, ':')\n    return string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Use the replace() function three times to replace each special character with a colon\n    text = text.replace(' ', ':')\n    text = text.replace(',', ':')\n    text = text.replace('.', ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    # replace spaces with colons\n    string = string.replace(' ', ':')\n    # replace commas with colons\n    string = string.replace(',', ':')\n    # replace dots with colons\n    string = string.replace('.', ':')\n    return string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    # Replace spaces, commas, or dots with a colon\n    output_str = input_str.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return output_str", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    # Replacing special characters with colon\n    input_str = input_str.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return input_str", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replacing spaces, commas, and dots with colon\n    output_string = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return output_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    output_string = input_string.replace(' ', ':')\n    output_string = output_string.replace(',', ':')\n    output_string = output_string.replace('.', ':')\n    return output_string", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 66.45454545454545, "dps_norm": 61.111111111111114, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Input tuple should have an even number of elements.\")\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    # Check if the length of tuple is even\n    if len(t) % 2 != 0:\n        raise ValueError(\"The length of the tuple must be even.\")\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2) if i + 1 < len(tup)}", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2) if i + 1 < len(tup)}", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2) if i + 1 < len(tup)}", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(t):\n    # An empty dictionary to store the result\n    result = {}\n    # Iterate over the tuple two elements at a time\n    for i in range(0, len(t), 2):\n        # Add each pair of elements to the dictionary\n        result[t[i]] = t[i + 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The length of the tuple must be even.\")\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Create an empty dictionary\n    d = {}\n    # Traverse the tuple in steps of 2\n    for i in range(0, len(tup), 2):\n        # If index+1 is within the tuple range, add pair to dictionary\n        if i+1 < len(tup):\n            d[tup[i]] = tup[i+1]\n    return d", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    This function takes a tuple as input and converts it to a dictionary where keys are\n    elements of the tuple at even indices and values are elements at odd indices.\n    \"\"\"\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    :param t: tuple of elements\n    :return: dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Function to convert a tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    # Initialize an empty dictionary\n    result_dict = {}\n\n    # Iterate over the tuple with a step size of 2\n    for i in range(0, len(input_tuple), 2):\n        # Use slicing to get the key and value, add them to the dictionary\n        result_dict[input_tuple[i]] = input_tuple[i+1]\n\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tuple_input):\n    # Initialize an empty dictionary\n    dict_output = {}\n\n    # Iterate over every other element in the tuple\n    for i in range(0, len(tuple_input), 2):\n        # Add each pair of elements as a key-value pair in the dictionary\n        dict_output[tuple_input[i]] = tuple_input[i + 1]\n\n    return dict_output", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tuple_val):\n    return {tuple_val[i]: tuple_val[i + 1] for i in range(0, len(tuple_val), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2) if i + 1 < len(t)}", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 96.4041095890411, "dps_norm": 97.5, "pass@1": 100.0, "profiled": [{"solution": "def check_none(t):\n    if None in t:\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    This function takes a tuple as input and returns True if the tuple contains None, otherwise it returns False.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_value):\n    return None in tuple_value", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    This function checks if a given tuple has any None value or not.\n\n    Arguments:\n    t -- the tuple to be checked\n\n    Returns:\n    True if the tuple contains at least one None value, False otherwise\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    # Checking if None is in the tuple\n    if None in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"Check if the given tuple has any None value.\"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    This function checks if the given tuple has any none value or not.\n    \"\"\"\n    if None in t:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    if None in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    for val in input_tuple:\n        if val is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(tup):\n    if None in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    # check if any value in the tuple is None\n    if None in input_tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_val):\n    \"\"\"\n    This function checks if a given tuple contains any None value.\n    It returns True if any None value is found, False otherwise.\n    \"\"\"\n    for val in tuple_val:\n        if val is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    This function takes a tuple as an argument and returns True if it contains\n    any None value, otherwise returns False\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 60.74829931972789, "dps_norm": 62.5, "pass@1": 97.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    # iterate over each item in tuple\n    for item in tup:\n        # add each item to the list\n        lst.append(item)\n    # return the updated list\n    return lst", "matching_cluster_idx": 0}, {"solution": "def add_tuple(lst, tpl):\n    # convert tuple to list\n    lst_tpl = list(tpl)\n    # extend list with the new elements from tuple\n    lst.extend(lst_tpl)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_obj, tuple_obj):\n    \"\"\"\n    This function takes a list and a tuple as arguments.\n    It then appends each element of the tuple to the end of the list.\n    \"\"\"\n    list_obj.extend(tuple_obj)\n    return list_obj", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Convert the tuple to a list\n    tpl_as_list = list(tpl)\n    # Extend the list with the elements from the tuple\n    lst.extend(tpl_as_list)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(list_, tuple_):\n    list_.extend(tuple_)\n    return list_", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"\n    Function to add a given tuple to a given list.\n    \"\"\"\n    # Convert the tuple to list and extend the list with the tuple list\n    list1.extend(list(tuple1))\n    return list1", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"Add a tuple to a list\"\"\"\n    for element in tpl:\n        lst.append(element)\n    return lst", "matching_cluster_idx": 0}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    This function takes a list and a tuple as inputs, then appends the elements of the tuple to the list.\n\n    Parameters:\n    lst (list): The list to which the elements of the tuple will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The input list, modified to include the elements of the input tuple.\n    \"\"\"\n    # Add the tuple to the list\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Function to add the given tuple to the given list.\n\n    Parameters:\n    lst (list): the given list\n    tup (tuple): the given tuple\n\n    Returns:\n    list: the given list with the contents of the given tuple appended\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    This function takes a list and a tuple as arguments,\n    appends all elements of the tuple to the list, and returns the new list.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    # Converting tuple to list\n    tpl = list(tpl)\n    # Adding tuple to list\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    for i in tup:\n        lst.append(i)\n    return lst", "matching_cluster_idx": 0}, {"solution": "def add_tuple(lst, tup):\n    # Add each element of the tuple to the list\n    for elem in tup:\n        lst.append(elem)\n    # Return the modified list\n    return lst", "matching_cluster_idx": 0}, {"solution": "def add_tuple(list, tuple):\n    \"\"\"\n    This function takes a list and a tuple as arguments.\n    It adds all elements of the tuple to the end of the list.\n    :param list: A list of elements\n    :param tuple: A tuple of elements\n    :return: The list with all elements of the tuple added at the end\n    \"\"\"\n    list.extend(tuple)\n    return list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def min_k(records, k):\n    \"\"\"\n    Function to find minimum k records from tuple list.\n\n    Parameters:\n    records (list): A list of tuples where each tuple contains a string and an integer\n    k (int): Number of minimum records to return\n\n    Returns:\n    list: A list of tuples containing the k records with minimum integers\n    \"\"\"\n    # Sort the list of tuples based on the integer element\n    records.sort(key=lambda x: x[1])\n    # Return the first k elements\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    return sorted(tuples_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # sort the records based on their scores\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # sort the records based on the second element of each tuple\n    records.sort(key=lambda x: x[1])\n    # return the first k records\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key = lambda x: x[1])\n\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # sort the list of tuples\n    tuples_list.sort(key=lambda x: x[1])\n    # return the first k tuples\n    return tuples_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records list in ascending order based on the second element of the tuple.\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records.\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # sort the tuple list based on second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # return first k tuples from sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # sort the list based on the second element of the tuple\n    records.sort(key=lambda x: x[1])\n    # return the first k records\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sorts the list based on second element of tuple in ascending order\n    sorted_list = sorted(tuples_list, key = lambda x: x[1])\n\n    # Returns first k records\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list based on the second element of each tuple\n    records.sort(key = lambda x: x[1])\n    # Return the first k elements\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    tuples.sort(key=lambda x: x[1])\n    return tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the tuple list based on second element of tuple in ascending order\n    records.sort(key=lambda x: x[1])\n    # Return the first k records\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    sorted_records = sorted(records, key=lambda record: record[1])\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    tuples.sort(key=lambda x: x[1])\n    return tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n\n    # Return the first k tuples from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Function to find minimum k records from tuple list.\n    \"\"\"\n    # Sort the tuple list\n    records.sort(key=lambda x: x[1])\n    # Return the first k records\n    return records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    # sorting the tuple list based on the second element of the tuple\n    sorted_lst = sorted(lst, key=lambda x: x[1])\n\n    # returning the first k records\n    return sorted_lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    records.sort(key=lambda x: x[1])\n    return records[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 92.24137931034483, "dps_norm": 93.05555555555556, "pass@1": 18.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    # Loop through the indexes of the lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # If the element appears in all three lists under the same index, append it to the common_elements list\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Zip three lists into one list of tuples\n    zipped = list(zip(l1, l2, l3))\n\n    # Use list comprehension to find elements that are common at the same index in three lists\n    common = [item[0] for item in zipped if item[0] == item[1] == item[2]]\n\n    return common", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [i for i, j, k in zip(l1, l2, l3) if i == j == k]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [i for i, j, k in zip(l1, l2, l3) if i == j == k]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [i for i, j, k in zip(l1, l2, l3) if i == j == k]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialise an empty list to hold the common elements\n    common_elements = []\n    # Use zip to iterate over all three lists simultaneously\n    for a, b, c in zip(l1, l2, l3):\n        # If an element is common, add it to the list\n        if a == b == c:\n            common_elements.append(a)\n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # zip returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables\n    # tuple unpacking is then used to iterate through each triplet of elements from the three lists\n    common_elements = [i for i, j, k in zip(l1, l2, l3) if i == j == k]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [i for i, j, k in zip(l1, l2, l3) if i == j == k]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [i for i, j, k in zip(l1, l2, l3) if i == j == k]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Using list comprehension, find the common elements\n    # which are present in all three lists at same indices\n    common_elements = [i for i, j, k in zip(l1, l2, l3) if i == j == k]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Get the length of the shortest list\n    min_len = min(len(l1), len(l2), len(l3))\n    # Use list comprehension to create a list of elements common to all three lists\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize empty list to store common elements\n    common = []\n    # Iterate over lists simultaneously using zip function\n    for a, b, c in zip(l1, l2, l3):\n        # Check if elements at same index are common in all lists\n        if a == b == c:\n            common.append(a)\n    # Return list of common elements\n    return common", "matching_cluster_idx": 7}]}, "Mbpp/755": {"dps": 87.7433628318584, "dps_norm": 94.16666666666667, "pass@1": 26.0, "profiled": [{"solution": "def second_smallest(num_list):\n    \"\"\"\n    A function to find the second smallest number in a list.\n    \"\"\"\n    unique_list = list(set(num_list))\n    unique_list.sort()\n    return unique_list[1] if len(unique_list) >= 2 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    unique_numbers = sorted(set(numbers))\n    return unique_numbers[1] if len(unique_numbers) >= 2 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    \"\"\"\n    Function to find the second smallest number in a list.\n    \"\"\"\n    # If the list is empty or only contains one element, there is no second smallest number\n    if len(lst) < 2:\n        return None\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            # If a number is found that is smaller than the current smallest,\n            # shift the smallest and second smallest numbers down\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            # If a number is found that is smaller than the current second smallest\n            # and not equal to the smallest, update the second smallest\n            second_smallest = num\n\n    # If there is no second smallest number, return None\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 4}, {"solution": "def second_smallest(lst):\n    # Check if the list is long enough\n    if len(lst) < 2:\n        return None\n\n    # Initialize with positive infinity and the smallest number as the first element in the list\n    second_min, min_num = float('inf'), min(lst)\n\n    # Traverse the list\n    for num in lst:\n        if min_num < num < second_min:\n            second_min = num\n\n    # If no second smallest element\n    if second_min == float('inf'):\n        return None\n\n    return second_min", "matching_cluster_idx": 3}, {"solution": "def second_smallest(num_list):\n    num_set = set(num_list)\n    if len(num_set) < 2:\n        return None\n    num_list = list(num_set)\n    num_list.sort()\n    return num_list[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    unique_numbers = list(set(numbers))\n    unique_numbers.sort()\n    return unique_numbers[1] if len(unique_numbers) >= 2 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Check if list has at least 2 elements\n    if len(numbers) < 2:\n        return None\n\n    # Initialize smallest and second smallest as the first two numbers\n    smallest = second_smallest = float('inf')\n    for num in numbers:\n        if num < smallest:\n            # Update both smallest and second smallest\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            # Update second smallest\n            second_smallest = num\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Use set to remove duplicates and sort the list\n    numbers = sorted(set(numbers))\n\n    # Return the second smallest number\n    return numbers[1] if len(numbers) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    unique_lst = list(set(lst))\n    unique_lst.sort()\n    if len(unique_lst) < 2:\n        return None\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Removing duplicates from the list\n    unique_numbers = list(set(numbers))\n    # Sorting the list in ascending order\n    unique_numbers.sort()\n    # Returning the second smallest number\n    return unique_numbers[1] if len(unique_numbers) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set and then convert it back to a list\n    numbers = list(set(numbers))\n    # Sort the list in ascending order\n    numbers.sort()\n    # Return the second smallest number in the list\n    return numbers[1] if len(numbers) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # First, we remove duplicates from the list using set to get unique elements\n    unique_numbers = list(set(numbers))\n    # Then, we sort the unique elements in ascending order\n    unique_numbers.sort()\n    # After that, we check if the list has enough elements to find the second smallest\n    if len(unique_numbers) < 2:\n        return None\n    # Finally, we return the second element of the sorted list\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    unique_numbers = list(set(numbers))\n    unique_numbers.sort()\n    return unique_numbers[1] if len(unique_numbers) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Create a list of unique numbers sorted in ascending order.\n    unique_numbers = sorted(set(numbers))\n\n    # Check if there are at least 2 unique numbers.\n    if len(unique_numbers) < 2:\n        return None\n\n    # Return the second smallest number.\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    unique_numbers = sorted(set(numbers))\n    if len(unique_numbers) < 2:\n        return None\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Use a set to get unique numbers and sort them in ascending order\n    unique_numbers = sorted(set(numbers))\n    # If there are at least two unique numbers, return the second smallest\n    if len(unique_numbers) >= 2:\n        return unique_numbers[1]\n    # If there are less than two unique numbers, return None\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # handle invalid input\n    if len(numbers) < 2:\n        return None\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    # if there is no second smallest number\n    if second_smallest == float('inf'):\n        return None\n\n    return second_smallest", "matching_cluster_idx": 3}, {"solution": "def second_smallest(lst):\n    # Remove duplicates and sort the list\n    lst = sorted(set(lst))\n\n    # Check if the list has at least 2 elements\n    if len(lst) < 2:\n        return None\n\n    # Return the second smallest element\n    return lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    numbers = list(set(numbers))\n\n    # Sort the list in ascending order\n    numbers.sort()\n\n    # Check if the list contains at least two elements\n    if len(numbers) < 2:\n        return None\n\n    # Return the second element\n    return numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # remove duplicates and sort the list\n    unique_lst = sorted(list(set(lst)))\n\n    # check if the list has at least two elements\n    if len(unique_lst) < 2:\n        return None\n\n    # return the second element (which is the second smallest number)\n    return unique_lst[1]", "matching_cluster_idx": 5}]}, "Mbpp/757": {"dps": 82.71028037383178, "dps_norm": 23.076923076923077, "pass@1": 77.0, "profiled": [{"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(word_list):\n    # initialize the counter to 0\n    count = 0\n\n    # iterate over the list of words\n    for i in range(len(word_list)):\n        # for each word, iterate over the remaining list of words\n        for j in range(i + 1, len(word_list)):\n            # if the word is the reverse of the other word, increment the counter\n            if word_list[i] == word_list[j][::-1]:\n                count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    reverse_pairs_count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                reverse_pairs_count += 1\n    return reverse_pairs_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Function to count the pairs of reverse strings in the given string list.\n    \"\"\"\n    reverse_pairs = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                reverse_pairs += 1\n    return reverse_pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    count = 0\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if words[i] == words[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    # Initialize a counter to keep track of the pairs of reverse strings\n    count = 0\n    # Iterate through the string list\n    for i in range(len(strings)):\n        # Iterate through the string list again, starting from the next element\n        for j in range(i+1, len(strings)):\n            # If the reverse of the current string is equal to the next string, increment the counter\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    # Return the counter\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    # initialize the counter of reverse pairs\n    count = 0\n    # traverse the list\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            # if reversed pair is found increment the counter\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    # return the count\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:  # if a string equals to reversed of another one\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    This function takes a list of strings as input and returns the count of pairs of reverse strings in the list.\n    \"\"\"\n    pairs = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                pairs += 1\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    \"\"\"\n    Function to count the pairs of reverse strings in the given string list.\n    \"\"\"\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    \"\"\"Count the pairs of reverse strings in the given string list.\"\"\"\n\n    count = 0\n\n    # Traverse through the list\n    for i in range(len(str_list)):\n        # For each string, check with the rest of the list if its reverse is present\n        for j in range(i+1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                # If reverse is present, increment the count\n                count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 93.97683397683396, "dps_norm": 91.875, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    sublists_count = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublists_count:\n            sublists_count[sublist_tuple] += 1\n        else:\n            sublists_count[sublist_tuple] = 1\n    return sublists_count", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        t = tuple(sublist)\n        if t in counts:\n            counts[t] += 1\n        else:\n            counts[t] = 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    # create an empty dictionary to store results\n    counts = {}\n\n    # convert each sublist to a tuple and count occurrences\n    for sublist in lst:\n        # convert sublist to tuple\n        subtuple = tuple(sublist)\n\n        # update count for this subtuple\n        if subtuple in counts:\n            counts[subtuple] += 1\n        else:\n            counts[subtuple] = 1\n\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    counter = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in counter:\n            counter[tuple_sublist] += 1\n        else:\n            counter[tuple_sublist] = 1\n    return counter", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # create an empty dictionary\n    count_dict = {}\n    # iterate over the sublists in the input list\n    for sublist in lst:\n        # convert the sublist to a tuple\n        tuple_sublist = tuple(sublist)\n        # if the tuple is already a key in the dictionary, increment its value\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # otherwise, add the tuple as a new key with value 1\n        else:\n            count_dict[tuple_sublist] = 1\n    # return the resulting dictionary\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    counter = {}\n    for sublist in lst:\n        t = tuple(sublist)\n        if t in counter:\n            counter[t] += 1\n        else:\n            counter[t] = 1\n    return counter", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        t = tuple(sublist)\n        if t in counts:\n            counts[t] += 1\n        else:\n            counts[t] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # convert sublists to tuples\n    tuple_lst = [tuple(sublst) for sublst in lst]\n    # count occurrences of each tuple\n    counts = {}\n    for t in tuple_lst:\n        if t in counts:\n            counts[t] += 1\n        else:\n            counts[t] = 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary\n    sublist_counts = {}\n    # Loop through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist into a tuple and increase its count in the dictionary\n        sublist_tuple = tuple(sublist)\n        sublist_counts[sublist_tuple] = sublist_counts.get(sublist_tuple, 0) + 1\n    # Return the resulting dictionary\n    return sublist_counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        else:\n            counts[tuple_sublist] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_counts = {}\n    for sublist in lst:\n        t = tuple(sublist)\n        if t in sublist_counts:\n            sublist_counts[t] += 1\n        else:\n            sublist_counts[t] = 1\n    return sublist_counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        # Convert list to tuple\n        t = tuple(sublist)\n        if t in counts:\n            counts[t] += 1\n        else:\n            counts[t] = 1\n    return counts", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        tup = tuple(sublist)\n        if tup not in counts:\n            counts[tup] = 0\n        counts[tup] += 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # create an empty dictionary\n    result = {}\n    # iterate over each list in the given list\n    for sublist in lst:\n        # convert list to a tuple\n        tup = tuple(sublist)\n        # if tuple already exists in dictionary, increment its value\n        if tup in result:\n            result[tup] += 1\n        # else, initialize its value to 1\n        else:\n            result[tup] = 1\n    # return the resulting dictionary\n    return result", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    dict_count = {}\n    for sublist in lst:\n        tup = tuple(sublist)\n        if tup not in dict_count:\n            dict_count[tup] = 1\n        else:\n            dict_count[tup] += 1\n    return dict_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert lists to tuples\n    tpl_lst = [tuple(sublst) for sublst in lst]\n\n    # Count occurrences\n    count_dict = {}\n    for tpl in tpl_lst:\n        if tpl in count_dict:\n            count_dict[tpl] += 1\n        else:\n            count_dict[tpl] = 1\n    return count_dict", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple\n    tuple_lst = [tuple(sublist) for sublist in lst]\n    # Initialize an empty dictionary\n    count_dict = {}\n    # Iterate over each tuple in the list\n    for tup in tuple_lst:\n        # If the tuple is already in the dictionary, increment its count\n        if tup in count_dict:\n            count_dict[tup] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[tup] = 1\n    # Return the dictionary\n    return count_dict", "matching_cluster_idx": 7}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        else:\n            counts[tuple_sublist] = 1\n    return counts", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/764": {"dps": 89.38271604938271, "dps_norm": 50.833333333333336, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # initialize counter\n    count = 0\n    # iterate over each character in the string\n    for char in s:\n        # if the character is a digit, increment the counter\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_str):\n    count = 0\n    for char in input_str:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_str):\n    num_count = 0\n    for char in input_str:\n        if char.isdigit():\n            num_count += 1\n    return num_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    # Count number of digits in a given string\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    # Initialize a counter to 0\n    count = 0\n    # Iterate through each character in the input string\n    for char in input_string:\n        # If the character is a digit, increment the counter\n        if char.isdigit():\n            count += 1\n    # Return the final count of digits in the string\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    # Initialize a counter variable to 0\n    count = 0\n\n    # Iterate through each character in the string\n    for char in input_string:\n        # If the character is a digit, increment the counter\n        if char.isdigit():\n            count += 1\n\n    # Return the final count of digits in the string\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter to 0\n    count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # If the character is a digit, increment the counter\n        if char.isdigit():\n            count += 1\n    # Return the total count of digits\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    This function takes a string as input and returns the count of digits in it.\n\n    Parameters:\n    s (str): The input string\n\n    Returns:\n    int: The count of digits in the string\n    \"\"\"\n    # using list comprehension to get the digits from string\n    digits = [char for char in s if char.isdigit()]\n    return len(digits)", "matching_cluster_idx": 3}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Function to count number of digits in a given string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 71.54205607476635, "dps_norm": 60.833333333333336, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    if len(lst) < 2:\n        return []\n    else:\n        return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    return [(input_list[i], input_list[i + 1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    if len(lst) < 2:\n        return []\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    This function takes a list as an input and returns a list of all pairs of consecutive items in the input list.\n\n    Parameters:\n    lst (list): A list of elements of any type\n\n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items from the input list\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    if len(lst) < 2:\n        return []\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    pairs = [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    return pairs", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 88.63999999999999, "dps_norm": 65.71428571428572, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list in step of 2 starting from index 1\n    for i in range(1, len(lst), 2):\n        # Check if the value at the current index is odd\n        if lst[i] % 2 == 0:\n            # If the value is even return False\n            return False\n    # If all the odd indexed values are odd return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(i % 2 != 0 for i in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # iterate over list using index and value\n    for i, val in enumerate(lst):\n        # check if index is odd and corresponding value is even\n        if i % 2 != 0 and val % 2 == 0:\n            # if condition is True, then return False\n            return False\n    # if loop completes without returning False, then return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    # loop over every odd index\n    for i in range(1, len(lst), 2):\n        # if the element at the odd index is even, return False\n        if lst[i] % 2 == 0:\n            return False\n    # if all odd-indexed elements are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    This function checks if every odd index of a given list contains an odd number.\n    If the condition is fulfilled, it returns True; otherwise, it returns False.\n\n    Args:\n    lst: List of numbers\n\n    Returns:\n    A boolean value indicating the condition's satisfaction\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/781": {"dps": 85.55118110236221, "dps_norm": 73.0, "pass@1": 88.0, "profiled": [{"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i <= n:\n        if (n % i == 0):\n            count += 1\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": -1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function counts the number of divisors for a given integer n.\n    If the count of divisors is even, it returns True, else it returns False.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n        i += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    # Counting divisors of a number\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2\n    # If n is a perfect square, decrease count by 1\n    if int(n**0.5)**2 == n:\n        count -= 1\n    # Checking if count is even\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n//i else 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n/i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"Return True if the count of divisors is even, False otherwise.\"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function takes an integer n and returns True if the count of divisors is even, otherwise False.\n    \"\"\"\n    count = 0\n    # find all divisors up to sqrt(n)\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if i == n/i: # if the divisors are equal, count it only once\n                count += 1\n            else: # if the divisors are not equal, count them both\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n / i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(num):\n    divisors = [i for i in range(1, num + 1) if num % i == 0]\n    return len(divisors) % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, increment count by one\n            if n // i == i:\n                count += 1\n            # Otherwise increment count by two\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors is even.\n\n    Args:\n    n (int): Number to check\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else: # In this case, i and n//i are both divisors\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if i == (n / i):\n                count += 1\n            else: # Otherwise count both divisors\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if n // i != i else 1\n    return count % 2 == 0", "matching_cluster_idx": 3}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 91.0, "profiled": [{"solution": "def remove_all_spaces(input_str):\n    # Using the replace function to remove all occurrences of whitespace\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Function to remove all whitespaces from a string.\n    \"\"\"\n    # using the replace() method to replace whitespaces with no space.\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # The replace() method in Python replaces all occurrences of one specified phrase with another specified phrase.\n    # Here, we're replacing all spaces (' ') with an empty string (''):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    # replace all occurrences of a whitespace with empty string\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function removes all whitespaces from a given string.\n\n    Arguments:\n    input_string : str, The input string from which whitespaces are to be removed.\n\n    Returns:\n    str, The string after removing all whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def max_sum_list(lists):\n    # Initialize max_sum and result list\n    max_sum = float('-inf')\n    result = []\n\n    # Loop through each list in the input\n    for lst in lists:\n        # Calculate the sum of the list\n        lst_sum = sum(lst)\n        # If the sum is greater than the current max_sum, update max_sum and result\n        if lst_sum > max_sum:\n            max_sum = lst_sum\n            result = lst\n    # Return the result list\n    return result", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    max_sum = float('-inf')\n    max_list = []\n    for lst in lists:\n        if sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = float('-inf')\n    max_list = []\n\n    for sublist in list_of_lists:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    max_sum = float('-inf')\n    max_sublist = None\n    for sublist in lst:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n            max_sublist = sublist\n    return max_sublist", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst_of_lst):\n    return max(lst_of_lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initiate variables to store the max sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n\n    # Loop through each list in the list of lists\n    for lst in lists:\n        # Compute the sum of the list\n        sum_lst = sum(lst)\n        # If the sum is larger than max_sum, update max_sum and max_list\n        if sum_lst > max_sum:\n            max_sum = sum_lst\n            max_list = lst\n\n    # Return the list with the highest sum of elements\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize the max sum and the max sum list\n    max_sum = float('-inf')\n    max_sum_list = []\n\n    # Iterate through each sub-list\n    for sublist in list_of_lists:\n        sublist_sum = sum(sublist)\n        # If the sum of elements in the current sub-list is greater than the max sum found so far\n        if sublist_sum > max_sum:\n            # Update the max sum and the max sum list\n            max_sum = sublist_sum\n            max_sum_list = sublist\n\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Parameters:\n    lists (list): A list of lists, where each sublist contains integers.\n\n    Returns:\n    list: The sublist with the maximum sum of its elements.\n    \"\"\"\n    # Use the max function to find the sublist with the maximum sum.\n    # The key for the max function is the sum of the elements in each sublist.\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    max_sum = float('-inf')\n    max_list = []\n    for lst in lists:\n        if sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 86.14035087719299, "dps_norm": 96.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    \"\"\"\n    This function checks if the given tuples contain the k or not.\n\n    Args:\n    tup (tuple): The tuple in which the element is to be found.\n    k (any): The element to be found in the tuple.\n\n    Returns:\n    bool: True if the element is found, else False.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    if k in tuples:\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"Check if the given tuple contains the value k.\"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    if k in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the k.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the element k.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    if k in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    This function checks if the given tuple 'tup' contains the element 'k'.\n\n    Args:\n    tup: A tuple of elements.\n    k: The element to be checked in the tuple.\n\n    Returns:\n    A boolean value. True if 'k' is found in 'tup', else False.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_values, K):\n    \"\"\"\n    A function to check if the given tuple contains the value K.\n    \"\"\"\n    return K in tuple_values", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Function to check if the given tuple contains the k or not.\n    \"\"\"\n    if k in input_tuple:\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the k or not.\n    :param tup: Tuple of integers\n    :param k: Integer\n    :return: Boolean value\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    Function to check if the given tuple contains the k or not\n\n    Args:\n        t (tuple): The input tuple\n        k: The element to check\n\n    Returns:\n        bool: True if k is in t, False otherwise\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}]}}}
