{"date": "2024-10-19 16:28", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 83.54712283112897, "dps_norm": 78.3588319852899, "pass@1": 87.5677966101695}, "eval": {"HumanEval/9": {"dps": 83.9589905362776, "dps_norm": 91.11111111111111, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list of integers representing the rolling maximum up to each index in the input list.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = []\n\n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list of integers representing the rolling maximums.\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    current_max = numbers[0]\n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = []\n\n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_list = [numbers[0]]\n    current_max = numbers[0]\n    \n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    \n    return max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\"\"\"\n    if not numbers:\n        return []\n    \n    max_list = [numbers[0]]  # Initialize the rolling max list with the first element\n    current_max = numbers[0]  # Initialize current_max with the first element\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num  # Update current_max if the current number is greater\n        max_list.append(current_max)  # Append the current_max to the max_list\n    \n    return max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = []\n    \n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    for number in numbers[1:]:\n        result.append(max(result[-1], number))\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Args:\n        numbers (List[int]): The list of integers.\n        \n    Returns:\n        List[int]: A list of rolling maximums.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_maxes = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        rolling_maxes.append(max_so_far)\n    \n    return rolling_maxes", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    current_max = numbers[0]\n\n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until the given moment in the sequence.\n\n    Args:\n        numbers: List of integers.\n\n    Returns:\n        A list of rolling maximum integers found until each moment in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until the given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: The list of rolling maximums.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_list = [numbers[0]]\n    current_max = numbers[0]\n    \n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    \n    return max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\"\"\"\n    if not numbers:\n        return []\n    \n    max_list = [numbers[0]]\n    current_max = numbers[0]\n    \n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    \n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        A list of integers representing the rolling maximums.\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_val = numbers[0]\n    result = [max_val]\n\n    for number in numbers[1:]:\n        if number > max_val:\n            max_val = number\n        result.append(max_val)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_list = [numbers[0]]\n    current_max = numbers[0]\n\n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n\n    return max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until the given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_list = [numbers[0]]\n    current_max = numbers[0]\n\n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n\n    return max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_list = [numbers[0]]\n    current_max = numbers[0]\n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    \n    return max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = []\n\n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n        \n    return result", "matching_cluster_idx": 7}]}, "HumanEval/0": {"dps": 52.325581395348834, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list to find if any adjacent elements are closer than the threshold\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make comparison easier\n    sorted_numbers = sorted(numbers)\n    \n    # Compare each adjacent pair in the sorted list\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to bring closer numbers next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Check the difference between adjacent numbers\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    :param numbers: List of numbers.\n    :param threshold: Threshold value.\n    :return: True if there are any two numbers closer than the threshold, False otherwise.\n    \"\"\"\n    numbers.sort()  # Sort the numbers to compare adjacent elements\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make it easier to find closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to bring closer numbers adjacent to each other\n    numbers.sort()\n    \n    # Iterate through the list to check if any adjacent numbers are closer than the threshold\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n        numbers: A list of floating-point numbers.\n        threshold: A floating-point number representing the maximum allowed distance between any two numbers.\n\n    Returns:\n        A boolean value indicating if there are any two numbers in the list closer to each other than the given threshold.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    numbers.sort()  # Sorting the numbers to make it easier to find close elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make comparison easier\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list to check the difference between consecutive elements\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i-1] < threshold:\n            return True\n            \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make it easier to check closeness\n    numbers.sort()\n    \n    # Iterate through the list to check the difference between consecutive numbers\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the maximum allowed distance between any two numbers.\n    :return: True if any two numbers are closer to each other than the threshold, otherwise False.\n    \"\"\"\n    # Sort the list to ensure we only need to check adjacent elements for the condition.\n    numbers.sort()\n    \n    # Iterate through the list and check if any two adjacent elements are closer than the threshold.\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list of numbers to bring closer numbers adjacent to each other\n    numbers.sort()\n    \n    # Iterate through the sorted list to check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    numbers.sort()\n\n    # Iterate through the sorted list to check for any two consecutive elements\n    # that are closer than the given threshold\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make sure that any two close numbers will be adjacent\n    numbers.sort()\n\n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    Args:\n        numbers: A list of floating-point numbers.\n        threshold: A floating-point number representing the distance threshold.\n\n    Returns:\n        A boolean indicating whether there are any two numbers in the list closer to\n        each other than the threshold.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than given threshold.\"\"\"\n    # Sort the list to ensure that the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the list and check if any two adjacent elements are closer than the threshold\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in the given list of numbers, any two numbers are closer to each other\n    than the given threshold.\n    \"\"\"\n    # First, sort the numbers to make comparison easier\n    numbers.sort()\n    \n    # Compare each adjacent pair of numbers\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to ensure that the closest numbers are next to each other\n    numbers.sort()\n\n    # Iterate through the list and check if any two consecutive numbers are closer than the threshold\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the numbers to bring the closest elements next to each other\n    numbers.sort()\n\n    # Iterate through the list and check if any two adjacent elements are closer than the threshold\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list of numbers to ensure that the elements we compare are the closest pairs\n    numbers.sort()\n\n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n        numbers: A list of floating-point numbers.\n        threshold: The threshold distance to check for closeness between elements.\n    \n    Returns:\n        A boolean value indicating if any two elements are closer than the threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the numbers to easily find the closest pairs\n    numbers.sort()\n\n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 8.655063291139241, "dps_norm": 30.833333333333336, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\nfrom math import fabs\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    total_deviation = sum(fabs(x - mean_value) for x in numbers)\n    \n    return total_deviation / len(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation (MAD) is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    :param numbers: List of input numbers\n    :return: Mean Absolute Deviation as a float\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([5.0, 7.0, 3.0])\n    1.3333333333333333\n    \"\"\"\n    # Calculate the mean of the numbers\n    mean_value = mean(numbers)\n    # Calculate the sum of absolute differences from the mean\n    total_deviation = sum(abs(x - mean_value) for x in numbers)\n    # Calculate the mean of those deviations\n    return total_deviation / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean_value = mean(numbers)\n    # Calculate the absolute differences from the mean and then take their mean.\n    return mean([abs(x - mean_value) for x in numbers])", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 if the list is empty\n\n    avg = mean(numbers)\n    return mean(abs(x - avg) for x in numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    return mean(deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom functools import reduce\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n\n    # Calculate the sum of absolute differences between each element and mean\n    absolute_differences_sum = reduce(lambda a, b: a + abs(b - mean_value), numbers, 0)\n\n    # Calculate and return the Mean Absolute Deviation\n    return absolute_differences_sum / len(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:\n        return 0.0  # Avoid division by zero if the list is empty\n    \n    mean_value = mean(numbers)\n    total_deviation = sum(abs(x - mean_value) for x in numbers)\n    return total_deviation / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    return mean(deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Handle empty list case\n        return 0.0\n\n    mean_value = mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    return mean(deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Handle empty list case\n        return 0.0\n    mean_value = mean(numbers)\n    return sum(abs(x - mean_value) for x in numbers) / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom functools import reduce\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    mean_value = sum(numbers) / len(numbers)\n    # Calculate the mean absolute deviation\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom math import fsum\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers: List[float] - A list of floating-point numbers.\n\n    Returns:\n    float - The mean absolute deviation of the dataset.\n\n    Example:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n    mean_value = fsum(numbers) / n\n    total_deviation = fsum(abs(x - mean_value) for x in numbers)\n    return total_deviation / n", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean_value = mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    return mean(deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom functools import reduce\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the dataset\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute difference of each element from the mean\n    absolute_diff = [abs(x - mean_value) for x in numbers]\n    \n    # Calculate the mean of these absolute differences\n    mad = sum(absolute_diff) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    \n    mean_value = mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    return mean(deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = mean(numbers)\n    return mean(abs(x - mean_value) for x in numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    mean_value = mean(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the dataset\n    mean_value = mean(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean_value = mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    mad = mean(deviations)\n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    avg = mean(numbers)\n    total_diff = sum(abs(x - avg) for x in numbers)\n    return total_diff / len(numbers)", "matching_cluster_idx": 0}]}, "HumanEval/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store unique characters and calculate the size of the set\n    return len(set(string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    # Convert the string to lowercase to ignore case and then use a set to find unique characters\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\"\"\"\n    # Convert the string to lower case to ignore the case and create a set to get distinct characters\n    distinct_chars = set(string.lower())\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case and then use a set to find unique characters\n    unique_chars = set(string.lower())\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    # Convert string to lower case to ensure case insensitivity and use set to find unique characters\n    unique_chars = set(string.lower())\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    if not string:\n        return 0\n    # Convert string to lower case to ignore case and create a set of characters to get distinct ones\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    if not string:\n        return 0\n    \n    # Convert string to lowercase to make the function case-insensitive\n    string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(string)\n    # Return the count of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert to lower case to ensure case insensitivity and then create a set of characters\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    # Convert the string to lower case to ignore case and then use a set to find distinct characters\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    # Convert the string to lower case to ensure case insensitivity\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    # Convert the string to lower case to ignore case and create a set to store distinct characters\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert to lower case and then create a set to eliminate duplicates\n    distinct_chars = set(string.lower())\n    # Return the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ignore case differences\n    # Use a set to store unique characters\n    unique_chars = set(string.lower())\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    # Convert the string to lower case to ignore the case and then create a set to store unique characters\n    unique_chars = set(string.lower())\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lower case to ignore case and then use set to find unique characters\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\"\"\"\n    # Convert the string to lower case to ensure case insensitivity\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\"\"\"\n    # Normalize the string to lower case and create a set to store unique characters\n    unique_chars = set(string.lower())\n    return len(unique_chars)", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 56.84019370460048, "dps_norm": 71.11111111111111, "pass@1": 98.0, "profiled": [{"solution": "from typing import List, Tuple\nfrom functools import cmp_to_key\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers first\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize closest pair and the smallest difference with the first pair\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = sorted_numbers[1] - sorted_numbers[0]\n    \n    # Iterate over the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to facilitate comparison\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the variables to store the closest elements and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the list to find the closest elements\n    for num1, num2 in combinations(sorted_numbers, 2):\n        if (diff := abs(num2 - num1)) < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (num1, num2)\n    \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make sure we're comparing consecutive elements only\n    sorted_numbers = sorted(numbers)\n    closest_pair = min(combinations(sorted_numbers, 2), key=lambda pair: abs(pair[1] - pair[0]))\n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = sorted_numbers[1] - sorted_numbers[0]\n\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_difference < smallest_difference:\n            smallest_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    :param numbers: List of float numbers.\n    :return: A tuple of two closest numbers (smaller, larger).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_difference < min_difference:\n            min_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure pairs are in increasing order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to keep track of the closest pair\n    min_distance = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate over adjacent pairs of numbers\n    for num1, num2 in combinations(sorted_numbers, 2):\n        # Calculate the distance between the numbers\n        distance = abs(num2 - num1)\n        \n        # Update closest pair if a new closest distance is found\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (num1, num2)\n            \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\nfrom typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n\n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i+1] - sorted_numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom math import inf\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # First, sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the closest pair with the first two elements\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < smallest_difference:\n            smallest_difference = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the numbers to make comparison easier\n    numbers.sort()\n    \n    # Initialize variables to store the closest elements\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[1] - numbers[0])\n    \n    # Iterate through the list to find the pair with the smallest difference\n    for i in range(1, len(numbers) - 1):\n        current_diff = abs(numbers[i + 1] - numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom math import inf\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to find the closest elements more easily\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference with infinity\n    min_diff = inf\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the list and find the minimum difference between two consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure pairs are considered in order\n    sorted_numbers = sorted(numbers)\n    # Find the minimum difference and the corresponding pair\n    min_diff = float('inf')\n    closest_pair = ()\n    for a, b in combinations(sorted_numbers, 2):\n        diff = abs(b - a)\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (a, b)\n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the numbers to make it easier to find the closest pair\n    numbers.sort()\n    \n    # Calculate differences between adjacent elements\n    closest_pair = min(combinations(numbers, 2), key=lambda pair: abs(pair[1] - pair[0]))\n    \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\nfrom math import inf\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Ensure the list is sorted to avoid any order dependency for difference calculation.\n    numbers.sort()\n    \n    # Initialize the minimum difference to a very high value.\n    min_diff = inf\n    closest_pair = (0, 0)\n    \n    # Iterate over the list to find the smallest difference between two adjacent numbers.\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to simplify finding the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the closest pair with the first pair and calculate the initial difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(closest_pair[1] - closest_pair[0])\n    \n    # Iterate through each pair to find the smallest difference\n    for x, y in combinations(sorted_numbers, 2):\n        diff = y - x\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (x, y)\n    \n    return closest_pair", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to make sure pairs are in ascending order\n    sorted_numbers = sorted(numbers)\n\n    # Create pairs using combinations and find the closest pair\n    closest_pair = min(combinations(sorted_numbers, 2), key=lambda pair: abs(pair[1] - pair[0]))\n\n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize with the first pair of elements\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(closest_pair[1] - closest_pair[0])\n    \n    # Iterate over each pair to find the closest\n    for num1, num2 in combinations(sorted_numbers, 2):\n        if abs(num2 - num1) < smallest_diff:\n            smallest_diff = abs(num2 - num1)\n            closest_pair = (num1, num2)\n    \n    return closest_pair", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements.\")\n    \n    # Sort the numbers to make finding the closest elements easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted numbers to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_difference < smallest_difference:\n            smallest_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Use itertools.combinations to generate all possible pairs\n    # And find the pair with the smallest difference\n    closest = min(combinations(sorted_numbers, 2), key=lambda pair: abs(pair[1] - pair[0]))\n    \n    return closest", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the numbers to ensure they are in order.\n    numbers.sort()\n    \n    # Use combinations to pair each element with its adjacent one after sorting.\n    # This guarantees that the closest pairs are compared, as the list is sorted.\n    closest_pair = min(combinations(numbers, 2), key=lambda pair: abs(pair[1] - pair[0]))\n    \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\nfrom itertools import combinations\nimport math\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list of numbers\n    sorted_numbers = sorted(numbers)\n    closest_pair = None\n    min_diff = math.inf\n    \n    # Iterate over pairs of successive numbers to find the minimum difference\n    for first, second in combinations(sorted_numbers, 2):\n        # Since the list is sorted, no need to keep track of pairs with same difference,\n        # we just take the first occurrence.\n        if second - first < min_diff:\n            min_diff = second - first\n            closest_pair = (first, second)\n    \n    return closest_pair", "matching_cluster_idx": 4}]}, "HumanEval/24": {"dps": 96.32653061224491, "dps_norm": 61.875, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # If no divisor found, return 1 (this case is for n=1 or n=2)", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1, which is a trivial divisor for all n", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # If no divisor is found, return 1, as every number is divisible by 1.", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1, as every number is divisible by 1.", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # If no divisor is found, return 1 (trivial case)", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found, return 1 as every number is divisible by 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found, which happens only if n is 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # If no divisor is found, return 1. Note: For n > 1, 1 is always a divisor.", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n    n (int): A positive integer\n\n    Returns:\n    int: The largest divisor of n, smaller than n\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    \"\"\"\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # If no divisor is found, n is prime, so return 1.", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1, as every number is divisible by 1.", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1, which trivially divides n.", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1, as every number is divisible by 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found, return 1, which trivially divides n evenly.", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found other than 1, return 1 (every number is divisible by 1)", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n        n (int): The number to find the largest divisor for.\n\n    Returns:\n        int: The largest divisor of n, smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(28)\n        14\n    \"\"\"\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # This case is for prime numbers, where the largest divisor < n is 1.", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found other than 1, return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1, as every number is divisible by 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found, return 1 (applies to the case where n is 1 or 2)", "matching_cluster_idx": 4}]}, "HumanEval/26": {"dps": 45.2, "dps_norm": 71.25, "pass@1": 88.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> remove_duplicates([1, 1, 2, 2, 3, 3])\n    []\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            # Check if number appears more than once\n            if numbers.count(number) == 1:\n                result.append(number)\n            else:\n                seen.add(number)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n            result.append(number)\n        else:\n            # Remove from result if it's already there\n            if number in result:\n                result.remove(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 5, 4, 6, 6, 7])\n    [7]\n    >>> remove_duplicates([10, 20, 20, 10, 30])\n    [30]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return [num for num in result if numbers.count(num) == 1]", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([10, 20, 20, 10, 30])\n    [30]\n    >>> remove_duplicates([4, 5, 6, 4, 5, 7])\n    [6, 7]\n    \"\"\"\n    occurrence = {}\n    for num in numbers:\n        if num in occurrence:\n            occurrence[num] += 1\n        else:\n            occurrence[num] = 1\n    \n    return [num for num in numbers if occurrence[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n        else:\n            # If we see it again, remove it from the result if present\n            if number in result:\n                result.remove(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 5, 4, 2])\n    [2]\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    count_map = {}\n    for num in numbers:\n        count_map[num] = count_map.get(num, 0) + 1\n\n    return [num for num in numbers if count_map[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n        else:\n            if number in result:\n                result = [n for n in result if n != number]\n            seen.add(number)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n        else:\n            # Remove the number from the final result if it was already seen\n            if number in result:\n                result.remove(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n            result.append(number)\n        else:\n            # If the number is encountered again, remove it from the result list\n            result = [n for n in result if n != number]\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 5, 4, 6, 7])\n    [6, 7]\n    >>> remove_duplicates([10, 10, 10])\n    []\n    >>> remove_duplicates([1, 2, 3])\n    [1, 2, 3]\n    \"\"\"\n    seen = set()\n    unique = []\n    for number in numbers:\n        if number not in seen:\n            # Add number to the unique list only if it's not seen before\n            seen.add(number)\n            unique.append(number)\n        else:\n            # If the number is already seen, remove it from the unique list\n            if number in unique:\n                unique.remove(number)\n    return unique", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 5, 4, 6, 7, 8, 6, 8])\n    [7]\n    \"\"\"\n    seen = set()\n    unique = []\n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n            unique.append(number)\n        elif number in unique:\n            unique.remove(number)\n    return unique", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    occurrence = {}\n    for number in numbers:\n        occurrence[number] = occurrence.get(number, 0) + 1\n\n    return [number for number in numbers if occurrence[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n        else:\n            # Remove the element if it appears more than once\n            if number in result:\n                result.remove(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Track occurrences of each number\n    count = {}\n    for number in numbers:\n        if number in count:\n            count[number] += 1\n        else:\n            count[number] = 1\n\n    # Include in result only numbers that occurred once\n    result = [number for number in numbers if count[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    unique_elements = []\n    for number in numbers:\n        if number not in seen:\n            unique_elements.append(number)\n            seen.add(number)\n        else:\n            # Remove the element from the unique list if it's a duplicate\n            if number in unique_elements:\n                unique_elements.remove(number)\n    return unique_elements", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n        elif number in result:\n            result.remove(number)\n            seen.add(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([5, 5, 6, 7, 8, 8])\n    [6, 7]\n    >>> remove_duplicates([9, 10, 9, 10, 11])\n    [11]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 1, 1, 1, 1])\n    []\n    \"\"\"\n    # Count the occurrence of each number\n    num_counts = {}\n    for num in numbers:\n        num_counts[num] = num_counts.get(num, 0) + 1\n\n    # Return numbers that occur exactly once\n    return [num for num in numbers if num_counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n        else:\n            # Remove the number from the result if it was added before\n            if number in result:\n                result.remove(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n        elif number in result:\n            result.remove(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 5, 4, 6, 7])\n    [6, 7]\n    >>> remove_duplicates([10, 10, 11, 12, 11, 13])\n    [12, 13]\n    \"\"\"\n    seen = set()\n    unique = []\n    for num in numbers:\n        if num not in seen:\n            # Add number to unique list only if it hasn't been seen before\n            unique.append(num)\n            seen.add(num)\n        else:\n            # If the number has been seen before, ensure it's not kept in unique list\n            if num in unique:\n                unique.remove(num)\n    return unique", "matching_cluster_idx": 2}]}, "HumanEval/31": {"dps": 97.46835443037975, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \n    Args:\n    n (int): The number to check for primality.\n    \n    Returns:\n    bool: True if n is prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 92.60416666666667, "dps_norm": 80.9090909090909, "pass@1": 97.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extracting elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sorting the extracted elements\n    divisible_by_three.sort()\n    \n    # Creating the result list\n    result = l[:]\n    # Replacing the values at indices divisible by three with sorted values\n    for i, value in enumerate(divisible_by_three):\n        result[i*3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract the elements at indices divisible by three and sort them\n    indices_div_by_three = [i for i in range(len(l)) if i % 3 == 0]\n    elements_div_by_three = sorted(l[i] for i in indices_div_by_three)\n    \n    # Create the new list l' based on the requirements\n    l_prime = l[:]\n    for i, idx in enumerate(indices_div_by_three):\n        l_prime[idx] = elements_div_by_three[i]\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    divisible_by_three_sorted = sorted(divisible_by_three)\n    \n    # Create the resulting list\n    l_prime = []\n    sort_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime.append(divisible_by_three_sorted[sort_index])\n            sort_index += 1\n        else:\n            l_prime.append(l[i])\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_elements = sorted(divisible_by_three)\n    \n    # Generate the new list with sorted elements at the correct positions\n    result_list = [sorted_elements.pop(0) if i % 3 == 0 else l[i] for i in range(len(l))]\n    \n    return result_list", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract values at indices divisible by three and sort them\n    divisible_by_three_sorted = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Create the result list\n    result = l[:]\n    sorted_index = 0\n    \n    # Replace the values at indices divisible by three with sorted values\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = divisible_by_three_sorted[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    :param l: The input list.\n    :return: The modified list l'.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    # Initialize the output list as a copy of the input list\n    l_prime = l[:]\n    # Place the sorted elements back into their original positions\n    for i, value in enumerate(sorted_divisible_by_three):\n        l_prime[i*3] = value\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    \n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3 (0-indexed)\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort the extracted elements\n    sorted_elements = sorted(divisible_by_three)\n    \n    # Prepare the output list\n    result = l[:]\n    \n    # Replace the elements at indices divisible by 3 with the sorted ones\n    for i, value in enumerate(sorted_elements):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract values at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these values\n    sorted_values = sorted(divisible_by_three)\n    \n    # Create a new list to hold the result\n    result = l[:]\n    # Replace values at indices divisible by three with sorted values\n    for i, value in enumerate(sorted_values):\n        result[i*3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these extracted elements\n    divisible_by_three.sort()\n    \n    # Construct the result list\n    result = []\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            # Replace the element if the index is divisible by three\n            result.append(divisible_by_three[sorted_index])\n            sorted_index += 1\n        else:\n            # Keep the original element\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n\n    # Construct the resulting list\n    result = []\n    sort_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(divisible_by_three[sort_index])\n            sort_index += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these extracted elements\n    divisible_by_three.sort()\n    \n    # Initialize an empty list to hold the new sorted list\n    l_prime = []\n    # Counter for the sorted divisible_by_three list\n    sorted_index = 0\n    \n    for i in range(len(l)):\n        if i % 3 == 0:\n            # Replace the element at indices divisible by three with sorted values\n            l_prime.append(divisible_by_three[sorted_index])\n            sorted_index += 1\n        else:\n            # Keep other elements as they are\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements whose indices are divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Construct the resulting list\n    result = l[:]\n    sorted_idx = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_divisible_by_three[sorted_idx]\n            sorted_idx += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three and sort them\n    divisible_by_three_sorted = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Construct the result list\n    result = []\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(divisible_by_three_sorted[sorted_index])\n            sorted_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Construct the new list\n    l_prime = []\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime.append(sorted_divisible_by_three[sorted_index])\n            sorted_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the values at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort those values\n    divisible_by_three_sorted = sorted(divisible_by_three)\n    \n    # Create the output list by copying the original list\n    l_prime = l[:]\n    # Replace the values at indices divisible by 3 with the sorted ones\n    for i, value in enumerate(divisible_by_three_sorted):\n        l_prime[i * 3] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    \n    # Construct the new list l'\n    l_prime = l.copy()\n    for i, value in enumerate(divisible_by_three):\n        l_prime[i * 3] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three (0-indexed)\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    \n    # Construct the new list\n    l_prime = []\n    sort_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime.append(divisible_by_three[sort_index])\n            sort_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    divisible_by_three.sort()\n    \n    # Create the resulting list\n    result = []\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            # Replace every third element with the sorted ones\n            result.append(divisible_by_three[sorted_index])\n            sorted_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3 (0-indexed, so these are every third element starting from 0)\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list with the same length as the original one\n    result = l[:]\n    # Replace every third element with the corresponding element from the sorted list\n    for i, val in enumerate(sorted_divisible_by_three):\n        result[i*3] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    \n    # Build the new list l'\n    l_prime = []\n    sort_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime.append(divisible_by_three[sort_index])\n            sort_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then sort and return the result\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    \n    Args:\n    l (list): The list from which to extract unique elements.\n    \n    Returns:\n    list: A list of sorted unique elements.\n    \n    Example:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    Args:\n        l (list): A list of elements\n\n    Returns:\n        list: A sorted list of unique elements\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Returns the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: An integer limit\n    :return: Count of digit 7 appearances\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n    n (int): The upper limit (exclusive) to check for numbers.\n    \n    Returns:\n    int: The count of digit 7 appearances in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: An integer to check against.\n    :return: Count of digit 7 appearances in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: Upper limit (non-inclusive) for searching numbers divisible by 11 or 13.\n    :return: Count of digit 7 appearances in qualifying numbers.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Returns the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: Upper limit to search for numbers with the digit 7.\n    :return: Number of times the digit 7 appears in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 95.18003273322422, "dps_norm": 90.5, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even index elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create a new list with the correct elements\n    result = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_idx])\n            even_idx += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract the elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the elements at even indices\n    sorted_even = sorted(even_indices_elements)\n    \n    # Construct the result list\n    result = []\n    even_idx = 0\n    for idx in range(len(l)):\n        if idx % 2 == 0:\n            # Place the sorted element at the even index\n            result.append(sorted_even[even_idx])\n            even_idx += 1\n        else:\n            # Place the original element at the odd index\n            result.append(l[idx])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted values\n    sorted_even_indices_values = sorted(even_indices_values)\n    \n    # Construct the new list\n    l_prime = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(sorted_even_indices_values[even_index])\n            even_index += 1\n        else:\n            l_prime.append(l[i])\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-index elements and sort them\n    even_elements = sorted(l[::2])\n    \n    # Prepare a result list with the same size as the input\n    result = [None] * len(l)\n    \n    # Place sorted even-index elements back into the result list\n    result[::2] = even_elements\n    \n    # Copy odd-index elements directly from the input list\n    result[1::2] = l[1::2]\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices values and sort them\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    even_indices_values_sorted = sorted(even_indices_values)\n    \n    # Create a new list to store the final result\n    sorted_list = []\n    even_index = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the sorted even index value\n            sorted_list.append(even_indices_values_sorted[even_index])\n            even_index += 1\n        else:\n            # Keep the odd index value as is\n            sorted_list.append(l[i])\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-index elements and sort them\n    even_sorted = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Prepare a list to hold the result\n    result = l[:]\n    \n    # Put the sorted even-index elements back into their original positions\n    even_idx = 0\n    for i in range(0, len(l), 2):\n        result[i] = even_sorted[even_idx]\n        even_idx += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-indexed elements and sort them\n    even_sorted = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Construct the new list\n    l_prime = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_sorted[even_idx])\n            even_idx += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-index elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create the resulting list l' with the same size as l\n    l_prime = l[:]\n    \n    # Replace even indices in l' with the sorted even-index elements\n    for i, value in enumerate(even_elements):\n        l_prime[i * 2] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract the even-indexed elements and sort them.\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Construct the resulting list.\n    result_list = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the sorted even-indexed element.\n            result_list.append(even_elements[even_idx])\n            even_idx += 1\n        else:\n            # Place the original odd-indexed element.\n            result_list.append(l[i])\n    \n    return result_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-index elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create the result list\n    result = []\n    even_idx = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the next sorted even-index element\n            result.append(even_elements[even_idx])\n            even_idx += 1\n        else:\n            # Copy the odd-index elements as is\n            result.append(l[i])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\"\"\"\n    # Extract even-index elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Construct the result list\n    result = []\n    even_idx = 0\n    for idx in range(len(l)):\n        if idx % 2 == 0:\n            # Insert the next sorted even element\n            result.append(even_elements[even_idx])\n            even_idx += 1\n        else:\n            # Copy the odd-indexed element as is\n            result.append(l[idx])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-indexed elements and sort them\n    even_elements = sorted(l[::2])\n    \n    # Create a new list to store the result\n    result = []\n    even_idx = 0\n    \n    # Iterate through the original list and construct the result list\n    for idx in range(len(l)):\n        if idx % 2 == 0:\n            # For even indices, get the next element from the sorted even_elements\n            result.append(even_elements[even_idx])\n            even_idx += 1\n        else:\n            # For odd indices, just copy the element from the original list\n            result.append(l[idx])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even index elements and sort them\n    even_elements_sorted = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create the result list, copying odd indices from l\n    # and placing sorted even elements back at even indices\n    result = [None] * len(l)\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result[i] = even_elements_sorted[even_index]\n            even_index += 1\n        else:\n            result[i] = l[i]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-indexed elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n\n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = [even_elements.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extracting even index elements\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sorting the even index elements\n    sorted_even_indices_elements = sorted(even_indices_elements)\n    \n    # Creating the result list\n    result = []\n    even_index_counter = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # For even index, place the sorted value\n            result.append(sorted_even_indices_elements[even_index_counter])\n            even_index_counter += 1\n        else:\n            # For odd index, keep the original value\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\"\"\"\n    # Extracting even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n    # Sorting the values at the even indices\n    even_indices_values.sort()\n\n    # Building the result list\n    result = []\n    even_counter = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_values[even_counter])\n            even_counter += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-index elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Initialize the result list with None to later fill with correct values\n    result = [None] * len(l)\n    \n    # Fill in the even indices with sorted elements\n    even_iter = iter(even_elements)\n    for i in range(0, len(l), 2):\n        result[i] = next(even_iter)\n    \n    # Fill in the odd indices with the original list's elements\n    for i in range(1, len(l), 2):\n        result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at even indices and sort them\n    even_indices_values_sorted = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create the result list by placing sorted even indices and unchanged odd indices\n    result_list = [even_indices_values_sorted.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]\n    \n    return result_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract the elements at even indices\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    sorted_even_indices_elements = sorted(even_indices_elements)\n    \n    # Create a new list to store the result\n    l_prime = []\n    # Counter for the sorted even indices elements\n    sorted_counter = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Even index, append from sorted even indices elements\n            l_prime.append(sorted_even_indices_elements[sorted_counter])\n            sorted_counter += 1\n        else:\n            # Odd index, directly append the original value\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \n    Example usage:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices and sort them.\n    sorted_evens = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Generate the result list.\n    result = []\n    even_idx = 0  # Track the position in sorted_evens.\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            # At even indices, use sorted values.\n            result.append(sorted_evens[even_idx])\n            even_idx += 1\n        else:\n            # At odd indices, use original value.\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    # Use Python's built-in pow function with three arguments for efficiency and numeric stability\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Use Python's built-in pow function which efficiently computes (x^y) % z\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Use Python's built-in pow function which efficiently handles large powers modulo a number\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    Args:\n        n (int): The exponent to raise 2 by.\n        p (int): The modulo value.\n\n    Returns:\n        int: The result of (2^n) % p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Using Python's built-in pow function to handle large numbers efficiently\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Use Python's built-in pow function for efficient modular exponentiation\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 91.35265700483092, "dps_norm": 71.875, "pass@1": 100.0, "profiled": [{"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import string\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import string\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    # Define a set of vowels\n    vowels = set('aeiouAEIOU')\n    \n    # Use list comprehension to filter out vowels and join the result into a new string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[AEIOUaeiou]', '', text)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 95.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings contain exactly the same characters, False otherwise.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    :param s0: First string to compare\n    :param s1: Second string to compare\n    :return: True if both strings consist of the same characters, False otherwise\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function checks if both strings s0 and s1 are composed of the same set of characters,\n    regardless of their order or the number of occurrences of each character.\n    \n    Args:\n    s0 (str): The first string to be checked.\n    s1 (str): The second string to be checked.\n    \n    Returns:\n    bool: True if both strings are composed of the same characters, False otherwise.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    :param s0: First string.\n    :param s1: Second string.\n    :return: True if both strings contain the same characters, False otherwise.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): First string to compare.\n    s1 (str): Second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same set of characters, False otherwise.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Parameters:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings contain the same set of characters, False otherwise.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of their frequency.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Use sets to check if both strings contain the same unique characters\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first word.\n    s1 (str): The second word.\n    \n    Returns:\n    bool: True if both words contain the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and allow comparison of unique characters\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, disregarding the frequency and order of characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function compares two strings to determine if they contain exactly the same characters\n    (ignoring frequency and order).\n\n    :param s0: First string to compare.\n    :param s1: Second string to compare.\n    :return: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function checks if two strings contain the same set of characters, regardless of order or frequency.\n\n    :param s0: First string to compare\n    :param s1: Second string to compare\n    :return: True if both strings contain the same characters, False otherwise\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 93.26771653543307, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n    l1: First list of integers.\n    l2: Second list of integers.\n    \n    Returns:\n    A list of integers that are common and unique to both l1 and l2, sorted in ascending order.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    common_set = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n    l1: First list of integers.\n    l2: Second list of integers.\n    \n    Returns:\n    A list containing sorted unique common elements of l1 and l2.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets and use set intersection to find common elements\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    # Find intersection of both sets to get common elements\n    common_elements = set1.intersection(set2)\n    # Return sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \"\"\"\n    # Use set intersection to find common elements and sort the result\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Args:\n    l1: First list of elements.\n    l2: Second list of elements.\n\n    Returns:\n    A list of sorted unique elements that are common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find the intersection of two lists and convert to set to remove duplicates, then sort the result\n    return sorted(set(l1).intersection(set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements and then sort the result.\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets and find the intersection to get common elements\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    # Intersect the two sets and convert back to a sorted list\n    return sorted(list(set1.intersection(set2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # Find common elements using set intersection and return sorted list\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n    l1: A list of integers.\n    l2: A list of integers.\n    \n    Returns:\n    A sorted list containing the unique common elements between l1 and l2.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find common elements\n    common_elements = set(l1).intersection(l2)\n    \n    # Return sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n    l1: First list of integers.\n    l2: Second list of integers.\n    \n    Returns:\n    A list of integers that are common in both lists, sorted and unique.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Using set intersection to find common elements and then sorting the result\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of the intersection elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # Find common elements using set intersection\n    common_elements = set(l1).intersection(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements and then sort them\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        \n    Returns:\n        list: A sorted list of unique elements common to both lists.\n        \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Find unique elements in both lists by converting them to sets\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find intersection of both sets to get common elements\n    common_set = set1.intersection(set2)\n    \n    # Convert the set back to a sorted list and return it\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and find intersection\n    common_elements = list(set(l1) & set(l2))\n    # Return sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Converting both lists to sets to remove duplicates and find intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Returning the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets and find the intersection\n    common_set = set(l1) & set(l2)\n    # Convert the set back to a sorted list and return\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find unique common elements\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n    l1: First list of elements.\n    l2: Second list of elements.\n    \n    Returns:\n    A list containing the sorted unique elements that are common in both lists.\n    \n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Using set intersection to find common elements and then sorting them\n    result = sorted(set(l1).intersection(set(l2)))\n    return result", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 95.71180555555556, "dps_norm": 98.88888888888889, "pass@1": 99.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # Now n must be odd. Start from 3 and check for factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, remove i and set largest_prime to i\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n    \n    # If n becomes a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Parameters:\n    n (int): The integer to find the largest prime factor for.\n    \n    Returns:\n    int: The largest prime factor of n.\n    \"\"\"\n    i = 2\n    # While i^2 is less than or equal to n, do the iteration\n    while i * i <= n:\n        # If n is divisible by i, divide n by i\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    # After the loop, n should be the largest prime factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = 2\n    \n    while i * i <= n:\n        if n % i == 0:\n            largest_prime = i\n            n //= i\n        else:\n            i += 1\n\n    if n > largest_prime:\n        largest_prime = n\n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: Integer to find the largest prime factor of.\n    :return: The largest prime factor of n.\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i = i + 2) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, remove i and set largest_prime to i\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_factor = 2\n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        n = n // 2\n    \n    # n must be odd at this point, so a skip of 2 (i = i + 2) can be used\n    factor = 3\n    while factor * factor <= n:\n        # While factor divides n, remove it and update largest_factor\n        while n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n        factor += 2\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the smallest prime factor\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the smallest prime factor\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        # While 'n' is divisible by 'factor', divide 'n' by 'factor'\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n        # Increment the factor, skip even numbers after 2\n        factor += 1 if factor == 2 else 2\n        # Optimization: if factor*factor > n, then n is prime\n        if factor * factor > n:\n            if n > 1:\n                last_factor = n\n            break\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor variable\n    largest_factor = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Now n must be odd, start from 3 and check for factors\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n        factor += 2\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = 1\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor variable\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n // 2\n\n    # n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, print i and divide n\n        while n % i == 0:\n            largest_prime = i\n            n = n // i\n\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: Integer greater than 1 and not a prime.\n    :return: Largest prime factor of n.\n    \"\"\"\n    # Initialize the largest prime factor variable\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n // 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i + 2)\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_prime = factor\n            n = n // factor\n        factor += 2\n    \n    # This condition is to handle the case when n is a prime number\n    # greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(number):\n        if number <= 1:\n            return False\n        if number <= 3:\n            return True\n        if number % 2 == 0 or number % 3 == 0:\n            return False\n        i = 5\n        while i * i <= number:\n            if number % i == 0 or number % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Start from the smallest prime factor\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n        factor += 1\n        if is_prime(factor):\n            if n % factor == 0:\n                last_factor = factor\n                n //= factor\n    return last_factor", "matching_cluster_idx": 6}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # Now n must be odd, start checking for factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_prime = factor\n            n //= factor\n        factor += 2\n    \n    # If n becomes a prime number > 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # Now n must be odd, start from 3 and remove all factors\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_prime = factor\n            n //= factor\n        factor += 2\n    \n    # If n became a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 92.20779220779221, "dps_norm": 62.5, "pass@1": 93.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith(('y', 'Y')):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the vowels set\n    vowels = set(\"aeiouAEIOU\")\n    # Count the vowels in the string\n    count = sum(1 for char in s if char in vowels)\n    # Check if 'y' or 'Y' is at the end and add to count if true\n    if s and (s[-1] in \"yY\"):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = sum(1 for char in s.lower() if char in vowels)\n    if s.endswith('Y') or s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith(('y', 'Y')):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1] in 'yY':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Count the number of vowels in the string.\n    Vowels include 'a', 'e', 'i', 'o', 'u', and 'y' only if it is at the end of the word.\n    \n    :param s: The input string representing a word.\n    :return: The number of vowels in the string.\n    \"\"\"\n    # Convert the string to lower case to make the function case-insensitive\n    s = s.lower()\n    # Define a set of vowels\n    vowels = set('aeiou')\n    # Initialize a counter for the number of vowels\n    count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # If the character is a vowel, increment the count\n        if char in vowels:\n            count += 1\n    # Check if the last character is 'y', if so, add 1 to the count\n    if s and s[-1] == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Count the number of vowels in the string. 'y' is considered a vowel\n    only if it is at the end of the word.\n    \n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"SYZYGY\")\n    1\n    >>> vowels_count(\"aeiouy\")\n    6\n    >>> vowels_count(\"bcdfghjkl\")\n    0\n    \"\"\"\n    vowels = 'aeiou'\n    count = sum(1 for char in s.lower() if char in vowels)\n    # Check if 'y' at the end and not already counted\n    if s and s[-1].lower() == 'y' and s[-1].lower() not in vowels:\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Return the number of vowels in the string.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' only at the end of the word.\n    \n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1] in 'yY':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1] in 'yY':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Returns the number of vowels in the string. Vowels are 'a', 'e', 'i', 'o', 'u',\n    and 'y' only when it is at the end of the given word.\n    \n    Args:\n        s (str): A string representing a word.\n\n    Returns:\n        int: The number of vowels in the string.\n    \"\"\"\n    vowels = 'aeiou'\n    count = sum(1 for char in s.lower() if char in vowels)\n    if s and s.lower()[-1] == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the vowels and initialize a counter\n    vowels = 'aeiouAEIOU'\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n            \n    # Check if the last character is 'y' or 'Y'\n    if s and s[-1] in 'yY':\n        count += 1\n            \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = sum(1 for char in s.lower() if char in vowels)\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Return the number of vowels in the string. Vowels in this case are\n    'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it\n    is at the end of the given word.\n\n    :param s: A string representing a word.\n    :return: An integer representing the number of vowels in the string.\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    count_lst1 = sum(len(s) for s in lst1)\n    count_lst2 = sum(len(s) for s in lst2)\n    \n    if count_lst1 <= count_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len_lst1 = sum(len(word) for word in lst1)\n    len_lst2 = sum(len(word) for word in lst2)\n\n    if len_lst1 <= len_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Return the list with fewer total characters or the first list if they are equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    count_lst1 = sum(len(s) for s in lst1)\n    count_lst2 = sum(len(s) for s in lst2)\n    \n    if count_lst1 <= count_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Count total number of characters in each list\n    count1 = sum(len(word) for word in lst1)\n    count2 = sum(len(word) for word in lst2)\n    \n    # Return the list with fewer total characters, or the first list if equal\n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    # Calculate total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # Compare total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    \n    if len1 <= len2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Count the total number of characters in each list\n    count1 = sum(len(s) for s in lst1)\n    count2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer total characters, or the first list if equal\n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    # Calculate the total number of chars in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # Return the first list if they have the same number of chars", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    # Calculate the total number of characters in lst1\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    # Calculate the total number of characters in lst2\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the totals and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # Return the first list if the totals are equal", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in each list\n    count1 = sum(len(word) for word in lst1)\n    count2 = sum(len(word) for word in lst2)\n    \n    # Return the list with fewer total characters, or the first list if equal\n    return lst1 if count1 <= count2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare and return the list with fewer total characters, or the first one if equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the list with fewer total characters, or the first list if they are equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    # Calculate the total number of chars in both lists\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Return the list with the fewer total chars, or the first list if they are equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    # Calculate total number of characters in both lists\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Return the list with fewer total characters, or the first list if equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 91.68316831683168, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to zero\n    total_sum = 0\n    \n    # Loop through the list, starting from index 1 (the second element), stepping by 2\n    for i in range(1, len(lst), 2):\n        # Check if the element at the odd index is even\n        if lst[i] % 2 == 0:\n            total_sum += lst[i]\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to zero\n    sum_even_at_odd_indices = 0\n    \n    # Loop through the list with index\n    for index in range(1, len(lst), 2):  # Start from 1 to consider odd indices\n        # Check if the element at the current odd index is even\n        if lst[index] % 2 == 0:\n            # Add the even number to the sum\n            sum_even_at_odd_indices += lst[index]\n    \n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total_sum = 0\n    for i in range(1, len(lst), 2):  # Start from 1 to check odd indices\n        if lst[i] % 2 == 0:\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize sum to zero\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index in range(1, len(lst), 2):  # Start from 1 to ensure we check odd indices\n        if lst[index] % 2 == 0:\n            total_sum += lst[index]\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Adds the even elements that are at odd indices in the given list of integers.\n    \n    :param lst: List of integers\n    :return: Sum of even elements at odd indices\n    \"\"\"\n    # Initialize the sum\n    sum_even = 0\n    \n    # Iterate through the list, starting from index 1 (second element), stepping by 2\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current odd index is even\n        if lst[i] % 2 == 0:\n            # Add it to the sum\n            sum_even += lst[i]\n    \n    return sum_even", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. Add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize sum of even elements at odd indices\n    sum_even_at_odd_indices = 0\n\n    # Loop through the list with index\n    for index in range(len(lst)):\n        # Check if the index is odd and the element at that index is even\n        if index % 2 != 0 and lst[index] % 2 == 0:\n            sum_even_at_odd_indices += lst[index]\n    \n    return sum_even_at_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    # Loop through the list, starting from the second element (index 1)\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, adds the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to zero\n    total = 0\n    \n    # Loop through the list, starting from the second element, with a step of 2\n    for i in range(1, len(lst), 2):\n        # Check if the current element is even\n        if lst[i] % 2 == 0:\n            # Add the even element to the total\n            total += lst[i]\n    \n    # Return the total sum of even elements at odd indices\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to zero\n    sum_even_at_odd_indices = 0\n\n    # Iterate through the list, starting from index 1 and incrementing by 2 to only check odd indices\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_even_at_odd_indices += lst[i]\n    \n    return sum_even_at_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Parameters:\n    lst (list of int): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even elements that are at odd indices in the list.\n    \"\"\"\n    # Initialize sum to 0\n    sum_even_at_odd_indices = 0\n\n    # Iterate over the list\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the sum\n            sum_even_at_odd_indices += value\n\n    return sum_even_at_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for index in range(len(lst)):\n        if index % 2 != 0 and lst[index] % 2 == 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize a variable to hold the sum of even elements at odd indices\n    sum_even_odd_indices = 0\n\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value at that index is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the sum\n            sum_even_odd_indices += value\n\n    return sum_even_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    sum_even_at_odd_indices = 0\n    \n    # Iterate over the list using index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            sum_even_at_odd_indices += value\n    \n    return sum_even_at_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    sum_even_at_odd_indices = 0\n\n    # Iterate over the list with both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            sum_even_at_odd_indices += value\n\n    return sum_even_at_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize sum to zero\n    total = 0\n    \n    # Iterate over the list, starting from the first odd index (1)\n    for index in range(1, len(lst), 2):\n        # Check if the current element is even\n        if lst[index] % 2 == 0:\n            # Add it to the total\n            total += lst[index]\n    \n    # Return the total sum of even elements at odd indices\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    sum_even_at_odd_indices = 0\n    \n    # Loop through the list using index\n    for index in range(len(lst)):\n        # Check if the index is odd and the element at that index is even\n        if index % 2 != 0 and lst[index] % 2 == 0:\n            # Add the element to the sum\n            sum_even_at_odd_indices += lst[index]\n    \n    # Return the sum of even elements at odd indices\n    return sum_even_at_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize sum to store the sum of even elements at odd indices\n    even_sum = 0\n\n    # Iterate through the list by index\n    for index in range(1, len(lst), 2):  # Start from 1 to target odd indices\n        if lst[index] % 2 == 0:  # Check if element is even\n            even_sum += lst[index]\n\n    return even_sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. Add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize sum\n    total = 0\n    \n    # Iterate through the list, starting from index 1, and considering every other element (odd indices)\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    \n    return total", "matching_cluster_idx": 3}]}, "HumanEval/86": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 90.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    :param s: String to be ordered\n    :return: Ordered string version\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    # Initialize a list to hold the ordered words\n    ordered_words = []\n    # Iterate over each word\n    for word in words:\n        # Sort the characters in the word and join them back into a string\n        sorted_word = ''.join(sorted(word))\n        # Append the sorted word to the list\n        ordered_words.append(sorted_word)\n    # Join the words back into a string with spaces in between\n    ordered_sentence = ' '.join(ordered_words)\n    return ordered_sentence", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Split the input string into words based on spaces\n    words = s.split(' ')\n    \n    # Initialize an empty list to hold the transformed words\n    transformed_words = []\n\n    # Iterate over each word\n    for word in words:\n        # Convert the word into a list of characters, sort it, then join back into a string\n        sorted_word = ''.join(sorted(word))\n        # Append the transformed word to the list\n        transformed_words.append(sorted_word)\n\n    # Join the transformed words back into a single string, separated by spaces\n    ordered_s = ' '.join(transformed_words)\n    \n    return ordered_s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Transform each word by sorting the characters\n    ordered_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the ordered words back into a string with spaces\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    :param s: input string\n    :return: ordered version of the input string\n    \"\"\"\n    # Split the input string into words based on spaces\n    words = s.split(' ')\n    # For each word, sort the characters and reconstruct the word\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Join the ordered words back into a string with spaces in between\n    ordered_string = ' '.join(ordered_words)\n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Split the input string into words based on space delimiter\n    words = s.split(' ')\n    \n    # Initialize a list to hold the transformed words\n    ordered_words = []\n    \n    # Loop through each word to rearrange its characters\n    for word in words:\n        # Sort the characters of the word based on ascii value and join them back\n        ordered_word = ''.join(sorted(word))\n        # Append the ordered word to the list of ordered words\n        ordered_words.append(ordered_word)\n    \n    # Join the ordered words back into a single string with spaces in between\n    ordered_sentence = ' '.join(ordered_words)\n    \n    return ordered_sentence", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Sort the characters in each word and join them back\n    ordered_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the ordered words back into a single string\n    ordered_string = ' '.join(ordered_words)\n    \n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    The ordered version is where characters in each word are arranged in\n    ascending order based on ascii value, preserving the order of words and blank spaces.\n    \"\"\"\n    def sort_word(word):\n        \"\"\"Sorts a single word based on ascii value.\"\"\"\n        return ''.join(sorted(word))\n    \n    # Splitting the string into words based on space\n    words = s.split(' ')\n    # Sorting each word and joining them back together with spaces\n    sorted_words = [sort_word(word) for word in words]\n    # Joining the sorted words back into a sentence\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_chars(word):\n        return ''.join(sorted(word))\n\n    return ' '.join([sort_chars(w) for w in s.split(' ')])", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns a version of it where each word\n    (words are separated by spaces) is reordered so that characters within\n    each word are sorted in ascending ASCII order.\n    The function keeps the original order of words and spaces.\n    \n    Parameters:\n    s (str): The input string to be processed.\n    \n    Returns:\n    str: The processed string with each word's characters sorted.\n    \"\"\"\n    # Split the string into words, keeping the spaces intact\n    words = s.split(' ')\n    # Sort characters in each word\n    sorted_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back into a string\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version means all characters in each word (separated by space)\n    are arranged in ascending order based on ascii value.\n    Blank spaces and order of words are preserved.\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort characters in each word and join them back to form a sorted word\n    ordered_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the ordered words back into a single string\n    ordered_str = ' '.join(ordered_words)\n    \n    return ordered_str", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        # Sort the characters in the word and return the new word.\n        return ''.join(sorted(word))\n    \n    # Split the string into words, sort each word, and join them back.\n    return ' '.join(sort_word(word) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    # For each word, sort the characters and join them back\n    sorted_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back into a single string\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    The words in the ordered string have their characters sorted in ascending order based on ASCII value.\n    The order of words and blank spaces in the sentence is preserved.\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    # Sort each word's characters and join them back into a word\n    sorted_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back into a sentence\n    ordered_string = ' '.join(sorted_words)\n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    In the ordered version, characters in each word are sorted based on ascii value.\n    Spaces and the order of words are preserved.\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Initialize an empty list to store the modified words\n    ordered_words = []\n    \n    # Loop through each word in the list\n    for word in words:\n        # Sort the characters in the word based on ascii value and join them back into a string\n        sorted_word = ''.join(sorted(word))\n        # Append the ordered word to the list\n        ordered_words.append(sorted_word)\n    \n    # Join the ordered words back into a string with spaces in between\n    ordered_s = ' '.join(ordered_words)\n    \n    # Return the ordered string\n    return ordered_s", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Writes a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Splitting the string into words\n    words = s.split(' ')\n    # Processing each word to sort the characters\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Joining the words back into a single string\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    # Order each word and maintain the order of words\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Join the ordered words back into a string\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [\"\".join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in ascending\n    order based on ascii value.\n    Note: Keeps the order of words and blank spaces in the sentence.\n\n    :param s: The input string to be transformed.\n    :return: The transformed string with ordered characters in each word.\n    \"\"\"\n    # Split the input string into words, keeping the order and blank spaces\n    words = s.split(' ')\n    # Transform each word by sorting its characters\n    transformed_words = [''.join(sorted(word)) for word in words]\n    # Join the transformed words back into a string\n    return ' '.join(transformed_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Initialize the list that will hold the transformed words\n    ordered_words = []\n    \n    # Iterate over each word in the input string\n    for word in words:\n        # Sort the characters of the word and join them back into a string\n        ordered_word = ''.join(sorted(word))\n        # Append the ordered word to the list of ordered words\n        ordered_words.append(ordered_word)\n    \n    # Join the ordered words back into a single string with spaces\n    result = ' '.join(ordered_words)\n    \n    return result", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 97.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    Find occurrences of integer x in a nested list and return their coordinates sorted.\n    \"\"\"\n    # List to store coordinates of the found elements.\n    coordinates = []\n\n    # Iterate through the list to find the occurrences of x.\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort coordinates by row in ascending order and then by column in descending order within each row.\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list and an integer x, this function finds the integer x in the list\n    and returns a sorted list of tuples (coordinates), where each tuple is a (row, column)\n    coordinate of x. The coordinates are sorted by row in ascending order and by column in\n    descending order within the same row.\n    \"\"\"\n    # Find the coordinates of x\n    coordinates = [(i, j) for i, row in enumerate(lst) for j, value in enumerate(row) if value == x]\n\n    # Sort the coordinates by row in ascending and by column in descending order\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n\n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds integers x in the given nested list and returns their coordinates\n    sorted by row in ascending order and column in descending order within rows.\n    \"\"\"\n    # Find coordinates of x in the list\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort coordinates by row in ascending order, column in descending order within rows\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n    \n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Searches for integer x in the given 2D list (lst) and returns\n    a list of tuples representing coordinates of the found items.\n    Coordinates are sorted by rows in ascending order and by columns\n    in descending order within each row.\n    \"\"\"\n    found_items = []\n    \n    # Loop through each row and its index\n    for row_index, row in enumerate(lst):\n        # Loop through each column and its index in the row\n        for col_index, value in enumerate(row):\n            # If the value matches the integer x, store the coordinates\n            if value == x:\n                found_items.append((row_index, col_index))\n    \n    # Sort the list of found items by row in ascending order\n    # and by column in descending order within each row\n    found_items.sort(key=lambda item: (item[0], -item[1]))\n    \n    return found_items", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    This function searches through a 2D list with variable column lengths\n    and finds all occurrences of the integer x, returning their coordinates\n    as tuples. Coordinates are sorted by rows in ascending order and by columns\n    in descending order within each row.\n    \"\"\"\n    # List to hold the coordinates of found x values\n    coordinates = []\n    \n    # Loop through each row in the list\n    for row_index, row in enumerate(lst):\n        # Loop through each column in the row\n        for col_index, value in enumerate(row):\n            # If the value matches x, add its coordinates to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates: by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the occurrence of integer x in the given nested list and returns the coordinates\n    sorted by row in ascending order and by column in descending order within each row.\n    \n    :param lst: A 2D list with potentially varying column lengths.\n    :param x: The integer to find in the list.\n    :return: A list of tuples with coordinates of found x values.\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    # Sort by row in ascending order and column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Searches for the occurrences of integer x in the given nested list and returns\n    the coordinates of these occurrences sorted by rows in ascending order and\n    by columns in descending order within the same row.\n    \"\"\"\n    result = []\n    # Iterate over the list to find occurrences of x\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    # Sort the result based on row in ascending order\n    # and by column in descending order within each row\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer x in the given 2D list (lst),\n    and returns a list of their coordinates sorted by specified criteria.\n    \"\"\"\n    # This list will hold tuples of (row, column) indices\n    coordinates = []\n\n    # Iterate over the list with row index and row itself\n    for row_idx, row in enumerate(lst):\n        # Iterate over the row with column index and column value\n        for col_idx, value in enumerate(row):\n            # If the value matches x, add the indices to coordinates\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort coordinates by row in ascending order, column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in the nested list and returns the coordinates of x.\n    The coordinates are sorted by rows in ascending order and by columns in descending order.\n    \"\"\"\n    # Find coordinates of x\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, elem in enumerate(row):\n            if elem == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort coordinates initially by rows in ascending order,\n    # and then by columns in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Searches for occurrences of x in the 2D list lst and returns the coordinates in a specified format.\n    \"\"\"\n    # Collecting the coordinates where the element equals to x\n    coordinates = [(row_index, col_index) for row_index, row in enumerate(lst)\n                   for col_index, element in enumerate(row) if element == x]\n    \n    # Sorting the coordinates\n    # First by row in ascending order, then by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Searches for the integer x in a 2D list (nested lists) and returns the coordinates of x in the list.\n    The coordinates are sorted by rows in ascending order and by columns in descending order within each row.\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    # Sorting by row in ascending order and by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \"\"\"\n    # Initialize a list to store the coordinates\n    coordinates = []\n\n    # Iterate over the list with both index and row\n    for row_index, row in enumerate(lst):\n        # Iterate over the row to find the value x\n        for col_index, value in enumerate(row):\n            if value == x:\n                # Append the found coordinate as a tuple to the list\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by row in ascending and by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    This function finds occurrences of integer x in a 2D nested list,\n    where rows may have different lengths. It returns a list of coordinates,\n    where each coordinate is a tuple (row, column). Coordinates are sorted\n    by rows in ascending order, and within each row, by columns in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the list\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row\n        for col_index, elem in enumerate(row):\n            # If the element is equal to the given integer x, add its coordinate to the list\n            if elem == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by row in ascending order and by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Sort by row in ascending order and by column in descending order within each row\n    return sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in a nested list and returns the coordinates of each occurrence.\n    Sorts the coordinates by rows in ascending order and within rows by columns in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of found integers.\n    coordinates = []\n    \n    # Iterate over the list with both row index and its content.\n    for row_index, row in enumerate(lst):\n        # Iterate over the row with both column index and its content.\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x.\n            if element == x:\n                # If yes, append its coordinate to the coordinates list.\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by row in ascending order.\n    # Within the same row, sort by column in descending order.\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the coordinates of integer x in the 2D list 'lst',\n    and returns a list of tuples sorted by rows in ascending order\n    and by columns in descending order within each row.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, item in enumerate(row):\n            if item == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates by row in ascending order and by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds occurrences of x in the given 2D list and returns their coordinates.\n    Sorts the coordinates first by rows in ascending order and then by columns in descending order within each row.\n    \"\"\"\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sorting by row in ascending order, then by column in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list and an integer x, return a list of tuples with\n    coordinates of occurrences of x in the list. Coordinates are sorted\n    first by rows in ascending order and then by columns in descending order.\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, item in enumerate(row):\n            if item == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list (nested lists) and an integer x, find all occurrences of x,\n    and return a list of tuples indicating the coordinates of those occurrences.\n    The coordinates are sorted by rows in ascending order, and within each row,\n    sorted by columns in descending order.\n    \"\"\"\n    coordinates = []\n    # Iterate over the list to find the occurrences of x\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                coordinates.append((i, j))\n    # Sorting the coordinates as specified\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Searches for integer x in a 2D list (nested lists) and returns the coordinates\n    of each occurrence of x, sorted by rows in ascending order and columns in descending order.\n    \"\"\"\n    # Find and collect the coordinates\n    coordinates = [(i, j) for i, sublist in enumerate(lst) for j, value in enumerate(sublist) if value == x]\n    \n    # Sort the coordinates first by rows (ascending) then by columns (descending)\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n    \n    return sorted_coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 97.15206185567011, "dps_norm": 45.0, "pass@1": 99.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet by four places.\"\"\"\n    # Define the alphabet and the rotated alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = 'efghijklmnopqrstuvwxyzabcd'\n    \n    # Create a translation table\n    translation_table = str.maketrans(alphabet, rotated_alphabet)\n    \n    # Encrypt the string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 6}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by rotating the alphabet letters \n    by four places down (2*2).\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_s = ''\n    for char in s:\n        if char in alphabet:\n            # Find the original index and apply the shift, wrapping around if necessary\n            shifted_index = (alphabet.index(char) + 4) % len(alphabet)\n            encrypted_s += alphabet[shifted_index]\n        else:\n            # Handle characters not in the alphabet (like spaces or punctuation)\n            encrypted_s += char\n    return encrypted_s", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a string by rotating the alphabet.\n    \n    The rotation is such that each letter is replaced by a letter\n    two times two places down the alphabet. Wraps around the end\n    of the alphabet.\n    \n    Args:\n        s (str): The input string to encrypt.\n        \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 2 * 2  # Two multiplied by two\n    encrypted_str = ''\n    \n    for char in s:\n        if char in alphabet:\n            # Find the index of the current character and apply the shift\n            new_index = (alphabet.index(char) + shift) % len(alphabet)\n            encrypted_str += alphabet[new_index]\n        else:\n            # If character is not a lowercase letter, just append it as is\n            encrypted_str += char\n            \n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet.\n    \n    The alphabet is rotated by 4 places (2*2) to the right.\n    Only lowercase alphabetic characters are encrypted.\n    \n    Parameters:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    shift = 4  # Two multiplied by two\n    encrypted = []\n    \n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate the new character after shifting\n            new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            encrypted.append(new_char)\n        else:\n            # Non-alphabetic characters are not encrypted\n            encrypted.append(char)\n    \n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a string by rotating the alphabet by 4 places.\"\"\"\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate the new position, with wrap around using modulo\n            new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            result.append(new_char)\n        else:\n            # Non-alphabet characters are kept as is\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the given string by rotating the alphabet down by four places.\n    \n    Args:\n        s (str): The string to be encrypted.\n        \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    # The alphabet string\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # The encrypted alphabet string, rotated down by four places\n    rotated_alphabet = alphabet[4:] + alphabet[:4]\n    # The encrypted string\n    encrypted_string = ''\n    for char in s:\n        if char in alphabet:\n            index = alphabet.index(char)\n            encrypted_string += rotated_alphabet[index]\n        else:\n            encrypted_string += char  # Append non-alphabetic characters as they are\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a given string by rotating the alphabet by 4 places.\"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    \n    # Loop through each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Find the new position after shifting 4 places down\n            new_pos = (alphabet.index(char) + 4) % 26\n            encrypted += alphabet[new_pos]\n        else:\n            # If the character is not in the alphabet, leave it as is\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a given string s by rotating the alphabet.\n    \n    Each letter in the input string is shifted down by 4 places\n    (2 multiplied by 2) in the alphabet. The alphabet wraps around\n    such that after 'z', it continues from 'a'.\n    \n    Args:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate the new character after shifting\n            new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(new_char)\n        else:\n            # If not a letter, append as it is\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string s by rotating each letter down the alphabet \n    by 4 places (2 * 2).\n    \"\"\"\n    # Define the alphabet and an empty result string\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    result = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Calculate the new position, wrap around using modulo\n            new_pos = (alphabet.index(char) + 4) % 26\n            result += alphabet[new_pos]\n        else:\n            # Handle non-alphabetic characters by leaving them as-is\n            result += char\n            \n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by rotating the alphabet.\n    Each character is shifted by four places down the alphabet.\n    \"\"\"\n    # Define the alphabet and the shifted alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    \n    # Create a dictionary to map each letter to its encrypted version\n    encryption_map = dict(zip(alphabet, shifted_alphabet))\n    \n    # Encrypt the input string\n    encrypted_string = ''.join(encryption_map.get(c, c) for c in s)\n    \n    return encrypted_string", "matching_cluster_idx": 2}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the given string by rotating the alphabet by 4 places.\n    \n    Args:\n        s (str): The input string to encrypt.\n        \n    Returns:\n        str: The encrypted string with the alphabet rotated by 4 places.\n    \"\"\"\n    # Define the alphabet and the rotated alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = alphabet[4:] + alphabet[:4]\n    \n    # Create a translation table\n    translation_table = str.maketrans(alphabet, rotated_alphabet)\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by rotating the alphabet by four places.\"\"\"\n    encrypted_str = \"\"\n    for char in s:\n        # Check if character is a lowercase letter\n        if 'a' <= char <= 'z':\n            # Calculate the new character, wrapping around the alphabet if necessary\n            new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted_str += new_char\n        else:\n            # If the character is not a lowercase letter, leave it unchanged\n            encrypted_str += char\n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a given string by rotating the alphabet by four places.\"\"\"\n    # Define the alphabet and the rotated alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = alphabet[4:] + alphabet[:4]\n    \n    # Create a translation table between the normal and rotated alphabets\n    translation_table = str.maketrans(alphabet, rotated_alphabet)\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a given string by rotating the alphabet down by four places.\n    \n    Args:\n        s (str): The string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_str = ''\n    for char in s:\n        if char in alphabet:\n            new_index = (alphabet.index(char) + 4) % len(alphabet)\n            encrypted_str += alphabet[new_index]\n        else:\n            encrypted_str += char  # Keep non-alphabet characters as is.\n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string with a rotated alphabet. The rotation\n    is defined as a shift down by two multiplied by two places.\n    \n    Args:\n    s (str): The input string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the shift value\n    shift = 2 * 2\n    \n    # Convert the string to the encrypted string\n    encrypted_string = \"\"\n    for char in s:\n        if char.isalpha():\n            # Calculate the shifted character\n            shifted_char = ord(char) + shift\n            # Wrap around if necessary\n            if char.islower():\n                if shifted_char > ord('z'):\n                    shifted_char -= 26\n            elif char.isupper():\n                if shifted_char > ord('Z'):\n                    shifted_char -= 26\n            encrypted_string += chr(shifted_char)\n        else:\n            # If not an alphabet character, keep as is\n            encrypted_string += char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by rotating the alphabet by four places.\n    \n    Args:\n        s (str): The input string to be encrypted.\n        \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    # Define the alphabet and the rotated alphabet by four places\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = alphabet[4:] + alphabet[:4]\n    \n    # Create a translation table\n    translation_table = str.maketrans(alphabet, rotated_alphabet)\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a given string by rotating the alphabet down by four places.\"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_str = ''\n    \n    # Iterate through each character in the string\n    for char in s:\n        if char in alphabet:\n            # Find the current character's index and apply the shift\n            index = (alphabet.index(char) + 4) % len(alphabet)\n            encrypted_str += alphabet[index]\n        else:\n            # Keep non-alphabetic characters as is\n            encrypted_str += char\n            \n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a string with a rotated alphabet.\n    \n    The alphabet is rotated by 4 places down (2 multiplied by 2).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = alphabet[4:] + alphabet[:4]  # Rotate by 4 places\n    encrypted_string = ''\n    \n    for char in s:\n        if char in alphabet:\n            index = alphabet.index(char)\n            encrypted_string += rotated_alphabet[index]\n        else:\n            encrypted_string += char  # Non-alphabet characters remain unchanged\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s: str) -> str:\n    \"\"\"\n    Encrypts a given string by rotating the alphabet by four places.\n    Each letter in the input string is replaced by the letter four places\n    down the alphabet.\n    \n    Parameters:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_str = ''\n    for char in s:\n        if char in alphabet:\n            new_pos = (alphabet.index(char) + 4) % 26\n            encrypted_str += alphabet[new_pos]\n        else:\n            encrypted_str += char\n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet by 4 places.\"\"\"\n    # Define the alphabet and the rotated alphabet\n    original_alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = 'efghijklmnopqrstuvwxyzabcd'\n\n    # Create a translation table\n    translation_table = str.maketrans(original_alphabet, rotated_alphabet)\n\n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n\n    return encrypted_string", "matching_cluster_idx": 6}]}, "HumanEval/90": {"dps": 87.54863813229572, "dps_norm": 58.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Convert the list to a set to remove duplicates and then back to a sorted list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if the list has at least two unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    else:\n        return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting to a set, then back to a sorted list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    else:\n        # Return the second element in the sorted list\n        return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates and check if we have at least 2 unique elements\n    unique_lst = list(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    # Sort the list and return the 2nd element\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting to a set, then back to list for sorting\n    unique_lst = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_lst) < 2:\n        return None\n    else:\n        # Return the second smallest element\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    # Check if the list has at least 2 unique elements\n    if len(sorted_unique_lst) < 2:\n        return None\n    else:\n        return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates to handle cases where all elements are the same\n    unique_lst = list(set(lst))\n    # Check if there are at least 2 unique elements\n    if len(unique_lst) < 2:\n        return None\n    # Sort the unique list and return the second element\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates and check if there's a second smallest element\n    unique_elements = list(set(lst))\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_numbers = list(set(lst))\n    if len(unique_numbers) < 2:\n        return None\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    \n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_lst = sorted(set(lst))\n    \n    # Check if there is a second smallest element\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_lst = sorted(set(lst))\n    # Check if there's at least 2 unique elements\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Finds the second smallest element in a list of integers.\n    Returns None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    sorted_elements = sorted(unique_elements)\n    return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Convert the list into a set to remove duplicates then back to list\n    unique_list = list(set(lst))\n    \n    # Check if we have at least 2 unique elements\n    if len(unique_list) < 2:\n        return None\n    \n    # Sort the unique elements to find the second smallest\n    unique_list.sort()\n    \n    # Return the second element in the sorted unique list\n    return unique_list[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    \n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Finds the 2nd smallest element in the list lst.\n    \n    :param lst: List of integers.\n    :return: The 2nd smallest element if exists, otherwise None.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    sorted_elements = sorted(unique_elements)\n    return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Check if the list is too short to have a 2nd smallest element\n    if len(lst) < 2:\n        return None\n\n    # Convert the list to a set to remove duplicates, then back to a sorted list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if after removing duplicates we have at least two different elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # Return the second element from the sorted unique list\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates and handle empty list or list with a single element\n    unique_lst = list(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    \n    # Sort the list and return the second element\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting to a set, then back to a sorted list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if there is a second smallest element\n    if len(unique_sorted_lst) < 2:\n        return None\n    else:\n        return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting to a set then back to a list\n    unique_lst = list(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_lst) < 2:\n        return None\n    \n    # Sort the list and return the second item\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 97.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for string in lst:\n        count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output_string = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    output = []\n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        template = \"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\"\n        result = template.format(odd_count)\n        output.append(result)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n    \n    for string in lst:\n        # Count the number of odd digits in the current string\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        # Use the counted odd number in the template replacing all occurrences of '{}'\n        result.append(template.format(odd_count, odd_count, odd_count, odd_count))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(int(digit) % 2 for digit in s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    output = []\n    template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n    for s in lst:\n        odd_count = sum(int(digit) % 2 for digit in s)\n        output.append(template.format(odd_count, odd_count, odd_count, odd_count))\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for string in lst:\n        # Count the number of odd digits in the current string\n        odd_digits_count = sum(int(char) % 2 for char in string)\n        # Construct the resulting string with replaced numbers\n        template = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        result.append(template)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \n    \"the number of odd elements in the string i of the input.\" \n    where all the i's should be replaced by the number of odd digits \n    in the i'th string of the input.\n    \"\"\"\n    output = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        \n        # Create the output string with the odd count replacing i\n        output_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        output.append(output_str)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        # Create the result string replacing 'i' with odd_count\n        result_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(result_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    # Define the template string\n    template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n    result = []\n    \n    # Iterate through each string in the list\n    for string in lst:\n        # Count the odd numbers in the string\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        # Replace all instances of the odd count in the template string\n        result_string = template.format(odd_count, odd_count, odd_count, odd_count)\n        # Append the formatted string to the result list\n        result.append(result_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Takes a list of strings containing only digits and returns a list of strings\n    where each element describes the number of odd digits in the corresponding\n    string of the input list with all 'i's replaced by the count of odd digits.\n    \n    Args:\n    lst (list): List of strings containing only digit characters.\n    \n    Returns:\n    list: List of strings describing the odd digit count in each input string.\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for char in s if int(char) % 2 != 0)\n        output_str = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    output = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        formatted_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        output.append(formatted_string)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        output_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for num_str in lst:\n        odd_count = sum(1 for digit in num_str if int(digit) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        result.append(template.format(odd_count, odd_count, odd_count, odd_count))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    output = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        output.append(result)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    output = []\n    template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output.append(template.format(odd_count, odd_count, odd_count, odd_count))\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        result.append(template.format(odd_count, odd_count, odd_count, odd_count))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        result.append(template.format(count, count, count, count))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings (each string consists of only digits), returns a list.\n    Each element in the output corresponds to an element in the input list and\n    is a string stating the number of odd digits in the input string, with 'i' in\n    the sentence replaced by the count of odd digits.\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits_count = sum(1 for c in s if int(c) % 2 != 0)\n        output_str = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits,\n    return a list of formatted strings based on the number of odd digits.\"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 40.542635658914726, "dps_norm": 49.333333333333336, "pass@1": 15.0, "profiled": [{"solution": "def match_parens(lst):\n    # Check both concatenation orders\n    for order in [lst, lst[::-1]]:\n        balance = 0\n        for char in ''.join(order):\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            # If at any point the balance goes negative, parentheses are not balanced\n            if balance < 0:\n                break\n        else:  # If the loop didn't break, check if the balance is zero\n            if balance == 0:\n                return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Try both possible concatenations\n    return 'Yes' if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Function to check balance of parentheses in a string\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Concatenate in both possible orders and check if either is balanced\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Try concatenating in both possible orders\n    if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    open_count = lst[0].count('(') + lst[1].count('(')\n    close_count = lst[0].count(')') + lst[1].count(')')\n    \n    # The string can be balanced if and only if the number of\n    # open and close parentheses are equal\n    if open_count != close_count:\n        return 'No'\n    \n    # Check if concatenation in either order is balanced\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'\ndef is_balanced(s):\n    '''\n    Helper function to check if the string s has balanced parentheses.\n    '''\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        # If at any point balance is negative, we have more closing\n        # parenthesis before opening ones, thus not balanced\n        if balance < 0:\n            return False\n    return balance == 0", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    open_count = lst[0].count('(') + lst[1].count('(')\n    close_count = lst[0].count(')') + lst[1].count(')')\n\n    # For the string to be balanced, open and close counts must be equal\n    if open_count != close_count:\n        return 'No'\n\n    # Check if concatenating in either order results in a valid string\n    for s1, s2 in [(lst[0], lst[1]), (lst[1], lst[0])]:\n        balance = 0\n        for char in s1 + s2:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                break\n        if balance == 0:\n            return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_good(str):\n        balance = 0\n        for char in str:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    s1, s2 = lst\n    open_count_s1, close_count_s1 = s1.count('('), s1.count(')')\n    open_count_s2, close_count_s2 = s2.count('('), s2.count(')')\n\n    # Try concatenating in both orders\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    # Counters for open and close parentheses\n    open_count, close_count = 0, 0\n    \n    # Count open and close parentheses in both strings\n    for s in lst:\n        for char in s:\n            if char == '(':\n                open_count += 1\n            else:\n                close_count += 1\n    \n    # Check if they can form a balanced string\n    # If total open and close parentheses are equal\n    # and no prefix has more closing parentheses than opening ones\n    if open_count != close_count:\n        return 'No'\n    \n    # Check if any of the strings is valid by itself\n    # or by appending one to the other\n    for string_order in [lst, lst[::-1]]:\n        balance = 0\n        for s in string_order:\n            for char in s:\n                if char == '(':\n                    balance += 1\n                else:\n                    balance -= 1\n                if balance < 0:\n                    break\n            if balance < 0:\n                break\n        if balance == 0:\n            return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    open_count = lst[0].count('(') + lst[1].count('(')\n    close_count = lst[0].count(')') + lst[1].count(')')\n    \n    # Check if total number of open and close parentheses are equal\n    if open_count != close_count:\n        return 'No'\n    \n    # Check if concatenation in any order results in a balanced string\n    for order in [lst, lst[::-1]]:\n        balance = 0\n        for s in order:\n            for char in s:\n                if char == '(':\n                    balance += 1\n                else:\n                    balance -= 1\n                # If balance goes negative, parentheses are not balanced\n                if balance < 0:\n                    break\n            if balance < 0:\n                break\n        if balance == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it is possible to concatenate two strings consisting of only\n    parentheses in some order to form a balanced string.\n    Returns 'Yes' if possible, 'No' otherwise.\n    '''\n    # Counters for open and close parentheses\n    open_count = 0\n    close_count = 0\n    \n    # Count the number of open and close parentheses in both strings\n    for s in lst:\n        for char in s:\n            if char == '(':\n                open_count += 1\n            else:\n                close_count += 1\n    \n    # A balanced string must have the same number of open and close parentheses\n    if open_count != close_count:\n        return 'No'\n    \n    # Check the first combination\n    balance = 0\n    for char in lst[0] + lst[1]:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            break\n    if balance == 0:\n        return 'Yes'\n    \n    # Check the second combination\n    balance = 0\n    for char in lst[1] + lst[0]:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            break\n    if balance == 0:\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def match_parens(lst):\n    # Function to check if the given string of parentheses is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Concatenate in both possible orders and check if either is balanced\n    str1, str2 = lst\n    if is_balanced(str1 + str2) or is_balanced(str2 + str1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Count open and closed parentheses in both strings\n    open_parens = sum(s.count('(') for s in lst)\n    close_parens = sum(s.count(')') for s in lst)\n    \n    # If the numbers of open and close parentheses are not equal, it cannot be balanced\n    if open_parens != close_parens:\n        return 'No'\n    \n    # Check if any of the two concatenated strings is balanced\n    for s in [lst[0] + lst[1], lst[1] + lst[0]]:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            # If balance goes negative, then there are more closing brackets than opening ones\n            if balance < 0:\n                break\n        else:\n            # If loop didn't break, balance is not negative at any point and is zero at the end\n            if balance == 0:\n                return 'Yes'\n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    first, second = lst[0], lst[1]\n    balance = 0\n    # Check if both strings can be concatenated in either order to be balanced\n    for char in first + second:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            break\n    # If balance is not zero, the first order doesn't work; try reversing the order\n    if balance != 0:\n        balance = 0\n        for char in second + first:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                break\n    return 'Yes' if balance == 0 else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    open_count = lst[0].count('(') + lst[1].count('(')\n    close_count = lst[0].count(')') + lst[1].count(')')\n    \n    # If total open and close parentheses are not equal, they can't be balanced\n    if open_count != close_count:\n        return 'No'\n    \n    # Check both possible concatenations\n    for strings in [lst, lst[::-1]]:\n        balance = 0\n        for char in ''.join(strings):\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            # If at any point balance is negative, it means there are more closing\n            # parentheses than opening ones before, which makes it unbalanced\n            if balance < 0:\n                break\n        else:\n            # If the loop didn't break, it means we found a balanced string\n            return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Function to check if it's possible to concatenate two given strings\n    of parentheses in some order to form a balanced string.\n    '''\n    # Counting open and close parentheses in both strings\n    open_parentheses = lst[0].count('(') + lst[1].count('(')\n    close_parentheses = lst[0].count(')') + lst[1].count(')')\n    \n    # If the total number of open parentheses is not equal to the total\n    # number of close parentheses, then it's impossible to form a balanced string\n    if open_parentheses != close_parentheses:\n        return 'No'\n    \n    # Check concatenation in both orders\n    for order in (lst, lst[::-1]):\n        balance = 0\n        for s in order:\n            for char in s:\n                if char == '(':\n                    balance += 1\n                else:\n                    balance -= 1\n                # If balance goes negative, parentheses are not balanced\n                if balance < 0:\n                    break\n            if balance < 0:\n                break\n        else:\n            return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 0}]}, "HumanEval/120": {"dps": 58.62068965517241, "dps_norm": 88.57142857142857, "pass@1": 47.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and slice the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted_arr in ascending order as the final result\n    return sorted(sorted_arr)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and slice the top k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of length k\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List[int], a list of integers.\n    :param k: int, the number of maximum values to return.\n    :return: List[int], a sorted list of the k largest numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and take the first k elements.\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of the k largest numbers.\n    return sorted(sorted_arr)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and slice the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Sort the sliced list in ascending order to match the expected output format\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in ascending order and then take the last k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of the maximum k elements\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Slice the first k elements\n    max_k_elements = sorted_arr[:k]\n    # Sort the result before returning\n    return sorted(max_k_elements)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and slice the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Sort the result in ascending order before returning as per the examples\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in descending order and slice the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of k maximum elements\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List[int] - a list of integers.\n    :param k: int - a positive integer indicating the number of maximum elements to return.\n    :return: List[int] - a sorted list of the maximum k elements.\n    \"\"\"\n    # Check edge cases\n    if k == 0:\n        return []\n    if k >= len(arr):\n        k = len(arr)\n    \n    # Sort the array and return the last k elements\n    arr.sort()\n    return arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Take the first k elements\n    result = sorted_arr[:k]\n    # Return the result sorted in ascending order\n    return sorted(result)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in ascending order and slice the last k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the k largest elements in ascending order\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and pick the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of length k in ascending order\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array and take the last k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of the k largest elements\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in ascending order\n    arr.sort()\n    \n    # Slice the last k elements, which are the largest\n    result = arr[-k:]\n    \n    # Return the result in ascending order\n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and slice the first k elements\n    sorted_arr = sorted(arr, reverse=True)\n    top_k_elements = sorted_arr[:k]\n    \n    # Sort the top_k_elements before returning to meet the output requirement\n    return sorted(top_k_elements)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Slice the first k elements\n    result = sorted_arr[:k]\n    # Return the sorted (ascending) list of the result\n    return sorted(result)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and slice the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted (ascending) top k elements\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Take the first k elements\n    result = sorted_arr[:k]\n    # Return the result sorted in ascending order as per the example\n    return sorted(result)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and then slice it to get the top k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted (ascending order) result as required\n    return sorted(sorted_arr)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements from the sorted array\n    max_k_elements = sorted_arr[:k]\n    \n    # Return the k elements sorted in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 5}]}, "HumanEval/121": {"dps": 84.12556053811659, "dps_norm": 62.85714285714286, "pass@1": 91.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Sum of all odd elements in even positions (0-indexed list, so these are actually odd positions in 1-indexed perspective)\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum odd elements at even positions. List indices start at 0 in Python,\n    # so we use step 2 to iterate over even indices (0, 2, 4, ...),\n    # and check if the element is odd before adding it to the sum.\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize sum of odd elements in even positions\n    sum_odds = 0\n    \n    # Iterate over the list, starting from the first element (index 0), with a step of 2 to cover even positions\n    for i in range(0, len(lst), 2):\n        # Check if the element is odd\n        if lst[i] % 2 != 0:\n            # Add it to the sum\n            sum_odds += lst[i]\n    \n    return sum_odds", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum to zero\n    sum_odd = 0\n    # Loop over the elements in the list, starting from the first element (index 0) and stepping by 2 for even positions\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current even position is odd\n        if lst[i] % 2 != 0:\n            # Add it to the sum\n            sum_odd += lst[i]\n    # Return the computed sum\n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum all odd elements at even positions (0-based index)\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate through list with index starting at 0 (even position) and step by 2 (even positions)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even position is odd\n        if lst[i] % 2 != 0:\n            # Add odd element to the sum\n            total_sum += lst[i]\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to zero\n    total_sum = 0\n    \n    # Loop through the list using index, to check for positions\n    for index in range(len(lst)):\n        # Check if the index is even and the element is odd\n        if index % 2 == 0 and lst[index] % 2 != 0:\n            total_sum += lst[index]\n            \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate through the list, starting from the first element (index 0), considering every second element\n    for i in range(0, len(lst), 2):\n        # Check if the current element is odd\n        if lst[i] % 2 != 0:\n            total_sum += lst[i]\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # We use list comprehension to filter the elements where:\n    # - the index is even (index % 2 == 0 considering Python's 0-based indexing)\n    # - the element at that index is odd (element % 2 != 0)\n    # Then we sum them up.\n    return sum(lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    sum_of_odds = 0\n    \n    # Iterate through the list with index\n    for i in range(len(lst)):\n        # Check if the index is even and the element is odd\n        if i % 2 == 0 and lst[i] % 2 == 1:\n            sum_of_odds += lst[i]\n    \n    return sum_of_odds", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Sum all odd elements that are in even positions (0-based index, so actual even positions are odd in 1-based index)\n    return sum(element for index, element in enumerate(lst) if index % 2 == 0 and element % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Initialize sum to 0\n    sum_of_odds = 0\n    # Iterate through the list, starting from index 0 (first element) and stepping by 2 (even positions)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even position is odd\n        if lst[i] % 2 != 0:\n            # Add it to the sum\n            sum_of_odds += lst[i]\n    return sum_of_odds", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, returns the sum of all of the odd elements that are in even positions.\n    \n    Parameters:\n    lst (list): A list of integers\n    \n    Returns:\n    int: The sum of odd elements that are in even positions.\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Since list indices are 0-based in Python, we need to iterate over the list\n    # using indices that represent even positions from a 1-based perspective, which\n    # are actually odd in the 0-based index system.\n    return sum(element for index, element in enumerate(lst) if index % 2 == 0 and element % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n\n    # Loop through the list with index and value\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total\n            total += value\n\n    # Return the computed sum\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    sum_of_odds = 0\n    \n    # Loop through the list, considering only even indices (0, 2, 4, ...)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even index is odd\n        if lst[i] % 2 != 0:\n            # Add it to the sum\n            sum_of_odds += lst[i]\n    \n    return sum_of_odds", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum to zero\n    sum_odd_even_positions = 0\n    \n    # Iterate through the list, considering only even positions (index 0, 2, 4, ...)\n    for index in range(0, len(lst), 2):\n        # Check if the element is odd\n        if lst[index] % 2 != 0:\n            # Add it to the sum\n            sum_odd_even_positions += lst[index]\n    \n    return sum_odd_even_positions", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum\n    total_sum = 0\n    \n    # Iterate over the list with index and element\n    for index, value in enumerate(lst):\n        # Check if the index is even (0-based) and the element is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n            \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, returns the sum of all of the odd elements that are in even positions.\n    \n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The sum of all odd elements that are in even positions.\n    \"\"\"\n    # Start the sum at 0\n    total = 0\n\n    # Iterate through the list, indexing by position\n    for index in range(len(lst)):\n        # Check if the position is even and the element is odd\n        if index % 2 == 0 and lst[index] % 2 != 0:\n            total += lst[index]\n\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 86.53543307086615, "dps_norm": 59.28571428571429, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \"\"\"\n    # Remove strings with odd lengths and sort the resulting list\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \"\"\"\n    # Remove strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length, then alphabetically\n    filtered_list.sort(key=lambda x: (len(x), x))\n    return filtered_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by the length of the strings, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length of the string, and alphabetically for strings of same length\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\"\"\"\n    # Filter out the strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length and alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Keep only the strings with even lengths and sort by length, then alphabetically if lengths are equal\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Sorts the list of strings by their length in ascending order,\n    removing strings with odd lengths, and then alphabetically if lengths are equal.\"\"\"\n    # Remove strings with odd lengths and sort the resulting list\n    sorted_lst = sorted([s for s in lst if len(s) % 2 == 0], key=lambda x: (len(x), x))\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes strings with odd lengths,\n    and returns the list sorted by string lengths in ascending order.\n    Strings of the same length are sorted alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list: first by length, then alphabetically\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    \n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths and sort the remaining\n    return sorted([s for s in lst if len(s) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Sorts a list of strings by length and alphabetically,\n    excluding strings of odd length.\"\"\"\n    # Filter out strings of odd length\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length, then alphabetically if lengths are the same\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings as a parameter, deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers, and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    \n    Parameters:\n    lst (list): A list of strings.\n\n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, and alphabetically if lengths are equal\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    \n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted first by the length of the strings,\n    then alphabetically if lengths are equal.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in lst if len(string) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically if lengths are equal\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    \n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Function that deletes strings with odd lengths from a list of strings and returns\n    the list sorted first by the length of the strings and then alphabetically if the\n    lengths are equal.\n    \n    Parameters:\n    lst (list): The input list of strings.\n    \n    Returns:\n    list: A list of strings sorted by the defined criteria.\n    \"\"\"\n    # Remove strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length, and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Returns a sorted list of strings based on the specified criteria.\"\"\"\n    # Keep only strings with even lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first alphabetically, then by length (which is already even)\n    even_length_strings.sort()\n    even_length_strings.sort(key=len)\n\n    return even_length_strings", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Sorts and returns a list of strings with only even-length words, sorted by ascending length and alphabetically if lengths are equal.\"\"\"\n    # Remove strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length first, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Sorts and returns a list of strings after removing the ones with odd lengths.\"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [string for string in lst if len(string) % 2 == 0]\n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Sorts a list of strings by the length of each string and alphabetically if lengths are equal.\n    Removes strings with odd lengths before sorting.\n    \n    Args:\n    lst (list): The list of strings to be processed.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first alphabetically, then by length\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    # Sort the list by length, and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Remove strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and alphabetically if the lengths are the same\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Returns a sorted list of strings, excluding those with odd lengths.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list by length (ascending), then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 88.98305084745763, "dps_norm": 93.75, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not a prime number.\n\n    :param n: Integer to check.\n    :return: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # divisible by 2 or 3, thus not a prime number\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    \n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n    \n    Parameters:\n    n (int): The number to check\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    \n    # Check if n is divisible by 2 or 3\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    \n    # Check for divisors up to the square root of n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    \n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime (except 2 and 3)\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    :param n: Integer to check\n    :return: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n    \n    Parameters:\n    n (int): The number to check\n    \n    Returns:\n    bool: True if the number is not a prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    \n    # Starting from 2 to the square root of n, check if n is divisible by any number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is not a prime number\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n\n    :param n: Integer to check.\n    :return: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 or 3 are not prime numbers\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    \n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Numbers divisible by 2 or 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0 and 1 are not considered prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # The number is not prime\n    return False  # The number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime, except for 2 and 3 themselves\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n    \n    Parameters:\n    n (int): The number to check\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Eliminate even numbers and multiples of 3\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    \n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True  # divisors found, not a prime\n        i += 6\n    \n    return False  # no divisors found, a prime number", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime.\n\n    :param n: Integer to check\n    :return: True if the number is not prime, False otherwise\n    \"\"\"\n    if n <= 1:\n        return True  # 0, 1 and negative numbers are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n\n    # This is checked so that we can skip middle five numbers in below loop\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to check if a number is not a prime number.\n    \n    Parameters:\n    n (int): The number to check\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers by definition\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Any other even number is not a prime\n    for i in range(3, int(n**0.5) + 1, 2):  # Test only odd factors\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n\n    :param n: Integer to check\n    :return: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 or 3 are not primes\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n\n    :param n: Integer to check\n    :return: True if the number is not prime, False if the number is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    \n    # This is checked so that we can skip middle five numbers in below loop\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    \n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not a prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # If divisible by 2 or 3, it's not prime\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    \n    return False  # The number is a prime number", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # other even numbers are not primes\n    \n    # We only need to check for factors up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True  # found a factor, so n is not prime\n    return False  # no factors found, n is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Args:\n    n: Integer to check.\n\n    Returns:\n    True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 98.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Function to find the n largest integers from a given list of numbers.\n    Returns these numbers in descending order.\n\n    :param nums: List of integers\n    :param n: The number of largest elements to return\n    :return: A list of n largest integers from nums in descending order\n    \"\"\"\n    # Use heapq's nlargest method to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest numbers in the given list and returns them in descending order.\n    \n    Args:\n    nums (list): The list of numbers to search through.\n    n (int): The number of largest elements to find.\n    \n    Returns:\n    list: A list of the n largest numbers from the given list, in descending order.\n    \"\"\"\n    # Use heapq's nlargest function to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param nums: List of integers.\n    :param n: Number of largest elements to return.\n    :return: A list of n largest integers in descending order.\n    \"\"\"\n    # Use nlargest method from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Function to find the n largest numbers in a given list, returned in descending order.\n    \n    Parameters:\n    nums (list): List of integers.\n    n (int): The number of largest elements to find.\n    \n    Returns:\n    list: A list of n largest integers from the input list, sorted in descending order.\n    \"\"\"\n    # Use heapq's nlargest method to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Returns a list of the n largest integers from the input list `nums` in descending order.\n    \n    Args:\n    nums (List[int]): The list of integers.\n    n (int): The number of top elements to return.\n    \n    Returns:\n    List[int]: A list of the n largest integers from `nums`, sorted in descending order.\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use nlargest method from heapq module to find n largest numbers\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Returns the n largest numbers from the given list `nums` in descending order.\n    \n    :param nums: List[int] - The list of numbers to find the largest n elements.\n    :param n: int - The number of largest elements to find.\n    :return: List[int] - The n largest elements in descending order.\n    \"\"\"\n    # Using nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from the given list of numbers, returned in descending order.\n    \n    :param nums: List[int] - a list of integers\n    :param n: int - the number of largest elements to find\n    :return: List[int] - a list of the n largest integers in descending order\n    \"\"\"\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use nlargest from heapq to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    This function finds the n largest integers from the given list of numbers\n    using a heap queue algorithm and returns them in descending order.\n    \n    :param nums: List of integers\n    :param n: Number of top largest elements to return\n    :return: A list of the n largest integers in descending order\n    \"\"\"\n    # Using nlargest from heapq to find the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param nums: List of integers\n    :param n: Number of top integers to retrieve\n    :return: A list of n largest integers from nums, sorted in descending order\n    \"\"\"\n    # Use nlargest method from heapq to find the top n largest numbers\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers and return them in descending order.\n    \n    :param nums: List of integers.\n    :param n: Number of largest elements to return.\n    :return: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use nlargest to get the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Function to find the n largest numbers from the list 'nums' and return them in descending order.\n    \n    :param nums: List of integers.\n    :param n: Number of largest elements to return.\n    :return: A list of n largest integers in descending order.\n    \"\"\"\n    # Use nlargest from heapq to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use nlargest to find the n largest numbers in the list\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq's nlargest function to find the n largest numbers in the list\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use nlargest method from heapq module to find n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from the given list of numbers and returns them in descending order.\n    \n    :param nums: List of integers from which the n largest are to be found.\n    :param n: Number of top elements to find.\n    :return: A list of the n largest integers from the given list, in descending order.\n    \"\"\"\n    # Use heapq's nlargest method to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest numbers in a list and returns them in descending order.\n    \n    :param nums: List of integers.\n    :param n: Number of largest elements to find.\n    :return: A list of n largest elements in descending order.\n    \"\"\"\n    # Using heapq to find the n largest numbers\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    This function finds the n largest integers in a list of numbers using the heapq module\n    and returns them in descending order.\n    \n    :param nums: List of integers\n    :param n: Number of largest integers to return\n    :return: A list of n largest integers, sorted in descending order\n    \"\"\"\n    # Use nlargest method from heapq to get the n largest numbers\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use nlargest from heapq to find the n largest numbers\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 97.27891156462584, "dps_norm": 60.0, "pass@1": 95.0, "profiled": [{"solution": "def find_Rotations(s):\n    # Double the string to account for all possible rotations\n    temp = s + s\n    n = len(s)\n    \n    # Iterate through the string to check for the smallest rotation that gives the original string\n    for i in range(1, n + 1):\n        # If the substring matches the original string\n        if temp[i:i+n] == s:\n            return i\n    \n    # If no rotation found (which should not happen for non-empty string)\n    return -1", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself to cover all possible rotations\n    temp = s + s\n    \n    # Initialize minimum rotations variable with string length\n    min_rotations = len(s)\n    \n    # Loop through all possible rotations of the string\n    for i in range(1, len(s) + 1):\n        # Extract substring corresponding to the current rotation\n        rotated_str = temp[i : i + len(s)]\n        \n        # If the rotated string matches the original string, update minimum rotations\n        if rotated_str == s:\n            min_rotations = i\n            break\n    \n    return min_rotations", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself to account for all possible rotations\n    temp = s + s\n    # Initialize the minimum number of rotations to the length of the string\n    n = len(s)\n    # Iterate through the concatenated string to check for the first occurrence of the original string\n    for i in range(1, n + 1):\n        # Extract the substring corresponding to the rotation\n        sub_str = temp[i : i + n]\n        # Check if the substring is equal to the original string\n        if sub_str == s:\n            # Return the index as the number of rotations needed\n            return i\n    \n    # If no rotations found (should not happen since a match is guaranteed at n rotations)\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Double the string to simulate infinite rotation\n    double_s = s + s\n    # Start with a rotation of 1\n    min_rotations = 1\n    \n    for i in range(1, len(s)):\n        # Check if the rotated string is equal to the original string\n        if double_s[i:i+len(s)] == s:\n            return min_rotations\n        min_rotations += 1\n    # If no rotation was found to produce the same string, return the maximum rotation (which is the length of the string)\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself\n    temp = s + s\n    \n    # Start with a rotation count of 1\n    n = 1\n    \n    # Loop to find the minimum number of rotations to get the same string\n    for i in range(1, len(s)):\n        # Extract substring from temp to check if it matches the original string\n        substring = temp[i:i+len(s)]\n        \n        # If the substring matches the original string, return the rotation count\n        if s == substring:\n            return n\n        # Increment the rotation count\n        n += 1\n    \n    # If no rotation gives the original string, return the length of the string\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    # Concatenate the string with itself to cover all rotations\n    temp = s + s\n    # Check for rotations, minimum value is 1\n    for i in range(1, n + 1):\n        # If the substring from index 'i' to 'i+n' matches the original string, return i\n        if temp[i:i+n] == s:\n            return i\n    # If no rotations found that match the original string, return 0\n    return 0", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself to handle rotations\n    temp = s + s\n    n = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, n + 1):\n        # Extract substring of same length as original string\n        sub_str = temp[i: i + n]\n        \n        # Check if the substring matches the original string\n        if sub_str == s:\n            return i\n            \n    return n  # Default to the length of the string if no earlier match was found", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Create a temp string by adding original string to itself\n    temp = s + s\n    \n    # Remove the first character from the temp string as a rotation of 0 is not considered\n    n = len(s)\n    for i in range(1, n+1):\n        # Check if the substring from i to i+n is equal to the original string\n        if temp[i:i+n] == s:\n            return i", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself to handle rotations\n    temp = s + s\n    n = len(s)\n    \n    # Iterate through the possible rotations\n    for i in range(1, n+1):\n        # Extract substring that represents the current rotation\n        substring = temp[i: i + n]\n        \n        # Check if the rotated substring matches the original string\n        if s == substring:\n            return i\n    \n    # If no rotation results in the original string, return -1\n    return -1", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself\n    temp = s + s\n    \n    # Iterate from 1 to the length of the original string\n    for i in range(1, len(s) + 1):\n        # Get the substring from index i to the length of the original string\n        substring = temp[i: i + len(s)]\n        \n        # Check if the substring is equal to the original string\n        if substring == s:\n            return i  # Return the rotation count if they are equal\n    \n    return -1  # Return -1 if no rotations were found", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    temp = s + s\n    # Loop from 1 to n to find the minimum rotations\n    for i in range(1, n + 1):\n        # Get the substring from position i to i+n\n        substring = temp[i: i + n]\n        # Check if this substring is equal to the original string\n        if s == substring:\n            return i\n    return n  # If no rotation is found, return the length of the string", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Double the string to simulate infinite rotations\n    temp = s + s\n    n = len(s)\n    \n    # Iterate through the string to find the minimum rotation\n    for i in range(1, n + 1):\n        # Check if the substring from index i equals the original string\n        if temp[i: i + n] == s:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    # Concatenate the string with itself to simplify rotation simulation\n    temp = s + s\n    \n    # Start with the minimum possible rotation (greater than 0)\n    for i in range(1, n + 1):\n        # Get the substring that represents the rotated string\n        sub = temp[i : i + n]\n        \n        # Check if the substring matches the original string\n        if s == sub:\n            return i\n            \n    return n  # If no rotation gives the original string, return the length of the string", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself\n    temp = s + s\n    n = len(s)\n    # Loop through the string\n    for i in range(1, n + 1):\n        # Get the substring that is a rotation of the original string\n        substring = temp[i: i + n]\n        # Check if the substring matches the original string\n        if s == substring:\n            return i\n    return n  # If no rotation is found, return the length of the string", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself\n    temp = s + s\n    # Iterate through the string, the maximum rotations needed will be the length of the string\n    for i in range(1, len(s) + 1):\n        # Extract the substring from index i to i+len(s)\n        substring = temp[i: i + len(s)]\n        # If the substring matches the original string, return the number of rotations\n        if substring == s:\n            return i\n    # If no rotations form the original string, return -1, though the problem guarantees a solution\n    return -1", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    # Concatenate the string with itself to simulate infinite rotations\n    temp = s + s\n    \n    # Iterate over the string from the second character to the end\n    for i in range(1, n + 1):\n        # Check if the substring of length n starting at index i is equal to the original string\n        if temp[i:i + n] == s:\n            return i", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself\n    temp = s + s\n    n = len(s)\n    \n    # Iterate through the string\n    for i in range(1, n + 1):\n        # Check if the substring matches the original string\n        if temp[i:i + n] == s:\n            return i", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Create a temporary string by concatenating the original string\n    temp = s + s\n    n = len(s)\n    \n    # Iterate over the string, starting from the first character\n    for i in range(1, n+1):\n        # Get the substring from position i to i+len(s)\n        substring = temp[i: i + n]\n        # Check if the substring equals the original string\n        if substring == s:\n            # If yes, return the index which denotes the number of rotations\n            return i", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Double the string to simulate rotations\n    temp = s + s\n    \n    # For each possible rotation, check if it matches the original string\n    for index in range(1, len(s) + 1):\n        # Slice the doubled string to get the current rotation\n        substring = temp[index:index+len(s)]\n        \n        # Check if the rotation matches the original string\n        if substring == s:\n            return index\n            \n    # If no rotation (other than 0) matches, return 0 (which isn't possible with this constraint)\n    return 0", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself to handle rotations\n    temp = s + s\n    # Iterate through the string to find the minimum rotations needed\n    for i in range(1, len(s) + 1):\n        # Extract substring of the original length\n        substring = temp[i: i + len(s)]\n        # Check if substring is equal to the original string\n        if substring == s:\n            return i\n    return len(s)", "matching_cluster_idx": 5}]}, "Mbpp/11": {"dps": 45.16129032258065, "dps_norm": 76.11111111111111, "pass@1": 65.0, "profiled": [{"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_occ = s.find(char)\n    \n    # Find the last occurrence of the character\n    last_occ = s.rfind(char)\n    \n    # If the character is not found at all, return the original string\n    if first_occ == -1 or last_occ == -1:\n        return s\n    \n    # Build the new string without the first and last occurrence\n    new_s = s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]\n    \n    return new_s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    # Convert the string to a list for easier manipulation\n    str_list = list(input_string)\n    \n    # Find and remove the first occurrence of the character\n    if char in str_list:\n        str_list.remove(char)\n    \n    # Reverse the list to find and remove the last occurrence\n    str_list.reverse()\n    if char in str_list:\n        str_list.remove(char)\n    \n    # Reverse the list back to the original order and join to form a string\n    str_list.reverse()\n    result_string = ''.join(str_list)\n    \n    return result_string", "matching_cluster_idx": 1}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_occurrence = s.find(char)\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(char)\n    \n    # If both the first and last occurrence positions are valid (i.e., character exists in the string)\n    if first_occurrence != -1 and last_occurrence != -1:\n        # If the first and last occurrence are the same, remove just once\n        if first_occurrence == last_occurrence:\n            return s[:first_occurrence] + s[first_occurrence+1:]\n        # If they are different, remove both occurrences\n        else:\n            return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    # If the character is not found, return the original string\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Find the index of the first occurrence of the character\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence of the character\n    last_index = string.rfind(char)\n    \n    # If first and last are the same, we only remove one occurrence\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # If they are different, remove both\n    part1 = string[:first_index]\n    part2 = string[first_index+1:last_index]\n    part3 = string[last_index+1:]\n    \n    return part1 + part2 + part3", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first = s.find(char)\n    # If the character does not exist, return the original string\n    if first == -1:\n        return s\n    # Find the last occurrence of the character\n    last = s.rfind(char)\n    # Create a new string with the first and last occurrence removed\n    # Check if the first and last occurrence are the same\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character and remove it\n    first_index = s.find(char)\n    if first_index != -1:\n        s = s[:first_index] + s[first_index+1:]\n    else:\n        return s  # Return original string if character not found\n    \n    # Find the last occurrence of the character and remove it\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Check if the character exists in the string and remove its first occurrence\n    if char in s:\n        s = s.replace(char, '', 1)\n    # Check again and remove the last occurrence\n    if char in s:\n        s = s[::-1].replace(char, '', 1)[::-1]\n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, ch):\n    # First occurrence index\n    first_index = s.find(ch)\n    \n    # Last occurrence index\n    last_index = s.rfind(ch)\n    \n    # If character is not found in string, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # Construct new string without first and last occurrence of the character\n    new_str = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    \n    return new_str", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Find the first occurrence of the character\n    first_index = string.find(char)\n    # Find the last occurrence of the character\n    last_index = string.rfind(char)\n    \n    # Construct the new string without the first and last occurrence of the character\n    if first_index != -1 and last_index != -1:\n        return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]\n    else:\n        return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence\n    first = s.find(char)\n    # Find the last occurrence\n    last = s.rfind(char)\n    \n    # If the character exists in the string\n    if first != -1 and last != -1:\n        # Create the new string excluding the first and last occurrence\n        new_s = s[:first] + s[first+1:last] + s[last+1:]\n        return new_s\n    else:\n        # Return the original string if the character is not found\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, char):\n    # Convert the string into a list for manipulation\n    str_list = list(input_str)\n    \n    # Find the index of the first occurrence of the character and remove it\n    try:\n        first_index = str_list.index(char)\n        del str_list[first_index]\n    except ValueError:\n        # If the character is not found, return the original string\n        return input_str\n    \n    # Reverse the list to find the last occurrence more easily\n    str_list.reverse()\n    \n    # Find the index of the last occurrence and remove it (which is now first after reversing)\n    try:\n        last_index = str_list.index(char)\n        del str_list[last_index]\n    except ValueError:\n        # If the character is not found again, simply return the list without further changes\n        pass\n    \n    # Reverse the list back to the original order and join the elements to form a string\n    str_list.reverse()\n    return ''.join(str_list)", "matching_cluster_idx": 1}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first = s.find(char)\n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n    # Replace the first occurrence of the character\n    s = s[:first] + s[first+1:]\n    \n    # Find the last occurrence of the character in the modified string\n    last = s.rfind(char)\n    # Replace the last occurrence of the character\n    if last != -1:\n        s = s[:last] + s[last+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Convert the string to a list to modify individual elements\n    s_list = list(s)\n    found = False\n    # Find the first occurrence\n    for i in range(len(s_list)):\n        if s_list[i] == char and not found:\n            s_list[i] = ''\n            found = True\n            break\n    # Find the last occurrence\n    for i in reversed(range(len(s_list))):\n        if s_list[i] == char:\n            s_list[i] = ''\n            break\n    # Convert the list back to a string\n    return ''.join(s_list)", "matching_cluster_idx": 1}, {"solution": "def remove_Occ(string, char):\n    # Find the first occurrence\n    first_index = string.find(char)\n    if first_index == -1:\n        return string\n    \n    # Remove the first occurrence\n    string = string[:first_index] + string[first_index + 1:]\n    \n    # Find the last occurrence, which will be the first occurrence in the reversed string\n    last_index = string.rfind(char)\n    if last_index != -1:\n        # Remove the last occurrence\n        string = string[:last_index] + string[last_index + 1:]\n        \n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Check if the character is in the string\n    if char in s:\n        # Find the first occurrence of the character\n        first_occ = s.find(char)\n        # Find the last occurrence of the character\n        last_occ = s.rfind(char)\n        # If the character appears more than once, remove both first and last occurrences\n        if first_occ != last_occ:\n            # Construct the string without the first occurrence of the character\n            s = s[:first_occ] + s[first_occ + 1:]\n            # Adjust last_occ for the shift in index due to the removal of the first occurrence\n            last_occ -= 1\n            # Construct the string without the last occurrence of the character\n            s = s[:last_occ] + s[last_occ + 1:]\n        else:\n            # If the character only appears once, just remove that single occurrence\n            s = s[:first_occ] + s[first_occ + 1:]\n    # Return the modified string\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Convert the string into a list to allow modification\n    str_list = list(s)\n    \n    # Initialize a counter for occurrences\n    found = False\n    \n    # Find and remove the first occurrence\n    for i in range(len(str_list)):\n        if str_list[i] == char and not found:\n            del str_list[i]\n            found = True\n            break\n    \n    # If char is not found, just return the original string\n    if not found:\n        return s\n    \n    # Reverse the list to find and remove the last occurrence\n    for i in range(len(str_list)-1, -1, -1):\n        if str_list[i] == char:\n            del str_list[i]\n            break\n    \n    # Convert the list back to string and return\n    return ''.join(str_list)", "matching_cluster_idx": 1}, {"solution": "def remove_Occ(input_str, char_to_remove):\n    # Remove first occurrence\n    first_removed = input_str.replace(char_to_remove, '', 1)\n    # Reverse the string and remove last occurrence (which is first now in the reversed string)\n    reversed_str = first_removed[::-1]\n    last_removed_reversed = reversed_str.replace(char_to_remove, '', 1)\n    # Reverse the string again to get the original order\n    final_str = last_removed_reversed[::-1]\n    return final_str", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(string, char):\n    # Find the first occurrence of the character\n    first_occurrence = string.find(char)\n    if first_occurrence != -1:\n        # Remove the first occurrence\n        string = string[:first_occurrence] + string[first_occurrence + 1:]\n    \n    # Find the last occurrence of the character\n    last_occurrence = string.rfind(char)\n    if last_occurrence != -1:\n        # Remove the last occurrence\n        string = string[:last_occurrence] + string[last_occurrence + 1:]\n    \n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(string, char):\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    # Remove the first occurrence\n    string = string[:first_index] + string[first_index+1:]\n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    # If the character is not found, return the string after removing the first occurrence\n    if last_index == -1:\n        return string\n    # Remove the last occurrence\n    string = string[:last_index] + string[last_index+1:]\n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(string, char):\n    # Remove first occurrence\n    first_index = string.find(char)\n    if first_index != -1:\n        string = string[:first_index] + string[first_index + 1:]\n    \n    # Remove last occurrence (from the end of the string)\n    last_index = string.rfind(char)\n    if last_index != -1:\n        string = string[:last_index] + string[last_index + 1:]\n    \n    return string", "matching_cluster_idx": 7}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    # Sorting the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sorts the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists containing the matrix to be sorted\n    :return: Sorted matrix based on row sums\n    \"\"\"\n    # Sorting the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sorts the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sorting the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sorts the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sorting the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n    \n    :param matrix: List of lists, where each sublist represents a row in the matrix.\n    :return: The sorted matrix.\n    \"\"\"\n    # Sorting the matrix based on the sum of elements in each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix by the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List of lists representing the matrix\n    :return: Sorted matrix\n    \"\"\"\n    # Sorting the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sorts the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/19": {"dps": 75.25252525252526, "dps_norm": 86.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    # Using a set to track unique elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert list to set to remove duplicates and compare lengths\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using a set to find duplicates\n    seen = set()\n    for number in arr:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the array to a set and compare lengths\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Use set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert list to set and compare lengths\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set to remove duplicates\n    # Compare the length of the set with the list\n    return len(set(arr)) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using a set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert list to set to remove duplicates and compare lengths\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using set to check for duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using a set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Using set to find duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    # Convert list to set to remove duplicates\n    # Compare length of set and original list\n    return len(set(nums)) != len(nums)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using set to remove duplicates and compare its length with the list's length\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Convert list to a set to remove duplicates\n    # If length of set and list is different, there are duplicates\n    return len(set(arr)) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using set to check for duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using a set to track unique elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set and compare lengths\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using set to find duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    # Using set to remove duplicates and comparing lengths\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 73.38461538461539, "dps_norm": 83.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    # Using min function to find the smallest element in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Initialize the smallest number as the first number in the list\n    smallest = lst[0]\n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize smallest with the first element\n    smallest = lst[0]\n    \n    # Iterate through the list to find the smallest element\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize smallest with the first element of the list\n    smallest = lst[0]\n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize the smallest number to the first element of the list\n    smallest = lst[0]\n    # Iterate over the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize smallest with the first element of the list\n    smallest = lst[0]\n    # Iterate through the list to find the smallest element\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize the smallest number as the first element\n    smallest = lst[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize the smallest number to the first element of the list\n    smallest = lst[0]\n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    :param lst: List of integers\n    :return: The smallest integer in the list\n    \"\"\"\n    if not lst:\n        return None\n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Using min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    :param lst: List of integers\n    :return: The smallest integer in the list\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        return None  # Return None if the list is empty\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Use min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Initialize the smallest element as the first element\n    smallest = lst[0]\n    \n    # Iterate through the list to find the smallest element\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize the smallest number as the first element of the list\n    smallest = lst[0]\n    # Iterate through the list starting from the second element\n    for num in lst[1:]:\n        # If a smaller number is found, update the smallest variable\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 2}, {"solution": "def smallest_num(lst):\n    # Use the min function to find the smallest element in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Initialize smallest with the first element of the list\n    smallest = lst[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize the smallest number as the first element of the list\n    smallest = lst[0]\n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize smallest as the first element of the list\n    smallest = lst[0]\n    # Iterate through all the elements in the list\n    for num in lst:\n        # Update smallest if a smaller number is found\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize the smallest number to the first element of the list\n    smallest = lst[0]\n    \n    # Iterate through all elements in the list\n    for num in lst:\n        # Update the smallest number if a smaller number is found\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize smallest with the first element of the list\n    smallest = lst[0]\n    # Iterate through each number in the list\n    for num in lst:\n        # Update smallest if the current number is smaller\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(test_list, k):\n    # Filter the list of tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Using list comprehension to filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(el % k == 0 for el in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Use list comprehension to filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Using list comprehension to filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Use list comprehension to filter out the tuples\n    # Check if all elements in the tuple are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter the list of tuples based on whether all elements in each tuple are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Use list comprehension to filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Use list comprehension to filter tuples where all elements are divisible by k\n    res = [ele for ele in test_list if all(e % k == 0 for e in ele)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Use list comprehension to filter out tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Use list comprehension to filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Use list comprehension to filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to hold the frequencies\n    freq_dict = {}\n    \n    # Iterate over the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # Otherwise, add the item to the dictionary with a count of 1\n        else:\n            freq_dict[item] = 1\n            \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequencies\n    freq_dict = {}\n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is not in the dictionary, add it with a count of 1\n        # Otherwise, increment the count of the element\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store frequencies\n    freq_dict = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # Update the frequency count for each element\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n            \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Creating an empty dictionary to hold frequencies\n    freq_dict = {}\n    # Iterating over each element in the list\n    for elem in lst:\n        # If the element is already in the dictionary, increment its frequency\n        if elem in freq_dict:\n            freq_dict[elem] += 1\n        # Otherwise, add the element to the dictionary with frequency 1\n        else:\n            freq_dict[elem] = 1\n    # Returning the populated dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to hold the frequency count\n    freq_dict = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[item] = 1\n    \n    # Return the populated dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate through the list to count the frequency of each element\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate through the list to count the frequency of each element\n    for elem in lst:\n        if elem in freq_dict:\n            freq_dict[elem] += 1\n        else:\n            freq_dict[elem] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate through the list and count the frequency of each element\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    \n    # Return the dictionary containing elements and their frequencies\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store frequencies\n    freq_dict = {}\n    \n    # Loop through each element in the list\n    for elem in lst:\n        # If the element is already in the dictionary, increment its count\n        if elem in freq_dict:\n            freq_dict[elem] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            freq_dict[elem] = 1\n    \n    # Return the dictionary containing the frequencies\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Dictionary to hold the frequency of elements\n    freq_dict = {}\n    # Iterate over the list and update the frequency\n    for elem in lst:\n        if elem in freq_dict:\n            freq_dict[elem] += 1\n        else:\n            freq_dict[elem] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate over the list to count the frequency of each element\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n            \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store frequency counts\n    freq_dict = {}\n    \n    # Iterate through the list and count the frequency of each element\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n            \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Loop through each element in the list\n    for element in lst:\n        # If the element is not yet in the dictionary, add it with a count of 1\n        # Otherwise, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    \n    # Return the dictionary containing elements and their frequencies\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            freq_dict[item] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    # Iterate over each element in the list\n    for item in lst:\n        # If the item is not in the dictionary, add it with a count of 1\n        # If the item is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to hold the counts\n    frequency_dict = {}\n    \n    # Iterate through each element in the list\n    for elem in lst:\n        # If the element is already in the dictionary, increment its count\n        if elem in frequency_dict:\n            frequency_dict[elem] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency_dict[elem] = 1\n    \n    # Return the completed dictionary\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequencies\n    freq_dict = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the item is not in the dictionary, add it with a count of 1\n        if item not in freq_dict:\n            freq_dict[item] = 1\n        # If the item is already in the dictionary, increment its count\n        else:\n            freq_dict[item] += 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to hold the counts\n    frequency_dict = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 76.73170731707317, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def len_log(lst):\n    # Find the length of the longest word in the list\n    max_length = max(len(word) for word in lst)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Find the length of the longest word in the list\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize max_length to zero\n    max_length = 0\n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the length of the current word is greater than max_length\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the length of the longest word in the list\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Calculate the length of the longest word in the list\n    max_length = max(len(word) for word in lst)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Find the maximum length among all words in the list\n    max_length = max(len(word) for word in lst)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Find the length of the longest word in the list\n    max_length = 0\n    for word in lst:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Find the maximum length of the words in the list\n    max_length = max(len(word) for word in lst)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize maximum length to 0\n    max_length = 0\n    # Iterate over each word in the list\n    for word in words:\n        # Update max_length if the length of the current word is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Find the maximum length of the words in the list\n    max_length = max(len(word) for word in lst)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Find the maximum length among all words in the list\n    max_length = max(len(word) for word in lst)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words_list):\n    # Find the length of the longest word in the list\n    max_length = max(len(word) for word in words_list)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Calculate the maximum length among the words\n    max_length = max(len(word) for word in words)\n    return max_length", "matching_cluster_idx": 4}, {"solution": "def len_log(lst):\n    # Find the length of the longest word in the list\n    max_length = max(len(word) for word in lst)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Initialize the maximum length variable\n    max_len = 0\n    # Iterate through each word in the list\n    for word in lst:\n        # Update max_len if the current word's length is greater\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Find the maximum length among the elements of the list\n    max_len = max(len(word) for word in lst)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Find the maximum length among all the words in the list\n    max_length = max(len(word) for word in lst)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Calculate the length of the longest word\n    max_length = max(len(word) for word in words)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    # Find the maximum length among the elements in the list\n    max_len = max(len(x) for x in lst)\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize max_length to zero\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n            \n    return max_length", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.04878048780488, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Finding the tuple with the minimum second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Returning the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the minimum value in the second position\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the minimum second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    return min(test_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the minimum second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the minimum second value and return its first value\n    return min(test_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the minimum second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    return min(test_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the minimum second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the minimum second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Finding the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Returning the first value of the tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Finding the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Returning the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 77.77777777777777, "dps_norm": 42.857142857142854, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    # Initialize count of divisors\n    count = 0\n    \n    # Loop through all numbers from 1 to n (inclusive) \n    for i in range(1, n + 1):\n        # If 'i' is a divisor of 'n', increment count\n        if n % i == 0:\n            count += 1\n            \n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Counts the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer to find the divisors of.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize the count of divisors\n    count = 0\n    # Iterate through possible divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize the count of divisors\n    count = 0\n    \n    # Loop from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    This function calculates the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer whose divisors are to be counted.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n    \n    :param n: Integer to find the number of divisors for\n    :return: Number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize count of divisors\n    count = 0\n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment the count\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter to count divisors\n    count = 0\n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    # Return the total number of divisors found\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    This function takes an integer n as input and returns the number of divisors of n.\n    \n    :param n: Integer to find divisors for\n    :return: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize the count of divisors\n    count = 0\n    # Iterate over all possible divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize count of divisors\n    count = 0\n    # Loop through possible divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/97": {"dps": 99.65811965811966, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(lst):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n    \n    # Create a dictionary to hold the frequencies\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Create an empty dictionary to store frequency of each element\n    frequency = {}\n    \n    # Iterate through each sublist\n    for sublist in lst:\n        # Iterate through each element in the sublist\n        for elem in sublist:\n            # Increment the count for the element, start at 0 if not already in the dictionary\n            frequency[elem] = frequency.get(elem, 0) + 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Initialize an empty dictionary to store frequencies\n    freq_dict = {}\n    \n    # Iterate over each list within the list of lists\n    for sublist in lst:\n        # Iterate over each element in the sublist\n        for elem in sublist:\n            # If the element is in the dictionary, increment its count\n            if elem in freq_dict:\n                freq_dict[elem] += 1\n            # Otherwise, add the element to the dictionary with a count of 1\n            else:\n                freq_dict[elem] = 1\n    \n    # Return the dictionary with frequencies\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Initialize an empty dictionary to hold frequencies\n    frequency_dict = {}\n    \n    # Iterate over each sublist\n    for sublist in lst:\n        # Iterate over each item in the sublist\n        for item in sublist:\n            # If the item is in the dictionary, increment its count\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            # Otherwise, add the item with a count of 1\n            else:\n                frequency_dict[item] = 1\n                \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to hold the frequencies\n    frequency = {}\n    \n    # Loop through each sublist in the list of lists\n    for sublist in lists:\n        # Loop through each element in the sublist\n        for item in sublist:\n            # If the item is not in the dictionary, add it with a count of 1\n            if item not in frequency:\n                frequency[item] = 1\n            else:\n                # If the item is already in the dictionary, increment its count by 1\n                frequency[item] += 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through each sublist in the main list\n    for sublist in lst:\n        # Iterate through each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            # Otherwise, add the element to the dictionary with a count of 1\n            else:\n                frequency_dict[element] = 1\n                \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    from collections import defaultdict\n\n    # Initialize a default dictionary to hold the counts\n    frequency_dict = defaultdict(int)\n    \n    # Iterate over each sublist in the list of lists\n    for sublst in lst:\n        # Iterate over each element in the sublist\n        for element in sublst:\n            # Increment the count of the element in the dictionary\n            frequency_dict[element] += 1\n    \n    # Convert the defaultdict to a regular dict before returning\n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store frequencies\n    frequency_dict = {}\n    # Flatten the list of lists and iterate over each element\n    for sublist in lists:\n        for item in sublist:\n            # Update the count of the item in the dictionary\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in lst:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # Update the count of the element in the dictionary\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to keep track of frequencies\n    frequency_dict = {}\n    \n    # Iterate over each sublist and then over each element in the sublist\n    for sublist in lists:\n        for item in sublist:\n            # Update the dictionary with the frequency of each item\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n                \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    from collections import defaultdict\n    \n    # Initialize a default dictionary to hold the frequency of each element\n    frequency = defaultdict(int)\n    \n    # Iterate over each sublist and each element within it\n    for sublist in lst:\n        for item in sublist:\n            frequency[item] += 1\n            \n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Import Counter from collections\n    from collections import Counter\n    \n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each element\n    frequency_dict = Counter(flattened_list)\n    \n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequencies\n    frequency_dict = {}\n    \n    # Flatten the list of lists and calculate frequencies\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n                \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Importing Counter from collections to count frequency of elements\n    from collections import Counter\n    \n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n    \n    # Count the frequency of each element in the flattened list\n    freq = Counter(flat_list)\n    \n    return dict(freq)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n    # Create an empty dictionary to store the frequency of each element\n    freq_dict = {}\n    # Iterate through the flat list\n    for item in flat_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    from collections import defaultdict\n    # Create a dictionary to hold the frequencies\n    frequency_dict = defaultdict(int)\n    \n    # Iterate through each list in the list of lists\n    for sublist in lst:\n        # Iterate through each element in the sublist\n        for element in sublist:\n            # Increment the count of the element in the dictionary\n            frequency_dict[element] += 1\n    \n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    from collections import Counter\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    # Count the frequency of each element\n    freq_dict = Counter(flat_list)\n    return dict(freq_dict)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lists):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    # Count the frequency of each item\n    frequency = Counter(flat_list)\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency = {}\n    \n    # Iterate over each list in the lists\n    for sublist in lists:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is not in the frequency dictionary, set its count to 0\n            if element not in frequency:\n                frequency[element] = 0\n            # Increment the count for the element\n            frequency[element] += 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate over each element in the flattened list\n    for element in flattened_list:\n        # If the element is not yet in the dictionary, initialize it with 1\n        if element not in frequency_dict:\n            frequency_dict[element] = 1\n        # If the element is already in the dictionary, increment the count\n        else:\n            frequency_dict[element] += 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 49.15584415584416, "dps_norm": 83.33333333333333, "pass@1": 96.0, "profiled": [{"solution": "def add_lists(lst, t):\n    # Convert the tuple to a list to append the given list\n    t_lst = list(t)\n    t_lst.extend(lst)\n    # Convert back to a tuple\n    result = tuple(t_lst)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Extend the tuple by adding the list elements to the end\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tuple1):\n    # Converting tuple to list to perform addition operation\n    temp_list = list(tuple1)\n    # Appending list elements to the temporary list\n    temp_list.extend(list1)\n    # Converting list back to tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Append each element of the list to the tuple\n    result = tup + tuple(lst)\n    return result", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, concatenate it with the given list, then convert it back to a tuple\n    result = tuple(list(tup) + lst)\n    return result", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    # Converting tuple to list to append the given list\n    temp = list(tup)\n    temp.extend(lst)\n    # Converting the list back to tuple\n    result = tuple(temp)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the given list, and then convert it back to a tuple\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the list to a tuple and concatenate it with the given tuple\n    result = tup + tuple(lst)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, concatenate it with the given list, and convert back to a tuple\n    new_tup = tup + tuple(lst)\n    return new_tup", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the list to a tuple and concatenate it to the given tuple\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, extend it with the given list, and convert it back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    # Append list elements to the tuple\n    result = tup + tuple(lst)\n    return result", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, extend it with the given list, and convert back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, concatenate it with the given list, then convert back to tuple\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n    # Convert the tuple to a list, append the given list to it\n    result = list(tuple1) + list1\n    # Convert the result back to a tuple\n    return tuple(result)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, and convert back to a tuple\n    new_tup = tup + tuple(lst)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Convert list to tuple and concatenate\n    result = tup + tuple(lst)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    # Convert tuple to a list, concatenate the input list, and convert back to tuple\n    combined_tuple = tuple(list(input_tuple) + input_list)\n    return combined_tuple", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, and convert back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    # Convert tuple to a list, append the given list, and then convert it back to a tuple\n    new_tup = tup + tuple(lst)\n    return new_tup", "matching_cluster_idx": 4}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merging all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sorting the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # Merging the three lists\n    merged_list = lst1 + lst2 + lst3\n    # Sorting the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # Combine the three lists into one\n    merged_list = lst1 + lst2 + lst3\n    # Sort the combined list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # Merging the three lists\n    merged_list = lst1 + lst2 + lst3\n    # Sorting the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merging all three lists\n    merged_list = list1 + list2 + list3\n    # Sorting the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merging all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sorting the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the combined list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # Concatenate all three lists\n    merged_list = lst1 + lst2 + lst3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 91.53846153846155, "dps_norm": 86.25, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sublist into a set and find intersection of all sets\n    common_elements = set(nested_lists[0]).intersection(*nested_lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sublist into a set and calculate the intersection\n    common_elements = set(nested_lists[0]).intersection(*nested_lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Using set intersection to find common elements across all lists\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with the rest of the lists to find common elements\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Find the intersection of all lists in the nested list\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sublist into a set and calculate intersection\n    common_elements = set.intersection(*map(set, nested_lists))\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set for comparison\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists and find common elements\n    for sublist in nested_lists[1:]:\n        common_elements.intersection_update(sublist)\n        \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sublist into a set and calculate the intersection of all sets\n    common_elements = set(nested_lists[0]).intersection(*nested_lists[1:])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the first list in the nested list to a set\n    common_elements = set(lists[0])\n    \n    # Iterate over the rest of the lists in the nested list\n    for lst in lists[1:]:\n        # Update common_elements with the intersection of itself and the current list (converted to a set)\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set to initiate intersection\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the rest of the lists and find the intersection\n    for sublist in nested_lists[1:]:\n        common_elements.intersection_update(sublist)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set for comparison\n    common_elements = set(nested_lists[0])\n    # Iterate through each list in the nested list\n    for lst in nested_lists[1:]:\n        # Update the set of common elements with the intersection of itself and the current list\n        common_elements.intersection_update(lst)\n    # Return the set of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lst):\n    # Convert the first sublist to a set\n    common_elements = set(lst[0])\n    \n    # Iterate over the rest of the sublists\n    for sublist in lst[1:]:\n        # Convert the sublist to a set and find intersection with the accumulated common elements\n        common_elements.intersection_update(sublist)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sublist into a set and find intersection\n    common_elements = set(nested_lists[0]).intersection(*nested_lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list in the nested lists to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the rest of the lists to find common elements\n    for lst in nested_lists[1:]:\n        # Update the common_elements set with the intersection of itself and the current list\n        common_elements.intersection_update(lst)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements across all sublists\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sublist into a set and then find the intersection of these sets\n    common_elements = set.intersection(*map(set, nested_lists))\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each list to a set and calculate the intersection of all sets\n    common_elements = set(nested_lists[0]).intersection(*nested_lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sublist to a set and find intersection\n    common_elements = set(nested_lists[0]).intersection(*nested_lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 73.0, "profiled": [{"solution": "def amicable_numbers_sum(limit):\n    # Initialize the sum of amicable numbers to 0\n    amicable_sum = 0\n    # Iterate through each number from 2 up to the limit\n    for num in range(2, limit + 1):\n        # If the number is part of an amicable pair, add it to the sum\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum\ndef proper_divisors_sum(n):\n    # Find the sum of proper divisors of n\n    divisors_sum = 1  # 1 is a proper divisor of all natural numbers\n    # Check for divisors from 2 up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            # Add the quotient if it's different from i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef is_amicable(n):\n    # Check if a number n is part of an amicable pair\n    # Find the sum of proper divisors of n\n    sum_n = proper_divisors_sum(n)\n    # If the sum of proper divisors of n equals the sum of proper divisors of this sum and is not equal to n itself, then it's amicable\n    return sum_n != n and n == proper_divisors_sum(sum_n)", "matching_cluster_idx": 11}, {"solution": "def divisors_sum(n):\n    \"\"\"Helper function to calculate the sum of proper divisors of n.\"\"\"\n    total = 1  # 1 is a proper divisor for all n > 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # add the quotient only if it's different from i\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Returns the sum of all amicable numbers up to a specified limit.\n    \n    An amicable pair (a, b) consists of two integers for which the sum of proper divisors\n    of each is equal to the other integer. For instance, (220, 284) is an amicable pair.\n    \"\"\"\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        sum_of_divs = divisors_sum(num)\n        if sum_of_divs > num and sum_of_divs <= limit and divisors_sum(sum_of_divs) == num:\n            amicable_sum += num + sum_of_divs\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    # Initialize the sum of amicable numbers\n    sum_amicable = 0\n    \n    # Function to calculate sum of proper divisors of n\n    def sum_proper_divisors(n):\n        sum_div = 1  # Initialize with 1 since it's a proper divisor\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                sum_div += i\n                if i != n // i:  # Avoid adding the square root twice for perfect squares\n                    sum_div += n // i\n        return sum_div\n    \n    # Iterate through numbers to find amicable pairs\n    for num in range(2, limit + 1):\n        sum_div1 = sum_proper_divisors(num)\n        if sum_div1 > num and sum_div1 <= limit:  # Ensure we do not go out of bounds\n            sum_div2 = sum_proper_divisors(sum_div1)\n            if sum_div2 == num:\n                sum_amicable += num + sum_div1  # Add both numbers in the pair\n                \n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"\n    This function calculates the sum of proper divisors of a number n.\n    \"\"\"\n    total = 1  # start with 1 because it's a proper divisor of all numbers\n    root = int(n**0.5)\n    for i in range(2, root + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    This function finds the sum of all amicable numbers under a certain limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number.\n    \"\"\"\n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_of_divisors(num)\n        if partner > num and sum_of_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def proper_divisors_sum(n):\n    divisors_sum = 1  # 1 is a proper divisor for any n > 1\n    sqrt_n = int(n ** 0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    sum_of_amicable = 0\n    for num in range(2, limit + 1):\n        partner = proper_divisors_sum(num)\n        if partner > num and proper_divisors_sum(partner) == num:\n            sum_of_amicable += num + partner\n    return sum_of_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    total = 1  # 1 is a divisor for all numbers\n    sqrt_n = int(n**0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Function to sum all amicable numbers from 1 to a specified limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number.\n    \"\"\"\n    sum_dict = {i: sum_divisors(i) for i in range(1, limit + 1)}\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n        sum_i = sum_dict[i]\n        if sum_i != i and sum_i <= limit and sum_dict.get(sum_i, 0) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a specified limit.\n\n    Args:\n    - limit (int): The upper limit for finding amicable numbers.\n\n    Returns:\n    - int: The sum of all amicable numbers up to the limit.\n    \"\"\"\n    def sum_of_divisors(n):\n        # Return the sum of all proper divisors of n\n        total = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                if i == n // i:\n                    total += i\n                else:\n                    total += i + n // i\n        return total\n\n    # Generate a list of the sum of divisors for each number up to the limit\n    sum_of_divs = [sum_of_divisors(i) for i in range(limit + 1)]\n\n    # Find and sum all amicable numbers\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n        if (sum_of_divs[i] < limit + 1 and \n            sum_of_divs[i] != i and \n            sum_of_divs[sum_of_divs[i]] == i):\n            amicable_sum += i\n            \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    This function calculates the sum of all amicable numbers up to a given limit.\n    \n    Args:\n    limit (int): The upper bound for the search of amicable numbers.\n    \n    Returns:\n    int: The sum of all amicable numbers up to the given limit.\n    \"\"\"\n    \n    def sum_of_divisors(n):\n        \"\"\"Calculate the sum of the proper divisors of n.\"\"\"\n        divisors_sum = 1  # 1 is a proper divisor of all numbers\n        sqrt_n = int(n ** 0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n\n    # Dictionary to hold sums of divisors for encountered numbers\n    sums_of_divisors = {}\n\n    total_sum = 0\n    for number in range(2, limit + 1):\n        if number not in sums_of_divisors:\n            sum_divisors = sum_of_divisors(number)\n            sums_of_divisors[number] = sum_divisors\n\n        if sum_divisors <= limit and sum_divisors != number:\n            if sum_divisors in sums_of_divisors and sums_of_divisors[sum_divisors] == number:\n                total_sum += number + sum_divisors\n                # Once a pair is found, set their values to 0 to avoid recounting\n                sums_of_divisors[number] = 0\n                sums_of_divisors[sum_divisors] = 0\n\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    # This function calculates the sum of all amicable numbers below the given limit.\n    \n    def sum_of_divisors(n):\n        # Helper function to find the sum of proper divisors of n\n        divisors_sum = 1  # 1 is a proper divisor of any n > 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    total_sum = 0\n    for num in range(2, limit):\n        # Calculate the sum of proper divisors of the current number\n        ami_pair = sum_of_divisors(num)\n        # Check if the ami_pair is within the limit and is different from num\n        if ami_pair < limit and ami_pair != num and sum_of_divisors(ami_pair) == num:\n            # Add only if they are not already added (only once per pair)\n            if ami_pair > num:\n                total_sum += num + ami_pair\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_of_proper_divisors(n):\n        # Start with 1 because it is a proper divisor of any number\n        total = 1\n        # Loop from 2 to the square root of n to find proper divisors\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                # Add both divisors if they are not the same\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    \n    amicable_sum = 0\n    # Loop through numbers from 2 to the specified limit\n    for num in range(2, limit):\n        # Find sum of proper divisors of current number\n        sum1 = sum_of_proper_divisors(num)\n        # Check if sum of proper divisors of sum1 equals to the current number\n        if sum1 > num and sum_of_proper_divisors(sum1) == num:\n            amicable_sum += num + sum1\n            \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return divisors\ndef amicable_numbers_sum(limit):\n    # Store the sum of proper divisors for each number\n    div_sum = [sum(proper_divisors(i)) for i in range(limit + 1)]\n    # Track amicable numbers to avoid recounting\n    amicable = set()\n    for i in range(2, limit + 1):\n        if div_sum[i] < limit + 1 and i == div_sum[div_sum[i]] and i != div_sum[i]:\n            amicable.add(i)\n    return sum(amicable)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a given limit.\n    An amicable pair (a, b) consists of two integers for which the sum of proper divisors (excluding the number itself) of each is equal to the other number.\n    \"\"\"\n    def sum_of_divisors(n):\n        \"\"\"\n        Helper function to calculate sum of proper divisors of n.\n        \"\"\"\n        divisors_sum = 1  # 1 is a proper divisor for all n > 1\n        sqrt_n = int(n ** 0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n\n    amicable_sum = 0\n    for num in range(2, limit):\n        # Find the sum of proper divisors\n        divisor_sum = sum_of_divisors(num)\n        # Check if the number is amicable and the counterpart is within the limit\n        if divisor_sum != num and divisor_sum < limit and sum_of_divisors(divisor_sum) == num:\n            amicable_sum += num\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def proper_divisors_sum(n):\n    \"\"\"\n    Function to calculate sum of proper divisors of a number.\n    \"\"\"\n    divisors_sum = 1  # 1 is a proper divisor for all n > 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:  # Add the quotient only if it's different from i\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Function to sum all amicable numbers from 1 to a specified number.\n    \"\"\"\n    amicable_sums = {}\n    total_sum = 0\n    for i in range(2, limit + 1):\n        if i not in amicable_sums:\n            ami_pair = proper_divisors_sum(i)\n            if ami_pair != i and proper_divisors_sum(ami_pair) == i:\n                amicable_sums[i] = ami_pair\n                amicable_sums[ami_pair] = i\n                total_sum += i + ami_pair\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def get_proper_divisors_sum(n):\n    \"\"\"\n    Helper function to calculate the sum of proper divisors of n.\n    \"\"\"\n    div_sum = 1  # 1 is a proper divisor for all n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            div_sum += i\n            if i != n // i:\n                div_sum += n // i\n    return div_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Function to sum all amicable numbers from 1 to the specified limit.\n    \"\"\"\n    sum_of_divisors = [get_proper_divisors_sum(i) for i in range(limit)]\n    amicable_sum = 0\n    for i in range(2, limit):\n        if sum_of_divisors[i] < limit and i == sum_of_divisors[sum_of_divisors[i]] and i != sum_of_divisors[i]:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"\n    Calculate the sum of proper divisors of n.\n    \"\"\"\n    total = 1  # 1 is a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers up to a given limit.\n    \"\"\"\n    if limit < 220:\n        return 0  # 220 is the smallest amicable number\n    \n    # Calculate the sum of divisors for each number in the range\n    divisor_sums = [sum_of_divisors(i) for i in range(limit + 1)]\n    \n    # Identify and sum the amicable numbers\n    amicable_sum = 0\n    for a in range(220, limit + 1):\n        b = divisor_sums[a]\n        if b > a and b <= limit and divisor_sums[b] == a:\n            amicable_sum += a + b  # Add both numbers in the pair\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"\n    Function to calculate the sum of divisors of n excluding n itself.\n    \"\"\"\n    total = 1  # 1 is always a divisor\n    sqrt_n = int(n ** 0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Add the divisor pair if not a perfect square\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Calculates the sum of all amicable numbers up to the specified limit.\n    \"\"\"\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        partner = sum_divisors(num)\n        if partner > num and sum_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Function to calculate the sum of all amicable numbers up to a specified limit n.\n    Amicable numbers are a pair of numbers each of which is the sum of the divisors of the other.\n    \"\"\"\n    def sum_of_divisors(x):\n        \"\"\"Returns the sum of all proper divisors of x.\"\"\"\n        divisors_sum = 1  # 1 is a proper divisor for all x > 1\n        sqrt_x = int(x ** 0.5)\n        for divisor in range(2, sqrt_x + 1):\n            if x % divisor == 0:\n                divisors_sum += divisor\n                if divisor != x // divisor:\n                    divisors_sum += x // divisor\n        return divisors_sum\n    \n    amicable_sum = 0\n    for i in range(2, n):\n        sum_div_i = sum_of_divisors(i)\n        if sum_div_i > i and sum_div_i < n and sum_of_divisors(sum_div_i) == i:\n            amicable_sum += i + sum_div_i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers under the specified limit.\n    \n    An amicable pair consists of two integers for which the sum of proper divisors \n    (excluding the number itself) of each is equal to the other number.\n    \n    Parameters:\n    limit (int): The upper limit for identifying amicable numbers.\n    \n    Returns:\n    int: The sum of all amicable numbers under the limit.\n    \"\"\"\n    \n    def sum_of_divisors(n):\n        \"\"\"Calculate sum of proper divisors of n.\"\"\"\n        divisors_sum = 1  # Start with 1 as it's a divisor for all n > 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:  # Add the quotient only if it's not the square root\n                    divisors_sum += n // i\n        return divisors_sum\n\n    amicable_sum = 0\n    for num in range(2, limit):\n        partner = sum_of_divisors(num)\n        if partner > num and num == sum_of_divisors(partner):\n            amicable_sum += num + partner\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    # Calculate the sum of divisors for a given number\n    result = 1\n    i = 2\n    while i * i <= n:\n        count = 1\n        current_sum = 1\n        current_term = 1\n        while n % i == 0:\n            count += 1\n            current_sum += current_term * i\n            current_term *= i\n            n //= i\n        result *= current_sum\n        i += 1\n    if n != 1:\n        result *= (1 + n)\n    return result\ndef amicable_numbers_sum(number):\n    # Sum all amicable numbers up to the specified number\n    amicable_sum = 0\n    for each in range(2, number):\n        sum_divisors = sum_of_divisors(each) - each\n        sum_divisors_of_sum = sum_of_divisors(sum_divisors) - sum_divisors\n        if each == sum_divisors_of_sum and sum_divisors < each and sum_divisors != each:\n            amicable_sum += each + sum_divisors\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(max_num):\n    \"\"\"\n    This function finds the sum of all amicable numbers up to max_num.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number.\n    \n    :param max_num: The upper limit of the range to check for amicable numbers.\n    :return: The sum of all amicable numbers found.\n    \"\"\"\n    amicable_sum = 0\n    for num in range(2, max_num):\n        partner = sum_divisors(num)\n        if partner > num and sum_divisors(partner) == num:\n            amicable_sum += num + partner\n    return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, word_list):\n    # Split the string into a list of words\n    words = word_list.split()\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    # Split the string into words and filter out those shorter than or equal to n\n    result = [word for word in s.split() if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    # Split the string into a list of words\n    word_list = s.split()\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in word_list if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words and filter based on length > n\n    words = sentence.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    # Split the string into words and filter based on length\n    words = s.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter out words longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    # Split the string into words\n    words = string.split()\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    # Split the string into words\n    word_list = s.split()\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in word_list if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    # Split the string into words\n    word_list = s.split()\n    # Filter words that are longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Split the word_list string into a list of words\n    words = word_list.split()\n    # Use list comprehension to filter out words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    # Return the filtered list of words\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    # Split the string into words\n    words = string.split()\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    # Return the list of long words\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter out words shorter than or equal to n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    # Split the string into a list of words\n    words = s.split()\n    # Use list comprehension to find words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, s):\n    # Split the string into words\n    words = s.split()\n    \n    # Use list comprehension to filter words longer than n\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into a list of words\n    words = text.split()\n    # Filter out words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    # Return the list of words longer than n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into a list of words\n    words = text.split()\n    # Filter the words to keep only those longer than n characters\n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the input string into words\n    words = text.split()\n    # Filter out words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Use list comprehension to filter out words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 89.84693877551021, "dps_norm": 98.66666666666667, "pass@1": 84.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as a reference\n    expected_sum = sum(matrix[0])\n    \n    # Check the sums of all rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check the sums of all columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != expected_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != expected_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Calculate the size of the matrix\n    n = len(mat)\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(mat[0])\n    \n    # Check the sums of all rows\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sums of all columns\n    for col in range(n):\n        if sum(mat[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(mat[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(mat[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Calculate the sum of the first row to define the target sum\n    target_sum = sum(mat[0])\n    \n    # Check rows and columns\n    for i in range(len(mat)):\n        if sum(mat[i]) != target_sum or sum(mat[j][i] for j in range(len(mat))) != target_sum:\n            return False\n    \n    # Check diagonals\n    if sum(mat[i][i] for i in range(len(mat))) != target_sum or sum(mat[i][len(mat)-1-i] for i in range(len(mat))) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set as the benchmark\n    target_sum = sum(matrix[0])\n    \n    # Check sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set as a reference\n    magic_sum = sum(matrix[0])\n    n = len(matrix)\n    \n    # Check rows and columns\n    for i in range(n):\n        if sum(matrix[i]) != magic_sum or sum(row[i] for row in matrix) != magic_sum:\n            return False\n    \n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum or sum(matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set as the base sum\n    base_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != base_sum:\n            return False\n    \n    # Check the sum of each column\n    for col_idx in range(len(matrix[0])):\n        col_sum = sum(row[col_idx] for row in matrix)\n        if col_sum != base_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    main_diagonal_sum = sum(matrix[idx][idx] for idx in range(len(matrix)))\n    if main_diagonal_sum != base_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[idx][len(matrix)-1-idx] for idx in range(len(matrix)))\n    if secondary_diagonal_sum != base_sum:\n        return False\n    \n    # If all checks pass, it is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Calculate the sum of the first row to set as the reference\n    magic_sum = sum(mat[0])\n    \n    # Check the sums of all rows\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sums of all columns\n    for col in range(len(mat)):\n        if sum(mat[row][col] for row in range(len(mat))) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(mat[i][i] for i in range(len(mat))) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(mat[i][len(mat)-1-i] for i in range(len(mat))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set as a benchmark\n    magic_sum = sum(matrix[0])\n    \n    # Check sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sum of each column\n    for col in range(len(matrix[0])):\n        if sum(row[col] for row in matrix) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Extracting the size of the matrix\n    n = len(matrix)\n    \n    # Creating a list of all row sums, column sums, and diagonal sums\n    # Calculate the sum of the first row to use as a reference\n    sum_first_row = sum(matrix[0])\n    \n    # Check row sums\n    for row in matrix:\n        if sum(row) != sum_first_row:\n            return False\n    \n    # Check column sums\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != sum_first_row:\n            return False\n    \n    # Check diagonals sums\n    if sum(matrix[i][i] for i in range(n)) != sum_first_row:\n        return False\n    if sum(matrix[i][n-1-i] for i in range(n)) != sum_first_row:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Size of the matrix\n    n = len(mat)\n    \n    # Calculate the sum of the first row to establish the target sum\n    target_sum = sum(mat[0])\n\n    # Check the sum of each row\n    for row in mat:\n        if sum(row) != target_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(mat[row][col] for row in range(n)) != target_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(mat[i][i] for i in range(n)) != target_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(mat[i][n - 1 - i] for i in range(n)) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Calculate the size of the matrix\n    n = len(mat)\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(mat[0])\n    \n    # Check sums of rows\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of columns\n    for col in range(n):\n        if sum(mat[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(mat[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(mat[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks passed, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Get the size of the matrix\n    n = len(mat)\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(mat[0])\n    \n    # Check the sums of all rows\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sums of all columns\n    for col in range(n):\n        if sum(mat[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(mat[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(mat[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks passed, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Get the size of the matrix\n    n = len(mat)\n    \n    # Calculate the sum of the first row to set as the magic constant\n    magic_sum = sum(mat[0])\n    \n    # Check the sums of all rows\n    for i in range(n):\n        if sum(mat[i]) != magic_sum:\n            return False\n    \n    # Check the sums of all columns\n    for j in range(n):\n        if sum(mat[i][j] for i in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(mat[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(mat[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Sum of the first row to compare with other sums\n    sum1 = sum(mat[0])\n    \n    n = len(mat)\n    \n    # Check sums of all rows\n    for i in range(n):\n        if sum(mat[i]) != sum1:\n            return False\n    \n    # Check sums of all columns\n    for i in range(n):\n        col_sum = sum(row[i] for row in mat)\n        if col_sum != sum1:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diag_sum = sum(mat[i][i] for i in range(n))\n    if main_diag_sum != sum1:\n        return False\n    \n    # Check sum of the secondary diagonal\n    sec_diag_sum = sum(mat[i][n-1-i] for i in range(n))\n    if sec_diag_sum != sum1:\n        return False\n    \n    # If all checks pass\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Sum of the first row to compare with other sums\n    sum_check = sum(mat[0])\n    \n    # Check sum of each row\n    for row in mat:\n        if sum(row) != sum_check:\n            return False\n    \n    # Check sum of each column\n    for col in range(len(mat)):\n        if sum(mat[row][col] for row in range(len(mat))) != sum_check:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(mat[i][i] for i in range(len(mat))) != sum_check:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(mat[i][len(mat)-1-i] for i in range(len(mat))) != sum_check:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # The size of the matrix (assuming it's a square matrix)\n    size = len(mat)\n    \n    # Sum of the first row to compare with others\n    target_sum = sum(mat[0])\n    \n    # Check all rows\n    for row in mat:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check all columns\n    for col in range(size):\n        if sum(mat[row][col] for row in range(size)) != target_sum:\n            return False\n    \n    # Check the main diagonal\n    if sum(mat[i][i] for i in range(size)) != target_sum:\n        return False\n    \n    # Check the secondary diagonal\n    if sum(mat[i][size - 1 - i] for i in range(size)) != target_sum:\n        return False\n    \n    # If all checks passed\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the size of the matrix (n x n)\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to establish the 'magic' constant\n    magic_sum = sum(matrix[0])\n    \n    # Check rows and columns\n    for i in range(n):\n        if sum(matrix[i]) != magic_sum or sum(matrix[j][i] for j in range(n)) != magic_sum:\n            return False\n    \n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum or sum(matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(mat):\n    # Calculate the sum of the first row to set as the reference\n    magic_sum = sum(mat[0])\n    \n    # Check sum of each row\n    for row in mat:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sum of each column\n    for col in range(len(mat)):\n        if sum(row[col] for row in mat) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(mat[i][i] for i in range(len(mat))) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(mat[i][len(mat)-1-i] for i in range(len(mat))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Get the size of the matrix (n x n)\n    n = len(mat)\n    \n    # Calculate the sum of the first row to use as a reference sum\n    target_sum = sum(mat[0])\n    \n    # Check sum of each row\n    for row in mat:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check sum of each column\n    for col in range(n):\n        if sum(mat[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(mat[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(mat[i][n-1-i] for i in range(n)) != target_sum:\n        return False\n    \n    # If all checks pass, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(mat):\n    # Function to calculate the sum of each row, column, or diagonal\n    def calculate_sum(data):\n        return sum(data)\n    \n    size = len(mat)\n    if size == 0:\n        return False\n\n    # Calculating the sum of the first row to set as a reference\n    magic_sum = calculate_sum(mat[0])\n    \n    # Check rows and columns\n    for i in range(size):\n        if calculate_sum(mat[i]) != magic_sum or calculate_sum(row[i] for row in mat) != magic_sum:\n            return False\n    \n    # Check diagonals\n    if calculate_sum(mat[i][i] for i in range(size)) != magic_sum:\n        return False\n    if calculate_sum(mat[i][size - 1 - i] for i in range(size)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 81.99551569506727, "dps_norm": 71.66666666666667, "pass@1": 97.0, "profiled": [{"solution": "def max_occurrences(lst):\n    # Create a dictionary to keep count of each item's frequency\n    frequency_dict = {}\n    \n    # Iterate through the list to populate the frequency dictionary\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_frequency_item = max(frequency_dict, key=frequency_dict.get)\n    return max_frequency_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to keep track of occurrences of each element\n    occurrences = {}\n    for item in lst:\n        if item in occurrences:\n            occurrences[item] += 1\n        else:\n            occurrences[item] = 1\n    \n    # Finding the item with the maximum occurrences\n    max_item = lst[0]\n    max_count = occurrences[max_item]\n    for item in occurrences:\n        if occurrences[item] > max_count:\n            max_item = item\n            max_count = occurrences[item]\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to keep the count of each element\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Finding the element with maximum frequency\n    max_freq_item = None\n    max_freq = 0\n    for item, count in frequency.items():\n        if count > max_freq:\n            max_freq = count\n            max_freq_item = item\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Count the frequency of each element\n    frequency = Counter(lst)\n    # Find the maximum frequency\n    max_freq = max(frequency.values())\n    # Find the item(s) with the maximum frequency\n    max_items = [item for item, count in frequency.items() if count == max_freq]\n    # Assuming there's at least one item with the maximum frequency, return one\n    return max_items[0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Dictionary to count occurrences of each element\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with maximum frequency\n    max_freq_item = None\n    max_freq_count = 0\n    for item, count in frequency.items():\n        if count > max_freq_count:\n            max_freq_count = count\n            max_freq_item = item\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count frequency of each item\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = lst[0]\n    max_count = 1\n    for key, value in frequency_dict.items():\n        if value > max_count:\n            max_count = value\n            max_item = key\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Count the frequency of each item in the list\n    freq_counter = Counter(lst)\n    # Find the item with the maximum frequency\n    max_freq_item = freq_counter.most_common(1)[0][0]\n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "from collections import defaultdict\ndef max_occurrences(lst):\n    # Create a dictionary to keep track of frequency\n    frequency = defaultdict(int)\n    \n    # Iterate over the list to populate the frequency dictionary\n    for item in lst:\n        frequency[item] += 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Calculate the frequency of each element\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = lst[0]\n    max_count = frequency_dict[max_item]\n    for item, count in frequency_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to keep track of occurrences\n    frequency_dict = {}\n    \n    # Iterate through the list to populate the dictionary with frequencies\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Find the item with the maximum occurrence in the dictionary\n    max_freq_item = max(frequency_dict, key=frequency_dict.get)\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    If there are multiple items with the same maximum frequency, it returns\n    the first one encountered.\n    \n    Parameters:\n    lst (list): The list to check for frequency of items.\n    \n    Returns:\n    int: The item with the highest frequency.\n    \"\"\"\n    # Count the frequency of each item in the list\n    frequency_counter = Counter(lst)\n    # Find the item with maximum frequency\n    max_freq_item = max(frequency_counter, key=frequency_counter.get)\n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Dictionary to keep track of occurrences of each element\n    occurrences = {}\n    for item in lst:\n        if item in occurrences:\n            occurrences[item] += 1\n        else:\n            occurrences[item] = 1\n    \n    # Initialize variables to track the max frequency and corresponding item\n    max_freq = 0\n    max_item = None\n    \n    # Iterate through occurrences to find the item with max frequency\n    for item, freq in occurrences.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to hold frequency of each item\n    frequency_dict = {}\n    \n    # Populate the dictionary with frequencies\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Finding the item with maximum occurrences\n    max_item = None\n    max_count = 0\n    for item, count in frequency_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to count occurrences\n    occurrences = {}\n    \n    # Counting occurrences of each element\n    for item in lst:\n        if item in occurrences:\n            occurrences[item] += 1\n        else:\n            occurrences[item] = 1\n    \n    # Finding the element with maximum occurrence\n    max_occurrence = 0\n    max_element = None\n    for key, value in occurrences.items():\n        if value > max_occurrence:\n            max_occurrence = value\n            max_element = key\n    \n    return max_element", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Initialize a dictionary to store the frequency of each item\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq_item = None\n    max_freq = 0\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_freq_item = item\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to store the frequency of each item\n    frequency_dict = {}\n    \n    # Iterate over each item in the list and count occurrences\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Initialize variables to track the item with maximum frequency\n    max_item = lst[0]\n    max_count = frequency_dict[max_item]\n    \n    # Iterate over frequency_dict to find the item with the maximum count\n    for item, count in frequency_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n            \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Using Counter to count occurrences of each element\n    count = Counter(lst)\n    # Finding the element with maximum frequency\n    max_freq = max(count.values())\n    # Getting all elements with the maximum frequency\n    max_elements = [k for k, v in count.items() if v == max_freq]\n    # Return the first element with the highest frequency\n    return max_elements[0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Count the occurrences of each element in the list\n    occurrences = Counter(lst)\n    # Find the element with the maximum occurrences\n    max_occurrence_value = max(occurrences.values())\n    # Get all items with maximum occurrences\n    max_occurrence_items = [item for item, count in occurrences.items() if count == max_occurrence_value]\n    # If there is a tie, return the first element from the list\n    return max_occurrence_items[0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Initialize a dictionary to hold the frequency of elements\n    frequency_dict = {}\n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            # Otherwise, initialize its count to 1\n            frequency_dict[element] = 1\n    \n    # Find the element with the maximum frequency\n    max_freq_item = max(frequency_dict, key=frequency_dict.get)\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count the occurrences of each item in the list\n    count = Counter(lst)\n    # Find the item with the maximum occurrence\n    max_item = max(count, key=count.get)\n    return max_item", "matching_cluster_idx": 4}]}, "Mbpp/137": {"dps": 99.99999999999999, "dps_norm": 100.0, "pass@1": 86.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function calculates the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List[int] - A list of integers.\n    :return: float - The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else float('inf')", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    :param arr: List[int] - an array of integers\n    :return: float - ratio of zeroes to non-zeroes\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function takes an array of integers as input and returns the ratio of zeroes to non-zeroes.\n    \n    Parameters:\n    arr (list): List of integers.\n    \n    Returns:\n    float: Ratio of zeroes to non-zeroes.\n    \"\"\"\n    num_zeros = arr.count(0)\n    num_non_zeros = len(arr) - num_zeros\n    if num_non_zeros == 0:\n        return float('inf')\n    ratio = num_zeros / num_non_zeros\n    return ratio", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    :param arr: List[int], the input array of integers.\n    :return: float, the ratio of zeroes to non-zeroes in the array.\n    \"\"\"\n    num_zeros = arr.count(0)\n    num_non_zeros = len(arr) - num_zeros\n    \n    # Avoid division by zero if there are no non-zero numbers\n    if num_non_zeros == 0:\n        return float('inf') if num_zeros > 0 else 0\n    \n    return num_zeros / num_non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float.\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # If there are no non-zeroes, return infinity\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    :param arr: List of integers\n    :return: The ratio of zeroes to non-zeroes as a float.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function calculates the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes in the array.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # If there are no non-zero elements, return infinity\n    \n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function calculates the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Parameters:\n    arr (list of int): The array of integers.\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    \n    # Avoid division by zero\n    if non_zero_count == 0:\n        return float('inf')\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    :param arr: List[int] - the input array of integers\n    :return: float - the ratio of zeroes to non-zeroes\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # to avoid division by zero\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function takes an array of integers and returns the ratio of zeroes to non-zeroes.\n    \n    :param arr: List[int] - a list of integers\n    :return: float - the ratio of zeroes to non-zeroes\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # If there are no non-zeroes, ratio should be infinite\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    :param arr: List[int], a list of integers.\n    :return: float, ratio of zeroes to non-zeroes.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # If there are no non-zero elements, the ratio tends to infinity\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function calculates the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    ratio = zero_count / non_zero_count if non_zero_count != 0 else float('inf')\n    return ratio", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function takes an array of integers as input and returns the ratio of zeroes to non-zeroes.\n    \n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if all elements are zeroes to avoid division by zero.\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Function to calculate the ratio of zeroes to non-zeroes in an array.\n    \n    Parameters:\n    arr (list): List of integers.\n    \n    Returns:\n    float: Ratio of zeroes to non-zeroes.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else float('inf')", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # If there are no non-zeroes, the ratio is infinite\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes\n    zero_count = arr.count(0)\n    \n    # Count the number of non-zero elements\n    non_zero_count = len(arr) - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    ratio = zero_count / non_zero_count if non_zero_count != 0 else float('inf')\n    \n    return ratio", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function takes an array of integers and returns the ratio of zeroes to non-zeroes.\n    \n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    # Avoid division by zero if there are no non-zero elements\n    if non_zero_count == 0:\n        return float('inf')  # or some other appropriate value to indicate this case\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Parameters:\n    arr (list of int): The input array of integers.\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    \n    # To avoid division by zero, we check if there are any non-zeroes.\n    if non_zero_count == 0:\n        return float('inf')  # Infinite ratio if no non-zero elements are present\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in the array of integers.\n    \n    Parameters:\n    arr (list): List of integers\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # if all elements are zero, ratio is infinite\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}]}, "Mbpp/140": {"dps": 79.17701863354037, "dps_norm": 78.75, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_tuples):\n    # Flatten the list of tuples and convert to a set\n    flattened_set = set(number for sublist in list_of_tuples for number in sublist)\n    return flattened_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    # Flatten the list of tuples and convert to a set\n    result = {item for sublist in lst for item in sublist}\n    return result", "matching_cluster_idx": 5}, {"solution": "def extract_singly(input_list):\n    # Flatten the list of tuples into a single set\n    result_set = set()\n    for item in input_list:\n        result_set.update(item)\n    return list(result_set)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Flatten the list of tuples into a single set\n    return {item for sublist in list_of_tuples for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    # Flatten the list of tuples into a set to remove duplicates\n    flat_set = set(num for tup in list_of_tuples for num in tup)\n    return flat_set", "matching_cluster_idx": 5}, {"solution": "def extract_singly(input_list):\n    # Flatten the list of tuples into a single set\n    result_set = set()\n    for item in input_list:\n        result_set.update(item)\n    return list(result_set)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Flatten the list of tuples into a set of elements\n    flattened_set = {element for sublist in list_of_tuples for element in sublist}\n    return flattened_set", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    # Create a set from the flattened list of lists\n    result_set = set()\n    for sublist in lst:\n        for item in sublist:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(input_list):\n    # Flatten the list of tuples and convert to a set\n    return {item for sublist in input_list for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    # Flatten the list of tuples and convert to a set\n    result_set = set()\n    for sublist in nested_list:\n        for element in sublist:\n            result_set.add(element)\n    return list(result_set)", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_tuples):\n    # Convert list of tuples to a set of unique elements\n    unique_elements = set()\n    for tup in list_of_tuples:\n        unique_elements.update(tup)\n    return list(unique_elements)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Convert each tuple in the list to a set and combine them using union\n    flattened_set = set()\n    for tup in list_of_tuples:\n        flattened_set.update(tup)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(test_list):\n    # Flatten the list of tuples and convert to a set to remove duplicates\n    return set([ele for sub in test_list for ele in sub])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    # Flatten the list of tuples into a single list and then convert to a set\n    return set([item for sublist in lst for item in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_tuples):\n    # Convert list of tuples into a single set containing all elements\n    result_set = set()\n    for tup in list_of_tuples:\n        result_set.update(tup)\n    return list(result_set)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store unique elements\n    unique_elements = set()\n    \n    # Iterate over each tuple in the list\n    for tup in list_of_tuples:\n        # Update the set with elements of the current tuple\n        unique_elements.update(tup)\n    \n    return unique_elements", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Flatten the list of tuples into a single set\n    flattened_set = set()\n    for tuple_ in list_of_tuples:\n        flattened_set.update(tuple_)\n    return list(flattened_set)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Flatten the list of tuples into a set\n    result_set = set()\n    for tup in list_of_tuples:\n        result_set.update(tup)\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lst_of_lsts):\n    # Flatten the list of tuples into a set\n    flat_set = {item for sublist in lst_of_lsts for item in sublist}\n    return flat_set", "matching_cluster_idx": 5}, {"solution": "def extract_singly(tuples_list):\n    # Flatten the list of tuples and convert to a set\n    result_set = {item for sublist in tuples_list for item in sublist}\n    return result_set", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 68.63945578231294, "dps_norm": 41.875, "pass@1": 83.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n\n    Pancake sorting is a variation of the sorting problem in which the only allowed operation is to \n    reverse the elements of some prefix of the sequence.\n\n    Parameters:\n    arr (list): The list of integers to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def flip(sub_list, i):\n        \"\"\"Reverse the elements of the list up to index i\"\"\"\n        start = 0\n        while start < i:\n            sub_list[start], sub_list[i] = sub_list[i], sub_list[start]\n            start += 1\n            i -= 1\n\n    def find_max(sub_list, n):\n        \"\"\"Find the index of the maximum element in sub_list up to n\"\"\"\n        index = 0\n        for j in range(n):\n            if sub_list[j] > sub_list[index]:\n                index = j\n        return index\n    \n    n = len(arr)\n    while n > 1:\n        max_idx = find_max(arr, n)\n        flip(arr, max_idx)\n        flip(arr, n - 1)\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n    \n    Parameters:\n        arr (list): The list to be sorted.\n        \n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, i):\n        \"\"\"Reverses the sublist from 0 to i of sub_arr.\"\"\"\n        start = 0\n        while start < i:\n            sub_arr[start], sub_arr[i] = sub_arr[i], sub_arr[start]\n            start += 1\n            i -= 1\n\n    curr_size = len(arr)\n    while curr_size > 1:\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum element to the end of the current array if not already at the end\n        if max_index != curr_size - 1:\n            # Move it to the beginning if it's not already there\n            if max_index != 0:\n                flip(arr, max_index)\n            # Move it to its final position\n            flip(arr, curr_size - 1)\n        \n        # Reduce the current size of the array\n        curr_size -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, i):\n        start = 0\n        while start < i:\n            sub_arr[start], sub_arr[i] = sub_arr[i], sub_arr[start]\n            start += 1\n            i -= 1\n\n    def find_max_index(arr, n):\n        idx = 0\n        for i in range(n):\n            if arr[i] > arr[idx]:\n                idx = i\n        return idx\n\n    n = len(arr)\n    while n > 1:\n        max_idx = find_max_index(arr, n)\n        flip(arr, max_idx)\n        flip(arr, n - 1)\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the Pancake Sort algorithm.\n    \n    This function flips the largest unsorted element to the beginning of the array,\n    then flips it to its correct position at the end of the unsorted section.\n    This process is repeated until the entire array is sorted.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    def flip(sub_arr, i):\n        \"\"\"Reverses the first i elements of the list sub_arr.\"\"\"\n        start = 0\n        while start < i:\n            sub_arr[start], sub_arr[i] = sub_arr[i], sub_arr[start]\n            start += 1\n            i -= 1\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of arr\n        max_index = arr.index(max(arr[:size]))\n        if max_index + 1 != size:\n            # Flip the largest unsorted element to the start if it's not already there\n            if max_index != 0:\n                flip(arr, max_index)\n            # Flip it to its sorted position\n            flip(arr, size - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Perform pancake sort on the given list.\n    \n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes \n    in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. \n    A pancake number is the minimum number of flips required for a given number of pancakes. The problem was first posed \n    by Bill Gates and Christos Papadimitriou.\n    \n    :param arr: List of integers to be sorted.\n    :return: Sorted list of integers.\n    \"\"\"\n    n = len(arr)\n\n    while n > 1:\n        # Find the index of the maximum element\n        max_idx = arr.index(max(arr[0:n]))\n        \n        if max_idx != n - 1:\n            # Flip the array from 0 to max_idx\n            arr = arr[:max_idx+1][::-1] + arr[max_idx+1:]\n            # Flip the entire array to move the maximum element to its correct position\n            arr = arr[:n][::-1] + arr[n:]\n        \n        n -= 1\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n    \n    Parameters:\n    arr (list): The list of integers to sort.\n    \n    Returns:\n    list: The sorted list of integers.\n    \"\"\"\n    \n    def flip(sub_arr, i):\n        \"\"\"Flip the sub-array from 0 to i.\"\"\"\n        start = 0\n        while start < i:\n            sub_arr[start], sub_arr[i] = sub_arr[i], sub_arr[start]\n            start += 1\n            i -= 1\n            \n    n = len(arr)\n    while n > 1:\n        # Find index of the maximum element in arr[0:n]\n        max_index = arr.index(max(arr[0:n]))\n        \n        # Move the maximum element to the end of the current array if it's not already there\n        if max_index != n - 1:\n            # Flip the array up to the max index\n            flip(arr, max_index)\n            # Flip the entire array to move the max element to the end\n            flip(arr, n - 1)\n        \n        # Reduce n by 1 since the last element is now sorted\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort an array by repeatedly flipping sublists, similar to sorting a stack of pancakes.\n    \n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    def flip(sub_list, i):\n        \"\"\"Flip (reverse) the sublist from start to index i.\"\"\"\n        start = 0\n        while start < i:\n            sub_list[start], sub_list[i] = sub_list[i], sub_list[start]\n            start += 1\n            i -= 1\n\n    cur = len(arr)\n    while cur > 1:\n        # Find the index of the maximum element in the remaining sublist\n        mi = arr.index(max(arr[0:cur]))\n        # Flip the sublist so the maximum element goes to the start\n        flip(arr, mi)\n        # Flip the entire sublist so the maximum element goes to the end\n        flip(arr, cur - 1)\n        cur -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Perform a pancake sort on the given list.\n    \n    :param arr: List to be sorted\n    :return: The sorted list\n    \"\"\"\n    def flip(sublist, i):\n        start = 0\n        while start < i:\n            sublist[start], sublist[i] = sublist[i], sublist[start]\n            start += 1\n            i -= 1\n\n    n = len(arr)\n    \n    while n > 1:\n        # Find the index of the maximum element in arr[0..n-1]\n        max_index = arr.index(max(arr[0:n]))\n        \n        # Bring the maximum element to the beginning of the array\n        flip(arr, max_index)\n        \n        # Now move the maximum element to its correct position\n        flip(arr, n - 1)\n        \n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sort algorithm.\n    \n    Pancake sorting involves flipping the elements of the array to move the largest element to its correct position.\n    It works by iterating through the array from the last element to the first and finding the index of the maximum element\n    within the current unsorted portion of the array. It then flips the array twice to move the maximum element to its\n    correct position.\n    \n    :param arr: List of integers to be sorted.\n    :return: The sorted list.\n    \"\"\"\n    def flip(sub_arr, i):\n        start = 0\n        while start < i:\n            sub_arr[start], sub_arr[i] = sub_arr[i], sub_arr[start]\n            start += 1\n            i -= 1\n    \n    n = len(arr)\n    while n > 1:\n        max_index = arr.index(max(arr[0:n]))\n        flip(arr, max_index)\n        flip(arr, n - 1)\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort an array using the pancake sort algorithm.\n    \n    The function sorts an array of integers in ascending order using the\n    pancake sort technique, which involves flipping parts of the list to \n    move the largest (or smallest) unsorted element to its final position.\n\n    :param arr: List of integers to be sorted.\n    :return: The sorted list.\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"\n        Flip the elements of the sublist up to index k.\n\n        :param sublist: The list to flip.\n        :param k: The number of elements to flip.\n        \"\"\"\n        sublist[:k] = sublist[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find index of maximum element in arr[0:n]\n        max_idx = arr.index(max(arr[0:n]))\n        # Move the maximum element to the end of the current array\n        if max_idx != n - 1:\n            # Flip the list from 0 to max_idx\n            flip(arr, max_idx + 1)\n            # Flip the entire list to move the maximum element to the end\n            flip(arr, n)\n        n -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort a list of elements using pancake sort algorithm.\n    \"\"\"\n    def flip(sub_arr, i):\n        \"\"\"Flip the sub-array from start to i.\"\"\"\n        start = 0\n        while start < i:\n            sub_arr[start], sub_arr[i] = sub_arr[i], sub_arr[start]\n            start += 1\n            i -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in arr[0...n-1]\n        max_idx = arr.index(max(arr[0:n]))\n        # Move the maximum element to the end of the array\n        if max_idx != n-1:\n            # Flip the array from 0 to max_idx\n            flip(arr, max_idx)\n            # Flip the entire array to move the maximum number to the end\n            flip(arr, n-1)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n    \n    Parameters:\n    arr (list): The input list to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def flip(sublist, i):\n        \"\"\"Helper function to flip the sublist from 0 to i.\"\"\"\n        start = 0\n        while start < i:\n            sublist[start], sublist[i] = sublist[i], sublist[start]\n            start += 1\n            i -= 1\n    \n    n = len(arr)\n    while n > 1:\n        # Find index of the maximum element in arr[0...n-1]\n        max_idx = arr.index(max(arr[0:n]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_idx != n - 1:\n            # Flip the array from 0 to max_idx\n            flip(arr, max_idx)\n            # Flip the entire array to move max element at the end\n            flip(arr, n - 1)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort an array using the Pancake Sort algorithm.\n    \n    The function sorts an array in ascending order by flipping sublists \n    of the array. A flip means to reverse the order of the first k elements \n    of the array, where k is a positive integer less than or equal to the length \n    of the array.\n    \n    :param arr: List[int] - The array to be sorted.\n    :return: List[int] - The sorted array.\n    \"\"\"\n    def flip(sub_list, k):\n        \"\"\"\n        Flip the first k elements of the sub_list.\n        \n        :param sub_list: List[int] - The sub-list to be flipped.\n        :param k: int - The number of elements from the start to flip.\n        \"\"\"\n        i = 0\n        while i < k // 2:\n            sub_list[i], sub_list[k-i-1] = sub_list[k-i-1], sub_list[i]\n            i += 1\n            \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the remaining sublist\n        max_idx = arr.index(max(arr[0:n]))\n        if max_idx != n - 1:\n            # Flip the sublist to move the maximum element to the beginning\n            flip(arr, max_idx+1)\n            # Flip the entire sublist to move the maximum element to the end\n            flip(arr, n)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the Pancake Sort algorithm.\n    \n    The function repeatedly finds the maximum element, flips the array at that element,\n    and then flips the entire unsorted section of the array to move the maximum element\n    to its correct position at the end of the array. This process is repeated until the\n    array is sorted.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def flip(sublist, i):\n        # Reverses the first i elements of the sublist\n        sublist[:i] = sublist[:i][::-1]\n    \n    cur = len(arr)\n    while cur > 1:\n        # Find the index of the maximum element in arr[0:cur]\n        mi = arr.index(max(arr[0:cur]))\n        if mi != cur - 1:\n            # Flip the maximum number to the beginning\n            flip(arr, mi+1)\n            # Flip it to its destination\n            flip(arr, cur)\n        cur -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n    \n    Parameters:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def flip(sub_list, i):\n        \"\"\"Reverse elements in the list up to index i.\"\"\"\n        sub_list[:i+1] = sub_list[:i+1][::-1]\n    \n    arr_len = len(arr)\n    for size in range(arr_len, 1, -1):\n        max_index = max(range(size), key=arr.__getitem__)\n        if max_index+1 != size:\n            # Move the maximum element to the beginning if it's not already there.\n            if max_index != 0:\n                flip(arr, max_index)\n            # Move the maximum element to its correct position.\n            flip(arr, size-1)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n    This algorithm flips sublists of the array to move the largest element to its correct position.\n\n    :param arr: List of elements to be sorted.\n    :return: The sorted list.\n    \"\"\"\n    def flip(sub_arr, i):\n        \"\"\"\n        Reverses the elements of sub_arr up to index i.\n        \n        :param sub_arr: The sub-array to flip.\n        :param i: The index up to which to flip.\n        :return: The flipped sub-array up to i.\n        \"\"\"\n        start = 0\n        while start < i:\n            sub_arr[start], sub_arr[i] = sub_arr[i], sub_arr[start]\n            start += 1\n            i -= 1\n        return sub_arr\n\n    n = len(arr)\n\n    while n > 1:\n        # Find the index of the maximum element in arr[0..n-1]\n        max_idx = arr.index(max(arr[0:n]))\n        if max_idx != n - 1:\n            # Flip the array from 0 to max_idx\n            arr = flip(arr, max_idx)\n            # Flip the entire array to move the max element to the end\n            arr = flip(arr, n - 1)\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort the array using the pancake sort technique.\n    \n    :param arr: List of integers to be sorted\n    :return: The sorted list of integers\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"\n        Reverse the first k elements of the sublist.\n        \n        :param sublist: The list to be flipped\n        :param k: The index to which the sublist needs to be flipped\n        \"\"\"\n        i = 0\n        while i < k // 2:\n            sublist[i], sublist[k - i - 1] = sublist[k - i - 1], sublist[i]\n            i += 1\n\n    cur = len(arr)\n    while cur > 1:\n        # Find the index of the maximum element in arr[:cur]\n        mi = arr.index(max(arr[0:cur]))\n        if mi != cur - 1:\n            # Flip arr[0:mi + 1] (to move max to the beginning)\n            flip(arr, mi + 1)\n            # Flip arr[0:cur] (to move max to its correct position)\n            flip(arr, cur)\n        cur -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the pancake sorting algorithm.\n    \n    :param arr: List of integers to be sorted.\n    :return: The sorted list of integers.\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"Helper function to reverse the first k elements of the sublist.\"\"\"\n        sublist[:k] = sublist[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find index of the maximum element in the list\n        max_index = arr.index(max(arr[0:n]))\n        \n        # Move the maximum element to the beginning of the array\n        flip(arr, max_index + 1)\n        \n        # Move the maximum element to its correct position at the end\n        flip(arr, n)\n        \n        n -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array using the Pancake sorting algorithm.\n    The function flips the elements of the array to sort it.\n    \n    :param arr: List of integers to be sorted.\n    :return: The sorted list.\n    \"\"\"\n    def flip(sub_arr, i):\n        \"\"\"Reverse elements in the list up to index i.\"\"\"\n        sub_arr[:i+1] = sub_arr[:i+1][::-1]\n    \n    for size in range(len(arr), 1, -1):\n        # Find the index of the maximum element in the remaining sublist\n        max_index = arr.index(max(arr[:size]))\n        \n        # Move the maximum element to the beginning of the sublist if it's not already there\n        if max_index != size - 1:\n            # If the maximum is not at the beginning, flip it to the beginning\n            if max_index != 0:\n                flip(arr, max_index)\n            # Flip it into its final position\n            flip(arr, size - 1)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort the array using pancake sort algorithm.\n    \n    Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the minimum number of flips required for a given number of pancakes. In this case, we are sorting a list of numbers.\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"Flip the sublist from 0 to k.\"\"\"\n        sublist[:k+1] = sublist[:k+1][::-1]\n    \n    def find_max(arr, n):\n        \"\"\"Find the index of the maximum element in the first n elements of arr.\"\"\"\n        return max(range(n), key=arr.__getitem__)\n    \n    cur_size = len(arr)\n    while cur_size > 1:\n        max_idx = find_max(arr, cur_size)\n        if max_idx != cur_size - 1:\n            # Flip the maximum number to the beginning if it's not already at the end.\n            flip(arr, max_idx)\n            # Flip it to the current position at the end.\n            flip(arr, cur_size - 1)\n        cur_size -= 1\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    :param nums: List of integers\n    :return: Count of pairs that XOR to an even number\n    \"\"\"\n    even_xor_count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_xor_count += 1\n    return even_xor_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Initialize count of even XOR pairs\n    even_xor_pairs = 0\n    \n    # Iterate through each possible pair in the list\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # Calculate XOR of the pair\n            xor_result = nums[i] ^ nums[j]\n            # Check if XOR result is even\n            if xor_result % 2 == 0:\n                even_xor_pairs += 1\n                \n    return even_xor_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    # Iterate through the list with two loops to check every pair\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # If the XOR of the pair is even, increment count\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Initialize the count to 0\n    count = 0\n    # Get the length of the list\n    n = len(nums)\n    \n    # Iterate through the list to get all possible pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # If the XOR of the pair is even, increment the count\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n                \n    # Return the total count of pairs with even XOR\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Count the number of pairs of integers in the list that XOR to an even number.\n    \n    :param lst: List of integers\n    :return: Number of pairs that XOR to an even number\n    \"\"\"\n    even_pair_count = 0\n    n = len(lst)\n    # Iterate through the list to find pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_pair_count += 1\n    return even_pair_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of unique pairs in the list that XOR to an even number.\n    \n    :param lst: List of integers\n    :return: Count of pairs that XOR to an even number\n    \"\"\"\n    even_count = 0\n    # Iterate over each unique pair\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # Check if xor is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    # Iterate through the array to find pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_pairs_count = 0\n    n = len(nums)\n    # Iterate through the list to find all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_pairs_count += 1\n    return even_pairs_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    \n    # Iterate through each pair in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if xor of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n                \n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    # Initialize counter for pairs\n    even_pair_count = 0\n    \n    # Iterate through the list to find pairs\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # XOR the pair and check if the result is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_pair_count += 1\n                \n    return even_pair_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Initialize the count of pairs\n    count = 0\n    # Iterate over the list to get the first element of the pair\n    for i in range(len(nums)):\n        # Iterate over the list to get the second element of the pair\n        for j in range(i + 1, len(nums)):\n            # Check if xor of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                # Increment count if xor is even\n                count += 1\n    # Return the count of pairs with even xor\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Initialize counter for pairs with even XOR\n    even_xor_pairs = 0\n    \n    # Iterate through the list for the first element of the pair\n    for i in range(len(nums)):\n        # Iterate through the list for the second element of the pair\n        for j in range(i + 1, len(nums)):\n            # Check if the XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                # If true, increment the counter\n                even_xor_pairs += 1\n    \n    # Return the total count of pairs with even XOR\n    return even_xor_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the counter for even XOR pairs\n    even_xor_pairs = 0\n    # Get the length of the list\n    n = len(arr)\n    # Loop through each element\n    for i in range(n):\n        for j in range(i + 1, n):\n            # If the XOR of the pair is even, increment the counter\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                even_xor_pairs += 1\n    return even_xor_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Initialize counter for even XOR pairs\n    even_xor_pairs = 0\n    \n    # Iterate through each number in the list\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # Check if the XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_xor_pairs += 1\n                \n    return even_xor_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Initialize the count of pairs\n    even_pair_count = 0\n    \n    # Iterate through the list to get all possible pairs\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # Check if xor of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_pair_count += 1\n                \n    return even_pair_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    n = len(nums)\n    \n    # Iterate through each possible pair in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n                \n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list nums that XOR to an even number.\n    \n    :param nums: List of integers\n    :return: Count of pairs that XOR to an even number\n    \"\"\"\n    even_count = 0\n    # Iterate through the list to get all possible pairs\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # Check if XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize counter for pairs\n    even_pairs_count = 0\n    \n    # Iterate through the array for all possible pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # XOR the pair and check if the result is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                even_pairs_count += 1\n                \n    return even_pairs_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate over the list to get pairs\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # Check if the xor of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_pairs = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_pairs += 1\n    return even_pairs", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 93.6231884057971, "dps_norm": 98.75, "pass@1": 98.0, "profiled": [{"solution": "def sum_range_list(lst, start_index, end_index):\n    # Calculate the sum of the sublist defined by the given range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate sum of elements in the specified range\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Ensure the indices are within the bounds of the list\n    start = max(0, start)\n    end = min(len(lst) - 1, end)\n    # Compute the sum of elements between the indices\n    return sum(lst[start:end+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate the sum of elements within the specified range\n    total_sum = sum(lst[start:end+1])\n    return total_sum", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    # Calculate the sum of the specified range in the list\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate the sum of the sublist from start index to end index inclusive\n    sublist = lst[start:end+1]\n    return sum(sublist)", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    # Calculate the sum of elements within the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate the sum of elements from start to end index\n    total_sum = sum(lst[start:end+1])\n    return total_sum", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    # Calculate the sum of elements within the specified range\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    # Calculate the sum of elements from start_index to end_index inclusive\n    sub_list_sum = sum(lst[start_index:end_index + 1])\n    return sub_list_sum", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate the sum of the sublist from start to end (inclusive)\n    sublist_sum = sum(lst[start:end+1])\n    return sublist_sum", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate the sum of elements from start to end (inclusive)\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    # Calculate the sum of elements in the specified range\n    total_sum = sum(lst[start_idx:end_idx+1])\n    return total_sum", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    # Calculate the sum of elements between the given indices\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    # Ensure indices are within the bounds of the list\n    start_idx = max(0, start_idx)\n    end_idx = min(len(lst) - 1, end_idx)\n    \n    # Calculate the sum of the specified range\n    return sum(lst[start_idx:end_idx + 1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    # Calculate the sum of the specified range in the list\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate the sum of the sublist specified by the indices\n    sublist_sum = sum(lst[start:end+1])\n    return sublist_sum", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_idx, end_idx):\n    # Calculate the sum of the sublist defined by the start and end indices\n    sublist_sum = sum(nums[start_idx:end_idx + 1])\n    return sublist_sum", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    # Calculate the sum of elements within the specified range\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate sum of elements from index 'start' to 'end'\n    total_sum = sum(lst[start:end+1])\n    return total_sum", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 79.57364341085271, "dps_norm": 48.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(s):\n    # Extract characters with even index (odd position in human terms)\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    # Select characters that have even index values (which correspond to odd positions in human counting)\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    # Return a new string formed by characters at even indices from the original string\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate through the string and select characters at even indices\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty result string\n    result = ''\n    \n    # Iterate over the string and take only characters with even index values (odd positions)\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    # Using list comprehension to construct a string from characters at even indices (0-based)\n    result = ''.join([input_str[i] for i in range(len(input_str)) if i % 2 == 0])\n    return result", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(s):\n    # Use slicing to get characters at even indices (0-based index)\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    # Return characters from the string which are at even index positions\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    # Using list comprehension to filter out characters at odd indices\n    result = ''.join([s[i] for i in range(len(s)) if i % 2 == 0])\n    return result", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(s):\n    # Initialize an empty result string\n    result = ''\n    # Iterate through the string using the index\n    for index in range(len(s)):\n        # Check if the index is even (since indexing starts from 0)\n        if index % 2 == 0:\n            # Append the character at the even index to the result string\n            result += s[index]\n    # Return the result string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Select characters at even indices (0-based index, so these are the odd positions in 1-based terms)\n    result = s[::2]\n    return result", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(str):\n    # Initialize an empty result string\n    result = ''\n    \n    # Iterate over the string, considering only even indices (0-based)\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Extract characters with even index values (odd positions in human counting)\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(str):\n    # Initialize an empty string to hold the result\n    result = ''\n    # Iterate over the string with index\n    for i in range(len(str)):\n        # Check if index is even (since we want characters at odd positions based on human count)\n        if i % 2 == 0:\n            # Append the character at this index to the result string\n            result += str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate through the string, considering only even indices (0, 2, 4, ...)\n    for i in range(0, len(s), 2):\n        result += s[i]\n    return result", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(s):\n    # Return the string made up of characters at even indices (0-based)\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(str):\n    # Initialize an empty result string\n    result_string = ''\n    \n    # Loop through the string, checking the index\n    for i in range(len(str)):\n        # Append character if its index is even (since index starts at 0, even indexes correspond to odd positions)\n        if i % 2 == 0:\n            result_string += str[i]\n    \n    return result_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Use slicing to get characters at even indices (0-based indexing)\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(str):\n    # Initialize an empty result string\n    result = ''\n    # Iterate over the string with index\n    for i in range(len(str)):\n        # Check if index is even (0, 2, 4, ...)\n        if i % 2 == 0:\n            # Append character at even index to result string\n            result += str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Return a new string that includes characters at even indices\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 1}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace blank spaces with the given character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    # Replace blank spaces with the provided character\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace blank spaces in the string with the provided character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    # Replace spaces in the string 's' with the character 'ch'\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace blank spaces with the given character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, replace_char):\n    # Replace all blank spaces in the input string with the replace character\n    return input_str.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace all blank spaces with the specified character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace blank spaces with the given character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    # Replace spaces with the specified character\n    result_string = string.replace(' ', char)\n    return result_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    # Replace blank spaces with the given character\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace blank spaces with the given character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    # Replace blank spaces in the string with the specified character\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    # Replace spaces in the input_string with replace_char\n    return input_string.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace spaces in the string with the specified character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace blank spaces with the given character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    # Replace spaces with the character 'ch'\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace blank spaces in the string with the specified character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace blank spaces with the specified character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 73.62068965517241, "dps_norm": 76.5, "pass@1": 54.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP table with dimensions (m+1) x (n+1)\n    # dp[i][j] represents the number of sequences of length j ending with a number less than or equal to i\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    # Fill the table with base cases and recursive cases\n    for i in range(1, m+1):\n        dp[i][1] = 1  # There is exactly one sequence of length 1 for each number i: the sequence [i]\n\n    for j in range(2, n+1):\n        for i in range(1, m+1):\n            for x in range(1, i//2 + 1):\n                dp[i][j] += dp[x][j-1]\n    \n    # Sum up all the sequences of length n\n    result = sum(dp[i][n] for i in range(1, m+1))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a DP table with dimensions (n+1) x (m+1)\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Base case: There's one sequence of length 1 for each possible value\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    \n    # Fill the DP table\n    for length in range(2, n + 1):  # Sequence length from 2 to n\n        for max_val in range(1, m + 1):  # Maximum possible value in sequence\n            # Calculate the sum of sequences ending with values less than or equal to half of max_val\n            for prev_val in range(1, (max_val // 2) + 1):\n                dp[length][max_val] += dp[length - 1][prev_val]\n    \n    # Sum up all possibilities for sequences of length n\n    total_sequences = sum(dp[n])\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: If the length of the sequence is 1, any number from 1 to m is a valid sequence.\n    if n == 1:\n        return m\n    \n    # Initialize a 2D list with 0s to store the count of sequences for lengths 1 to n.\n    sequence_counts = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # For sequences of length 1, every number from 1 to m is a valid sequence, so count is 1.\n    for i in range(1, m + 1):\n        sequence_counts[i][1] = 1\n    \n    # Fill the sequence_counts table.\n    for length in range(2, n + 1):  # For each length from 2 to n\n        for current_val in range(1, m + 1):  # For each possible value from 1 to m\n            # The count of sequences ending with 'current_val' is the sum of counts of all\n            # possible previous values in the sequence which are less than or equal to half of 'current_val'.\n            for prev_val in range(1, current_val // 2 + 1):\n                sequence_counts[current_val][length] += sequence_counts[prev_val][length - 1]\n    \n    # The total count of sequences of length n is the sum of counts ending with any value from 1 to m.\n    total_sequences = sum(sequence_counts[i][n] for i in range(1, m + 1))\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a DP table\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Initialize base case\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the DP table\n    for length in range(2, n + 1):\n        for current in range(1, m + 1):\n            for prev in range(1, current // 2 + 1):\n                dp[current][length] += dp[prev][length - 1]\n    \n    # Sum up all the ways to form a sequence of length n with numbers up to m\n    total_sequences = sum(dp[i][n] for i in range(1, m + 1))\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a DP table with zeros\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Base case: For each number from 1 to m, there is one sequence of length 1\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the DP table\n    for length in range(2, n + 1):\n        for end in range(1, m + 1):\n            for prev in range(1, (end // 2) + 1):\n                dp[end][length] += dp[prev][length - 1]\n    \n    # Sum up all possible sequences ending with any number from 1 to m\n    total_sequences = sum(dp[i][n] for i in range(1, m + 1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP array with zeros\n    dp = [[0 for _ in range(n + 1)] for __ in range(m + 1)]\n    \n    # Base case initialization\n    for i in range(m + 1):\n        dp[i][1] = i\n    \n    # Fill the DP table\n    for j in range(2, n + 1):\n        for i in range(2, m + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n\n    return dp[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize the dp array with zeros\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Set base case, for each m, there's 1 sequence of length 1 (the number itself)\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(2, n + 1):\n            for k in range(1, (i // 2) + 1):\n                dp[i][j] += dp[k][j - 1]\n    \n    # Sum up all the possible sequences of length n for numbers up to m\n    result = sum(dp[i][n] for i in range(1, m + 1))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a DP array with size m+1, set all values to 0\n    dp = [0] * (m + 1)\n    \n    # Start filling the DP table from the first possible value to m\n    for i in range(1, m + 1):\n        dp[i] = 1  # Every number itself is a sequence of length 1\n    \n    for length in range(2, n + 1):  # For each sequence length from 2 to n\n        new_dp = [0] * (m + 1)  # Create a new DP array for this length\n        \n        for i in range(1, m + 1):\n            for j in range(1, i // 2 + 1):\n                new_dp[i] += dp[j]  # Add all possible sequences ending with j that can be followed by i\n        \n        dp = new_dp  # Update the DP array for the next iteration\n    \n    return sum(dp)  # Sum of all possible sequences of length n", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list with dimensions (m+1) x (n+1) filled with zeros\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    # Fill the dp table with base cases: Any sequence of length 1 is 1\n    for i in range(1, m+1):\n        dp[i][1] = 1\n    \n    # Fill the dp table for sequences of length 2 to n\n    for i in range(1, m+1):\n        for j in range(2, n+1):\n            # Sum the number of sequences ending with each number less than or equal to half of i\n            for k in range(1, (i//2) + 1):\n                dp[i][j] += dp[k][j-1]\n    \n    # Sum all the ways to form sequences of length n with the last element being from 1 to m\n    total_sequences = sum(dp[i][n] for i in range(1, m+1))\n    return total_sequences", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list to store subproblem solutions\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Initialize the base case for subproblem solutions\n    for i in range(m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for j in range(2, n + 1):  # For every length j from 2 to n\n        for i in range(1, m + 1):  # For every value i from 1 to m\n            for x in range(1, i // 2 + 1):  # For every possible previous element x\n                dp[i][j] += dp[x][j - 1]\n    \n    # Sum all possible sequences ending with any number from 1 to m\n    total_sequences = sum(dp[i][n] for i in range(1, m + 1))\n    return total_sequences", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list with base case values, 1 for all m and n=1\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for j in range(2, n + 1):  # For each length from 2 to n\n        for i in range(1, m + 1):  # For each possible maximum value from 1 to m\n            for k in range(1, i // 2 + 1):  # For each possible previous value\n                dp[i][j] += dp[k][j - 1]\n    \n    # Sum up all possible sequences of length n with maximum value from 1 to m\n    total_sequences = sum(dp[i][n] for i in range(1, m + 1))\n    return total_sequences", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    def dfs(current_length, prev):\n        if current_length == n:\n            return 1\n        total_sequences = 0\n        for i in range(2 * prev, m + 1):\n            total_sequences += dfs(current_length + 1, i)\n        return total_sequences\n\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += dfs(1, i)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list dp with dimensions (n+1) x (m+1) filled with zeros\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):  # for each sequence length\n        for j in range(1, m + 1):  # for each possible max value\n            if i == 1:\n                # For sequence length 1, there's exactly 1 sequence for each j\n                dp[i][j] = j\n            else:\n                # dp[i][j] is the sum of dp[i-1][k] for all k <= j//2\n                dp[i][j] = dp[i][j - 1] + (dp[i - 1][j // 2] if j > 1 else 0)\n    \n    # The answer is the total for sequence length n with max value m\n    return dp[n][m]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list to store subproblems' results\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize the base case where sequence length is 1\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp array\n    for length in range(2, n + 1):  # length of sequence\n        for last in range(1, m + 1):  # last element in sequence\n            # Sum up all possible sequences ending with last and of length (length-1)\n            for prev in range(1, last // 2 + 1):\n                dp[last][length] += dp[prev][length - 1]\n    \n    # Sum up all possible sequences of length n with last element up to m\n    result = sum(dp[i][n] for i in range(1, m + 1))\n    return result", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2D list to store the count of sequences\n    dp = [[0 for _ in range(n + 1)] for __ in range(m + 1)]\n    \n    # Initialize the base case: sequences of length 1\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for length in range(2, n + 1):\n        for last in range(1, m + 1):\n            total = 0\n            for prev in range(1, (last // 2) + 1):\n                total += dp[prev][length - 1]\n            dp[last][length] = total\n    \n    # Sum all sequences of length n\n    result = 0\n    for i in range(1, m + 1):\n        result += dp[i][n]\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a DP table with zeros\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    # Each single number is a valid sequence for n = 1\n    for i in range(1, m+1):\n        dp[i][1] = 1\n    \n    # Fill the DP table\n    for j in range(2, n+1):  # For each sequence length\n        for i in range(1, m+1):  # For each value i\n            for k in range(1, (i // 2) + 1):  # Find all possible previous elements\n                dp[i][j] += dp[k][j-1]\n    \n    # Sum up all the sequences of length n\n    total_sequences = sum(dp[i][n] for i in range(1, m+1))\n    \n    return total_sequences", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP array with zeros\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    # Fill the DP table\n    for i in range(1, m+1):\n        dp[i][1] = 1  # With sequence length 1, every number is a valid sequence\n    \n    for j in range(2, n+1):\n        for i in range(1, m+1):\n            for k in range(1, (i // 2) + 1):\n                dp[i][j] += dp[k][j-1]\n    \n    # Sum up all the sequences that end with any number from 1 to m\n    total_sequences = sum(dp[i][n] for i in range(1, m+1))\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize the memoization table\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    # Base case: There's one way to form a sequence of length 1 for each number\n    for i in range(1, m+1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for length in range(2, n+1):\n        for num in range(1, m+1):\n            # Sum up all valid sequences ending with a number less than num//2\n            for prev_num in range(1, num//2 + 1):\n                dp[num][length] += dp[prev_num][length - 1]\n    \n    # Sum up all possible sequences of length n\n    total_sequences = sum(dp[i][n] for i in range(1, m+1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a DP table\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Base case: for sequence length 1, there are 'm' possibilities\n    for i in range(1, m + 1):\n        dp[i][1] = i\n\n    # Fill the DP table\n    for length in range(2, n + 1):\n        for value in range(1, m + 1):\n            dp[value][length] = dp[value - 1][length]\n            if value >= 2 * (length - 1):\n                dp[value][length] += dp[value // 2][length - 1]\n    \n    # The answer will be in dp[m][n]\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list for dynamic programming\n    # dp[i][j] will store the number of sequences of length i ending with a number j\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # There is 1 sequence of length 1 ending with each number from 1 to m\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    \n    # Fill the dp table\n    for length in range(2, n + 1):\n        for last_num in range(1, m + 1):\n            for prev_num in range(1, (last_num // 2) + 1):\n                dp[length][last_num] += dp[length - 1][prev_num]\n    \n    # Sum up all sequences of length n\n    total_sequences = sum(dp[n])\n    return total_sequences", "matching_cluster_idx": 7}]}, "Mbpp/240": {"dps": 100.00000000000001, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    # Remove the last element of the first list\n    del list1[-1]\n    # Extend list1 with all elements of list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from the first list\n    lst1.pop()\n    # Extend the first list with all elements from the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element of the first list\n    list1.pop()\n    # Extend the first list with all elements from the second list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with all elements from the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with all elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from the first list\n    lst1.pop()\n    # Extend lst1 with the elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element from the first list\n    first_list.pop()\n    # Extend the first list with the elements of the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with all elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element of the first list\n    first_list.pop()\n    # Extend the first list with all elements from the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with the elements from the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from the first list\n    lst1.pop()\n    # Extend the first list with all elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with all elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(first_list, second_list):\n    # Remove the last element of the first list\n    first_list.pop()\n    # Extend the first list with all elements of the second list\n    first_list.extend(second_list)\n    return first_list", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from the first list\n    lst1.pop()\n    # Extend the first list with the elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from lst1\n    lst1.pop()\n    # Extend lst1 with all elements from lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element from the first list\n    list1.pop()\n    # Extend the first list with the elements of the second list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from the first list\n    lst1.pop()\n    # Extend the first list with all elements from the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with the elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Remove the last element of the first list\n    list1.pop()\n    # Extend the first list with all elements of the second list\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 8}]}, "Mbpp/251": {"dps": 87.95977011494254, "dps_norm": 76.66666666666666, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, elem):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through each element in the list\n    for item in lst:\n        # Append the element and then the item to the result list\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through each element in the list\n    for item in lst:\n        # Append the 'element' and the current item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over each item in the input list\n    for item in lst:\n        # Append the element to be inserted before each item\n        result.append(element)\n        # Append the original item\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty result list\n    result = []\n    \n    # Iterate through each item in the original list\n    for item in lst:\n        # Append the element and the item to the result list\n        result.append(element)\n        result.append(item)\n        \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    # Create a new list to store the result\n    result = []\n    # Iterate through the input list and insert 'elem' before each element\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, ele):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through each item in the original list\n    for item in lst:\n        # Append the element first, then the item\n        result.append(ele)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Loop through each item in the input list\n    for item in lst:\n        # Append the element and the item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over each element in the input list\n    for item in lst:\n        # Append the element and the current item to the result list\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Loop through each item in the input list\n    for item in lst:\n        # Append the specified element to the result list\n        result.append(element)\n        # Append the current item from the list to the result list\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over each item in the input list\n    for item in lst:\n        # Append the element and then the item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    # Initialize an empty result list\n    result = []\n    # Iterate over each item in the input list\n    for item in lst:\n        # Append the element before each item\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over each item in the input list\n    for item in lst:\n        # Append the element and the item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    # Initialize an empty list to store the results\n    result = []\n    # Iterate over each element in the list\n    for item in lst:\n        # Append the specified element and the current list item to the result list\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over each element in the list\n    for i in lst:\n        # Append the additional element\n        result.append(element)\n        # Append the current element from the list\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    # Create a new list to store the result\n    result = []\n    # Iterate through each element in the original list\n    for i in range(len(lst)):\n        # Insert the element before the current element\n        result.append(elem)\n        result.append(lst[i])\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element and the item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    # Initialize an empty list to hold the result\n    result = []\n    # Loop through each element in the list\n    for el in lst:\n        # Append the element 'elem' and then the current element 'el' to the result list\n        result.append(elem)\n        result.append(el)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over each item in the given list\n    for item in lst:\n        # Append the given element to the result list\n        result.append(element)\n        # Append the item to the result list\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to hold the result\n    result = []\n    # Iterate over each item in the input list\n    for item in lst:\n        # Append the element and the item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    # Initialize an empty list to store the results\n    result = []\n    # Iterate through each element in the input list\n    for item in lst:\n        # Append the additional element and then the current list element to the result list\n        result.extend([elem, item])\n    # Return the result list\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 51.41552511415525, "dps_norm": 48.52941176470588, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(num):\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Count the prime numbers less than the given non-negative number.\"\"\"\n    # Initialize counter for prime numbers\n    prime_count = 0\n    \n    # Iterate through numbers less than n\n    for num in range(2, n):\n        if is_prime(num):\n            prime_count += 1\n    \n    return prime_count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Takes a non-negative number and returns the count of prime numbers less than n.\n    \n    Args:\n    n (int): A non-negative number\n    \n    Returns:\n    int: The count of prime numbers less than n\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize the count of primes\n    count = 0\n    \n    # Loop through all numbers up to n to check if they are prime\n    for num in range(2, n):\n        i = 2\n        # Check if num is prime\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                break\n        else:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Define a helper function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Count the number of primes less than n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Handle edge cases where the input is less than or equal to 2\n    prime_counter = 0\n    for num in range(2, n):\n        for i in range(2, num):\n            if (num % i) == 0:\n                break\n        else:\n            prime_counter += 1\n    return prime_counter", "matching_cluster_idx": 2}, {"solution": "def is_prime(num):\n    \"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Returns the count of prime numbers less than the given non-negative number.\n    \"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative integer n.\n\n    :param n: A non-negative integer\n    :return: Count of prime numbers less than n\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        i = 2\n        while(i <= num ** 0.5):\n            if num % i == 0:\n                break\n            i += 1\n        else:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Takes in a non-negative number and returns the number of prime numbers less than the given number.\n    \n    :param n: Non-negative number\n    :return: Number of prime numbers less than n\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"\n    Helper function to check if a number is a prime.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"\n    Takes in a non-negative number and returns the count of prime numbers less than the given number.\n    \"\"\"\n    count = 0\n    for n in range(2, num):\n        if is_prime(n):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \n    :param n: A non-negative integer\n    :return: The count of prime numbers less than n\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    # Iterate over each number from 2 to n-1\n    for num in range(2, n):\n        # Assume number is prime\n        is_prime = True\n        # Check if the number is divisible by any number less than itself\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                # If divisible, it's not a prime number\n                is_prime = False\n                break\n        # If number is prime, increment count\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to check if a number is a prime number.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \n    :param n: Non-negative number\n    :return: Count of prime numbers less than n\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    prime_counter = 0\n    \n    # Loop through the range from 2 up to but not including n\n    for num in range(2, n):\n        # Assume the number is prime\n        is_prime = True\n        # Check if there's any number from 2 to num-1 that divides num\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                # If found, num is not prime\n                is_prime = False\n                break\n        # If num is prime, increase the counter\n        if is_prime:\n            prime_counter += 1\n            \n    return prime_counter", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    prime_nums = 0\n    \n    # Iterate over the range from 2 to n (exclusive)\n    for num in range(2, n):\n        # Assume the number is prime until proven otherwise\n        is_prime = True\n        \n        # Check if num is divisible by any number up to its square root\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        \n        # If is_prime is still True, we found a prime number\n        if is_prime:\n            prime_nums += 1\n    \n    return prime_nums", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"\n    Takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 8}]}, "Mbpp/265": {"dps": 61.97674418604651, "dps_norm": 77.5, "pass@1": 65.0, "profiled": [{"solution": "def list_split(lst, n):\n    # Create a list of lists to hold the split lists\n    split_lists = [[] for _ in range(n)]\n    # Iterate over the list, splitting it\n    for i, item in enumerate(lst):\n        split_lists[i % n].append(item)\n    return split_lists", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Calculate the number of sublists needed\n    num_sublists = (len(lst) + n - 1) // n\n    # Initialize the list of sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list and distribute the elements into the sublists\n    for index, value in enumerate(lst):\n        sublist_index = index % n\n        result[sublist_index].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the split lists\n    result = []\n    # Loop through n times\n    for i in range(n):\n        # Generate each split list and add it to the result\n        result.append(lst[i::n])\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize a list of empty lists, one for each column\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the original list, appending items to the appropriate column\n    for index, item in enumerate(lst):\n        result[index % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        result.append(lst[i::n])\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the split lists\n    result = []\n    # Iterate over the range of n to create sublists for every nth element\n    for i in range(n):\n        # Use list comprehension to slice the list starting from i and stepping by n\n        result.append([lst[j] for j in range(i, len(lst), n)])\n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting sublists\n    result = []\n    # Loop through each index up to n to create sublists\n    for i in range(n):\n        # Add elements starting from index i, stepping by n\n        result.append(lst[i::n])\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the final sublists\n    result = []\n\n    # Loop through the list in steps of n\n    for i in range(n):\n        # Use list slicing to select every nth element starting at i\n        sublist = lst[i::n]\n        # Add the sublist to the result\n        result.append(sublist)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize the list of lists\n    result = []\n    \n    # Loop through n times\n    for i in range(n):\n        # Select every nth element starting from index i\n        temp = lst[i::n]\n        # Add the temporary list to the result\n        result.append(temp)\n        \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Using list comprehension and slicing to achieve the split\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        result.append(lst[i::n])\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        result.append(lst[i::n])\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the final lists\n    result = []\n    \n    # Loop through each index up to n to create sublists\n    for i in range(n):\n        # Use list comprehension to create each sublist starting at index i and taking every nth element\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        # Append the sublist to the result list\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting sublists\n    result = []\n    # Loop through n times to create each sublist\n    for i in range(n):\n        # Use list slicing to select every nth element starting from i\n        sublist = lst[i::n]\n        # Append the sublist to the result list\n        result.append(sublist)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        result.append(lst[i::n])\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to store the resulting lists\n    result = []\n    # Loop through each index from 0 to n-1 to extract every nth element\n    for i in range(n):\n        # Extract every nth element starting from index i\n        split_list = lst[i::n]\n        # Append the extracted list to the result\n        result.append(split_list)\n    # Return the final list of lists\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        result.append(lst[i::n])\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Calculate the number of resulting lists we will have\n    num_lists = (len(lst) + n - 1) // n\n    result = []\n    \n    # Loop through each position up to n (columns in the split list)\n    for i in range(n):\n        # For each position i, collect every nth element starting from i\n        sublist = lst[i::n]\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to store the split lists\n    result = []\n    # Loop over each index from 0 to n-1 to create sublists\n    for i in range(n):\n        # Create a sublist starting from index i and stepping by n\n        sub_list = lst[i::n]\n        # Append the sublist to the result list\n        result.append(sub_list)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the final sublists\n    result = []\n    \n    # Loop through each index up to n\n    for i in range(n):\n        # Initialize an empty list to hold the current sublist\n        sub_list = []\n        # Loop through the original list starting from i and stepping by n\n        for j in range(i, len(lst), n):\n            # Add the jth element of the original list to the current sublist\n            sub_list.append(lst[j])\n        # Add the current sublist to the result\n        result.append(sub_list)\n    \n    return result", "matching_cluster_idx": 3}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    # Convert list to set to remove duplicates, compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Check if the length of the list is equal to the length of the set created from the list\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Converting list to set removes duplicates\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Compare the length of the list with the length of the set created from the list\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert the list to a set to remove duplicates\n    # Compare the length of the list with the length of the set\n    # If the lengths are equal, all elements are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert list to set to remove duplicates\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Check if the length of the list is equal to the length of the set of the list\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert list to a set to remove duplicates and compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert list to a set to remove duplicates\n    # If length of set is same as length of list, all elements are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert the list to a set to remove duplicates and compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert the list to a set to remove duplicates\n    # If the length of the list and set are the same, all elements are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert list to a set and compare lengths to check uniqueness\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Create a set from the list and compare its length with the list's length\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Check if all elements are unique by comparing lengths of list and set\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert list to a set to remove duplicates and compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert list to set and compare lengths to check for uniqueness\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert the list to a set to remove duplicates and compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert list to set to remove duplicates, then compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert the list to a set and compare its length with the original list\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert list to set and compare lengths\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 42.56410256410256, "dps_norm": 73.33333333333334, "pass@1": 82.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count\n    inv_count = 0\n\n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Count inversions where arr[i] > arr[j]\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the count to 0\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # For each element, compare with all the elements after it\n        for j in range(i + 1, len(arr)):\n            # If the current element is greater than the element after it, it's an inversion\n            if arr[i] > arr[j]:\n                count += 1\n                \n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize count of inversions\n    inv_count = 0\n    n = len(arr)\n    \n    # Iterate through the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Count inversions\n            if arr[i] > arr[j]:\n                inv_count += 1\n                \n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort(arr, temp_arr, left, mid)\n            inv_count += merge_sort(arr, temp_arr, mid + 1, right)\n            inv_count += merge(arr, temp_arr, left, mid, right)\n        return inv_count\n\n    def merge(arr, temp_arr, left, mid, right):\n        i = left\n        j = mid + 1\n        k = left\n        inv_count = 0\n        \n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp_arr[loop_var]\n        \n        return inv_count\n    \n    temp_arr = [0] * len(arr)\n    return merge_sort(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # This function will count the inversions in the array\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize count\n    count = 0\n    \n    # Loop through the array to find inversions\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n                \n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    def merge_count_split_inv(left, right):\n        result = []\n        count = 0\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                count += len(left) - i  # All remaining elements in left are inversions\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result, count\n\n    def sort_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            middle = len(arr) // 2\n            left, inv_left = sort_count(arr[:middle])\n            right, inv_right = sort_count(arr[middle:])\n            result, inv_split = merge_count_split_inv(left, right)\n            count = inv_left + inv_right + inv_split\n            return result, count\n\n    _, count = sort_count(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort(arr, temp_arr, left, mid)\n            inv_count += merge_sort(arr, temp_arr, mid + 1, right)\n            inv_count += merge(arr, temp_arr, left, mid, right)\n        return inv_count\n\n    def merge(arr, temp_arr, left, mid, right):\n        i = left       # Starting index of left subarray\n        j = mid + 1    # Starting index of right subarray\n        k = left       # Starting index of to be sorted subarray\n        inv_count = 0\n\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                k += 1\n                j += 1\n\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n\n        while j <= right:\n            temp_arr[k] = arr[j]\n            k += 1\n            j += 1\n\n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp_arr[loop_var]\n\n        return inv_count\n\n    # Auxiliary array\n    temp_arr = [0] * len(arr)\n    return merge_sort(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Initialize count\n    inv_count = 0\n    # Initialize the length of the array\n    n = len(arr)\n    # Iterate through the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Count inversions\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the count of inversions to 0\n    inv_count = 0\n    # Iterate through the array elements\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize count to 0\n    count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Compare with all the elements following the current element\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # This function counts the number of inversions in the array\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Function to use in merge step\n    def merge(arr, temp_arr, left, mid, right):\n        i = left        # Starting index for left subarray\n        j = mid + 1     # Starting index for right subarray\n        k = left        # Initial index for merged array\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # Inversion will occur here due to right subarray value being lower than left subarray\n                temp_arr[k] = arr[j]\n                inv_count += (mid-i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray into temporary array\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n\n        # Copy the remaining elements of right subarray into temporary array\n        while j <= right:\n            temp_arr[k] = arr[j]\n            k += 1\n            j += 1\n\n        # Copy the sorted subarray into original array\n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp_arr[loop_var]\n            \n        return inv_count\n    \n    # Merge sort function\n    def merge_sort(arr, temp_arr, left, right):\n        # A variable to store inversion counts in\n        inv_count = 0\n        if left < right:\n            mid = (left + right)//2\n            inv_count += merge_sort(arr, temp_arr, left, mid)   # Inversion count from left subarray\n            inv_count += merge_sort(arr, temp_arr, mid + 1, right)  # Inversion count from right subarray\n            inv_count += merge(arr, temp_arr, left, mid, right)  # Merging arrays and getting inversion count in the process\n        return inv_count\n    \n    # Create a temporary array\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the count of inversions to 0\n    inv_count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with all elements after it\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    # Return the total count of inversions\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the inversion count to 0\n    inv_count = 0\n    # Traverse all elements in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the count of inversions to 0\n    inv_count = 0\n    \n    # Iterate over the array to find inversions\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If the current element is greater than the next element, it's an inversion\n            if arr[i] > arr[j]:\n                inv_count += 1\n    \n    return inv_count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 83.32758620689656, "dps_norm": 66.66666666666667, "pass@1": 56.0, "profiled": [{"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Finds the k largest products from two given lists by selecting one factor from each list.\n    \n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param k: Number of largest products to return\n    :return: List of k largest products\n    \"\"\"\n    from heapq import nlargest\n    \n    # Generate all possible products between the two lists\n    products = [x*y for x in list1 for y in list2]\n    \n    # Find the k largest products\n    largest_products = nlargest(k, products)\n    \n    return largest_products", "matching_cluster_idx": 4}, {"solution": "def large_product(nums1, nums2, k):\n    # Multiply every element of nums1 with every element of nums2\n    products = [i * j for i in nums1 for j in nums2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the first k elements\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Initialize a list to store the products\n    products = []\n    \n    # Iterate through each element in the first list\n    for i in list1:\n        # For each element in the first list, iterate through elements in the second list\n        for j in list2:\n            # Compute the product of the two elements\n            product = i * j\n            # Add the product to the list\n            products.append(product)\n    \n    # Sort the list of products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'num' elements from the sorted list\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Loop through each element in list1 and list2\n    for i in list1:\n        for j in list2:\n            # Calculate the product of the elements\n            product = i * j\n            \n            # Append the product to the products list\n            products.append(product)\n    \n    # Sort the products list in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'n' largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "from heapq import nlargest\ndef large_product(list1, list2, k):\n    # Calculate all possible products\n    products = [x*y for x in list1 for y in list2]\n    # Find the k largest products using nlargest from heapq module\n    largest_products = nlargest(k, products)\n    return largest_products", "matching_cluster_idx": 4}, {"solution": "from heapq import nlargest\nfrom itertools import product\ndef large_product(list1, list2, k):\n    # Generate all possible products from the two lists\n    products = [p[0]*p[1] for p in product(list1, list2)]\n    # Use nlargest to find the k largest products\n    largest_products = nlargest(k, products)\n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, k):\n    \"\"\"\n    Finds the k largest products from two given lists by selecting one factor from each list.\n    \n    Parameters:\n    nums1 (list): First list of integers.\n    nums2 (list): Second list of integers.\n    k (int): Number of largest products to find.\n    \n    Returns:\n    list: List containing the k largest products.\n    \"\"\"\n    # Calculate all possible products\n    products = [x * y for x in nums1 for y in nums2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the first k products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, k):\n    # Calculate all possible products from the two lists\n    products = sorted([x * y for x in nums1 for y in nums2], reverse=True)[:k]\n    return products", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, k):\n    # Sort the lists to facilitate finding the largest products\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Initialize a heap queue\n    product_heap = []\n    \n    # Iterate over each pair of elements to generate products\n    for num1 in list1:\n        for num2 in list2:\n            # Push the product into the heap\n            heapq.heappush(product_heap, num1 * num2)\n            # Keep the heap size <= k\n            if len(product_heap) > k:\n                heapq.heappop(product_heap)\n    \n    # Since the heap is min-heap, the largest elements are at the bottom.\n    # Therefore, we need to reverse the order of the heap to get the largest products.\n    return sorted(product_heap, reverse=True)", "matching_cluster_idx": 1}, {"solution": "import heapq\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], k: int) -> List[int]:\n    \"\"\"\n    Find the top k largest products from two lists by picking one element from each list.\n    \n    :param list1: First list of integers.\n    :param list2: Second list of integers.\n    :param k: Number of top largest products to find.\n    :return: A list of the top k largest products.\n    \"\"\"\n    # Heap to keep track of the largest k products\n    min_heap = []\n    \n    # Loop through both lists and calculate the product\n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            if len(min_heap) < k:\n                heapq.heappush(min_heap, product)\n            else:\n                # Push new element and pop the smallest if current product is larger\n                heapq.heappushpop(min_heap, product)\n                \n    # Since it's a min heap, the elements are in ascending order, we need to reverse it\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, k):\n    # Multiply each element of list1 with each element of list2\n    products = [x * y for x in list1 for y in list2]\n    # Sort the products list in descending order\n    products.sort(reverse=True)\n    # Return the first k elements from the sorted list\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(nums1, nums2, k):\n    # Sort the lists in reverse order to have largest elements first\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    \n    # Use a heap to keep track of the k largest products\n    heap = []\n    \n    # Iterate over each combination and push the product onto the heap\n    for num1 in nums1:\n        for num2 in nums2:\n            if len(heap) < k:\n                heapq.heappush(heap, num1 * num2)\n            else:\n                # If the current product is larger than the smallest product in the heap,\n                # replace it to ensure the heap always contains the k largest products\n                heapq.heappushpop(heap, num1 * num2)\n    \n    # Convert the heap to a sorted list (largest products first)\n    result = sorted(heap, reverse=True)\n    return result", "matching_cluster_idx": 2}, {"solution": "from heapq import nlargest\nfrom itertools import product\ndef large_product(list1, list2, k):\n    # Calculate the product of each possible pair\n    products = [x*y for x, y in product(list1, list2)]\n    # Find the 'k' largest products using nlargest from heapq\n    largest_products = nlargest(k, products)\n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, k):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Iterate through both lists and compute the products\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order and slice the first 'k' elements\n    products.sort(reverse=True)\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "from heapq import nlargest\ndef large_product(list1, list2, n):\n    # Calculate all possible products of pairs\n    products = [x*y for x in list1 for y in list2]\n    # Find 'n' largest products\n    largest_products = nlargest(n, products)\n    return largest_products", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef large_product(list1: List[int], list2: List[int], k: int) -> List[int]:\n    \"\"\"\n    Find the k largest products of pairs where one element is from list1 and another from list2.\n    \n    Parameters:\n    list1 (List[int]): First list of integers.\n    list2 (List[int]): Second list of integers.\n    k (int): Number of largest products to return.\n    \n    Returns:\n    List[int]: List containing the k largest products.\n    \"\"\"\n    # Compute all products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Get the first k products\n    return sorted_products[:k]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(nums1, nums2, k):\n    # Sort the lists in descending order to get the largest products first\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    \n    result = []\n    # Generate the k largest products by multiplying the largest elements\n    for i in nums1:\n        for j in nums2:\n            if len(result) < k:\n                heapq.heappush(result, i * j)\n            else:\n                # Keep only the k largest products\n                heapq.heappushpop(result, i * j)\n                \n    # The heap contains the k largest products but not necessarily sorted\n    result.sort(reverse=True)\n    return result", "matching_cluster_idx": 2}, {"solution": "from heapq import nlargest\ndef large_product(list1, list2, k):\n    # Calculate all possible products of pairs from both lists\n    products = [x * y for x in list1 for y in list2]\n    # Find the k largest products using nlargest function from heapq module\n    largest_products = nlargest(k, products)\n    return largest_products", "matching_cluster_idx": 4}, {"solution": "from heapq import nlargest\ndef large_product(list1, list2, k):\n    # Calculate the product of every possible pair from list1 and list2\n    products = [x*y for x in list1 for y in list2]\n    # Find the k largest products\n    largest_products = nlargest(k, products)\n    return largest_products", "matching_cluster_idx": 4}, {"solution": "def large_product(list1, list2, k):\n    # Generate all possible products\n    products = [x*y for x in list1 for y in list2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the first k products\n    return products[:k]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 93.68544600938966, "dps_norm": 95.38461538461539, "pass@1": 88.0, "profiled": [{"solution": "def get_max_sum(n):\n    # Initialize a memoization array with -1\n    memo = [-1 for _ in range(n + 1)]\n    \n    # Define a recursive function to calculate the max sum\n    def recursive_max_sum(n):\n        # Base case\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        # If value already computed, return it\n        if memo[n] != -1:\n            return memo[n]\n        \n        # Calculate the value considering the equation\n        result = max((recursive_max_sum(n // 2) + recursive_max_sum(n // 3) +\n                      recursive_max_sum(n // 4) + recursive_max_sum(n // 5)), n)\n        \n        # Store the computed value in memo\n        memo[n] = result\n        return result\n    \n    # Call the recursive function with the given number\n    return recursive_max_sum(n)", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store the results of subproblems\n    memo = {0: 0}\n    \n    # Define a helper function to calculate the maximum sum recursively\n    def max_sum(x):\n        # If the value has been computed, return it\n        if x in memo:\n            return memo[x]\n        # Calculate the maximum sum for the current value of x\n        memo[x] = max(x, max_sum(x//2) + max_sum(x//3) + max_sum(x//4) + max_sum(x//5))\n        return memo[x]\n    \n    # Call the helper function with the original value of n\n    return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the computed values for memoization\n    memo = {}\n    \n    def f(n):\n        # Base case\n        if n == 0:\n            return 0\n        # Return memoized value if already computed\n        if n in memo:\n            return memo[n]\n        # Calculate the maximum of the given equation\n        memo[n] = max(n, f(n//2) + f(n//3) + f(n//4) + f(n//5))\n        return memo[n]\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization array to store calculated values\n    memo = {}\n\n    def f(n):\n        # Base case\n        if n < 2:\n            return n\n\n        # Check if the result for n is already computed\n        if n in memo:\n            return memo[n]\n\n        # Calculate the value according to the function\n        result = max((f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)), n)\n\n        # Store the result in the memoization dictionary\n        memo[n] = result\n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the calculated values\n    memo = {}\n    \n    def f(n):\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the value only if n is greater than or equal to 2\n        if n >= 2:\n            result = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        else:\n            result = n\n        # Store the computed value in the dictionary\n        memo[n] = result\n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store the computed results\n    memo = {}\n    \n    def max_sum_helper(n):\n        # Base case\n        if n < 2:\n            return n\n        \n        # Check if the value is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the value based on the given equation\n        result = max(n, max_sum_helper(n//2) + max_sum_helper(n//3) + max_sum_helper(n//4) + max_sum_helper(n//5))\n        \n        # Store the result in the dictionary for future reference\n        memo[n] = result\n        \n        return result\n    \n    # Call the helper function with the initial value\n    return max_sum_helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # A dictionary to store the computed values of the function for optimization\n    memo = {0: 0, 1: 1}\n    \n    def helper(n):\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Compute the value if not computed already\n        result = max(n, helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5))\n        \n        # Store the computed value in the dictionary\n        memo[n] = result\n        \n        return result\n    \n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Define a memoization dictionary\n    memo = {}\n    \n    def f(n):\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # If n is less than 1, return 0 (base case)\n        if n < 1:\n            return 0\n        \n        # Compute the value using the given formula\n        result = max((f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)), n)\n        \n        # Save the computed value in the dictionary\n        memo[n] = result\n        \n        # Return the computed value\n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store the results of subproblems\n    memo = {}\n    \n    def f(n):\n        # Base case\n        if n < 2:\n            return n\n        \n        # Check if the result is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Recursive calls to find the maximum sum\n        result = max(n, f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5))\n        \n        # Store the result in memo dictionary\n        memo[n] = result\n        \n        return result\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the computed values for dynamic programming\n    memo = {0: 0, 1: 1}\n    \n    def dp(x):\n        # If the value is already computed, return it\n        if x in memo:\n            return memo[x]\n        \n        # Otherwise, compute the value using the equation and store it\n        memo[x] = max(x, dp(x // 2) + dp(x // 3) + dp(x // 4) + dp(x // 5))\n        \n        return memo[x]\n    \n    return dp(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store the results of subproblems\n    memo = {}\n\n    def max_sum_recursion(n):\n        # Base case: if n is less than or equal to 1, return n\n        if n <= 1:\n            return n\n        # If the result is already computed and stored, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum recursively and store it in memo before returning\n        memo[n] = max((max_sum_recursion(n // 2) + max_sum_recursion(n // 3) + max_sum_recursion(n // 4) + max_sum_recursion(n // 5)), n)\n        return memo[n]\n    \n    # Call the recursive function with the input n\n    return max_sum_recursion(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the computed values to avoid redundant calculations\n    memo = {}\n\n    def f(n):\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # If n is less than or equal to 1, the maximum sum is n itself\n        if n <= 1:\n            return n\n        # Calculate the value and store it in the dictionary\n        memo[n] = max((f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)), n)\n        return memo[n]\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize the memoization dictionary with base case\n    memo = {0: 0, 1: 1}\n    \n    def helper(x):\n        # If the value is not in memo, calculate it\n        if x not in memo:\n            # Calculate the maximum sum using the given equation\n            memo[x] = max(x, helper(int(x/2)) + helper(int(x/3)) + helper(int(x/4)) + helper(int(x/5)))\n        return memo[x]\n    \n    # Calculate the maximum sum for the given input\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the results of subproblems\n    memo = {0: 0, 1: 1}\n    \n    def helper(n):\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the value if not computed before\n        memo[n] = max(n, helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5))\n        return memo[n]\n    \n    # Call the helper function with the input value\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store results of subproblems\n    memo = {}\n    \n    def calculate_max_sum(n):\n        # Check if the result for the given value of n is already computed\n        if n in memo:\n            return memo[n]\n        # If n is less than or equal to 1, the maximum sum is n itself\n        if n <= 1:\n            return n\n        # Calculate the maximum sum using the provided formula\n        max_sum = max((calculate_max_sum(n // 2) + calculate_max_sum(n // 3) + calculate_max_sum(n // 4) + calculate_max_sum(n // 5)), n)\n        # Store the result in the memoization dictionary\n        memo[n] = max_sum\n        return max_sum\n    \n    return calculate_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the computed values to avoid recomputation\n    memo = {0: 0}\n    \n    def f(x):\n        # Check if the value is already computed\n        if x not in memo:\n            # Recursive call to compute the value using the given equation\n            memo[x] = max((f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5)), x)\n        return memo[x]\n    \n    # Start the recursive computation with the given input n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the computed maximum sums to avoid recomputation\n    memo = {0: 0}\n\n    def find_max_sum(n):\n        # Check if the result is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Compute the result if not already computed\n        result = max(n, find_max_sum(n // 2) + find_max_sum(n // 3) + find_max_sum(n // 4) + find_max_sum(n // 5))\n        memo[n] = result\n        return result\n    \n    return find_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store the computed results for subproblems\n    memo = {}\n    \n    def find_max_sum(n):\n        # If n is 0 or 1, return n since f(0) = 0, f(1) = 1\n        if n == 0 or n == 1:\n            return n\n        # If the result is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the result using the given formula\n        result = max((find_max_sum(n // 2) + find_max_sum(n // 3) + find_max_sum(n // 4) + find_max_sum(n // 5)), n)\n        # Store the result in the memo dictionary\n        memo[n] = result\n        return result\n    \n    return find_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the computed values for reuse\n    memo = {}\n\n    def helper(n):\n        # Base case: if n is less than or equal to 1, return n\n        if n <= 1:\n            return n\n        \n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Recursive calls for the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n        memo[n] = max((helper(n//2) + helper(n//3) + helper(n//4) + helper(n//5)), n)\n        \n        # Return the computed value for n\n        return memo[n]\n    \n    # Start the process with the given number n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case for recursion\n    if n == 0:\n        return 0\n    \n    # Calculate the maximum of the given equation and n itself\n    max_sum = max((get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)), n)\n    \n    return max_sum", "matching_cluster_idx": 2}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrence of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has only one occurrence\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character was found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    \n    :param s: Input string\n    :return: The first non-repeated character or None if all characters repeat\n    \"\"\"\n    char_count = {}\n    # Count occurrence of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    # Find the first character that appears only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Parameters:\n    s (str): The string to search through.\n    \n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists.\n    \"\"\"\n    char_count = {}\n    # Count the occurrence of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character that appears only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    :param s: The input string\n    :return: The first non-repeated character or None if all characters are repeated\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrence of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that appears only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # Return None if no non-repeated character found\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import OrderedDict\ndef first_non_repeating_character(s):\n    # Dictionary to store character counts\n    char_count = OrderedDict()\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    :param s: Input string\n    :return: The first non-repeated character or None if all characters are repeated\n    \"\"\"\n    char_count = {}\n    # Count occurrence of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that appears only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    :param s: String to search in\n    :return: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    # Create a dictionary to keep track of the character counts\n    char_count = {}\n    \n    # Counting the occurrence of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Finding the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string to find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has only one occurrence\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Creating a dictionary to store the count of each character\n    count = {}\n    \n    # Counting occurrences of each character\n    for char in s:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    \n    # Finding the first character with count 1\n    for char in s:\n        if count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    :param s: Input string\n    :return: The first non-repeated character or None if all characters repeat\n    \"\"\"\n    freq = Counter(s)\n    for char in s:\n        if freq[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    This function finds the first non-repeated character in the given string.\n    It uses the Counter class to count occurrences of each character, and then\n    iterates through the string to find the first character with a count of 1.\n    \n    :param s: String to search\n    :return: The first non-repeated character or None if there is no such character\n    \"\"\"\n    # Count the occurrences of each character in the string\n    char_count = Counter(s)\n    \n    # Find and return the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store character frequencies\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    This function finds the first non-repeated character in a given string.\n    If all characters repeat, it returns None.\n    \n    :param s: String to search\n    :return: The first non-repeating character or None\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has only one occurrence\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store character counts\n    char_count = {}\n    \n    # Count occurrence of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store character counts\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If there is no non-repeated character, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store character frequency\n    count = {}\n    # Iterate through the string and update character count\n    for char in s:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    # Find the first non-repeating character\n    for char in s:\n        if count[char] == 1:\n            return char\n    # If there is no non-repeating character, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store character counts\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has only one occurrence\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character was found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store character frequencies\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    \n    # Finding the first non-repeated character\n    for char in s:\n        if freq[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists.\n    \"\"\"\n    char_count = {}\n    \n    # Counting occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Finding the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if the specified element exists in the given tuple.\n\n    Parameters:\n    test_tup (tuple): The tuple to search in.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Checks if the specified element exists in the given tuple.\n\n    :param test_tup: Tuple to search within.\n    :param element: Element to search for.\n    :return: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if the element exists within the tuple.\n\n    :param test_tup: tuple to search the element in\n    :param element: element to search for\n    :return: True if element is found, False otherwise\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Function to check if an element exists within a tuple.\n\n    Parameters:\n    test_tup (tuple): The tuple to check.\n    element (any): The element to look for within the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if an element exists within a given tuple.\n\n    Parameters:\n    test_tup (tuple): The tuple to search within.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if the specified element exists within the given tuple.\n    \n    Parameters:\n    test_tup (tuple): The tuple to be searched.\n    element (any): The element to search for in the tuple.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if the element exists in the given tuple.\n\n    :param test_tup: The tuple to search in.\n    :param element: The element to search for.\n    :return: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if the element exists within the provided tuple.\n    \n    Parameters:\n    test_tup (tuple): The tuple to search through.\n    element (any): The element to find within the tuple.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if an element exists within the given tuple.\n    \n    Parameters:\n    test_tup (tuple): The tuple to check.\n    element (Any): The element to look for within the tuple.\n    \n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Check if the element exists in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if the element exists within the given tuple.\n\n    Parameters:\n    test_tup (tuple): The tuple to be searched.\n    element (Any): The element to search for within the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Check if the element exists in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if the given element exists in the tuple.\n\n    Parameters:\n    test_tup (tuple): The tuple to check.\n    element: The element to look for in the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    This function checks if an element exists within a given tuple.\n\n    Parameters:\n    test_tup (tuple): The tuple to be searched.\n    element (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    :param test_tup: The tuple to check.\n    :param element: The element to look for in the tuple.\n    :return: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if the element exists in the given tuple.\n    \n    Parameters:\n    test_tup (tuple): The tuple to search.\n    element: The element to search for in the tuple.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Check if the element is in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if the specified element exists within the provided tuple.\n\n    Parameters:\n    test_tup (tuple): The tuple in which to search for the element.\n    element (Any): The element to search for within the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    # Check if the element is in the tuple\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element):\n    \"\"\"\n    Check if an element exists in the given tuple.\n\n    Parameters:\n    test_tup (tuple): The tuple to be checked.\n    element: The element to check for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 77.79503105590062, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    # Check if any value of seq1 is in seq2\n    return any(x in seq2 for x in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(s1, s2):\n    # Check if any element of s1 is in s2\n    for i in s1:\n        if i in s2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    # Convert both lists to sets and check for intersection\n    return bool(set(list1) & set(list2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any element in seq1 is in seq2\n    return any(x in seq2 for x in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if there is any common element between two sequences\n    return any(elem in seq2 for elem in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Convert the sequences to sets and find intersection\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any element of seq1 is in seq2\n    return any(x in seq2 for x in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any element in seq1 exists in seq2\n    return any(elem in seq2 for elem in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any value in seq1 exists in seq2\n    return any(value in seq2 for value in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any element in seq1 is also in seq2\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if there's any common element in both sequences\n    return any(x in seq2 for x in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any value in seq1 is present in seq2\n    return any(value in seq2 for value in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any element in seq1 exists in seq2\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any element in seq1 exists in seq2\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any element in seq1 is in seq2\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any element in seq1 is also in seq2\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    # Convert lists to sets and check intersection\n    set1 = set(list1)\n    set2 = set(list2)\n    # If intersection is not empty, return True, else False\n    if set1.intersection(set2):\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def overlapping(lst1, lst2):\n    # Converting lists to sets and finding intersection\n    return bool(set(lst1) & set(lst2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(list1, list2):\n    # Converting both lists to sets and checking intersection\n    return bool(set(list1) & set(list2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Check for any common element in both sequences\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 65.7201646090535, "dps_norm": 87.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(tup):\n    # Convert all elements in the tuple to strings and join them with the delimiter\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a string, separated by the delimiter.\n    \n    :param tup: Tuple of elements to concatenate\n    :param delimiter: The delimiter to use between each element\n    :return: Concatenated string\n    \"\"\"\n    # Convert each element in the tuple to a string and join them with the delimiter\n    result = delimiter.join(map(str, tup))\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    # Convert each element in the tuple to a string and join them with a delimiter\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n    # Convert tuple elements to string and join them using '-'\n    result = '-'.join(map(str, input_tuple))\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    # Convert all elements of tuple to string and join with '-'\n    return '-'.join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    # Convert each element of the tuple to string and join them with the delimiter '-'\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    # Convert each element of the tuple to a string and join them with the delimiter '-'\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(test_tup):\n    # Convert each element in the tuple to a string and join them with a delimiter\n    result = '-'.join(str(element) for element in test_tup)\n    return result", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    # Convert all elements of the tuple to string and join them with '-'\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the input tuple into a string, separated by the specified delimiter.\n    \n    Parameters:\n    tup (tuple): The input tuple.\n    delimiter (str): The delimiter to use for concatenation.\n    \n    Returns:\n    str: A string with each element of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements of the tuple to string and join with the delimiter\n    result = delimiter.join(map(str, tup))\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple):\n    # Convert each element in the tuple to string and join them with '-'\n    result = '-'.join(map(str, input_tuple))\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using a specified delimiter.\n    \n    :param tup: A tuple of elements to concatenate.\n    :param delimiter: The delimiter used for concatenation.\n    :return: A string with elements concatenated by the delimiter.\n    \"\"\"\n    # Convert all elements in the tuple to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    # Convert all elements in the tuple to strings and join with the delimiter '-'\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    # Convert all elements to string and join them with the delimiter '-'\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate elements of a tuple using a specified delimiter.\n    \n    :param tup: Tuple of elements to concatenate\n    :param delimiter: The delimiter to use for concatenation\n    :return: A string with elements concatenated by the delimiter\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    # Convert all elements in the tuple to string and join them with '-'\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    # Convert each element in the tuple to a string and then join them with a delimiter\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(test_tup):\n    # Convert each element of the tuple to a string and join with the delimiter '-'\n    result = '-'.join(map(str, test_tup))\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(test_tup):\n    # Convert each element of the tuple to string and join them with the delimiter '-'\n    result = '-'.join(map(str, test_tup))\n    return result", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple):\n    # Convert each element of the tuple to a string and then join them with the delimiter\n    return '-'.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}]}, "Mbpp/424": {"dps": 51.624548736462096, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(tup):\n    # Use list comprehension to iterate over each string in the tuple\n    # and extract the last character.\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # Extract the last character from each string in the tuple\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # Extract the last character of each string in the tuple\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test):\n    # Extract the last character from each string in the tuple\n    result = [s[-1] for s in test]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extract the last character of each string in the given tuple.\n\n    :param tup: Tuple containing strings.\n    :return: List of the last characters of each string in the tuple.\n    \"\"\"\n    # Extracting the last character of each string in the tuple\n    rear_elements = [s[-1] for s in tup]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # Extract the last character of each string in the tuple\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test):\n    # Extract the last character of each string in the tuple and return as a list\n    result = [item[-1] for item in test]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts the last character of each string within the given tuple.\n\n    :param input_tuple: A tuple containing strings\n    :return: A list containing the last character of each string in the tuple\n    \"\"\"\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test):\n    # Extracting the last character of each string in the tuple\n    result = [s[-1] for s in test]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # Use list comprehension to extract the last character of each string in the tuple\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    :param tup: A tuple containing strings.\n    :return: A list containing the last character of each string in the tuple.\n    \"\"\"\n    # Extract the last character of each string in the tuple\n    result = [item[-1] for item in tup]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tuple):\n    # Extract the last character of each string in the tuple\n    result = [sub[-1] for sub in test_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # Extract the last character of each string in the tuple\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # Extract the last character of each string in the tuple\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Using list comprehension to extract the last character from each string in the tuple\n    return [item[-1] for item in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # Extract the last character of each string in the tuple\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test):\n    # Extract the last character from each string in the tuple\n    result = [item[-1] for item in test]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test):\n    # Use a list comprehension to get the last character of each string in the tuple\n    result = [s[-1] for s in test]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # Extract the last character of each string in the tuple\n    result = [s[-1] for s in tup]\n    return result", "matching_cluster_idx": 3}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(lst, element):\n    # Count how many sublists contain the element\n    count = sum(element in sublist for sublist in lst)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count the number of sublists containing the specified element\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize counter to 0\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if element is found\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count how many sublists contain the specified element\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a counter for the number of sublists containing the element\n    count = 0\n    \n    # Iterate through each sublist in the list\n    for sublist in lst:\n        # Check if the element is present in the sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize counter\n    count = 0\n    \n    # Iterate through each sublist\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            count += 1\n            \n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count the number of sublists containing the specified element\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count how many sublists contain the specified element\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count how many sublists contain the element\n    count = sum(element in sublist for sublist in lst)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count the number of sublists containing the element\n    count = sum(element in sublist for sublist in lst)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count how many sublists contain the specified element\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count how many sublists contain the given element\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a counter to keep track of the sublists containing the element\n    count = 0\n    \n    # Iterate over each sublist in the main list\n    for sublist in lst:\n        # Check if the element is in the sublist\n        if element in sublist:\n            # Increment the count if the element is found in the sublist\n            count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count the number of sublists containing the element\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count how many sublists contain the specified element\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count how many sublists contain the element\n    count = sum(element in sublist for sublist in lst)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count the number of sublists containing the element\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count how many sublists contain the specified element\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n//2\n    \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell sort algorithm.\n    \n    Shell sort is an in-place comparison sort. It can be seen as either a generalization of sorting by exchange (bubble sort)\n    or sorting by insertion (insertion sort). The method starts by sorting pairs of elements far apart from each other,\n    then progressively reducing the gap between elements to be compared.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initial gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            \n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell sort algorithm.\n\n    :param arr: List of integers to be sorted.\n    :return: Sorted list of integers.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            temp = arr[i]\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using shell sort algorithm.\n    \n    :param arr: List of elements to be sorted\n    :return: Sorted list\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the shell sort algorithm.\n    \n    :param arr: List of elements to be sorted\n    :return: Sorted list\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            temp = arr[i]\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 68.08510638297872, "dps_norm": 76.0, "pass@1": 100.0, "profiled": [{"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if all elements in the array are less than the given number\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than any element in the array\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    # Check if all elements in the array are less than the given number\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the entered number is greater than all elements in the array\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    # Check if num is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if all elements in the array are less than the given number\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for elem in arr:\n        if num <= elem:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for item in arr:\n        if num <= item:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if num is greater than all elements in the array\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    # Check if any number in the array is greater than or equal to num\n    for element in arr:\n        if element >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Check if all elements in the array are less than the number\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 81.39705882352942, "dps_norm": 57.0, "pass@1": 93.0, "profiled": [{"solution": "def remove_odd(s):\n    # New string to store the result\n    result = ''\n    # Iterate through the string, considering only even indices (0-based)\n    for i in range(len(s)):\n        if i % 2 != 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Create a new string using characters at even indices\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(input_string):\n    # Initialize an empty result string\n    result_string = \"\"\n    \n    # Loop through the string using enumerate to get both index and character\n    for index, char in enumerate(input_string):\n        # Check if the index is even (since string indices start at 0)\n        if index % 2 != 0:\n            # Append the character at the odd index to the result string\n            result_string += char\n    return result_string", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Using list comprehension to select even index characters only\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(s):\n    # Select characters at even indices (0-based)\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    # Create a new string with characters at even indices (0-based)\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    # Keep characters at even indices (odd positions considering 1-based indexing)\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    # Keep characters at even indices (considering the first position as 0)\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(input_string):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Loop through the string, starting from index 1 (2nd character) and take every 2nd character\n    for i in range(1, len(input_string) + 1):\n        if i % 2 == 0:\n            result += input_string[i-1]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Create a new string with characters at even indices of the original string\n    result = ''.join([s[i] for i in range(len(s)) if i % 2 == 1])\n    return result", "matching_cluster_idx": 1}, {"solution": "def remove_odd(input_string):\n    # This list comprehension collects characters from the input_string\n    # that are at even indices (0, 2, 4, ...) as Python uses 0-based indexing\n    result = ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 1])\n    return result", "matching_cluster_idx": 1}, {"solution": "def remove_odd(s):\n    # Use list comprehension to select only even-indexed characters\n    result = ''.join([s[i] for i in range(len(s)) if i % 2 == 1])\n    return result", "matching_cluster_idx": 1}, {"solution": "def remove_odd(s):\n    # Create a new string by keeping characters at even indices only\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    # Create a string to hold even indexed characters\n    result = ''\n    # Loop through the string and add characters at even indices to the result\n    for i in range(1, len(s) + 1):\n        if i % 2 == 0:\n            result += s[i-1]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Keep characters at even indices (0-based, so these are actually odd positions in 1-based counting)\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    # Collect every character with an even index (which corresponds to odd positions)\n    return ''.join([s[i] for i in range(1, len(s), 2)])", "matching_cluster_idx": 2}, {"solution": "def remove_odd(s):\n    # Keep only the characters at even indices (0-indexed)\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    # Initialize an empty result string\n    result = ''\n    \n    # Iterate over the string with index\n    for index in range(len(s)):\n        # Check if the index is even\n        if index % 2 == 1:\n            # Append character to result if index is odd (1-based thinking)\n            result += s[index]\n    \n    # Return the result string with odd indexed characters\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Select every character at even index (0-based index)\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    # Keep characters at even indices (odd positions if counting from 1)\n    return s[1::2]", "matching_cluster_idx": 3}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 3.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 36.0, "profiled": [{"solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize the count to zero\n    res = 0\n    # Loop through each element in the list and add its occurrence count in the tuple to res\n    for ele in test_list:\n        res += test_tup.count(ele)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Count the occurrences of each element in the tuple\n    count = sum(test_tup.count(ele) for ele in test_list)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize the count to 0\n    result = 0\n    # Iterate over each element in the list\n    for elem in test_list:\n        # Add the number of occurrences of the element in the tuple to the result\n        result += test_tup.count(elem)\n    return result", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, elements_list):\n    # Count the occurrence of each element in the tuple\n    occurrence = sum(test_tup.count(elem) for elem in elements_list)\n    return occurrence", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Count the occurrence of elements in the tuple that are present in the list\n    res = sum(test_tup.count(ele) for ele in test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Using sum and a generator expression to count occurrences\n    res = sum(test_tup.count(ele) for ele in test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Count the occurrence of elements from test_list in test_tup\n    res = sum(test_tup.count(ele) for ele in test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Count the occurrences of elements in the list within the tuple\n    res = sum(test_tup.count(ele) for ele in test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize a counter to zero\n    occurrence_count = 0\n    \n    # Iterate over each element in the test_list\n    for element in test_list:\n        # Add the count of each element in the test_tup to the occurrence_count\n        occurrence_count += test_tup.count(element)\n    \n    return occurrence_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Count the occurrence of elements in the tuple that are also in the list\n    res = sum(test_tup.count(ele) for ele in test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Count the occurrences of each element from test_list in test_tup\n    result = sum(test_tup.count(element) for element in test_list)\n    return result", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Count the occurrences of each element in the tuple\n    occurrence_count = sum(test_tup.count(element) for element in test_list)\n    return occurrence_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize the count to 0\n    res = 0\n    # Iterate over each element in the provided list\n    for ele in test_list:\n        # Add the number of occurrences of the element in the tuple to the count\n        res += test_tup.count(ele)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Count occurrences of each element in the list within the tuple\n    res = sum(test_tup.count(ele) for ele in test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Using sum and count method to calculate occurrences\n    res = sum([test_tup.count(ele) for ele in test_list])\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize count to 0\n    count = 0\n    # Iterate over each element in the list\n    for elem in test_list:\n        # Add the count of the element in the tuple to the total count\n        count += test_tup.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Count the occurrence of each element in the tuple\n    occurrence_dict = {elem: test_tup.count(elem) for elem in test_tup}\n    # Sum the counts for the elements in the provided list\n    result = sum(occurrence_dict[elem] for elem in test_list if elem in occurrence_dict)\n    return result", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize count to 0\n    res = 0\n    # Iterate over the elements of the list\n    for ele in test_list:\n        # Add the count of each element in the tuple to the total count\n        res += test_tup.count(ele)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize the occurrence counter to 0\n    occurrence = 0\n    \n    # Iterate through each element in the list and count its occurrence in the tuple\n    for element in test_list:\n        occurrence += test_tup.count(element)\n    \n    return occurrence", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list\n    for element in test_list:\n        # Add the number of times the element occurs in the tuple to the counter\n        count += test_tup.count(element)\n    \n    # Return the total count\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 43.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    # Remove all whitespaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Using replace() to remove all whitespaces\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Removing all whitespaces from the string using replace\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using replace() method to remove all whitespaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Remove all whitespaces from the input_string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using replace() to remove all whitespaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Replace all whitespace characters with no space, effectively removing them\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using the replace method to remove all whitespace characters\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Using str.replace() to remove all spaces\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Using str.replace() to remove all spaces from the input string\n    no_space_string = input_string.replace(\" \", \"\")\n    # Returning the string without spaces\n    return no_space_string", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using join and replace to remove all whitespaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Using the replace method to remove whitespaces\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Remove all whitespaces from the string using replace method\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Using str.replace() method to replace spaces with no space\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using str.replace method to remove all whitespaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using replace to remove all whitespaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Using replace to remove all spaces\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    # Using the built-in str.replace() method to remove whitespaces\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Removing all whitespaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using the string replace method to remove all whitespace characters\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(lst):\n    # Reverse each string in the list using a list comprehension\n    reversed_list = [s[::-1] for s in lst]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    # Reverse each string in the list using list comprehension\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Reverse each string in the list\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Using list comprehension to reverse each string in the list\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Use list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in lst]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Reverse each string in the list\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Reverse each string in the list and return the new list\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    # List comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    # Using list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(list_of_strings):\n    # Reversing each string in the list\n    reversed_list = [s[::-1] for s in list_of_strings]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Using list comprehension to reverse each string in the list\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    # Use list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(list1):\n    # Reverse each string in the list using list comprehension\n    return [s[::-1] for s in list1]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Reverse each string in the list using list comprehension\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    This function takes a list of strings and returns a new list with each string reversed.\n    \n    :param lst: List of strings to be reversed\n    :return: A new list containing the reversed strings\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Reverse each string in the list using list comprehension\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Using list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in lst]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    # Using list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in input_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Reverse each string in the list and return the new list\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    # Reverse each string in the list\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 81.82692307692308, "dps_norm": 93.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst):\n    # Extract first element of each sublist using list comprehension\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    # Extract the first element of each sublist\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    # List comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Extract first element of each sublist using list comprehension\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    # List comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Use list comprehension to extract the first element of each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Extract the first element of each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Use list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    # Extract the first element from each sublist using list comprehension\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Extract the first element of each sublist\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    # Extract the first element of each sublist\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Extract the first element of each sublist in the list\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Extract the first element of each sublist in the given list\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Extract the first element of each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Use list comprehension to get the first element of each sublist\n    return [sub[0] for sub in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    # Use list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Extracting the first element from each sublist\n    result = [sublist[0] for sublist in lst]\n    return result", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    # Extract the first element of each sublist using list comprehension\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    # Extract the first element from each sublist\n    result = [sublist[0] for sublist in sublists]\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Extract the first element of each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(input_string, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in input_string\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in the string\n    new_string = string.replace(old_char, new_char)\n    return new_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in input_string\n    replaced_string = input_string.replace(old_char, new_char)\n    return replaced_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace all occurrences of old_char with new_char\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in input_string\n    replaced_string = input_string.replace(old_char, new_char)\n    return replaced_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replaces all occurrences of old_char with new_char in string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the input_string\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in input_string\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    # Find the minimum and maximum values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Calculate the sum of the minimum and maximum values\n    sum_val = min_val + max_val\n    \n    return sum_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Calculate the sum of the largest and smallest value in the array\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum value in the array\n    min_val = min(arr)\n    # Find the maximum value in the array\n    max_val = max(arr)\n    # Return the sum of the minimum and maximum values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n    # Return the sum of maximum and minimum values\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest and largest elements in the array\n    smallest = min(arr)\n    largest = max(arr)\n    \n    # Return their sum\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the array is empty\n    if not arr:\n        return 0\n    \n    # Find the smallest and largest values in the array\n    smallest = min(arr)\n    largest = max(arr)\n    \n    # Return the sum of smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Calculate the sum of the largest and smallest value in the array\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum and maximum values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Return the sum of the minimum and maximum values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest value in the array\n    min_val = min(arr)\n    # Find the largest value in the array\n    max_val = max(arr)\n    # Return the sum of the smallest and largest values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum and maximum values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Return the sum of the minimum and maximum values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum and maximum values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Return their sum\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum and maximum in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Return their sum\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum value in the array\n    max_val = max(arr)\n    # Find the minimum value in the array\n    min_val = min(arr)\n    # Return the sum of the maximum and minimum values\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum value in the array\n    max_val = max(arr)\n    # Find the minimum value in the array\n    min_val = min(arr)\n    # Return the sum of max and min values\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum value in the array\n    min_value = min(arr)\n    # Find the maximum value in the array\n    max_value = max(arr)\n    # Return the sum of the minimum and maximum values\n    return min_value + max_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the list is empty\n    if not arr:\n        return 0\n    # Find the largest and smallest value in the list\n    max_val = max(arr)\n    min_val = min(arr)\n    # Return the sum of the largest and smallest value\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum value in the array\n    min_val = min(arr)\n    # Find the maximum value in the array\n    max_val = max(arr)\n    # Return the sum of the minimum and maximum values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum and maximum values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Return the sum of the largest and smallest values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Calculate the sum of the largest and smallest values in the array\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum value in the array\n    min_val = min(arr)\n    # Find the maximum value in the array\n    max_val = max(arr)\n    # Return the sum of the minimum and maximum value\n    return min_val + max_val", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert string s to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the input string to lowercase\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lowercase\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the entire string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lowercase\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lowercase\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the input string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lowercase\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the entire string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string s to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Converts the entire string to lower case\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    # Find all occurrences of text enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Using regular expression to find all values enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Using regex to find all values within quotes\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Regular expression to find all text within double quotes\n    pattern = '\"(.*?)\"'\n    # Find all non-overlapping matches of the pattern in the string\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regex to find all patterns enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings enclosed in double quotes\n    result = re.findall(r'\"(.*?)\"', input_string)\n    return result", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all patterns enclosed by double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regex to find all occurrences of text between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all quoted values\n    return re.findall(r'\\\"(.*?)\\\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Using regular expression to find all strings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Using regular expression to find all patterns within double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Regular expression to find patterns within double quotes\n    pattern = '\"(.*?)\"'\n    # Find all non-overlapping matches of pattern in the string\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all matches of text enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all matches between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Regular expression to find text within double quotes\n    pattern = '\"(.*?)\"'\n    # Find all matches in the input string\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Regular expression to find all text within quotes\n    pattern = '\"(.*?)\"'\n    # Find all non-overlapping matches of the pattern in the string\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Regular expression to find all the values within quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Using regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Regular expression pattern to match text within double quotes\n    pattern = '\"(.*?)\"'\n    # Find all occurrences of the pattern\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all strings enclosed in double quotes\n    result = re.findall(r'\"(.*?)\"', input_string)\n    return result", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.30864197530865, "dps_norm": 86.42857142857142, "pass@1": 91.0, "profiled": [{"solution": "def two_unique_nums(lst):\n    # Count the occurrence of each number\n    count = {}\n    for num in lst:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Collect numbers that occur exactly once\n    result = [num for num, cnt in count.items() if cnt == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Calculate the frequency of each item in the list\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    \n    # Extract items that have frequency of 1\n    result = [item for item, count in freq.items() if count == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Find the count of each element in the list\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    \n    # Select elements that have a count of 1\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to hold the frequency of each element\n    frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Collect elements that appear exactly once\n    result = [num for num, count in frequency.items() if count == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num, count in count_dict.items() if count == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Count the occurrences of each number\n    num_counts = {}\n    for num in lst:\n        num_counts[num] = num_counts.get(num, 0) + 1\n    \n    # Collect numbers that occur only once\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Count the frequency of each element\n    from collections import Counter\n    freq = Counter(lst)\n    \n    # Extract elements that occur exactly once\n    unique = [item for item, count in freq.items() if count == 1]\n    \n    return unique", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(lst):\n    # Count the occurrence of each number in the list\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    \n    # Create a new list with numbers that appear only once\n    unique_nums = [num for num in lst if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Calculate the occurrence of each number\n    num_counts = {}\n    for num in lst:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Filter out the numbers that appear more than once\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(arr):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Collect numbers that appear exactly once in the input list\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Count the occurrences of each number\n    num_counts = {}\n    for num in nums:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Collect numbers that occur exactly once\n    unique_nums = [num for num in nums if num_counts[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to hold the count of each number\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out the numbers that appear more than once\n    result = [num for num, count in count_dict.items() if count == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to count occurrences of each number\n    num_count = {}\n    for num in lst:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Append numbers that appear exactly once to the result list\n    result = [num for num, count in num_count.items() if count == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Dictionary to hold the count of each element\n    count = {}\n    for num in lst:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # List to hold the unique elements that appear exactly once\n    result = [num for num in count if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Calculate the occurrence of each number\n    num_count = {}\n    for num in nums:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Extract numbers that occur exactly once\n    result = [num for num, count in num_count.items() if count == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to keep track of counts\n    count_dict = {}\n    # Iterate through the list to populate the dictionary\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Use list comprehension to filter out numbers that appear only once\n    return [num for num, count in count_dict.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Count the occurrences of each item in the list\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Append items to the result list if they occur only once\n    result = [item for item, count in count_dict.items() if count == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Count the occurrences of each number in the list\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Create a list of numbers that occur exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Count the occurrence of each element in the list\n    element_count = {}\n    for num in lst:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    # Return elements that appear only once\n    return [num for num in lst if element_count[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    num_count = {}\n    for num in nums:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Collect numbers that occur only once\n    unique_nums = [num for num, count in num_count.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 96.82539682539682, "dps_norm": 72.72727272727273, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    # Interleave the three lists into one using zip and list comprehension\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    # Use zip to pair elements from each list and then flatten the pairs into a single list\n    result = [item for sublist in zip(lst1, lst2, lst3) for item in sublist]\n    return result", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Interleave the three lists using zip and list comprehension\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Use zip to combine the lists and a list comprehension to flatten the list of tuples\n    interleaved = [item for tuple_items in zip(list1, list2, list3) for item in tuple_items]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Use zip to interleave the elements from each list and then flatten the resulting list of tuples\n    interleaved_list = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    # Use zip to interleave and list comprehension to flatten\n    interleaved_list = [item for sublist in zip(lst1, lst2, lst3) for item in sublist]\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Interleave the three lists by concatenating corresponding elements\n    interleaved = [val for pair in zip(list1, list2, list3) for val in pair]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Combine the three lists into a single flat list by interleaving\n    interleaved_list = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Combine the lists by zipping them together and then flattening the result\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Combine the lists by zipping them together and then flattening the result\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Zip the lists together, transpose with *, and flatten\n    result = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return result", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Use zip to pair elements from each list and then flatten the result\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Interleave the three lists\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Combine the elements from each list by zipping them together and then flattening the result\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Zip the lists together and flatten the result\n    interleaved_list = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Using zip to interleave and list comprehension to flatten the output\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Interleave the three lists into a single flat list\n    interleaved_list = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Combine the lists by zipping them together, then flatten the result\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Interleave the elements of all three lists and flatten the result\n    interleaved = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    # Interleave the three lists into a single flat list\n    result = [item for sublist in zip(lst1, lst2, lst3) for item in sublist]\n    return result", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 98.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # Concatenate the second part with the first part\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Split the list into two parts at the nth element\n    first_part = lst[:n]\n    second_part = lst[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array at the nth element and rearrange\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two halves at the nth element\n    first_half = arr[:n]\n    second_half = arr[n:]\n    \n    # Concatenate the second half with the first half\n    result = second_half + first_half\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Splitting the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Adding the first part to the end of the second part\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts and concatenate them in reversed order\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Splitting the array at nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Adding the first part to the end of the second part\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two halves at the nth element\n    first_half = arr[:n]\n    second_half = arr[n:]\n    \n    # Combine the second half with the first half\n    return second_half + first_half", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    new_arr = second_part + first_part\n    return new_arr", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenate the two parts, with the second part first\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Slicing the list to get the two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # Combining the two parts in reverse order\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Splitting the list at nth element and swapping the parts\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Split the list at the nth element and concatenate the parts\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Join the two parts, swapping their order\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Splitting the array into two halves\n    first_half = arr[:n]\n    second_half = arr[n:]\n    \n    # Combining the two halves in desired order\n    result = second_half + first_half\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenate the second part with the first part and return\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts and then concatenate them in reverse order\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Add the first part to the end of the second part\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def list_tuple(input_list):\n    # Convert the list to a tuple\n    result = tuple(input_list)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple using the tuple constructor\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert list to tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert the list to a tuple\n    result_tuple = tuple(input_list)\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert the list to a tuple\n    result = tuple(input_list)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert list to tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert list to tuple using the tuple() function\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert list to tuple\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert list to tuple\n    result = tuple(input_list)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple using the tuple constructor\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert the list to a tuple using the tuple() constructor\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the max and min values\n    diff = max_val - min_val\n    \n    return diff", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference\n    diff = max_val - min_val\n    \n    return diff", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between max and min values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the difference between the maximum and minimum value in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_num = max(nums)\n    min_num = min(nums)\n    \n    # Calculate the difference between the max and min values\n    diff = max_num - min_num\n    \n    return diff", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum value in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Return the difference between the maximum and minimum value\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the difference between the largest and smallest value in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the largest and smallest value in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the largest and smallest value\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between max and min value in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum value in the list\n    max_value = max(nums)\n    # Find the minimum value in the list\n    min_value = min(nums)\n    # Return the difference between the max and min values\n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_num = max(nums)\n    min_num = min(nums)\n    \n    # Calculate the difference\n    diff = max_num - min_num\n    \n    return diff", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the max and min values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the largest and smallest value in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Return the difference\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Check if the list is empty\n    if not nums:\n        return 0\n    # Find the difference between the maximum and minimum values\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum value in the list\n    max_val = max(nums)\n    # Find the minimum value in the list\n    min_val = min(nums)\n    # Calculate the difference\n    diff = max_val - min_val\n    return diff", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum value in the list\n    max_val = max(nums)\n    # Find the minimum value in the list\n    min_val = min(nums)\n    # Calculate the difference between the max and min value\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum value in the list\n    max_val = max(nums)\n    # Find the minimum value in the list\n    min_val = min(nums)\n    # Calculate the difference\n    diff = max_val - min_val\n    return diff", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the difference between the largest and smallest values\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 59.866666666666674, "dps_norm": 51.0, "pass@1": 51.0, "profiled": [{"solution": "from math import comb\ndef sum_Of_product(n):\n    # Calculate the sum of product of consecutive binomial coefficients\n    total_sum = sum(comb(n, k) * comb(n, k+1) for k in range(n))\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = sum(comb(n, k) * comb(n, k+1) for k in range(n))\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    return sum(comb(n, k) * comb(n, k+1) for k in range(n))", "matching_cluster_idx": 5}, {"solution": "from math import factorial\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    sum_product = 0\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    for r in range(n):\n        # Calculate the binomial coefficients for the current value of r and r + 1\n        product = (factorial(n) // (factorial(r) * factorial(n - r))) * \\\n                  (factorial(n) // (factorial(r + 1) * factorial(n - r - 1)))\n        # Add the product to the sum\n        sum_product += product\n    \n    return sum_product", "matching_cluster_idx": 2}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum to store the cumulative product of binomial coefficients\n    sum_product = 0\n    # Iterate through the range to calculate the product of consecutive binomial coefficients\n    for r in range(0, n + 1):\n        product = comb(n, r) * comb(n, r + 1) if r + 1 <= n else 0\n        sum_product += product\n    return sum_product", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum\n    total_sum = 0\n    \n    # Calculate the sum of product of consecutive binomial coefficients\n    for i in range(n+1):\n        total_sum += comb(n, i) * comb(n, i+1)\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    # Initialize the sum\n    sum_of_products = 0\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    for r in range(n + 1):\n        product = binomial_coefficient(n, r) * binomial_coefficient(n, r + 1) if r + 1 <= n else 0\n        sum_of_products += product\n    \n    return sum_of_products\ndef binomial_coefficient(n, k):\n    # Function to calculate the binomial coefficient C(n, k)\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k) # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "matching_cluster_idx": 4}, {"solution": "from math import factorial\ndef sum_Of_product(n):\n    # Initialize sum to 0\n    sum_product = 0\n    \n    # Loop through the range of n\n    for k in range(n):\n        # Calculate the product of two consecutive binomial coefficients\n        # binomial coefficient formula: C(n, k) = n! / (k!(n-k)!)\n        # Here we calculate C(n, k) * C(n, k+1)\n        product = (factorial(n) // (factorial(k) * factorial(n - k))) * \\\n                  (factorial(n) // (factorial(k + 1) * factorial(n - k - 1)))\n        # Add product to sum_product\n        sum_product += product\n    \n    return sum_product", "matching_cluster_idx": 2}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum\n    total_sum = 0\n    \n    # Calculate the sum of product of consecutive binomial coefficients\n    for k in range(n + 1):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = sum(comb(n, k) * comb(n, k+1) for k in range(n))\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = 0\n    for k in range(n):\n        total_sum += (calculate_binomial_coeff(n, k) * calculate_binomial_coeff(n, k + 1))\n    return total_sum\ndef calculate_binomial_coeff(n, k):\n    # Calculate binomial coefficient C(n, k)\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)\n    return result", "matching_cluster_idx": 3}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum\n    total_sum = 0\n    \n    # Loop through each value from 0 to n-1\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients\n        product = comb(n, k) * comb(n, k + 1)\n        # Add the product to the total sum\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import factorial\ndef sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    sum = 0\n    for i in range(n+1):\n        # Calculate the binomial coefficient for (n choose i)\n        binom_coeff = factorial(n) // (factorial(i) * factorial(n - i))\n        # Calculate the binomial coefficient for (n choose i+1)\n        if i+1 <= n:\n            next_binom_coeff = factorial(n) // (factorial(i+1) * factorial(n - (i+1)))\n        else:\n            next_binom_coeff = 0\n        # Add the product of the consecutive binomial coefficients to the sum\n        sum += binom_coeff * next_binom_coeff\n    return sum", "matching_cluster_idx": 1}, {"solution": "from functools import reduce\ndef sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = 0\n    for r in range(n + 1):\n        # Calculate binomial coefficient for (n choose r) * (n choose r+1)\n        # Using the formula C(n, k) = n! / (k! * (n-k)!)\n        binom_coeff1 = binom_coeff(n, r)\n        binom_coeff2 = binom_coeff(n, r + 1) if r + 1 <= n else 0\n        total_sum += binom_coeff1 * binom_coeff2\n    return total_sum\ndef binom_coeff(n, k):\n    # Calculate binomial coefficient using factorial\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    num = reduce(lambda x, y: x*y, range(n, n-k, -1), 1)\n    den = reduce(lambda x, y: x*y, range(1, k + 1), 1)\n    return num // den", "matching_cluster_idx": 3}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum\n    total_sum = 0\n    \n    # Loop through to calculate the sum of products\n    for k in range(n + 1):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum\n    total_sum = 0\n    \n    # Calculate the sum of product of consecutive binomial coefficients\n    for i in range(1, n + 1):\n        total_sum += comb(n, i - 1) * comb(n, i)\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = sum(comb(n, k) * comb(n, k + 1) for k in range(n))\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = sum(comb(n, k) * comb(n, k+1) for k in range(n))\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = sum(comb(n, k) * comb(n, k + 1) for k in range(n))\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = sum(comb(n, k) * comb(n, k+1) for k in range(n))\n    return total_sum", "matching_cluster_idx": 5}]}, "Mbpp/597": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 55.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    # Merge two sorted arrays\n    merged_array = sorted(arr1 + arr2)\n    \n    # Since we are asked for kth element, we subtract 1\n    # for zero-based indexing\n    if k > 0 and k <= len(merged_array):\n        return merged_array[k - 1]\n    else:\n        return None  # or raise an error for invalid k", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Find the kth element from the union of two sorted arrays.\n\n    :param nums1: First sorted array.\n    :param nums2: Second sorted array.\n    :param k: The kth position (1-based index) to find in the union of nums1 and nums2.\n    :return: The kth element in the union of the two arrays.\n    \"\"\"\n    # Merge the arrays and sort (though the input arrays are already sorted, they need to be merged)\n    merged = sorted(nums1 + nums2)\n    \n    # Retrieve the kth element (0-based index for list access)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays\n    merged_array = sorted(arr1 + arr2)\n    # Get the kth element (adjusting for 0-index)\n    return merged_array[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged_array = sorted(arr1 + arr2)\n    # Return the kth element\n    return merged_array[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged_arr = sorted(arr1 + arr2)\n    # Return the k-th element\n    return merged_arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge two sorted arrays\n    merged_array = sorted(arr1 + arr2)\n    \n    # Check if k is within the bounds of the merged array\n    if k > 0 and k <= len(merged_array):\n        # Return the (k-1)th element as list indices are zero-based\n        return merged_array[k - 1]\n    else:\n        # Return None or raise an error if k is out of bounds\n        return None", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n\n    :param nums1: First sorted array\n    :param nums2: Second sorted array\n    :param k: The 1-based index of the desired element\n    :return: The kth element\n    \"\"\"\n    # Merge two sorted arrays\n    merged = sorted(nums1 + nums2)\n    # Check if k is within the bounds of the merged list\n    if k > len(merged) or k <= 0:\n        return None  # or raise an error\n    # Return the k-1 indexed element as list index starts from 0\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays and sort the merged array\n    merged_array = sorted(arr1 + arr2)\n    \n    # Check if k is within the bounds of the merged array\n    if k > 0 and k <= len(merged_array):\n        # Return the (k-1)th element (since list indices are 0-based)\n        return merged_array[k - 1]\n    else:\n        # If k is out of bounds, return an error message\n        return \"Index out of bounds\"", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    # Merge the two sorted arrays into one sorted array\n    merged = sorted(nums1 + nums2)\n    \n    # Access the k-1 index to get the kth element\n    # since array index starts at 0\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays and sort the merged array\n    merged_arr = sorted(arr1 + arr2)\n    \n    # Return the k-th element (index k-1 as indexing starts from 0)\n    return merged_arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Finds the kth element in the combined sorted list of two sorted arrays.\n    \n    Parameters:\n    nums1 (List[int]): First sorted list.\n    nums2 (List[int]): Second sorted list.\n    k (int): The 1-based index of the element to find.\n    \n    Returns:\n    int: The kth element in the combined sorted list.\n    \"\"\"\n    # Merge the two arrays and sort\n    merged_nums = sorted(nums1 + nums2)\n    \n    # Check if k is within the bounds of the merged list\n    if k > 0 and k <= len(merged_nums):\n        # Lists are 0-indexed, so the kth element is at position k-1\n        return merged_nums[k - 1]\n    else:\n        raise IndexError(\"k is out of bounds of the merged list.\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    # Merge the two sorted arrays\n    merged_array = sorted(nums1 + nums2)\n    # Return the kth element (adjusting for 0-indexing)\n    return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays into one sorted array\n    merged_array = sorted(arr1 + arr2)\n    \n    # Find the kth element (adjusting for 0-index)\n    return merged_array[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine both sorted arrays\n    merged_array = sorted(arr1 + arr2)\n    # Return the kth element (considering 1-based index)\n    return merged_array[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged = sorted(arr1 + arr2)\n    # Return the k-th element (adjusting for 0-indexing)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n    \n    Parameters:\n    arr1 (List[int]): First sorted array.\n    arr2 (List[int]): Second sorted array.\n    k (int): The kth element to find.\n    \n    Returns:\n    int: The kth element from the combined sorted arrays.\n    \"\"\"\n    # Merge two sorted arrays\n    merged = sorted(arr1 + arr2)\n    # Return the kth element (0-indexed, so k-1)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Finds the k-th element from two sorted arrays.\n    \n    Args:\n    nums1: List[int] -- first sorted array.\n    nums2: List[int] -- second sorted array.\n    k: int -- the k-th position (1-indexed) to find in the merged array.\n    \n    Returns:\n    int -- the k-th element from the merged array.\n    \"\"\"\n    # Merge two sorted arrays\n    merged = sorted(nums1 + nums2)\n    # Return k-th element, adjusting for 0-indexing\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged = sorted(arr1 + arr2)\n    \n    # Check if k is within the bounds of the merged array\n    if k > 0 and k <= len(merged):\n        # Return the k-th element (1-based index)\n        return merged[k - 1]\n    else:\n        # Return None if k is out of bounds\n        return None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged_arr = sorted(arr1 + arr2)\n    # Find the kth element (0-based index)\n    return merged_arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge two sorted arrays\n    merged_array = sorted(arr1 + arr2)\n    \n    # Since indexing in array starts from 0, subtract 1 from k\n    # to get the correct index.\n    return merged_array[k - 1]", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 95.22727272727273, "dps_norm": 99.0, "pass@1": 50.0, "profiled": [{"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    words = words[::-1]\n    # Join the words back into a single string\n    reversed_s = ' '.join(words)\n    return reversed_s", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words and join them with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    # Split the sentence into words, reverse the list of words, and join them with spaces\n    words = sentence.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string by spaces, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    # Split the sentence into words, reverse the list of words, and join them back into a string\n    return ' '.join(sentence.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string by spaces, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list, and join back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string by spaces, reverse the list of words and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string by spaces, reverse the list of words and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the words back into a string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    words.reverse()\n    # Join the words back into a string\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string by spaces, reverse the list of words and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string by spaces into words, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the words back into a string with spaces\n    result = ' '.join(reversed_words)\n    return result", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back together with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string by spaces, reverse the list of words, and then join them back together with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words using space as a delimiter\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the words back into a string with spaces in between\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string by spaces, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 62.489343563512364, "dps_norm": 63.02521008403362, "pass@1": 17.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    # Adjust k to be zero-indexed\n    k_adjusted = k - 1\n    # Remove the k'th element by list slicing\n    return lst[:k_adjusted] + lst[k_adjusted+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # If k is 0 or negative, the function won't remove any element\n    if k <= 0:\n        return lst\n    # Remove the k'th element and return the new list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element by slicing the list and excluding the k'th index\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Copy the list to avoid modifying the original list\n    new_list = lst[:]\n    # Remove the k'th element (list is 0-indexed, so k-1 for k'th element)\n    if k > 0 and k <= len(new_list):\n        del new_list[k-1]\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element from the list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Create a new list without the k'th element\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element from the list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element from the list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element from the list\n    # Note: Python list index starts at 0, so we remove the element at index (k-1)\n    del lst[k-1]\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element from the list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Copy the list to avoid modifying the original list\n    new_lst = lst[:]\n    # Remove the k'th element by index k-1\n    new_lst.pop(k-1)\n    return new_lst", "matching_cluster_idx": 5}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element by slicing the list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Adjust k to be zero-indexed\n    k -= 1\n    if 0 <= k < len(lst):\n        # Remove the k'th element\n        return lst[:k] + lst[k+1:]\n    else:\n        # If k is out of bounds, return the original list\n        return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element by slicing the list and excluding the k'th index\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element from the list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element from the list\n    # Note: Python uses 0-based indexing, so the k'th element is at index k-1\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the k'th element from the list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 68.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column from the matrix\n    nth_column = [row[n] for row in matrix]\n    # Return the maximum value from the n-th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Ensure that the column index is within the bounds of the matrix\n    if not all(len(row) > n for row in matrix):\n        return None  # Return None if column index is out of bounds\n    \n    # Extract the n'th column and find the maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    nth_column = [row[n] for row in matrix]\n    # Find and return the max value in the n'th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix and find the max value\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the nth column from the matrix\n    nth_column = [row[n] for row in matrix]\n    # Return the maximum value in the nth column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column values and find the max\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column from the matrix and find the max value\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column and find the maximum value\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Get the n'th column from the matrix\n    nth_column = [row[n] for row in matrix]\n    # Return the maximum value of the n'th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Ensure the nth column exists in the matrix\n    if n >= len(matrix[0]):\n        return None  # or raise an error, depending on how you want to handle invalid n values\n    # Use a list comprehension to collect n'th column items and find the max\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Initialize max_value with the first element of the n-th column\n    max_value = matrix[0][n]\n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Update max_value if the current element in the n-th column is greater\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    nth_column = [row[n] for row in matrix]\n    # Return the max value of the n'th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix and find the max value\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the nth column from the matrix and find the max value\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Get the nth column from the matrix\n    nth_column = [row[n] for row in matrix]\n    # Return the maximum value from the nth column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Ensure the column index is within the bounds of the matrix\n    if not all(len(row) > n for row in matrix):\n        return None  # Return None if the column index is out of bounds\n    \n    # Use a generator expression to fetch the nth element from each row and find the max\n    max_value = max(row[n] for row in matrix)\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Check if the matrix is empty or n is out of bounds\n    if not matrix or n >= len(matrix[0]):\n        return None\n    # Use list comprehension to get the nth column and find the maximum value\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Ensure the column index n is within the bounds of the matrix\n    if not all(len(row) > n for row in matrix):\n        return None  # Return None if the column index is out of bounds\n    \n    # Use list comprehension to gather elements of the nth column and find the max\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Return the maximum value from the n'th column of the matrix\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column values\n    nth_column_values = [row[n] for row in matrix]\n    # Return the maximum value of the n-th column\n    return max(nth_column_values)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 48.40277777777777, "dps_norm": 43.125, "pass@1": 61.0, "profiled": [{"solution": "def replace_spaces(s):\n    # Replace whitespace with underscore and vice versa\n    return ''.join('_' if c == ' ' else ' ' if c == '_' else c for c in s)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    # Replace underscores with a placeholder\n    s = s.replace('_', 'TEMP_PLACEHOLDER')\n    # Replace spaces with underscores\n    s = s.replace(' ', '_')\n    # Replace placeholder with spaces\n    s = s.replace('TEMP_PLACEHOLDER', ' ')\n    return s", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    # Replace whitespaces with underscores and vice versa\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces all whitespaces in the string with underscores and vice versa.\n    \n    :param s: Input string to process.\n    :return: Modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Replace spaces with underscores and vice versa\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function takes a string and replaces all whitespace characters with underscores\n    and all underscores with whitespace characters.\n\n    :param s: The input string.\n    :return: The modified string with spaces and underscores swapped.\n    \"\"\"\n    # Replace all spaces with a temporary placeholder that is unlikely to appear in input\n    temp_str = s.replace(' ', '\\t')\n    \n    # Replace all underscores with spaces\n    temp_str = temp_str.replace('_', ' ')\n    \n    # Replace the temporary placeholder with underscores\n    return temp_str.replace('\\t', '_')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the input string.\n\n    :param s: String in which replacements are to be made.\n    :return: Modified string with replacements.\n    \"\"\"\n    modified_string = \"\"\n    for char in s:\n        if char == ' ':\n            modified_string += '_'\n        elif char == '_':\n            modified_string += ' '\n        else:\n            modified_string += char\n    return modified_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Replace spaces with underscores and vice versa\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function takes a string s and replaces all the whitespaces with underscores and all the underscores with whitespaces.\n    \n    :param s: A string to be transformed.\n    :return: A transformed string with whitespaces and underscores swapped.\n    \"\"\"\n    transformed_string = \"\"\n    for char in s:\n        if char == \" \":\n            transformed_string += \"_\"\n        elif char == \"_\":\n            transformed_string += \" \"\n        else:\n            transformed_string += char\n    return transformed_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function takes a string s and replaces all whitespace characters with underscores\n    and all underscores with whitespace characters.\n    \n    :param s: The input string to be modified.\n    :return: A string with whitespaces replaced by underscores and underscores replaced by whitespaces.\n    \"\"\"\n    modified_str = ''\n    for char in s:\n        if char == ' ':\n            modified_str += '_'\n        elif char == '_':\n            modified_str += ' '\n        else:\n            modified_str += char\n    return modified_str", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces all whitespaces with underscores and all underscores with whitespaces in the given string.\n\n    :param s: The input string to process.\n    :return: A new string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    return s.replace(\" \", \"temp\").replace(\"_\", \" \").replace(\"temp\", \"_\")", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    # Replace whitespaces with underscores and vice versa\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Replace spaces with underscores and vice versa\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Replace spaces with underscores and underscores with spaces\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    # Replace whitespaces with underscores and vice versa\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Replace whitespace with underscore and underscore with whitespace\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    # Replace spaces with underscores and vice versa\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Replace spaces with underscores and vice versa\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Replace whitespaces with underscores and vice versa\n    modified_string = ''\n    for char in s:\n        if char == ' ':\n            modified_string += '_'\n        elif char == '_':\n            modified_string += ' '\n        else:\n            modified_string += char\n    return modified_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Replace spaces with underscores and vice versa\n    modified_str = ''\n    for char in s:\n        if char == ' ':\n            modified_str += '_'\n        elif char == '_':\n            modified_str += ' '\n        else:\n            modified_str += char\n    return modified_str", "matching_cluster_idx": 2}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(arr):\n    # List to keep track of non-zero elements\n    non_zero = []\n    # Counter for zero elements\n    zero_count = 0\n    \n    # Separate zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero.append(num)\n    \n    # Add zeroes at the end of the non_zero list\n    non_zero.extend([0] * zero_count)\n    \n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Count the zeroes in the array\n    zero_count = arr.count(0)\n    # Remove all zeroes from the array\n    arr = [i for i in arr if i != 0]\n    # Extend the array with the number of zeroes removed\n    arr.extend([0] * zero_count)\n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # List to keep track of non-zero elements\n    non_zero = [i for i in lst if i != 0]\n    # Count the zeroes in the list\n    zero_count = lst.count(0)\n    # Extend the non-zero list with the zeroes counted\n    non_zero.extend([0] * zero_count)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Count the number of zeros in the list\n    zero_count = arr.count(0)\n    \n    # Filter out the zeros from the list\n    arr = [i for i in arr if i != 0]\n    \n    # Append the number of zeros counted at the end of the list\n    arr.extend([0] * zero_count)\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List to hold non-zero elements\n    non_zero = []\n    # Count the number of zero elements\n    zero_count = arr.count(0)\n    \n    # Append all non-zero elements to the non_zero list\n    for num in arr:\n        if num != 0:\n            non_zero.append(num)\n    \n    # Extend the non_zero list with zeros at the end\n    non_zero.extend([0] * zero_count)\n    \n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List to store non-zero elements\n    non_zero = []\n    # Counter for zero elements\n    zero_count = arr.count(0)\n    \n    # Iterate through the list and append non-zero elements to non_zero\n    for num in arr:\n        if num != 0:\n            non_zero.append(num)\n    \n    # Append zeroes to the end of the non_zero list\n    non_zero.extend([0] * zero_count)\n    \n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List to store non-zero elements\n    non_zero = [i for i in arr if i != 0]\n    # List to count the zeros\n    zero = [i for i in arr if i == 0]\n    # Concatenating non-zero elements with zeros at the end\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List to store non-zero elements\n    non_zero = []\n    # Counter for zero elements\n    zero_count = arr.count(0)\n    \n    # Loop through array and add non-zero elements to the new list\n    for num in arr:\n        if num != 0:\n            non_zero.append(num)\n    \n    # Append zeros at the end of the non_zero list\n    non_zero.extend([0]*zero_count)\n    \n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List comprehension that creates a new list with all non-zero values\n    non_zero = [i for i in arr if i != 0]\n    # Append zeros to the non_zero list based on the number of zeros in the original list\n    non_zero.extend([0] * arr.count(0))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List comprehension that separates non-zero and zero elements\n    return [i for i in arr if i != 0] + [i for i in arr if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Count the number of zeros in the list\n    zero_count = arr.count(0)\n    \n    # Remove all zeros from the list\n    arr = [i for i in arr if i != 0]\n    \n    # Append zeros at the end\n    arr.extend([0] * zero_count)\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # List comprehension to first collect all non-zero elements\n    non_zeros = [i for i in lst if i != 0]\n    # Count the number of zeros in the original list and append that many zeros to the non_zeros list\n    zeros = [0] * (len(lst) - len(non_zeros))\n    # Return the combined list of non-zeros followed by zeros\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List to store non-zero elements\n    non_zero = [i for i in arr if i != 0]\n    # Count the number of zero elements in the array\n    zero_count = arr.count(0)\n    # Extend the non-zero list with the zero_count number of zeroes\n    non_zero.extend([0] * zero_count)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List to hold non-zero elements\n    non_zero = [i for i in arr if i != 0]\n    # Count the number of zeroes\n    zero_count = arr.count(0)\n    # Append zeroes at the end of the non_zero list\n    non_zero.extend([0] * zero_count)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Initialize a list to hold the result\n    result = []\n    # Count the zeroes in the array\n    zero_count = arr.count(0)\n    # Iterate over the array\n    for num in arr:\n        # If the number is not zero, append it to the result\n        if num != 0:\n            result.append(num)\n    # Extend the result list with the number of zeroes counted\n    result.extend([0]*zero_count)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List to store non-zero elements\n    non_zero = [i for i in arr if i != 0]\n    # List to store zeroes\n    zeroes = [0] * arr.count(0)\n    # Combine non-zero elements and zeroes\n    result = non_zero + zeroes\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Count the number of zeros in the list\n    zero_count = nums.count(0)\n    # Filter out zeros and create a new list\n    non_zero = [num for num in nums if num != 0]\n    # Extend the non-zero list with zeros\n    non_zero.extend([0] * zero_count)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # List to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Count the zeroes in the original list\n    zero_count = nums.count(0)\n    # Extend the non_zero list with zeroes\n    non_zero.extend([0] * zero_count)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # List to store non-zero elements\n    non_zero = [i for i in arr if i != 0]\n    # Count the number of zeros in the original list\n    zero_count = arr.count(0)\n    # Append zeros to the end of the non_zero list\n    non_zero.extend([0]*zero_count)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Non-zero elements are collected here\n    non_zero = [num for num in nums if num != 0]\n    \n    # Zero elements are collected here\n    zero = [num for num in nums if num == 0]\n    \n    # Combine non-zero elements with zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 90.44715447154472, "dps_norm": 56.666666666666664, "pass@1": 69.0, "profiled": [{"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    result = 0\n    \n    # Iterate through each bit position\n    for i in range(0, 32): \n        # Count of zeroes \n        countZero = 0\n        \n        # Iterate through all numbers \n        for j in range(0, n): \n            # If ith bit is set \n            if (arr[j] & (1 << i)): \n                countZero += 1\n        \n        # Count of ones \n        countOne = n - countZero \n        \n        # XOR of a pair \n        result += (countZero * countOne * (1 << i)) \n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the result to 0\n    result = 0\n    \n    # Iterate over each bit position\n    for i in range(0, 32):\n        # Count the number of elements with ith bit set\n        count = 0\n        for j in range(n):\n            if (arr[j] & (1 << i)):\n                count += 1\n        \n        # There are 'count' numbers with ith bit set\n        # So, there will be 'count*(n-count)' pairs with ith bit set in one and not in other\n        # Every such pair will add 2^i to the xor-sum\n        result += (count * (n - count)) * (1 << i)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    xor_sum = 0\n    \n    # Calculate sum of xor of all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    xor_sum = 0\n    \n    # Calculate xor sum of all pairs \n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    xor_sum = 0\n    # Iterate through each pair and calculate xor sum\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    # Initialize result to 0\n    result = 0\n    \n    # Iterate over the bits position\n    for i in range(0, 32):\n        # Count the number of elements with i-th bit set\n        count = 0\n        for j in range(n):\n            if (nums[j] & (1 << i)):\n                count += 1\n                \n        # Add to result, the count of pairs where i-th bit is different\n        # count * (n - count) is the number of pairs with different i-th bits\n        result += (count * (n - count) * (1 << i))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def pair_xor_Sum(nums, n):\n    # Initialize sum\n    xor_sum = 0\n    \n    # Iterate through all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR the pair and add to sum\n            xor_sum += nums[i] ^ nums[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    res = 0\n    # iterate over all bits \n    for i in range(0, 32):\n        # count of zeros and ones \n        cz, co = 0, 0\n        # iterate over all elements \n        for j in range(0, n):\n            # if jth bit is set \n            if (arr[j] & (1 << i)):\n                co += 1  # increment count of ones \n            else:\n                cz += 1  # increment count of zeros \n        # XOR of pair of i'th bit will be 1 \n        # if one is set and other is not set \n        res += (1 << i) * cz * co\n    return res", "matching_cluster_idx": 3}, {"solution": "def pair_xor_Sum(nums, n):\n    # Initialize the result to 0\n    result = 0\n    \n    # Iterate through the list and compute the sum of xor for all pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate the xor of the pair (nums[i], nums[j])\n            xor_pair = nums[i] ^ nums[j]\n            # Add the xor result to the total result\n            result += xor_pair\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    xor_sum = 0\n    \n    # Calculate the sum of XOR for all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n            \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    xor_sum = 0\n    \n    # Calculate the sum of xor of all pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    result = 0\n    \n    # Calculate XORs of all pairs \n    for i in range(n):\n        for j in range(i + 1, n):\n            result += arr[i] ^ arr[j]\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    result = 0\n    \n    # Iterate through each bit position\n    for i in range(0, 32):\n        \n        # Count of zeros and ones at ith bit position\n        count_zero = 0\n        count_one = 0\n        \n        # Iterate through all elements in the array\n        for j in range(0, n):\n            # If ith bit is set\n            if (arr[j] & (1 << i)):\n                count_one += 1\n            else:\n                count_zero += 1\n        \n        # Add to the result, the number of pairs that have different ith bit\n        result += (count_zero * count_one * (1 << i))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    result = 0\n    \n    # Calculate the sum of XOR of all pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            result += arr[i] ^ arr[j]\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    xor_sum = 0\n    \n    # Calculate the XOR for each pair and add it to the result\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    result = 0\n    \n    # Calculate XOR of all pairs\n    for i in range(0, n):\n        for j in range(i+1, n):\n            result += arr[i] ^ arr[j]\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    res = 0\n    \n    # Calculate the sum of xor for all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            res += arr[i] ^ arr[j]\n    \n    return res", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    res = 0\n    \n    # Calculate XOR of all pairs \n    for i in range(0, n):\n        for j in range(i+1, n):\n            res += arr[i] ^ arr[j]\n            \n    return res", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    result = 0\n    \n    # Iterate over each bit position \n    for i in range(0, 32):\n        # Count of 1s in i-th position \n        ones = 0\n        \n        # Check each element of array for set bit \n        for j in range(0, n):\n            if (arr[j] & (1 << i)):\n                ones += 1\n        \n        # Count of zeros in i-th position is \n        # complement of ones. \n        zeros = n - ones\n        \n        # Add to the result, the value of ones * zeros * 2^i \n        result += (ones * zeros * (1 << i))\n    \n    # Return result \n    return result", "matching_cluster_idx": 3}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result \n    result = 0\n    \n    # Iterate through every bit position \n    for i in range(0, 32):\n        \n        # Count of zeroes \n        zero = 0\n        \n        # Iterate through all numbers \n        for j in range(n):\n            if (arr[j] & 1) == 0:\n                zero += 1\n            arr[j] = arr[j] >> 1\n        \n        # Count of ones \n        one = n - zero \n        \n        # Update result \n        result += (one * zero) * (1 << i)\n    \n    return result", "matching_cluster_idx": 3}]}, "Mbpp/644": {"dps": 89.33510638297871, "dps_norm": 88.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray from the start to the k-th index\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array up to the given position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reversing the array up to the k-th position\n    reversed_part = arr[:k][::-1]\n    # Keeping the rest of the array intact\n    remaining_part = arr[k:]\n    # Combining the reversed part and the remaining part\n    arr = reversed_part + remaining_part\n    return arr", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array up to the given position k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the portion of the array up to index k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array up to k and concatenate with the rest of the array\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the portion of the array up to index k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reversing the portion of the array up to the given position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the portion of the array from the start up to k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reversing the array up to the given position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array up to the given position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the portion of the array up to k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reversing the sub-array up to k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray from the start to the given position k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray up to k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array up to position k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array up to the given position k\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the portion of the array up to k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray up to the given position k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array from the start to the k-th element\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}]}, "Mbpp/720": {"dps": 52.11538461538461, "dps_norm": 84.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the tuple to a list to append the dictionary to it\n    temp_list = list(input_tuple)\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple and return\n    return tuple(temp_list)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert tuple to list, append dictionary to the list, and then convert back to tuple\n    updated_list = list(input_tuple)\n    updated_list.append(input_dict)\n    return tuple(updated_list)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Convert the tuple to a list to allow modification\n    temp_list = list(test_tup)\n    # Append the dictionary to the list\n    temp_list.append(test_dict)\n    # Convert the list back to a tuple\n    res = tuple(temp_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    output_tuple = tuple(temp_list)\n    \n    return output_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to enable modifications\n    temp_list = list(input_tuple)\n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    # Convert the list back to a tuple and return\n    output_tuple = tuple(temp_list)\n    return output_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Converting tuple to list to append the dictionary\n    temp_list = list(test_tup)\n    temp_list.append(test_dict)\n    # Converting the list back to a tuple\n    res = tuple(temp_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the input tuple to a list to append the dictionary and then convert it back to a tuple\n    temp_list = list(input_tuple)\n    temp_list.append(input_dict)\n    return tuple(temp_list)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Adding dictionary to tuple using tuple concatenation\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Convert the tuple to a list, append the dictionary, and then convert back to a tuple\n    res = tuple(list(test_tup) + [test_dict])\n    return res", "matching_cluster_idx": 2}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Convert the tuple to a list to use list methods\n    temp_list = list(test_tup)\n    # Append the dictionary to the list\n    temp_list.append(test_dict)\n    # Convert the list back to a tuple\n    res = tuple(temp_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Adding the dictionary to the end of the tuple\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Adding dictionary to tuple by concatenating it\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Convert the tuple into a list to allow modifications\n    temp_list = list(tup)\n    \n    # Add the dictionary to the end of the list\n    temp_list.append(dictionary)\n    \n    # Convert the list back into a tuple and return it\n    return tuple(temp_list)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Convert the tuple to a list to allow modifications\n    temp_list = list(test_tup)\n    \n    # Add the dictionary to the list\n    temp_list.append(test_dict)\n    \n    # Convert the list back to a tuple\n    res = tuple(temp_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, dictionary):\n    # Convert the tuple to a list to allow modifications\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(dictionary)\n    \n    # Convert the list back to a tuple\n    updated_tuple = tuple(temp_list)\n    \n    return updated_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Adding the dictionary to the tuple by converting it to a tuple with one element and concatenating\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Convert tuple to list and append the dictionary\n    temp_list = list(test_tup)\n    temp_list.append(test_dict)\n    \n    # Convert list back to tuple\n    res = tuple(temp_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Convert tuple to list to allow modification\n    temp_list = list(test_tup)\n    \n    # Append the dictionary to the list\n    temp_list.append(test_dict)\n    \n    # Convert list back to tuple\n    res = tuple(temp_list)\n    \n    return res", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Convert tuple to list to allow modifications\n    temp_list = list(test_tup)\n    # Append dictionary to the list\n    temp_list.append(test_dict)\n    # Convert list back to tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Convert the tuple to a list, append the dictionary, then convert back to a tuple\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 46.99453551912568, "dps_norm": 62.5, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_quotation(text):\n    # Using regular expression to find all content between double quotes\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all occurrences of text within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Using regular expression to find all patterns that start and end with double quotes\n    # and capturing the content inside the quotes with a group.\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    # Find all occurrences of text between quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Using regular expression to find all instances between quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all patterns that match text within quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Find all occurrences of text enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Find all occurrences of text between double quotes\n    result = re.findall(r'\"(.*?)\"', input_string)\n    return result", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Regular expression to find all occurrences of text between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Find all patterns that match the double-quoted text\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Regular expression to find strings enclosed in double quotes\n    pattern = r'\"(.*?)\"'\n    # Find all non-overlapping matches of pattern in the string\n    result = re.findall(pattern, input_string)\n    return result", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regular expression to find all patterns surrounded by quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Using regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Regular expression to find all matches of text enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all matches of text within double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all matches within quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Using regular expression to find all patterns between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    # Using regular expression to find all matches of text enclosed in quotes\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    # Find all substrings that are enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 4}]}, "Mbpp/732": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    result = s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with colons\n    for char in [' ', ',', '.']:\n        input_string = input_string.replace(char, ':')\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with colons\n    for char in (' ', ',', '.'):\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with colons\n    for char in [' ', ',', '.']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with colons\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace space, comma, and dot with colon\n    result_string = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with a colon\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    for char in [' ', ',', '.']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with colons\n    result = text.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    for char in [' ', ',', '.']:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    for char in [' ', ',', '.']:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with a colon\n    for char in [' ', ',', '.']:\n        input_string = input_string.replace(char, ':')\n    return input_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with colons\n    result = s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with colon\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with colons\n    result = text.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")\n    return result", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    for char in [' ', ',', '.']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 86.9090909090909, "dps_norm": 73.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(input_tuple):\n    # Check if the length of the tuple is even\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements to form key-value pairs.\")\n    \n    # Convert the tuple to a dictionary with adjacent elements as key-value pairs\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    \n    # Create a dictionary by zipping every two elements together\n    result_dict = {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the length of the tuple is odd, which means not all elements can form pairs\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Input tuple length must be even to form pairs\")\n    \n    # Create a dictionary by using the zip function with sliced tuples\n    # Slice the tuple to even indices for keys and odd indices for values\n    result_dict = dict(zip(tup[::2], tup[1::2]))\n    \n    return result_dict", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    # Use zip to pair every two elements from the tuple, and convert to a dictionary\n    it = iter(tup)\n    res_dict = dict(zip(it, it))\n    \n    return res_dict", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    \n    # Iterate over the tuple in steps of 2 to create key-value pairs\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Convert the tuple into a dictionary by taking elements in pairs\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the length of the tuple is even, ensuring there are no unpaired elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    # Convert the tuple to a dictionary by pairing adjacent elements\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements.\")\n    \n    # Create dictionary using dictionary comprehension\n    # Iterate over the tuple by steps of 2 and create key-value pairs\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    \n    # Create the dictionary by taking elements in pairs\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements.\")\n    \n    # Use dictionary comprehension to create the dictionary\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # Check if the length of the tuple is even, which is required for key-value pairs\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n    \n    # Create a dictionary using a dictionary comprehension\n    result_dict = {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    # Create a dictionary from the tuple elements\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # Check if the length of the tuple is even\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    # Convert tuple to dictionary by taking elements in pairs\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Ensure the tuple has an even number of elements for key-value pairs\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    \n    # Convert tuple to dictionary by taking elements in pairs\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements.\")\n    \n    # Create a dictionary using tuple elements as keys and values\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple should contain an even number of elements\")\n    \n    # Convert tuple to dictionary by pairing every two elements\n    res = {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    \n    # Use dictionary comprehension to create a dictionary from the tuple\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    \n    # Use dictionary comprehension to pair up adjacent elements\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Ensure the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    \n    # Convert tuple to dictionary using a dictionary comprehension\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 29.006849315068493, "dps_norm": 43.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def check_none(test_tuple):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    # Check if any element in the tuple is None\n    return any(element is None for element in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    # Iterate through each element in the tuple\n    for element in test_tuple:\n        # Check if the current element is None\n        if element is None:\n            # If None is found, return True\n            return True\n    # If no None is found, return False\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tup):\n    # Check if there is any None value in the tuple\n    return any(element is None for element in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    # Check if there is any None value in the tuple\n    return any(isinstance(element, type(None)) for element in test_tuple)", "matching_cluster_idx": -1}, {"solution": "def check_none(test_tup):\n    # Check if there is any None value in the tuple\n    return any(isinstance(elem, type(None)) for elem in test_tup)", "matching_cluster_idx": -1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tup):\n    # Check if None is in the tuple\n    return None in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    \"\"\"\n    This function checks if the given tuple has any None value or not.\n    \n    Parameters:\n    test_tup (tuple): The tuple to be checked.\n    \n    Returns:\n    bool: True if there is any None value in the tuple, False otherwise.\n    \"\"\"\n    return any(isinstance(x, type(None)) for x in test_tup)", "matching_cluster_idx": -1}, {"solution": "def check_none(test_tup):\n    \"\"\"\n    Check if there is any None value in the tuple.\n\n    :param test_tup: Tuple to be checked.\n    :return: True if any None value is found in the tuple, False otherwise.\n    \"\"\"\n    # Check for the presence of None in the tuple\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    # Check if None is in the tuple\n    return None in test_tuple", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    # Check if there's any None value in the tuple\n    return any(ele is None for ele in test_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(element is None for element in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    # Check if there is any None value in the tuple\n    return any(isinstance(x, type(None)) for x in test_tuple)", "matching_cluster_idx": -1}]}, "Mbpp/750": {"dps": 88.29931972789116, "dps_norm": 93.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with elements from the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list by converting the tuple to a list and concatenating\n    lst.extend(list(tup))\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with elements from the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extending the list with elements from the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extending the list with the tuple's elements\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Converting the tuple to a list and extending the original list\n    lst.extend(list(tup))\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements from the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tpl):\n    # Convert the tuple to a list, then extend the original list\n    lst.extend(list(tpl))\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tpl):\n    # Convert tuple to list and extend the original list with its elements\n    lst.extend(list(tpl))\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    # Convert the tuple to a list and extend the original list with it\n    lst.extend(list(tup))\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    # Convert tuple to list and extend the original list\n    lst.extend(list(tup))\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with elements from the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list by converting the tuple to a list and adding it\n    lst.extend(list(tup))\n    return lst", "matching_cluster_idx": 4}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the tuple's elements\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 30.134228187919465, "dps_norm": 57.5, "pass@1": 100.0, "profiled": [{"solution": "def min_k(test_list, k):\n    # Sort the list based on the second item of each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(lst, k):\n    \"\"\"\n    This function finds the minimum k records from a list of tuples based on the second element of the tuple.\n    :param lst: List of tuples\n    :param k: Number of minimum records to find\n    :return: List of k minimum records\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_lst = sorted(lst, key=lambda x: x[1])\n    # Return the first k elements\n    return sorted_lst[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    \"\"\"\n    Finds the k minimum records from a list of tuples based on the second item in the tuples.\n\n    Parameters:\n    test_list (list): The list of tuples to be processed.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list: A list of k minimum records.\n    \"\"\"\n    # Sorting the list of tuples based on the second item\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Slicing the sorted list to get the first k elements\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second item in each tuple.\n    \n    Parameters:\n    test_list (list of tuples): The input list to search within.\n    k (int): The number of minimum records to find.\n    \n    Returns:\n    list of tuples: A list containing the k tuples with the smallest second item.\n    \"\"\"\n    # Sort the list by the second item in each tuple and then slice the first k elements\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    \"\"\"\n    Function to find the minimum k records from a given list of tuples based on the second element of the tuples.\n    \n    Args:\n    test_list: List of tuples where sorting is to be performed based on the second element of each tuple.\n    k: Number of minimum records to retrieve from the list.\n    \n    Returns:\n    A list of tuples containing the minimum k records.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_test_list = sorted(test_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_test_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    \"\"\"\n    This function finds the minimum k records from a list of tuples, sorting them based on the second item in the tuple.\n    \n    :param test_list: The list of tuples to search through.\n    :param k: The number of minimum records to find.\n    :return: A list of tuples containing the minimum k records.\n    \"\"\"\n    # Sort the list based on the second item of each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first k items from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, k):\n    # Sort the list of tuples based on the second element in the tuple in ascending order\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Get the first k elements from the sorted list\n    min_k_elements = sorted_list[:k]\n    return min_k_elements", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    # Sort the list of tuples by the second item in each tuple and slice the first k elements\n    return sorted(test_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    # Sort the list of tuples by the second item in each tuple and return the first k items\n    return sorted(test_list, key=lambda x: x[1])[:k]\ntest_list = [('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)]\nk = 2", "matching_cluster_idx": 2}, {"solution": "def min_k(tup, k):\n    # Sort the list of tuples by the second item in each tuple\n    # in ascending order and slice the first k elements\n    return sorted(tup, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    \"\"\"\n    Find the k minimum records in a list of tuples based on the second element of the tuples.\n    \n    :param test_list: List of tuples where each tuple contains at least two elements.\n    :param k: Number of minimum records to return.\n    :return: A list of k tuples with the smallest second element values.\n    \"\"\"\n    # Sort the list based on the second element of the tuples\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Get the first k elements\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tup, k):\n    # Sort the tuple list based on the second element of each tuple and take the first k elements\n    return sorted(tup, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    # Sort the list of tuples based on the second item (index 1) in each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Slice the list to get the first k elements\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k, then returns the k tuples\n    with the smallest second elements.\n    \n    :param test_list: List of tuples, each containing a string and an integer\n    :param k: Number of minimum records to find\n    :return: List of k tuples with the smallest second elements\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    Parameters:\n    test_list (list of tuples): The list of tuples to search through.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuples: The k minimum records from the list based on the second element of the tuples.\n    \"\"\"\n    # Sort the list based on the second element of each tuple and slice the first k elements\n    return sorted(test_list, key=lambda x: x[1])[:k]\ntest_list = [('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)]\nk = 2", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    \"\"\"\n    Find the k tuples with the smallest second element in a given list of tuples.\n\n    :param test_list: A list of tuples.\n    :param k: The number of minimum tuples to find.\n    :return: A list of tuples with the smallest second elements.\n    \"\"\"\n    # Sort the list of tuples based on the second element in each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tup_list, k):\n    \"\"\"\n    Finds the k tuples with the smallest second element in the list of tuples.\n    \n    :param tup_list: List of tuples, where each tuple contains a string and an integer\n    :param k: Number of minimum records to return\n    :return: List of k tuples with the smallest second element\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tup_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list of tuples based on the second item of each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k as input.\n    It returns a list of the k tuples with the smallest second value.\n    \n    :param tuples_list: List of tuples, where each tuple contains at least two elements\n    :param k: Integer indicating the number of minimum tuples to return\n    :return: List of k tuples with the smallest second value\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, k):\n    \"\"\"\n    Finds the k minimum records from a list of tuples.\n\n    Parameters:\n    test_list (list of tuples): The list of tuples to search through.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuples: A list containing the k minimum tuples sorted by their second element.\n    \"\"\"\n    # Sort the list based on the second element of each tuple and get the first k elements\n    res = sorted(test_list, key=lambda x: x[1])[:k]\n    return res", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 92.24137931034483, "dps_norm": 90.625, "pass@1": 26.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    # Using list comprehension to compare elements at the same index\n    return [x1 for x1, x2, x3 in zip(l1, l2, l3) if x1 == x2 == x3]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Zip the three lists together to pair up elements at the same index\n    # Then use list comprehension to filter common elements\n    return [x[0] for x in zip(l1, l2, l3) if x[0] == x[1] == x[2]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements by comparing elements at the same index in all three lists\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use list comprehension to check if elements are common at the same index\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    result = []\n    \n    # Iterate through each index of the lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the element at index i is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If so, append the element to the result list\n            result.append(l1[i])\n    \n    # Return the list of common elements\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Zip the three lists together and iterate\n    common_elements = [x1 for x1, x2, x3 in zip(l1, l2, l3) if x1 == x2 == x3]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use list comprehension to find common elements at the same index\n    return [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Create an empty list to store the common elements\n    result = []\n    # Iterate through the lists using zip to pair elements with the same index\n    for a, b, c in zip(l1, l2, l3):\n        # If the elements are the same, add it to the result list\n        if a == b == c:\n            result.append(a)\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the list indices\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If yes, append the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length among the three lists to ensure index doesn't go out of bounds\n    min_length = min(len(l1), len(l2), len(l3))\n    # Use a list comprehension to find common elements at the same index\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate over the lists using zip to get elements at the same index from all three lists\n    for elem1, elem2, elem3 in zip(l1, l2, l3):\n        # If elements from all three lists are the same, append to common_elements\n        if elem1 == elem2 == elem3:\n            common_elements.append(elem1)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Create an empty list to store common elements\n    common_elements = []\n    # Iterate through the lists by index\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the elements at the current index are the same across all lists\n        if l1[i] == l2[i] == l3[i]:\n            # If so, append the element to the common_elements list\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use zip to iterate over the three lists simultaneously\n    return [x1 for x1, x2, x3 in zip(l1, l2, l3) if x1 == x2 == x3]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Iterate through the indices of the lists using zip to simultaneously access elements from each list\n    for a, b, c in zip(l1, l2, l3):\n        # If the elements are the same, append them to the common_elements list\n        if a == b == c:\n            common_elements.append(a)\n    \n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Zip the three lists to compare elements at the same index\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Create a list comprehension to iterate through zipped lists and find elements that are equal in all three lists\n    common_elements = [a for a, b, c in zip(l1, l2, l3) if a == b == c]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Create an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the indices of the lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if elements at the same index are the same\n        if l1[i] == l2[i] == l3[i]:\n            # Append common element to the list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Iterate through the elements of the lists using zip to pair up elements by their indices\n    for e1, e2, e3 in zip(l1, l2, l3):\n        # If the elements are the same, add to the common_elements list\n        if e1 == e2 == e3:\n            common_elements.append(e1)\n    \n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize a result list to store common elements\n    result = []\n    \n    # Iterate over the indices of the lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] and l2[i] == l3[i]:\n            # If they are, append the element to the result list\n            result.append(l1[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # List comprehension to find common elements at the same index\n    common_elements = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 93.45132743362832, "dps_norm": 96.66666666666667, "pass@1": 35.0, "profiled": [{"solution": "def second_smallest(nums):\n    # Remove duplicates and sort the list\n    unique_nums = sorted(set(nums))\n    # Return the second element in the sorted unique list\n    return unique_nums[1] if len(unique_nums) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates\n    unique_list = list(set(lst))\n    # Sort the list\n    unique_list.sort()\n    # Return the second element\n    return unique_list[1] if len(unique_list) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates and sort the list\n    unique_lst = sorted(set(lst))\n    # Return the second element in the sorted unique list\n    if len(unique_lst) > 1:\n        return unique_lst[1]\n    else:\n        return None  # Return None if there is no second smallest element", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Remove duplicates and sort the list\n    unique_nums = sorted(set(nums))\n    # Check if there is at least a second element\n    if len(unique_nums) > 1:\n        return unique_nums[1]\n    else:\n        return None  # Or any other value indicating no second smallest element", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Remove duplicates and sort the list\n    unique_nums = sorted(set(nums))\n    # Return the second element, which is the second smallest\n    return unique_nums[1] if len(unique_nums) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n    # Check if there is a second element\n    if len(unique_sorted_lst) < 2:\n        return None\n    return unique_sorted_lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates by converting list to a set, then back to a sorted list\n    unique_lst = sorted(set(lst))\n    # Return the second element of the sorted list\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Initialize the smallest and second smallest with infinity\n    first = second = float('inf')\n    for num in nums:\n        # Update the smallest and second smallest numbers\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    # Remove duplicates and sort the list\n    unique_nums = sorted(set(nums))\n    # Return the second element if it exists\n    if len(unique_nums) > 1:\n        return unique_nums[1]\n    else:\n        return None  # If there is no second smallest number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates and sort the list\n    unique_lst = sorted(set(lst))\n    # Return the second element if list has at least two unique elements\n    if len(unique_lst) > 1:\n        return unique_lst[1]\n    return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Remove duplicates by converting to a set, then back to a sorted list\n    unique_nums = sorted(set(nums))\n    # Return the second element if the list is long enough\n    if len(unique_nums) > 1:\n        return unique_nums[1]\n    return None  # If there is no second smallest, return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Initialize first and second smallest with infinity\n    first, second = float('inf'), float('inf')\n    for num in nums:\n        # Update the first and second smallest numbers\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    # Remove duplicates by converting list to a set, then convert back to sorted list\n    sorted_nums = sorted(set(nums))\n    \n    # If there are less than 2 unique elements, return None\n    if len(sorted_nums) < 2:\n        return None\n    \n    # Return the second element in the sorted list\n    return sorted_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    \"\"\"\n    Finds the second smallest number in the list.\n    \n    :param lst: List of numbers\n    :return: The second smallest number in the list\n    \"\"\"\n    unique_numbers = list(set(lst))  # Remove duplicates\n    unique_numbers.sort()  # Sort the list\n    if len(unique_numbers) < 2:\n        return None  # Not enough unique numbers\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates by converting the list to a set\n    unique_list = list(set(lst))\n    # Sort the list in ascending order\n    unique_list.sort()\n    # Return the second element in the sorted list\n    if len(unique_list) > 1:\n        return unique_list[1]\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates and sort the list\n    unique_lst = sorted(set(lst))\n    # Return the second element in the sorted unique list\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates to avoid counting the same element twice\n    unique_lst = list(set(lst))\n    # Sort the list to find the second smallest element\n    unique_lst.sort()\n    # Check if there is a second element, return it if so\n    if len(unique_lst) > 1:\n        return unique_lst[1]\n    else:\n        return None  # Return None if the list is too short to have a second smallest", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Remove duplicates by converting to a set, then back to a list\n    unique_nums = list(set(nums))\n    # Sort the list to order numbers\n    unique_nums.sort()\n    # Return the second element which is the second smallest number\n    return unique_nums[1] if len(unique_nums) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates to ensure we find the actual second smallest number\n    unique_nums = list(set(lst))\n    # Sort the list to find the second smallest number\n    unique_nums.sort()\n    # Return the second element in the sorted list\n    if len(unique_nums) > 1:\n        return unique_nums[1]\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates\n    unique_lst = list(set(lst))\n    # Sort the list\n    unique_lst.sort()\n    # Return the second element in the sorted list\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 5}]}, "Mbpp/757": {"dps": 84.88317757009347, "dps_norm": 32.69230769230769, "pass@1": 29.0, "profiled": [{"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Count the number of pairs of strings in the list that are reverse of each other.\n    \n    :param lst: List of strings\n    :return: Number of reverse string pairs\n    \"\"\"\n    counter = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                counter += 1\n    return counter", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    # Initialize the count to zero\n    count = 0\n    # Loop through each string in the list\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # Check if one string is the reverse of the other\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    # Initialize count of reverse string pairs\n    count = 0\n    # Iterate through the list with index\n    for i in range(len(lst)):\n        # Compare the remaining strings to find a reverse pair\n        for j in range(i + 1, len(lst)):\n            # Check if lst[j] is the reverse of lst[i]\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Count the number of pairs of strings in the list where one string is the reverse of the other.\n    \n    :param lst: List of strings\n    :return: Number of reverse string pairs\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Counts pairs of reverse strings in the list.\n    \n    :param lst: List of strings\n    :return: Count of pairs where one string is the reverse of another\n    \"\"\"\n    count = 0\n    # Loop through the list to find reverse pairs\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            # Check if one string is the reverse of the other\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    # Initialize counter for reverse pairs\n    count = 0\n    \n    # Iterate through the list with the first index\n    for i in range(len(lst)):\n        # Iterate through the list with the second index\n        for j in range(i + 1, len(lst)):\n            # Check if the second string is the reverse of the first string\n            if lst[i] == lst[j][::-1]:\n                count += 1\n                \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    This function takes a list of strings and returns the number of pairs of reverse strings within the list.\n    \n    :param lst: List of strings\n    :return: Integer count of reverse string pairs\n    \"\"\"\n    count = 0\n    # Loop through each string in the list\n    for i in range(len(lst)):\n        # Check each subsequent string to avoid duplicate pairs and improve efficiency\n        for j in range(i + 1, len(lst)):\n            # Check if one string is the reverse of the other\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(arr):\n    # Initialize counter for reverse pairs\n    reverse_pair_count = 0\n    # Iterate through the list of strings\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the current string is the reverse of another\n            if arr[i] == arr[j][::-1]:\n                reverse_pair_count += 1\n    return reverse_pair_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Count the number of pairs of reverse strings in the given list.\n\n    :param lst: List of strings to be checked.\n    :return: Number of reverse string pairs.\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[j] == lst[i][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Count the number of pairs of strings in the given list that are reverses of each other.\n    \n    :param lst: List of strings to be checked\n    :return: Integer count of reverse string pairs\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(arr):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n    \n    Args:\n    arr (list): List of strings to be checked.\n    \n    Returns:\n    int: Number of reverse string pairs.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] == arr[i][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    # Dictionary to keep track of seen strings and their reversed counterparts\n    seen = {}\n    count = 0\n\n    for string in lst:\n        # Reverse the current string\n        reversed_string = string[::-1]\n        \n        # Check if the reversed string is already seen\n        if reversed_string in seen:\n            count += seen[reversed_string]\n        \n        # Count the current string in the dictionary\n        if string in seen:\n            seen[string] += 1\n        else:\n            seen[string] = 1\n    \n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Counts the number of pairs of strings in the list that are reverse of each other.\n    \n    :param lst: List of strings to be checked\n    :return: Integer count of reverse string pairs\n    \"\"\"\n    # Create a dictionary to count string occurrences\n    str_count = {}\n    count = 0\n    \n    # Iterate over the list and populate the dictionary\n    for word in lst:\n        # Convert word to tuple to make it hashable and usable as a dictionary key\n        word_tuple = tuple(word)\n        reversed_word_tuple = tuple(reversed(word))\n        \n        # Check if the reverse tuple exists in the dictionary\n        if reversed_word_tuple in str_count:\n            count += str_count[reversed_word_tuple]\n        \n        # Increment the count of the current word tuple in the dictionary\n        str_count[word_tuple] = str_count.get(word_tuple, 0) + 1\n    \n    return count", "matching_cluster_idx": 7}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Counts the number of pairs of reverse strings in the list.\n    \n    Parameters:\n    lst (list): The list of strings to check for reverse pairs.\n    \n    Returns:\n    int: The count of reverse string pairs in the list.\n    \"\"\"\n    # Dictionary to keep track of strings seen and their counts\n    seen = {}\n    count = 0\n    for word in lst:\n        # Reverse the current word\n        reverse_word = word[::-1]\n        # If the reverse word has been seen, increment the count by its occurrences\n        if reverse_word in seen:\n            count += seen[reverse_word]\n        # Update the occurrences of the current word in the seen dictionary\n        seen[word] = seen.get(word, 0) + 1\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Counts the number of pairs of strings within a list that are reverses of each other.\n    \n    :param lst: List of strings to be checked.\n    :return: Integer count of reverse string pairs.\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    # Initialize the count of reverse string pairs\n    count = 0\n    # Iterate through the list to find reverse pairs\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            # Check if one string is the reverse of the other\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Counts the number of pairs of reverse strings in the given list.\n    \n    Parameters:\n    lst (list): A list of strings\n    \n    Returns:\n    int: The count of reverse string pairs in the list\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(arr):\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[j] == arr[i][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 93.37837837837837, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the count of each sublist\n    sublist_count = {}\n    \n    # Iterate through the list to count the occurrences of each sublist\n    for sublist in lst:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in sublist_count:\n            sublist_count[tuple_sublist] += 1\n        else:\n            # Otherwise, add it to the dictionary with a count of 1\n            sublist_count[tuple_sublist] = 1\n    \n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    # Initialize an empty dictionary to store the count of each tuple.\n    count_dict = {}\n    # Iterate over each sublist in the input_list.\n    for sublist in input_list:\n        # Convert the sublist into a tuple and increment its count in the dictionary.\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    # Return the dictionary with counts of each sublist.\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the occurrences of each sublist\n    sublist_counts = {}\n    \n    # Iterate through each sublist in the provided list\n    for sublist in lst:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already a key in the dictionary, increment its count\n        if sublist_tuple in sublist_counts:\n            sublist_counts[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            sublist_counts[sublist_tuple] = 1\n    \n    return sublist_counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Create a dictionary to store the frequency of each tuple\n    frequency_dict = {}\n    \n    # Convert each list in lst to a tuple and update its frequency\n    for sublist in lst:\n        # Convert sublist to tuple as lists are unhashable and cannot be dictionary keys\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in frequency_dict:\n            frequency_dict[sublist_tuple] += 1\n        else:\n            frequency_dict[sublist_tuple] = 1\n            \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Import Counter from collections to count elements\n    from collections import Counter\n    \n    # Convert inner lists to tuples to make them hashable and count occurrences\n    count_dict = Counter(map(tuple, lst))\n    \n    # Return the count dictionary\n    return dict(count_dict)", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Create an empty dictionary to store the sublists and their counts\n    sublist_count = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple already exists in the dictionary, increment its count\n        if tuple_sublist in sublist_count:\n            sublist_count[tuple_sublist] += 1\n        else:\n            # Otherwise, add the tuple to the dictionary with a count of 1\n            sublist_count[tuple_sublist] = 1\n    \n    # Return the dictionary containing the unique sublists and their counts\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Create an empty dictionary to store the sublists as tuples and their count\n    sublist_count = {}\n    \n    # Loop through each sublist in the given list\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is not in the dictionary, add it with a count of 1\n        # If it already exists, increment its count\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    \n    # Return the dictionary of sublists and their counts\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list_of_lists):\n    # Initialize an empty dictionary to store the occurrence count of each sublist\n    count_dict = {}\n    \n    # Iterate over each sublist in the given list of lists\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple because lists are not hashable and cannot be used as dictionary keys\n        tuple_sublist = tuple(sublist)\n        # If the tuple is already in the dictionary, increment its count. If not, add it to the dictionary with a count of 1\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    # Return the dictionary containing the unique sublists and their occurrence counts\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the provided list\n    for sublist in lists:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist in the list to a tuple to make it hashable\n    tuple_list = [tuple(sublist) for sublist in lst]\n    # Use a dictionary comprehension to count occurrences of each tuple\n    count_dict = {item: tuple_list.count(item) for item in set(tuple_list)}\n    return count_dict", "matching_cluster_idx": 2}, {"solution": "def unique_sublists(lst):\n    # Convert all sublists into tuples for hashability\n    tuple_lst = [tuple(sublist) for sublist in lst]\n    # Create a dictionary to count occurrences of each tuple\n    count_dict = {}\n    for item in tuple_lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple and count its occurrences\n    count_dict = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple and use it as the key\n        key = tuple(sublist)\n        if key in count_dict:\n            # Increment the count if the key is already present\n            count_dict[key] += 1\n        else:\n            # Initialize the count if the key is not present\n            count_dict[key] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple and use as a key in a dictionary to count occurrences\n    result = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            # Otherwise, add the tuple to the dictionary with a count of 1\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the results\n    result = {}\n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (as lists are not hashable and cannot be used as dictionary keys)\n        # and increment its count in the result dictionary\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the count of each sublist\n    sublist_count = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert sublist to tuple (since list cannot be a key in a dictionary)\n        tuple_sublist = tuple(sublist)\n        \n        # If tuple_sublist is already a key in the dictionary, increment its count\n        if tuple_sublist in sublist_count:\n            sublist_count[tuple_sublist] += 1\n        else:\n            # Otherwise, set its count to 1\n            sublist_count[tuple_sublist] = 1\n    \n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Dictionary to store the count of each sublist\n    sublist_count = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable\n        tuple_sublist = tuple(sublist)\n        # Update the count in the dictionary\n        if tuple_sublist in sublist_count:\n            sublist_count[tuple_sublist] += 1\n        else:\n            sublist_count[tuple_sublist] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    # Convert each sublist to a tuple and count occurrences\n    counts = {}\n    for sublist in input_list:\n        # Convert sublist to tuple to make it hashable\n        tup = tuple(sublist)\n        if tup in counts:\n            counts[tup] += 1\n        else:\n            counts[tup] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to hold the counts\n    counts = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are mutable and can't be dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already a key in the dictionary, increment its count\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            counts[tuple_sublist] = 1\n    \n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Dictionary to hold the counts of each tuple\n    count_dict = {}\n    # Convert each sublist into a tuple and count their occurrences\n    for sublist in lst:\n        # Convert sublist to tuple as list cannot be a key in dictionary\n        tup = tuple(sublist)\n        if tup in count_dict:\n            count_dict[tup] += 1\n        else:\n            count_dict[tup] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist to a tuple and use it as a key in a dictionary\n    # The value of the dictionary item will be the count of the tuple's occurrence\n    sublists_count = {}\n    for sublist in lst:\n        tuple_form = tuple(sublist)\n        if tuple_form in sublists_count:\n            sublists_count[tuple_form] += 1\n        else:\n            sublists_count[tuple_form] = 1\n    return sublists_count", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def unique_Element(nums):\n    # Convert list to set and check if length is 1\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Convert list to set to remove duplicates, if length is 1 then only one distinct element exists\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(arr):\n    # Using set to find unique elements\n    return len(set(arr)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert list to a set to remove duplicates and check if length is 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Convert the list to a set to remove duplicates and check if the length is 1\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if converting the list to a set results in a set of length 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, then there is only one distinct element\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Using a set to find distinct elements\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, it means there's only one distinct element\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if the set of numbers has only one unique element\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Convert the list to a set to remove duplicates and check if the length is 1\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Convert the list to a set to remove duplicates and check if the length is 1\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, all elements in the list are the same\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert list to set to remove duplicates and check its length\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates and check its length\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates, then check if length is 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, all elements in the list are identical\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Convert the list to a set to find unique elements\n    unique_elements = set(nums)\n    \n    # If there's only one unique element, return True, otherwise return False\n    return len(unique_elements) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert list to set to remove duplicates and check if length is 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert list to set to remove duplicates, then check if length is 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    # Initialize the count to 0\n    count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the count if it's a digit\n            count += 1\n    # Return the total count of digits in the string\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    # Iterate through the string\n    for char in s:\n        # Check if character is a digit\n        if char.isdigit():\n            digit_count += 1\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize counter to 0\n    count = 0\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize counter to 0\n    count = 0\n    # Loop through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter\n            count += 1\n    # Return the total count of digits\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize count to 0\n    count = 0\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the count\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    # Initialize counter to 0\n    digit_count = 0\n    \n    # Loop through each character in the string\n    for char in input_string:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    # Return the total count of digits\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize counter\n    count = 0\n    \n    # Iterate through the string and increment count if the character is a digit\n    for char in s:\n        if char.isdigit():\n            count += 1\n            \n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # If the character is a digit, increment the counter\n        if char.isdigit():\n            digit_count += 1\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize the count to zero\n    count = 0\n    \n    # Iterate through the string and increment count for digits\n    for char in s:\n        if char.isdigit():\n            count += 1\n            \n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize count to 0\n    count = 0\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if it's a digit\n            count += 1\n    \n    # Return the total count of digits in the string\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Loop through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the count for each digit found\n            count += 1\n    \n    # Return the total count of digits\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize count to 0\n    count = 0\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment count if the character is a digit\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize count to 0\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize counter to 0\n    digit_count = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the digit count\n            digit_count += 1\n            \n    # Return the total count of digits in the string\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter to 0\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if the character is a digit\n            count += 1\n            \n    # Return the final count of digits\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize counter to 0\n    count = 0\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter\n            count += 1\n    # Return the final count\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize counter to 0\n    count = 0\n    # Loop through each character in the string\n    for char in s:\n        # Check if character is a digit\n        if char.isdigit():\n            # Increment the counter if a digit is found\n            count += 1\n    # Return the final count\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize the count to 0\n    count = 0\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the count if it's a digit\n            count += 1\n    # Return the count of digits\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 73.78504672897196, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(input_list):\n    # Use list comprehension to generate the list of tuples containing pairs of consecutive items\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Use zip to pair consecutive items\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 4}, {"solution": "def pair_wise(lst):\n    # Use zip to pair each element with its successor\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    # Generate pairs of consecutive items using list comprehension\n    result = [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Create pairs of consecutive items in the list\n    pairs = [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]\n    return pairs", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    # Use zip to pair each element with the next one\n    # zip(input_list[:-1], input_list[1:]) pairs consecutive elements\n    return list(zip(input_list[:-1], input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    # Use zip to create pairs of consecutive items\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 4}, {"solution": "def pair_wise(lst):\n    # Generate pairs of consecutive items using zip\n    pairs = list(zip(lst[:-1], lst[1:]))\n    return pairs", "matching_cluster_idx": 4}, {"solution": "def pair_wise(lst):\n    # List comprehension to generate pairs of consecutive items\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Generate list of tuples for each pair of consecutive items\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Create a list to store the pairs\n    pairs = []\n    # Iterate through the list and pair each element with its successor\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i + 1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Generate pairs of consecutive items\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Generate pairs of consecutive items in the list\n    pairs = [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    return pairs", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Create a list to store pairs of consecutive items\n    result = []\n    # Iterate through the list, stopping before the last item\n    for i in range(len(lst) - 1):\n        # Append the pair of consecutive items to the result list\n        result.append((lst[i], lst[i + 1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Generate pairs of consecutive items in the list\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Create pairs of consecutive items in the list\n    pairs = [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Generate pairs of consecutive items\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Use list comprehension to generate pairs of consecutive items\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Create a list of pairs of consecutive items using list comprehension\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Create pairs of consecutive items\n    pairs = [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]\n    return pairs", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 91.52, "dps_norm": 68.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(lst):\n    # Check each odd index in the list\n    for i in range(1, len(lst), 2):\n        # If the number is not odd, return False\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Loop through the list starting from index 1, stepping by 2 to cover all odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at the current odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate through the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at the odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate through the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at the current odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate through the list checking every odd index\n    for i in range(1, len(lst), 2):\n        # If the number at the odd index is not odd, return False\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list, starting from the first odd index (1) and stepping by 2\n    for i in range(1, len(lst), 2):\n        # If the number at the odd index is not odd, return False\n        if lst[i] % 2 == 0:\n            return False\n    # If all odd indexes contain odd numbers, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Check if every odd index contains an odd number\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate through the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at the odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list starting from the first odd index (1) with a step of 2\n    for i in range(1, len(lst), 2):\n        # Check if the current element is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate through the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list, starting from index 1 (the second element) and stepping by 2\n    for i in range(1, len(lst), 2):\n        # Check if the number at the current odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Loop through the list starting from index 1 with a step of 2 to check all odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at the odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate through the list, starting at index 1, using a step of 2 to cover odd indices only\n    for i in range(1, len(lst), 2):\n        # If the element at an odd index is not odd, return False\n        if lst[i] % 2 == 0:\n            return False\n    # If the loop completes without returning False, all odd indices contained odd numbers\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate through the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list, starting from the first odd index (1) and stepping by 2 for each subsequent odd index\n    for i in range(1, len(lst), 2):\n        # Check if the current element at an odd index is not odd\n        if lst[i] % 2 == 0:\n            # Return False if any odd index does not contain an odd number\n            return False\n    # If all odd indices contain odd numbers, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list checking only the odd indices\n    for i in range(1, len(lst), 2):\n        # If the number at the odd index is not odd, return False\n        if lst[i] % 2 == 0:\n            return False\n    # If the loop completes without returning False, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Loop through the list to check each odd index\n    for i in range(1, len(lst), 2):\n        # If the number at the odd index is not odd, return False\n        if lst[i] % 2 == 0:\n            return False\n    # If all numbers at odd indices are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate through the list starting from index 1 and step by 2 for odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the number at the current odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list with index\n    for index in range(len(lst)):\n        # Check if the index is odd\n        if index % 2 != 0:\n            # Check if the element at the odd index is not odd\n            if lst[index] % 2 == 0:\n                return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    # Iterate through the list with index\n    for i in range(len(lst)):\n        # Check if the current index is odd and the number at that index is not odd\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}]}, "Mbpp/777": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 10.0, "profiled": [{"solution": "def find_sum(arr):\n    # Convert the list to a set to remove duplicates and then sum the elements\n    return sum(set(arr))", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    # Convert the list to a set to remove duplicates\n    non_repeated_set = set(arr)\n    # Calculate the sum of the non-repeated elements\n    return sum(non_repeated_set)", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    # Convert the list to a set to remove duplicates and then sum the non-repeated elements\n    unique_elements = set(arr)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    # Convert the list to a set to remove duplicates and then sum the unique elements\n    return sum(set(arr))", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    # Convert list to set to remove duplicates and sum the elements\n    unique_elements = set(arr)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    # Convert the list to a set to remove duplicates, then sum the unique elements\n    return sum(set(arr))", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    # Convert list to set to remove duplicates and then sum\n    unique_elements = set(arr)\n    total_sum = sum(unique_elements)\n    return total_sum", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    # Convert list to a set to remove duplicates\n    non_repeated_set = set(arr)\n    # Calculate the sum of non-repeated elements\n    total_sum = sum(non_repeated_set)\n    return total_sum", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    # Convert list to a set to remove duplicates and then sum all elements\n    return sum(set(arr))", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    # Convert the list to a set to remove duplicates\n    # Then calculate the sum of the unique elements\n    return sum(set(arr))", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 41.496062992125985, "dps_norm": 29.0, "pass@1": 100.0, "profiled": [{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    # Initialize a counter for divisors\n    count = 0\n    \n    # Loop through possible divisors from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            count += 1\n    \n    # Return True if the count of divisors is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize count of divisors\n    count = 0\n    \n    # Loop from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    # Return True if count of divisors is even, else False\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    # Initialize the count of divisors to 0\n    count = 0\n    # Loop from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize the count of divisors\n    count = 0\n    # Loop through all possible divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize divisor count\n    count = 0\n    # Loop through all numbers from 1 to n (inclusive) to count divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize count of divisors\n    count = 0\n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment count\n        if n % i == 0:\n            count += 1\n    # Check if count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    # Iterate over possible divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}]}, "Mbpp/800": {"dps": 80.0, "dps_norm": 88.0, "pass@1": 67.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Replace spaces with no space using the translate method\n    result_string = input_string.replace(\" \", \"\")\n    return result_string", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    # Remove all whitespaces from the string\n    return input_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Replace whitespaces with no space using str.replace()\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Replace spaces using the str.replace() method\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    # Replace spaces with no space using the string replace method\n    no_space_string = input_string.replace(\" \", \"\")\n    return no_space_string", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Replace all whitespace characters with no space\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    # Replace spaces with no space (effectively removing them)\n    no_spaces = input_string.replace(\" \", \"\")\n    return no_spaces", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    # Removing spaces from the input string\n    no_space_string = input_string.replace(' ', '')\n    return no_space_string", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_str):\n    # Removing all whitespaces using replace\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces from the string\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Using join and list comprehension to remove spaces\n    return ''.join([char for char in input_string if char != ' '])", "matching_cluster_idx": 0}, {"solution": "def remove_all_spaces(s):\n    # Removing all whitespaces from the string\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces using str.replace\n    no_space_string = input_string.replace(\" \", \"\")\n    return no_space_string", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces from the string\n    result_string = input_string.replace(\" \", \"\")\n    return result_string", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all spaces from the string using replace function\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all spaces using translate and str.maketrans\n    no_spaces = input_string.translate(str.maketrans('', '', ' '))\n    return no_spaces", "matching_cluster_idx": 3}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(lists):\n    # Initialize max_sum and max_list to keep track of the list with the highest sum\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # If the current sum is greater than max_sum, update max_sum and max_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum\n    max_sum_list = max(lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_sum = max(lists, key=sum)\n    return max_sum", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum\n    max_sum = max(lists, key=sum)\n    return max_sum", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of its elements\n    max_sum = max(lists, key=sum)\n    return max_sum", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_list = max(lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize the maximum sum and the list with the maximum sum\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate over each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update the maximum sum and the list with the maximum sum if needed\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n            \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum\n    max_sum_list = max(lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize the maximum sum and the list with the maximum sum\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for sublist in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(sublist)\n        # If the sum of the current list is greater than the max_sum, update max_sum and max_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_sum = max(lists, key=sum)\n    return max_sum", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize max_sum and max_list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if current_sum is greater than max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    # Return the list with the highest sum\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Find the list with the maximum sum\n    max_sum_list = max(list_of_lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Calculate the sum of each list and pair it with the original list\n    paired_lists = [(sum(lst), lst) for lst in lists]\n    # Find the pair with the maximum sum, and return the corresponding list\n    return max(paired_lists, key=lambda x: x[0])[1]", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Find the list with the maximum sum of elements\n    max_sum_list = max(list_of_lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize maximum sum and the list with the maximum sum\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the input lists\n    for sublist in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(sublist)\n        # Update maximum sum and list if current list's sum is greater than max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum\n    max_sum = max(lists, key=sum)\n    return max_sum", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize max_sum to a very low number\n    max_sum = float('-inf')\n    # Initialize the list that has the maximum sum to None\n    max_list = None\n    \n    # Iterate over each list in the lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # If the current_sum is greater than max_sum, update max_sum and max_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n            \n    # Return the list with the maximum sum\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize max_sum and max_list to store the highest sum and corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of elements of the current list\n        current_sum = sum(lst)\n        # Update max_sum and max_list if the current list's sum is greater than max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n            \n    # Return the list with the highest sum\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Find the list with the maximum sum\n    max_sum_list = max(list_of_lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 44.56140350877193, "dps_norm": 86.66666666666666, "pass@1": 99.0, "profiled": [{"solution": "def check_K(test_tup, K):\n    \"\"\"\n    This function checks if the given tuple contains the specified element K.\n\n    :param test_tup: Tuple in which to check the presence of K\n    :param K: Element to check in the tuple\n    :return: True if K is in test_tup, False otherwise\n    \"\"\"\n    # Checking if K is present in the tuple and returning the result\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    # Checking if K is present in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    This function checks if the given tuple contains the specified element k.\n    \n    :param test_tup: Tuple to be checked.\n    :param k: Element to look for in the tuple.\n    :return: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    # Check if k is in the tuple\n    return k in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple test_tup\n    return K in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    \"\"\"\n    Check if the given tuple contains the element K.\n\n    Parameters:\n    test_tup (tuple): The tuple to check.\n    K (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if K is found in the tuple, False otherwise.\n    \"\"\"\n    # Check if K is in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    This function checks if the given tuple contains the specified value k.\n    \n    :param test_tup: Tuple to be checked\n    :param k: The value to look for in the tuple\n    :return: True if k is found in test_tup, False otherwise\n    \"\"\"\n    # Check if k is in the tuple\n    return k in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, k):\n    # Check if k is present in the tuple test_tup\n    return k in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    \"\"\"\n    This function checks if the given tuple contains the specified element K.\n\n    :param test_tup: The tuple to be checked\n    :param K: The element to search for within the tuple\n    :return: True if K is found in the tuple, False otherwise\n    \"\"\"\n    # Checking if K is in the given tuple\n    return K in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple test_tup\n    return K in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    Function to check if the tuple contains the specified value k.\n    \n    Parameters:\n    test_tup (tuple): The tuple to check.\n    k (any): The value to look for in the tuple.\n    \n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    Check if the given tuple contains the specified value k.\n    \n    Parameters:\n    test_tup (tuple): The tuple to be checked.\n    k (any): The value to check for in the tuple.\n    \n    Returns:\n    bool: True if k is found in test_tup, False otherwise.\n    \"\"\"\n    # Checking if k is in the tuple\n    return k in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, k):\n    # Check if k is present in the tuple test_tup\n    return k in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    \"\"\"\n    Check if the tuple contains the given element K.\n\n    Parameters:\n    test_tup (tuple): The tuple to search within.\n    K (int): The element to search for in the tuple.\n\n    Returns:\n    bool: True if K is in test_tup, False otherwise.\n    \"\"\"\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the specified element 'k'.\n\n    :param test_tup: The tuple to be checked.\n    :param k: The element to search for in the tuple.\n    :return: True if 'k' is found in the tuple, False otherwise.\n    \"\"\"\n    # Check if k is in the tuple\n    return k in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple test_tup\n    return K in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    This function checks if the given tuple contains the specified value k.\n\n    :param test_tup: The input tuple to be checked.\n    :param k: The value to check for in the tuple.\n    :return: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    # Check if k is in the tuple\n    res = k in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    Check if the tuple test_tup contains the element k.\n    \n    Parameters:\n    test_tup (tuple): The tuple to check.\n    k (int): The element to look for in the tuple.\n    \n    Returns:\n    bool: True if k is found in test_tup, False otherwise.\n    \"\"\"\n    # Check if k is in the tuple test_tup\n    return k in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    \"\"\"\n    Check if K is present in the given tuple.\n\n    :param test_tup: Tuple to be checked.\n    :param K: Element to search for within the tuple.\n    :return: True if K is present in the tuple, False otherwise.\n    \"\"\"\n    # Checking if K is in the tuple\n    return K in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    This function checks if the provided tuple contains the specified element k.\n    \n    :param test_tup: Tuple to be searched\n    :param k: Element to search for in the tuple\n    :return: True if k is found in the tuple, False otherwise\n    \"\"\"\n    # Checking if k is in the tuple\n    return k in test_tup", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple\n    return K in test_tup", "matching_cluster_idx": 4}]}}}
