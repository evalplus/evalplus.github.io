{"date": "2024-10-24 15:52", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 78.40270067725943, "dps_norm": 76.22281062678165, "pass@1": 61.83050847457627}, "eval": {"HumanEval/9": {"dps": 98.15457413249212, "dps_norm": 97.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element at index `i` is the maximum of all elements up to index `i` in the input list.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Edge case: empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate through the list starting from the second element\n        if num > current_max:\n            current_max = num\n        rolling_maximums.append(current_max)\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Edge case: empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate through the rest of the list\n        if num > current_max:  # Found a new maximum\n            current_max = num\n        rolling_maximums.append(current_max)  # Add current max to the result list\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n    \"\"\"\n    if not numbers:  # Edge case: empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate over the rest of the list\n        if num > current_max:\n            current_max = num\n        rolling_maximums.append(current_max)\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Edge case: Empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate over the rest of the list\n        if num > current_max:  # Update current max if a larger number is found\n            current_max = num\n        rolling_maximums.append(current_max)  # Append current max to the result list\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\nimport unittest\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list of rolling maximum elements.\n    \"\"\"\n    if not numbers:  # Edge case: Empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        rolling_maximums.append(current_max)\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element is the maximum from the start of the input list to its corresponding index.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Handle the case when the input list is empty\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        rolling_maximums.append(current_max)\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n    \"\"\"\n    if not numbers:  # Edge case: empty list\n        return []\n\n    rolling_maxima = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate through the rest of the list\n        if num > current_max:  # If a new maximum is found\n            current_max = num\n        rolling_maxima.append(current_max)  # Append the current max to the result\n\n    return rolling_maxima", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Generates a list of rolling maximum elements found until the given moment in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element is the maximum of all elements up to that point in the input list.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Handle empty list\n        return []\n\n    rolling_max_list = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate over the rest of the list\n        if num > current_max:  # Update current max if a larger number is found\n            current_max = num\n        rolling_max_list.append(current_max)  # Append the current max to the result list\n\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element at index `i` is the maximum of all elements up to `i` in the input list.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Handle empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate through the rest of the list\n        if num > current_max:  # Update max if a larger number is found\n            current_max = num\n        rolling_maximums.append(current_max)  # Append current max to result\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n    \"\"\"\n    if not numbers:  # Edge case: Empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate through the list starting from the second element\n        if num > current_max:\n            current_max = num\n        rolling_maximums.append(current_max)\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element at index `i` is the maximum value from the original list up to index `i`.\n    \"\"\"\n    if not numbers:  # Edge case: Empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element as the first max\n    current_max = numbers[0]\n\n    # Iterate through the list starting from the second element\n    for num in numbers[1:]:\n        if num > current_max:  # If a new number is greater than current max, update max\n            current_max = num\n        rolling_maximums.append(current_max)  # Add current max to the result list\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        A list of integers representing the rolling maximum at each position.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Edge case: empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate over the rest of the list\n        if num > current_max:\n            current_max = num\n        rolling_maximums.append(current_max)\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n    \"\"\"\n    if not numbers:  # Handle empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    # Iterate through the list starting from the second element\n    for num in numbers[1:]:\n        if num > current_max:  # Update current_max if a larger number is found\n            current_max = num\n        rolling_maximums.append(current_max)  # Append the current max to the result list\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element at index `i` represents the maximum value from the start\n            of the input list up to and including index `i`.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Edge case: empty list\n        return []\n\n    rolling_max_list = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate from the second element to the end\n        if num > current_max:  # Update current_max if a larger number is found\n            current_max = num\n        rolling_max_list.append(current_max)  # Append current max to the result list\n\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n    \"\"\"\n    if not numbers:  # Edge case: Empty list\n        return []\n\n    rolling_maxima = []  # Initialize list to store rolling maxima\n    current_max = numbers[0]  # Initialize current max with the first element\n\n    # Iterate over the input list\n    for num in numbers:\n        # Update current max if a larger number is encountered\n        current_max = max(current_max, num)\n        # Append the current max to the result list\n        rolling_maxima.append(current_max)\n\n    return rolling_maxima", "matching_cluster_idx": 4}, {"solution": "from typing import List\nimport unittest\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n    \"\"\"\n    if not numbers:  # Check if the input list is empty\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate through the list starting from the second element\n        if num > current_max:\n            current_max = num\n        rolling_maximums.append(current_max)\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n    \"\"\"\n    if not numbers:  # Edge case: empty list\n        return []\n\n    rolling_max_values = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate over the rest of the list\n        if num > current_max:\n            current_max = num\n        rolling_max_values.append(current_max)\n\n    return rolling_max_values", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Handle the edge case of an empty list\n        return []\n\n    rolling_maximums = [numbers[0]]  # Initialize with the first element as the max so far\n    current_max = numbers[0]  # Keep track of the current maximum\n\n    # Iterate through the list starting from the second element (index 1)\n    for num in numbers[1:]:\n        if num > current_max:  # If a new number is greater than the current max\n            current_max = num  # Update the current max\n        rolling_maximums.append(current_max)  # Append the current max to the result list\n\n    return rolling_maximums", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list of rolling maximum elements.\n\n    Example:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Edge case: empty list\n        return []\n\n    rolling_maxima = []  # Initialize list to store rolling maxima\n    current_max = numbers[0]  # Initialize current max with the first element\n\n    # Add the first element as the initial maximum\n    rolling_maxima.append(current_max)\n\n    # Iterate through the list starting from the second element\n    for num in numbers[1:]:\n        if num > current_max:  # Update current max if a larger number is found\n            current_max = num\n        # Append the current max to the result list in each iteration\n        rolling_maxima.append(current_max)\n\n    return rolling_maxima", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list where each element at index `i` is the maximum of all elements up to `i` in the input list.\n\n    Examples:\n        >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n        [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Edge case: empty list\n        return []\n\n    rolling_max_list = [numbers[0]]  # Initialize with the first element\n    current_max = numbers[0]\n\n    for num in numbers[1:]:  # Iterate over the rest of the list\n        if num > current_max:\n            current_max = num\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 52.325581395348834, "dps_norm": 57.142857142857146, "pass@1": 15.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Iterate over the sorted list, comparing each number with its next neighbor\n    for i in range(len(numbers) - 1):\n        # If the difference between the current number and the next one is less than the threshold, return True\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If the function hasn't returned True after checking all pairs, no close elements were found, so return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n        threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Initialize the minimum difference as infinity\n    min_diff = float('inf')\n\n    # Iterate through the sorted list to find the minimum difference between any two adjacent numbers\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]  # Calculate the difference between the current and previous number\n        if diff < min_diff:  # Update the minimum difference if a smaller one is found\n            min_diff = diff\n            if min_diff < threshold:  # If the minimum difference is less than the threshold, return True immediately\n                return True\n\n    # If the loop completes without finding a difference less than the threshold, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in a given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n    - numbers (List[float]): A list of floating-point numbers.\n    - threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n    - bool: True if at least two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    # First, sort the list in ascending order to easily compare adjacent elements\n    numbers.sort()\n\n    # Iterate over the sorted list, comparing each element with its next one\n    for i in range(len(numbers) - 1):\n        # If the difference between two adjacent elements is less than the threshold, return True\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If the loop completes without finding close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n    - numbers (List[float]): A list of floating point numbers.\n    - threshold (float): The minimum distance required between two numbers.\n\n    Returns:\n    - bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Iterate over the sorted list, comparing each number with its next one\n    for i in range(len(numbers) - 1):\n        # If the difference between two consecutive numbers is less than the threshold, return True\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If the loop completes without finding close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, are any two numbers closer to each other than the given threshold.\n\n    Args:\n    - numbers (List[float]): A list of floating-point numbers.\n    - threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n    - bool: True if at least two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Iterate over the sorted list of numbers (excluding the last one)\n    for i in range(len(numbers) - 1):\n        # Check if the difference between the current number and the next one is less than the threshold\n        if numbers[i + 1] - numbers[i] < threshold:\n            # If the condition is met, return True immediately\n            return True\n\n    # If the loop completes without finding close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than \n    given threshold.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers.\n    threshold (float): The minimum difference for two numbers to be considered close.\n\n    Returns:\n    bool: True if any two numbers in the list have a difference less than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list in ascending order to efficiently check for close elements\n    numbers.sort()\n\n    # Iterate through the sorted list (excluding the last element) to compare with the next element\n    for i in range(len(numbers) - 1):\n        # Calculate the absolute difference between the current element and the next one\n        difference = abs(numbers[i] - numbers[i + 1])\n        \n        # If the difference is less than the threshold, immediately return True\n        if difference < threshold:\n            return True\n\n    # If the loop completes without finding close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in a given list of numbers, any two numbers are closer to each other than a given threshold.\n\n    Args:\n    - numbers (List[float]): A list of floating-point numbers.\n    - threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n    - bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Iterate through the sorted list to compare adjacent elements\n    for i in range(1, len(numbers)):\n        # If the difference between the current number and the previous one is less than the threshold, return True\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n\n    # If the function hasn't returned True after checking all pairs, no two numbers are closer than the threshold\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Iterate through the sorted list to check the distance between adjacent numbers\n    for i in range(1, len(numbers)):\n        # If the difference between the current number and the previous one is less than the threshold, return True\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n\n    # If the loop completes without finding any close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n        threshold (float): The minimum distance required between two numbers.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Iterate over the sorted list to find if the difference between any two adjacent numbers is less than the threshold\n    for i in range(1, len(numbers)):\n        # If the difference between the current number and the previous one is less than the threshold, return True\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n\n    # If the loop completes without finding any close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Checks if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n        threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n    \n    # Iterate through the sorted list with an index to compare each element with its next one\n    for i in range(len(numbers) - 1):\n        # If the difference between the current number and the next one is less than the threshold, return True\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    \n    # If the loop completes without finding any close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Checks if in a given list of numbers, any two numbers are closer to each other than a given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n        threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n    \n    # Iterate over the sorted list of numbers (excluding the last one)\n    for i in range(len(numbers) - 1):\n        # Check if the difference between the current number and the next one is less than the threshold\n        if numbers[i + 1] - numbers[i] < threshold:\n            # If so, return True as we found two numbers closer than the threshold\n            return True\n    \n    # If the loop completes without finding any close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n        threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n        bool: True if at least two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Iterate through the sorted list to find any adjacent numbers closer than the threshold\n    for i in range(len(numbers) - 1):\n        # Calculate the absolute difference between the current number and the next one\n        difference = abs(numbers[i] - numbers[i + 1])\n        # If the difference is less than the threshold, return True immediately\n        if difference < threshold:\n            return True\n\n    # If the function hasn't returned True after checking all pairs, no close elements were found\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n        threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Iterate over the sorted list to check the distance between adjacent numbers\n    for i in range(1, len(numbers)):\n        # If the difference between the current number and the previous one is less than the threshold, return True\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n\n    # If the loop completes without finding any close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        threshold (float): The maximum allowed distance between two numbers to be considered \"close\".\n\n    Returns:\n        bool: True if at least two numbers in the list are closer than the threshold, False otherwise.\n    \"\"\"\n\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Initialize a variable to keep track of the previous number in the sorted list\n    previous_number = None\n\n    # Iterate over the sorted list of numbers\n    for current_number in numbers:\n        # If this is not the first number in the list (i.e., previous_number is not None)\n        if previous_number is not None:\n            # Check if the difference between the current number and the previous one is less than the threshold\n            if current_number - previous_number < threshold:\n                # If it is, return True immediately because we found two numbers closer than the threshold\n                return True\n        # Update the previous number for the next iteration\n        previous_number = current_number\n\n    # If the loop completes without finding any close elements, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n        threshold (float): The minimum distance required between any two numbers.\n\n    Returns:\n        bool: True if at least two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # First, sort the list of numbers in ascending order\n    numbers.sort()\n\n    # Iterate through the sorted list to find any adjacent numbers with a difference less than the threshold\n    for i in range(len(numbers) - 1):\n        # Calculate the absolute difference between the current number and the next one\n        difference = abs(numbers[i] - numbers[i + 1])\n        \n        # If the difference is less than the threshold, return True\n        if difference < threshold:\n            return True\n\n    # If the loop completes without finding any close elements, return False\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 7.468354430379747, "dps_norm": 30.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n\n    # Check if the input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute differences from the mean\n    absolute_deviations = [abs(num - mean) for num in numbers]\n\n    # Calculate the mean of these absolute deviations\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n    float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    \n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Calculate the mean of the input numbers\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    \n    # Calculate the mean of these absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input numbers.\n    \"\"\"\n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Calculate the mean of the input numbers\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of floating point numbers.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    # Calculate the mean of the input list\n    mean = statistics.mean(numbers)\n    \n    # Calculate absolute deviations from the mean and sum them up\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of floating point numbers.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    # Calculate the mean of the input list\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate the absolute deviations from the mean for each number\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    \n    # Calculate the mean of these absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Deviation (MAD) of a given list of numbers.\n    \n    The Mean Absolute Deviation is the average absolute difference between each element\n    and the mean of the dataset:\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \n    Example:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Calculate the mean of the input numbers\n    mean = statistics.mean(numbers)\n    \n    # Calculate the absolute deviation for each number from the mean\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate the mean of these absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate Mean Absolute Deviation (MAD) around the mean of a given dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and the dataset's mean:\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input dataset.\n\n    Example:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n\n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviation of each number from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate the Mean Absolute Deviation\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input dataset.\n    \n    Example:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Calculate the mean of the input dataset\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate absolute deviations from the mean\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations (MAD)\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers (List[float]): A list of floating point numbers.\n    \n    Returns:\n    float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    # Calculate the mean of the input list\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate absolute deviations from the mean\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculates Mean Absolute Deviation around the mean of a given dataset.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input dataset.\n    \"\"\"\n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Calculate the mean of the input numbers\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations (MAD)\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n    float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    \n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Calculate the mean of the input numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviation of each number from the mean\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate the mean of these absolute deviations\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculates the Mean Absolute Deviation (MAD) around the mean of a given dataset.\n    \n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of floating point numbers.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input dataset.\n    \n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n\n    # Check if the input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Calculate the mean of the dataset\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate absolute deviations from the mean\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    \n    # Calculate the mean of the absolute deviations (MAD)\n    mad_value = statistics.mean(absolute_deviations)\n    \n    return mad_value", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input numbers.\n\n    Example:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Calculate the mean of the numbers\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate the absolute deviation from the mean for each number\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    \n    # Calculate the mean of these absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate Mean Absolute Deviation around the mean of a dataset.\n    \n    Mean Absolute Deviation (MAD) is the average absolute difference \n    between each element and the centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \n    Example:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    # Check for empty list to avoid statistic.calculate_mean error\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Calculate the mean of the input list\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate absolute differences from the mean\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    \n    # Calculate the mean of these absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n\n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Calculate the mean of the input numbers\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate absolute differences from the mean\n    absolute_deviations = [abs(num - mean) for num in numbers]\n\n    # Calculate the Mean Absolute Deviation\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n    numbers (List[float]): A list of floating point numbers.\n    \n    Returns:\n    float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    \n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Calculate the mean of the input list\n    mean = statistics.mean(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of floating point numbers.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Calculate the mean of the input numbers\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    \n    # Calculate the mean of these absolute deviations\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input numbers.\n    \"\"\"\n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Calculate the mean of the input numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate the Mean Absolute Deviation\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n    \"\"\"\n    # Check if input list is empty\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Calculate the mean of the input numbers\n    mean_value = statistics.mean(numbers)\n    \n    # Calculate the absolute deviation for each number from the mean\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    \n    # Calculate the Mean Absolute Deviation\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the input list.\n\n    Examples:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n    \"\"\"\n    if not numbers:  # Check for empty list\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Calculate the mean of the input numbers\n    mean = statistics.mean(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    \n    # Calculate the Mean Absolute Deviation\n    mad = statistics.mean(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 0}]}, "HumanEval/16": {"dps": 45.73643410852713, "dps_norm": 88.88888888888889, "pass@1": 89.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    Args:\n        string (str): The input string\n\n    Returns:\n        int: Number of distinct characters in the string (case-insensitive)\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Convert the string into a set, which automatically removes duplicates\n    distinct_chars = set(lower_case_string)\n    \n    # Return the number of elements in the set, which represents distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n    string (str): The input string to count distinct characters in.\n\n    Returns:\n    int: The number of distinct characters in the string.\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    lower_string = string.lower()\n    \n    # Use a set to automatically eliminate duplicate characters\n    distinct_chars = set(lower_string)\n    \n    # The number of distinct characters is the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to analyze.\n\n    Returns:\n        int: The number of distinct characters in the string (case-insensitive).\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        5  # Note: Corrected expected output since 'J', 'e', 'r', 'r', 'y' are distinct as 'r' appears twice but still counts as one distinct character\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Use a set to store unique characters; sets automatically eliminate duplicates\n    distinct_chars = set(lower_case_string)\n    \n    # Return the number of distinct characters, which is the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to analyze.\n\n    Returns:\n        int: The number of distinct characters in the string, case-insensitive.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to a set, which automatically removes duplicates\n    # Use casefold() to make the comparison case-insensitive\n    distinct_chars = set(string.casefold())\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to check.\n\n    Returns:\n        int: The number of distinct characters in the string, regardless of case.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Use a set to store unique characters. Sets automatically eliminate duplicates.\n    distinct_characters = set(lower_case_string)\n    \n    # Return the number of distinct characters, which is the size of the set\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): Input string to check.\n\n    Returns:\n        int: Number of distinct characters in the string, ignoring case.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to a set, which automatically removes duplicates\n    # Use casefold() to make the comparison case-insensitive\n    distinct_chars = set(string.casefold())\n    \n    # Return the number of distinct characters, which is the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    :param string: Input string to check for distinct characters\n    :return: Number of distinct characters in the string (case-insensitive)\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Convert the string into a set, which automatically removes duplicates\n    distinct_chars_set = set(lower_case_string)\n    \n    # The number of elements in the set is the number of distinct characters\n    return len(distinct_chars_set)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: Number of distinct characters in the string.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        5\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    string_lower = string.lower()\n    \n    # Use a set to store unique characters, since sets in Python only store distinct elements\n    distinct_chars = set(string_lower)\n    \n    # Return the number of distinct characters, which is the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to analyze.\n\n    Returns:\n        int: The number of distinct characters in the string, ignoring case.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        5\n    \"\"\"\n    # Convert the string to a set, which automatically removes duplicates\n    # and convert to lower case to ignore case sensitivity\n    distinct_chars = set(string.lower())\n    \n    # Since sets in Python cannot contain duplicate values, the length of the set\n    # will give us the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to analyze.\n\n    Returns:\n        int: The number of distinct characters in the string, case-insensitive.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to a set, which automatically removes duplicates.\n    # Since we're case-insensitive, convert the string to lower case first.\n    distinct_chars = set(string.lower())\n    \n    # The length of the set is the number of distinct characters.\n    # Subtract 1 if the set contains an empty string (in case input string has spaces or is empty)\n    count = len(distinct_chars) - (1 if '' in distinct_chars else 0)\n    \n    return max(count, 0)  # Return at least 0, even if string only contains spaces or is empty", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Counts the number of distinct characters in a given string, ignoring case sensitivity.\n    \n    Args:\n        string (str): The input string to analyze.\n    \n    Returns:\n        int: The number of distinct characters in the string.\n    \"\"\"\n    # Convert the string to a set, which automatically removes duplicates. \n    # Use case folding to ignore case sensitivity.\n    distinct_chars = set(string.casefold())\n    \n    # Subtract 1 from the length if the string contained whitespace or other non-alphabetic characters \n    # you might want to exclude, based on your interpretation of 'characters'. \n    # For this solution, all unique characters are counted.\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Counts the number of distinct characters in a string, ignoring case.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The number of distinct characters in the string.\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Use a set to store unique characters; sets automatically eliminate duplicates\n    distinct_chars = set(lower_case_string)\n    \n    # The number of distinct characters is the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to analyze.\n\n    Returns:\n        int: The number of distinct characters in the string, ignoring case.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        5\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Use a set to store unique characters, as sets automatically eliminate duplicates\n    unique_characters = set(lower_case_string)\n    \n    # Return the number of unique characters, which is the size of the set\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n    string (str): The input string to count distinct characters from.\n\n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    5\n    \"\"\"\n\n    # Convert the string to lower case to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Convert the string into a set, which automatically removes duplicates\n    distinct_chars_set = set(lower_case_string)\n    \n    # Count the number of elements in the set, which represents distinct characters\n    count = len(distinct_chars_set)\n    \n    return count", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n    string (str): The input string to analyze.\n\n    Returns:\n    int: The number of distinct characters in the string, case-insensitive.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    5  # Corrected example output to reflect actual distinct characters\n    \"\"\"\n\n    # Convert the string to a set, which automatically removes duplicates. \n    # Convert to lower case to ensure the comparison is case-insensitive.\n    distinct_chars = set(string.lower())\n    \n    # The number of distinct characters is the size of the set.\n    # Subtract 1 if the string contains a space (assuming space is not a character of interest), if needed.\n    # For this solution, spaces are considered characters.\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: Number of distinct characters in the string (case-insensitive).\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Convert the string into a set, which automatically removes duplicates\n    distinct_chars = set(lower_case_string)\n    \n    # Count the number of distinct characters\n    count = len(distinct_chars)\n    \n    return count", "matching_cluster_idx": 7}, {"solution": "import unittest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Counts the number of distinct characters in a string, ignoring case sensitivity.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The number of distinct characters in the string.\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Use a set to store unique characters (sets automatically eliminate duplicates)\n    distinct_chars = set(lower_case_string)\n    \n    # Return the number of distinct characters, which is the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: Number of distinct characters in the string, regardless of case.\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    lower_case_string = string.lower()\n    \n    # Use a set to store unique characters, as sets automatically eliminate duplicates\n    distinct_chars = set(lower_case_string)\n    \n    # Return the number of distinct characters, which is the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "import unittest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: The number of distinct characters in the string (case-insensitive).\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to a set, which automatically removes duplicates.\n    # Use casefold() to make the operation case-insensitive.\n    distinct_chars = set(string.casefold())\n    \n    # Subtract 1 from the length if the string originally contained a space to ignore it, if that's a requirement.\n    # For this solution, we're counting all distinct characters including spaces as per the unit tests provided.\n    # If spaces should be ignored, uncomment the line below.\n    # if ' ' in distinct_chars: distinct_chars.remove(' ')\n    \n    # Return the number of distinct characters, which is the size of the set.\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "import unittest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string.\n\n    Returns:\n        int: Number of distinct characters in the string (case-insensitive).\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to a set, which automatically removes duplicates.\n    # Convert to lower case to ensure the count is case-insensitive.\n    distinct_chars = set(string.lower())\n    \n    # Subtract 1 from the length if the string contained whitespace or other non-alphabetic characters\n    # you might want to ignore. For this solution, we stick strictly to the problem's implied scope.\n    # Return the number of distinct characters.\n    return len(distinct_chars)", "matching_cluster_idx": 7}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    :param numbers: A list of floating point numbers (at least two elements)\n    :return: A tuple of two numbers that are closest to each other in ascending order\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two numbers\")\n\n    # Sort the list in ascending order\n    numbers.sort()\n\n    # Initialize minimum difference and the pair of numbers with the minimum difference\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    :param numbers: A list of floats (length of at least 2)\n    :return: A tuple of two floats, the closest to each other in ascending order\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of numbers with the minimum difference\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Args:\n    numbers: A list of floating point numbers (length of at least two).\n    \n    Returns:\n    A tuple of two floats, the closest pair of numbers in ascending order.\n    \"\"\"\n    \n    # Check if the list contains at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n    \n    # Sort the list in ascending order\n    numbers.sort()\n    \n    # Initialize minimum difference and the pair of numbers with the minimum difference\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers with at least two elements.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n\n    # Check if the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of closest numbers with the first two elements\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate over the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating point numbers with a length of at least two.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n    \n    # First, we sort the list in ascending order to easily find adjacent numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the pair of closest numbers with the first two elements\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list starting from the second element\n    for i in range(1, len(sorted_numbers) - 1):\n        # Calculate the difference between the current element and the next one\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        \n        # If the current difference is smaller than the min_diff found so far, update min_diff and the closest_pair\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers: A list of floating point numbers with a length of at least two.\n\n    Returns:\n        A tuple of two floats representing the closest numbers in the list, in ascending order.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two numbers\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of closest numbers with the first two elements\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating point numbers with a length of at least two.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n\n    # First, sort the list in ascending order\n    numbers.sort()\n\n    # Initialize minimum difference and the pair of numbers with the minimum difference\n    # Assuming the first two elements as the initial closest pair\n    min_diff = numbers[1] - numbers[0]\n    closest_pair = (numbers[0], numbers[1])\n\n    # Iterate through the sorted list starting from the second element\n    for i in range(1, len(numbers) - 1):\n        # Calculate the difference between the current element and the next one\n        diff = numbers[i + 1] - numbers[i]\n        \n        # If the current difference is smaller than the min_diff found so far, update min_diff and the closest_pair\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers: A list of floats with a length of at least two.\n\n    Returns:\n        A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements.\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of closest elements with the first two elements\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each \n    other and return them in order (smaller number, larger number).\n    \n    Args:\n    numbers (List[float]): A list of floating point numbers with a length of at least two.\n    \n    Returns:\n    Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n\n    # First, sort the list in ascending order\n    numbers.sort()\n\n    # Initialize minimum difference and the pair of closest elements with the first two elements\n    min_diff = numbers[1] - numbers[0]\n    closest_pair = (numbers[0], numbers[1])\n\n    # Iterate through the sorted list starting from the second element\n    for i in range(1, len(numbers) - 1):\n        # Calculate the difference between the current element and the next one\n        diff = numbers[i + 1] - numbers[i]\n        \n        # If the current difference is smaller than the min_diff found so far, update min_diff and the closest_pair\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers (length >= 2).\n\n    Returns:\n        Tuple[float, float]: A tuple of two numbers closest to each other, in ascending order.\n    \"\"\"\n\n    # Check if the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n\n    # Initialize minimum difference and the pair of closest numbers\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()\n\n    # Iterate over the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers with a length of at least two.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n\n    # Check if the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two numbers\")\n\n    # Sort the list in ascending order\n    numbers.sort()\n\n    # Initialize minimum difference and the pair of closest numbers with the first two elements\n    min_diff = numbers[1] - numbers[0]\n    closest_pair = (numbers[0], numbers[1])\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers (length of at least two).\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n\n    # First, sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of closest numbers with the first two elements\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers with at least two elements.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n\n    # Check if list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of closest numbers with the first two elements\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    :param numbers: A list of floating point numbers (length of at least 2)\n    :return: A tuple of two floats representing the closest numbers in ascending order\n    \"\"\"\n\n    # Check if list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of closest numbers\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()  # Initialize as an empty tuple\n\n    # Iterate over the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            # Update the closest pair, ensuring the smaller number comes first\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each \n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating point numbers (length of at least two).\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n\n    # First, we sort the list in ascending order to easily compare adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of closest elements with the first two elements of the sorted list\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list starting from the second element to compare each element with its successor\n    for i in range(1, len(sorted_numbers) - 1):\n        # Calculate the difference between the current element and the next one\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        \n        # If the current difference is smaller than the minimum found so far, update the minimum difference and the closest pair\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers (length >= 2)\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order\n    \"\"\"\n\n    # Check if the list contains at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements\")\n\n    # First, sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of closest elements with the first two elements of the sorted list\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each \n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers with a length of at least two.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n\n    # Check if the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two numbers.\")\n\n    # Sort the list in ascending order\n    numbers.sort()\n\n    # Initialize minimum difference and the pair of numbers with the minimum difference\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            # Update the closest pair, ensuring the smaller number comes first\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating point numbers (length of at least 2).\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n\n    # Check if the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n\n    # Sort the list in ascending order\n    numbers.sort()\n\n    # Initialize the minimum difference and the pair of closest elements\n    # with the first two elements of the sorted list\n    min_diff = numbers[1] - numbers[0]\n    closest_pair = (numbers[0], numbers[1])\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each \n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers: A list of floating point numbers with a length of at least two.\n\n    Returns:\n        A tuple containing two floats: the closest pair of numbers in ascending order.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of numbers with the minimum difference\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            # Update the closest pair, ensuring the smaller number comes first\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers with a length of at least two.\n\n    Returns:\n        Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n\n    Raises:\n        ValueError: If the input list contains less than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements.\")\n\n    # Sort the list in ascending order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the pair of closest elements\n    min_diff = float('inf')  # Initialize with positive infinity\n    closest_pair = ()  # Initialize with an empty tuple\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 72.10884353741497, "dps_norm": 25.0, "pass@1": 95.0, "profiled": [{"solution": "import unittest\ndef largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n, smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input number n must be greater than 0.\")\n\n    # Starting from n-1 to find the largest divisor\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n, smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)  # Prime number, so returns 1\n        1\n        >>> largest_divisor(20)\n        10\n    \"\"\"\n    # Start from n-1 and decrement to find the largest divisor\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    Finds the largest divisor of a given number, excluding the number itself.\n\n    Args:\n        n (int): The number for which to find the largest divisor.\n\n    Returns:\n        int: The largest divisor of `n`, smaller than `n`.\n\n    Raises:\n        ValueError: If `n` is less than 2 (since the problem doesn't apply to 0, 1, or negatives).\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"Input number should be an integer greater than 1.\")\n\n    # Start checking from the largest possible divisor, which is n-1\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, return i as it's the largest found so far (due to the descending order of the loop)\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n, smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)  # Prime number, largest divisor will be 1\n        1\n        >>> largest_divisor(20)\n        10\n    \"\"\"\n    # Starting from the largest possible divisor (n-1) down to the smallest (1)\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, return it as it's the largest due to the descending order\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    Finds the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n (excluding n itself).\n\n    Raises:\n        ValueError: If n is less than 2 (since problem constraints imply n > 1).\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"Input number must be greater than 1\")\n\n    # Starting from n-1 down to 2 to find the first (thus the largest) divisor\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n\n    # If no divisors other than 1 are found, return 1\n    # This is technically the smallest divisor, but since the problem seeks the 'largest'\n    # and given the constraints, 1 is the closest answer when n is a prime number\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n    n (int): The input number\n\n    Returns:\n    int: The largest divisor of n smaller than n itself\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)  # Prime number\n    1\n    >>> largest_divisor(24)\n    12\n    \"\"\"\n\n    # Start checking from n-1 down to 1, since we want the largest divisor\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, return i as it's the largest we've found so far (due to the descent order)\n            return i\n\n    # If no divisors other than 1 are found (meaning n is a prime number), return 1\n    return 1", "matching_cluster_idx": 1}, {"solution": "import doctest\ndef largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n that is less than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n    \"\"\"\n    # Start checking from n-1 down to 1 for efficiency\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, return immediately since we're iterating in descending order\n            return i\n\n    # If no divisor is found (theoretically impossible for n > 1), return None\n    # This case is more about code completeness; for n > 1, a divisor will always be found\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n smaller than n.\n\n    Raises:\n        ValueError: If n is less than 2 (since the problem implies existence of a divisor < n).\n    \"\"\"\n\n    # Check for edge case: n must be at least 2 to have a divisor smaller than itself\n    if n < 2:\n        raise ValueError(\"Input number must be at least 2\")\n\n    # Iterate from the largest possible divisor (n-1) downwards to 1\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Return the first (thus largest, due to the descending order) divisor found\n            return i\n\n    # This line should not be reached given the problem's constraints but is here for logical completeness\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n that is smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)  # Prime number, largest divisor will be 1\n        1\n        >>> largest_divisor(24)\n        12\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input number n must be greater than 0\")\n\n    # Start checking from n-1 downwards to find the first number that divides n evenly\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n\n    # If no divisors are found (n is a prime number), return 1\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    Args:\n    n (int): The input number for which to find the largest divisor.\n    \n    Returns:\n    int: The largest divisor of n, which is less than n.\n    \n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)  # Prime number, so divisor will be 1\n    1\n    \"\"\"\n\n    # Check if n is less than 2, since numbers less than 2 have no divisors other than 1\n    if n < 2:\n        return 1\n    \n    # Start checking from the largest possible divisor (n-1) downwards to 2\n    for i in range(n - 1, 1, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If i is a divisor, it is the largest (since we're iterating downwards), so return it\n            return i\n    \n    # If no divisors other than 1 are found (meaning n is a prime number), return 1\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n, smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)  # Prime number, so returns 1\n        1\n        >>> largest_divisor(24)\n        12\n    \"\"\"\n    if n < 2:  # Edge case: Numbers less than 2 have no divisors smaller than themselves\n        return None\n    \n    for i in range(n - 1, 0, -1):  # Iterate from n-1 downwards to 1\n        if n % i == 0:  # Check if i is a divisor of n\n            return i  # Return the first (thus largest) divisor found", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n, smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)  # Prime number\n        1\n        >>> largest_divisor(24)\n        12\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Start checking from the largest possible divisor (n-1) down to 1\n    for i in range(n - 1, 0, -1):\n        # If n is divisible by i, then i is a divisor\n        if n % i == 0:\n            # Since we're iterating from largest to smallest, the first hit is the largest divisor\n            return i\n\n    # If no divisor is found (which should not happen for n > 1), return 1 (technically, 1 is a divisor of every number)\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n, smaller than n.\n\n    Raises:\n        ValueError: If n is less than 2 (since the concept applies to numbers with at least two distinct divisors).\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)  # Prime number\n        1\n        >>> largest_divisor(20)\n        10\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"Input number must be greater than 1.\")\n    \n    # Starting from the largest possible divisor (n-1) down to 1\n    for i in range(n - 1, 0, -1):\n        # Check if 'i' is a divisor of 'n'\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n that is smaller than n.\n\n    Raises:\n        ValueError: If n is less than 2, since the problem's condition implies n > 1.\n    \"\"\"\n\n    if n < 2:\n        raise ValueError(\"Input number n must be greater than 1.\")\n\n    # Starting from n-1 downwards to find the first divisor (which will be the largest)\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            return i\n\n    # This should not be reachable given the problem's constraints and the initial check\n    raise RuntimeError(\"No divisor found, which is unexpected for n > 1.\")", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n, smaller than n.\n\n    Raises:\n        ValueError: If n is less than 2 (since the problem is not well-defined for n < 2).\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"Input number n must be greater than or equal to 2\")\n\n    # Start checking from n-1 downwards to find the first number that divides n evenly\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n\n    # This line should never be reached due to the nature of the problem (n >= 2)\n    assert False, \"Unreachable code, as n >= 2 should always have a divisor < n\"", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n (excluding n itself).\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)  # Prime number example\n        1\n    \"\"\"\n    # Start checking from n-1 downwards to find the largest divisor\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, return i as it's the largest divisor found so far (and will be the largest due to the downwards search)\n            return i\n    # If no divisors are found (i.e., n is prime), return 1 (since 1 is a divisor of every number)\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n that is smaller than n.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)  # Prime number, largest divisor will be 1\n        1\n        >>> largest_divisor(20)\n        10\n    \"\"\"\n    if n < 2:  # Numbers less than 2 have no divisors other than 1\n        return 1\n    \n    # Start checking from n-1 downwards for the largest divisor\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:  # Found a divisor\n            return i\n\n    # This should not be reachable given the initial condition, but for clarity:\n    return None  # No divisor found (theoretically impossible for n >= 2)", "matching_cluster_idx": 1}, {"solution": "import unittest\ndef largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number `n`, find the largest number that divides `n` evenly, smaller than `n`.\n    \n    Args:\n        n (int): The input number.\n    \n    Returns:\n        int: The largest divisor of `n`, excluding `n` itself.\n    \"\"\"\n    # Start checking from the largest possible divisor (n-1) downwards to 1\n    for i in range(n - 1, 0, -1):\n        # If n is divisible by i, then i is the largest divisor smaller than n\n        if n % i == 0:\n            return i\n\n    # If no divisor is found (which should not happen for n > 1), return 1\n    # This is technically the largest divisor for any number, but the problem implies n > 1\n    return 1", "matching_cluster_idx": 1}, {"solution": "import unittest\ndef largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n, which is smaller than n.\n\n    Raises:\n        ValueError: If n is less than 1, since divisors are defined for positive integers.\n\n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(17)  # Prime number, largest divisor is 1\n        1\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Iterate from n-1 downwards to find the first number that divides n evenly\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n\n    # If no divisors are found (i.e., n is 1), return 1\n    # This could also be handled by a more explicit check for n=1 before the loop\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The largest divisor of n, smaller than n.\n\n    Raises:\n        ValueError: If n is less than 1, as the concept of divisors applies to positive integers.\n    \"\"\"\n\n    if n < 1:\n        raise ValueError(\"Input number n must be a positive integer.\")\n\n    # Start from the largest possible divisor (n-1) down to 1\n    for i in range(n - 1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, return i as it's the largest found so far (and thus the largest overall)\n            return i\n\n    # This should theoretically never be reached given the problem constraints (n > 0)\n    # But for completeness, in case of an edge case or future modifications:\n    return None", "matching_cluster_idx": 1}]}, "HumanEval/26": {"dps": 63.0, "dps_norm": 75.0, "pass@1": 85.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers\n\n    Returns:\n        List[int]: List with duplicates (elements occurring more than once) removed\n    \"\"\"\n    seen = set()\n    seen_more_than_once = set()\n    result = []\n\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n        else:\n            if num not in seen_more_than_once:\n                # Mark as seen more than once and remove from result if already there\n                seen_more_than_once.add(num)\n                if num in result:\n                    result.remove(num)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers\n\n    Returns:\n        List[int]: List of integers with duplicates (elements occurring more than once) removed\n    \"\"\"\n    seen = set()  # Set to keep track of elements we've seen\n    seen_more_than_once = set()  # Set to keep track of elements that appear more than once\n    result = []  # Result list with no duplicates (more than once)\n\n    # First pass: Identify elements that appear more than once\n    for num in numbers:\n        if num in seen:\n            seen_more_than_once.add(num)\n        seen.add(num)\n\n    # Second pass: Filter out elements that appear more than once\n    for num in numbers:\n        if num not in seen_more_than_once:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The input list with duplicates (elements occurring more than once) removed.\n    \"\"\"\n    # Create an empty dictionary to store the count of each number\n    # and an empty list to store the result\n    count_dict = {}\n    result = []\n\n    # Iterate over the input list to count occurrences of each number\n    for num in numbers:\n        if num not in count_dict:\n            count_dict[num] = 1\n        else:\n            count_dict[num] += 1\n\n    # Iterate over the input list again to filter out duplicates\n    for num in numbers:\n        if count_dict[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The list with duplicates removed, preserving original order.\n    \"\"\"\n    # Create an empty dictionary to store counts of numbers\n    num_counts = {}\n    \n    # Create an empty list to store result\n    result = []\n    \n    # First pass: Count occurrences of each number\n    for num in numbers:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Second pass: Include only numbers that occur once in the result\n    for num in numbers:\n        if num_counts[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The input list with all duplicates removed, preserving the original order.\n\n    Examples:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n    \"\"\"\n    # Create an empty dictionary to store the count of each number\n    count_dict = {}\n    \n    # Iterate over the input list to count occurrences of each number\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Use a list comprehension to filter out numbers that occur more than once\n    # This preserves the original order since we're iterating over the original list\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The input list with all duplicate elements (elements occurring more than once) removed.\n    \"\"\"\n    seen = set()  # To keep track of elements we've seen\n    seen_multiple = set()  # To keep track of elements that appear more than once\n    result = []  # The resulting list with no duplicates\n\n    for num in numbers:\n        if num in seen:\n            # If we've seen this number before, mark it as seen multiple times\n            seen_multiple.add(num)\n        else:\n            # If not, add it to the seen set and the result list (for now)\n            seen.add(num)\n            result.append(num)\n\n    # Filter out elements that appear more than once from the result\n    result = [num for num in result if num not in seen_multiple]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The input list with all duplicate elements removed.\n    \"\"\"\n    # Utilize OrderedDict to preserve order while removing duplicates\n    # and a dictionary comprehension to count occurrences\n    seen = OrderedDict()\n    for num in numbers:\n        seen[num] = seen.get(num, 0) + 1\n    \n    # Filter out elements that occur more than once\n    return [num for num, count in seen.items() if count == 1]", "matching_cluster_idx": 2}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The list with duplicates (elements occurring more than once) removed.\n    \"\"\"\n    # Use OrderedDict to maintain insertion order and eliminate duplicates\n    seen = OrderedDict()\n    for num in numbers:\n        seen[num] = None  # The value doesn't matter here, we're only using keys\n\n    # Filter out elements that appear more than once in the original list\n    unique_or_single = [num for num in seen.keys() if numbers.count(num) == 1]\n\n    return unique_or_single", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The input list with duplicates (elements occurring more than once) removed.\n    \"\"\"\n    # Use OrderedDict to maintain order and remove duplicates\n    # since OrderedDict only keeps the first occurrence of each key\n    unique_ordered = OrderedDict((num, True) for num in numbers if numbers.count(num) == 1)\n    \n    # Return the unique elements as a list\n    return list(unique_ordered.keys())", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The input list with all duplicate elements removed.\n    \"\"\"\n    seen = set()  # To keep track of elements we've seen once\n    seen_twice = set()  # To keep track of elements that appear more than once\n\n    # First pass to identify all duplicates\n    for num in numbers:\n        if num in seen:\n            seen_twice.add(num)\n        seen.add(num)\n\n    # Second pass to filter out duplicates, preserving order\n    return [num for num in numbers if num not in seen_twice]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The input list with duplicates (elements occurring more than once) removed.\n    \"\"\"\n    seen = set()  # Set to keep track of elements we've seen\n    seen_more_than_once = set()  # Set to keep track of elements that occur more than once\n    result = []  # List to store the result\n\n    # First pass: identify elements that occur more than once\n    for num in numbers:\n        if num in seen:\n            seen_more_than_once.add(num)\n        seen.add(num)\n\n    # Second pass: filter out elements that occur more than once\n    for num in numbers:\n        if num not in seen_more_than_once:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The input list with all duplicates removed, preserving original order.\n    \"\"\"\n    seen = set()\n    seen_more_than_once = set()\n    result = []\n\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n        else:\n            if num not in seen_more_than_once:\n                # If we've seen this number before, but not more than once yet,\n                # remove it from the result if it was there and mark it as seen more than once\n                if num in result:\n                    result.remove(num)\n                seen_more_than_once.add(num)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: List of integers with duplicates (elements occurring more than once) removed.\n    \"\"\"\n    # Use OrderedDict to keep track of the first occurrence of each number\n    # Since Python 3.7, dictionaries maintain insertion order, but we use OrderedDict for clarity and compatibility with earlier Python versions\n    seen = OrderedDict()\n    for num in numbers:\n        seen[num] = None  # The value doesn't matter here, we're just interested in the keys\n    \n    # Filter out numbers that appear more than once in the original list\n    # by checking their count in the original list\n    return [num for num in seen if numbers.count(num) == 1]", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: The list with duplicates (elements occurring more than once) removed.\n    \"\"\"\n    # Use OrderedDict to preserve order and eliminate duplicates\n    # since Python 3.7+, dictionaries maintain insertion order\n    seen = OrderedDict()\n    for num in numbers:\n        seen[num] = None  # Value is arbitrary since we're only using keys\n    \n    # Filter out numbers that appeared more than once in the original list\n    unique_numbers = [num for num in seen if numbers.count(num) == 1]\n    \n    return unique_numbers", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The list with all duplicates (elements occurring more than once) removed.\n    \"\"\"\n    # Use OrderedDict to maintain order and automatically remove duplicates\n    # Then, filter out elements that occurred more than once in the original list\n    seen = OrderedDict()\n    for num in numbers:\n        seen[num] = seen.get(num, 0) + 1\n    \n    # Filter out elements that occur more than once\n    result = [num for num, count in seen.items() if count == 1]\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The input list with all duplicate elements removed.\n    \"\"\"\n    seen = set()  # Set to track elements we've seen\n    seen_more_than_once = set()  # Set to track elements that appear more than once\n    result = []  # List to store the result\n\n    # First pass: Identify elements that appear more than once\n    for num in numbers:\n        if num in seen:\n            seen_more_than_once.add(num)\n        seen.add(num)\n\n    # Second pass: Include elements in the result if they don't appear more than once\n    for num in numbers:\n        if num not in seen_more_than_once:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: A list with duplicates (elements occurring more than once) removed.\n    \"\"\"\n    # Use OrderedDict to maintain order and remove duplicates\n    seen = OrderedDict()\n    for num in numbers:\n        seen[num] = None  # The value doesn't matter here, we're just using it for its keys\n    \n    # Filter out elements that were seen more than once in the original list\n    result = [num for num in seen if numbers.count(num) == 1]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n    - numbers (List[int]): A list of integers.\n\n    Returns:\n    - List[int]: The input list with all duplicate elements removed, preserving order.\n\n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create an OrderedDict to keep track of element counts while preserving order\n    count_dict = OrderedDict()\n    \n    # Iterate over the input list to count occurrences of each number\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num, count in count_dict.items() if count == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: List with all duplicates (elements occurring more than once) removed.\n    \"\"\"\n    seen = set()  # Set to track elements we've seen once\n    seen_more_than_once = set()  # Set to track elements that occur more than once\n    \n    result = []  # Result list with duplicates removed\n    \n    for num in numbers:\n        if num not in seen:\n            # First occurrence of this number\n            seen.add(num)\n            result.append(num)\n        elif num in seen and num not in seen_more_than_once:\n            # Second occurrence, mark as seen more than once and remove from result\n            seen_more_than_once.add(num)\n            result.remove(num)\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n\n    Returns:\n        List[int]: A new list with duplicates removed, preserving the original order.\n    \"\"\"\n    seen = set()  # To keep track of elements we've seen once\n    seen_twice = set()  # To keep track of elements we've seen more than once\n    \n    # First pass to identify all duplicates\n    for num in numbers:\n        if num in seen:\n            seen_twice.add(num)\n        seen.add(num)\n    \n    # Second pass to filter out duplicates, preserving order\n    result = [num for num in numbers if num not in seen_twice]\n    \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 87.15189873417721, "dps_norm": 84.375, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number `n` is prime, and False otherwise.\n\n    :param n: The number to check for primality.\n    :type n: int\n    :return: Whether `n` is prime.\n    :rtype: bool\n    \"\"\"\n    if n <= 1:  # 0 and 1 are not prime numbers\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # all other even numbers are not prime\n        return False\n\n    # Check odd factors up to the square root of n\n    # because a larger factor of the number would be a multiple of smaller factor that has already been checked\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    :param n: The number to check for primality.\n    :type n: int\n    :return: True if `n` is prime, False otherwise.\n    :rtype: bool\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    elif n <= 3:  # 2 and 3 are prime\n        return True\n    elif n % 2 == 0 or n % 3 == 0:  # If divisible by 2 or 3, not prime\n        return False\n    i = 5\n    while i * i <= n:  # Check divisibility up to the square root of n\n        if n % i == 0 or n % (i + 2) == 0:  # Check for factors of the form 6k \u00b1 1\n            return False\n        i += 6  # Increment by 6 to check the next pair of potential factors\n    return True  # If no factors found, the number is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    :param n: The number to check for primality\n    :type n: int\n    :return: True if n is prime, False otherwise\n    :rtype: bool\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n <= 1:\n        return False  # Numbers less than or equal to 1 are not prime\n    if n == 2:\n        return True  # 2 is the only even prime number\n    if n % 2 == 0:\n        return False  # All other even numbers are not primes\n    max_divisor = int(n**0.5) + 1  # Only need to check up to the square root of n\n    for d in range(3, max_divisor, 2):  # Check odd divisors starting from 3\n        if n % d == 0:\n            return False\n    return True  # If no divisors found, n is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number `n` is prime, and False otherwise.\n\n    :param n: The number to check for primality.\n    :type n: int\n    :return: True if `n` is prime, False otherwise.\n    :rtype: bool\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # All other even numbers are not prime\n        return False\n\n    # Check odd factors up to the square root of n\n    # This is an optimization, as a larger factor of the number\n    # would be a multiple of a smaller factor that has already been checked\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n\n    return True  # If no factors found, the number is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    :param n: The number to check for primality\n    :type n: int\n    :return: True if `n` is prime, False otherwise\n    :rtype: bool\n    \"\"\"\n\n    # Handle edge cases: Numbers less than 2 are not prime\n    if n < 2:\n        return False\n\n    # 2 is the only even prime number\n    if n == 2:\n        return True\n\n    # All other even numbers are not prime\n    if n % 2 == 0:\n        return False\n\n    # Check odd factors up to the square root of n\n    # This is an optimization to reduce the number of checks\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n\n    # If no factors found, the number is prime\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n\n    :param n: The number to check for primality.\n    :return: True if n is prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # All other even numbers are not prime\n        return False\n\n    # Only need to check up to the square root of n for factors\n    # as a larger factor of the number would be a multiple of a smaller\n    # factor that has already been checked\n    from math import sqrt\n    for i in range(3, int(sqrt(n)) + 1, 2):  # Check odd numbers only\n        if n % i == 0:  # Found a factor, not a prime\n            return False\n    return True  # No factors found, is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    :param n: The number to check for primality.\n    :return: True if `n` is prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime.\n        return False\n    for i in range(2, int(n ** 0.5) + 1):  # Check up to the square root of n.\n        if n % i == 0:  # If n is divisible by any number, it's not prime.\n            return False\n    return True  # If no divisors are found, the number is prime.", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n\n    :param n: The number to check for primality.\n    :type n: int\n    :return: True if `n` is prime, False otherwise.\n    :rtype: bool\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 2:\n        return False  # Numbers less than 2 are not prime\n    for i in range(2, int(n ** 0.5) + 1):\n        # Checking divisibility up to the square root of n is sufficient\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    :param n: The number to check for primality.\n    :return: True if n is prime, False otherwise.\n    \"\"\"\n\n    # Corner cases: Numbers less than 2 are not prime\n    if n < 2:\n        return False\n\n    # 2 is the only even prime number\n    if n == 2:\n        return True\n\n    # All other even numbers are not prime\n    if n % 2 == 0:\n        return False\n\n    # Check odd factors up to the square root of n\n    # This is an optimization since a larger factor of n must be a multiple of a smaller factor that has already been checked\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n\n    # If no factors were found, the number is prime\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    :param n: The number to check for primality\n    :return: True if `n` is prime, False otherwise\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # All other even numbers are not prime\n        return False\n\n    # Check odd factors up to the square root of n\n    # This is an optimization to reduce the number of checks\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:  # If n is divisible by any odd number, it's not prime\n            return False\n\n    return True  # If no divisors are found, n is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    Args:\n        n (int): The number to check for primality.\n\n    Returns:\n        bool: True if `n` is prime, False otherwise.\n\n    Examples:\n        >>> is_prime(6)\n        False\n        >>> is_prime(101)\n        True\n        >>> is_prime(11)\n        True\n        >>> is_prime(13441)\n        True\n        >>> is_prime(61)\n        True\n        >>> is_prime(4)\n        False\n        >>> is_prime(1)\n        False\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    if n <= 3:  # 2 and 3 are prime\n        return True\n    if n % 2 == 0 or n % 3 == 0:  # If divisible by 2 or 3, not prime\n        return False\n    i = 5\n    while i * i <= n:  # Check divisibility up to the square root of n\n        if n % i == 0 or n % (i + 2) == 0:  # Check for factors of the form 6k \u00b1 1\n            return False\n        i += 6\n    return True  # If no factors found, the number is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number `n` is prime, False otherwise.\n\n    :param n: The number to check for primality\n    :type n: int\n    :return: Whether `n` is prime\n    :rtype: bool\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    elif n <= 3:  # 2 and 3 are prime\n        return True\n    elif n % 2 == 0 or n % 3 == 0:  # If divisible by 2 or 3, it's not prime\n        return False\n    i = 5\n    while i * i <= n:  # Only need to check up to the square root of n\n        if n % i == 0 or n % (i + 2) == 0:  # Check for divisibility by 6k \u00b1 1\n            return False\n        i += 6\n    return True  # If all checks pass, n is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n\n    :param n: The number to check for primality\n    :type n: int\n    :return: Whether the number is prime\n    :rtype: bool\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # All other even numbers are not prime\n        return False\n\n    # Check odd factors up to the square root of n\n    # This is an optimization since a larger factor of the number would be a multiple of a smaller factor that has already been checked\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n\n    return True  # If no factors found, the number is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n\n    :param n: The number to check for primality.\n    :type n: int\n    :return: True if n is prime, False otherwise.\n    :rtype: bool\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # All other even numbers are not prime\n        return False\n    # Check odd factors up to the square root of n\n    # This is an optimization to reduce the number of checks\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:  # If n is divisible by any odd number, it's not prime\n            return False\n    return True  # If all checks pass, n is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n\n    :param n: The number to check for primality\n    :type n: int\n    :return: Whether the number is prime\n    :rtype: bool\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # All other even numbers are not prime\n        return False\n\n    # Only need to check odd factors up to the square root of n\n    # because a larger factor of the number would be a multiple of a smaller\n    # factor that has already been checked\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n\n    :param n: The number to check for primality.\n    :type n: int\n    :return: True if `n` is prime, False otherwise.\n    :rtype: bool\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 2:  # 0, 1, and negatives are not prime\n        return False\n    # Check from 2 to the square root of n for factors\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:  # Found a factor, not prime\n            return False\n    return True  # No factors found, is prime", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n\n    ### Example Use Cases:\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    # Corner cases: Numbers less than 2 are not prime\n    if n < 2:\n        return False\n\n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    # All other even numbers are not prime\n    if n % 2 == 0:\n        return False\n\n    # Only check odd factors up to the square root of n\n    # because a larger factor of the number would be a multiple of a smaller factor that has already been checked\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n\n    # If no factors were found, the number is prime\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n\n    :param n: The number to check for primality.\n    :return: True if prime, False if not.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    elif n <= 3:  # 2 and 3 are prime\n        return True\n    elif n % 2 == 0 or n % 3 == 0:  # If divisible by 2 or 3, not prime\n        return False\n    i = 5\n    while i * i <= n:  # Check divisibility up to the square root of n\n        if n % i == 0 or n % (i + 2) == 0:  # Check for divisibility by 6k \u00b1 1\n            return False\n        i += 6\n    return True  # If all checks pass, the number is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    Args:\n        n (int): The number to check for primality.\n\n    Returns:\n        bool: True if the number is prime, False otherwise.\n\n    Examples:\n        >>> is_prime(6)\n        False\n        >>> is_prime(101)\n        True\n        >>> is_prime(11)\n        True\n        >>> is_prime(13441)\n        True\n        >>> is_prime(61)\n        True\n        >>> is_prime(4)\n        False\n        >>> is_prime(1)\n        False\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    elif n <= 3:  # 2 and 3 are prime\n        return True\n    elif n % 2 == 0 or n % 3 == 0:  # If divisible by 2 or 3, not prime\n        return False\n    i = 5\n    while i * i <= n:  # Only need to check up to the square root of n\n        if n % i == 0 or n % (i + 2) == 0:  # Check for divisibility by 6k \u00b1 1\n            return False\n        i += 6\n    return True  # If all checks pass, the number is prime", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    :param n: The number to check for primality\n    :return: True if n is prime, False otherwise\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # All other even numbers are not prime\n        return False\n\n    # Check odd factors up to the square root of n\n    # This is an optimization to reduce the number of checks\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:  # If n is divisible by any odd number, it's not prime\n            return False\n\n    return True  # If all checks pass, n is prime", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 80.0, "profiled": [{"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list `l` and returns a list `l'` such that:\n    - `l'` is identical to `l` in the indices that are not divisible by three.\n    - Its values at the indices that are divisible by three are equal to the values \n      of the corresponding indices of `l`, but sorted.\n\n    :param l: Input list to be processed\n    :return: The modified list according to the problem statement\n    \"\"\"\n    # Separate elements at indices divisible by 3 and sort them\n    third_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Index to track the current element in the sorted third elements list\n    third_idx = 0\n    \n    # Iterate over the original list with enumerate to have both index and value\n    for idx, val in enumerate(l):\n        # If the index is divisible by 3, append the next sorted third element\n        if idx % 3 == 0:\n            result.append(third_elements[third_idx])\n            third_idx += 1\n        # Otherwise, append the original value\n        else:\n            result.append(val)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list `l` and returns a list `l'` such that:\n    - `l'` is identical to `l` in the indices that are not divisible by three.\n    - Its values at the indices that are divisible by three are equal to the values \n      of the corresponding indices of `l`, but sorted.\n\n    :param l: Input list to be partially sorted\n    :return: A new list with specified sorting at indices divisible by three\n    \"\"\"\n\n    # Separate elements at indices divisible by 3\n    third_indices = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the elements at indices divisible by 3\n    third_indices.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Counter for the sorted third index elements\n    third_index_counter = 0\n    \n    # Iterate over the original list with enumerate to access both index and value\n    for i, value in enumerate(l):\n        # If the index is divisible by 3, append the next sorted element\n        if i % 3 == 0:\n            result.append(third_indices[third_index_counter])\n            third_index_counter += 1\n        # Otherwise, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list `l` and returns a list `l'` such that:\n    - `l'` is identical to `l` in the indices that are not divisible by three.\n    - Its values at the indices that are divisible by three are equal to the values of the corresponding indices of `l`, but sorted.\n\n    :param l: The input list to be processed.\n    :return: The processed list as per the problem statement.\n    \"\"\"\n\n    # Separate elements at indices divisible by 3 and sort them\n    third_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter for the sorted third elements\n    third_element_index = 0\n    \n    # Iterate over the original list with enumerate to have both index and value\n    for i, value in enumerate(l):\n        # If the index is divisible by 3, append the next sorted element\n        if i % 3 == 0:\n            result.append(third_elements[third_element_index])\n            third_element_index += 1\n        # Otherwise, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a modified list.\n    The returned list is identical to `input_list` at indices not divisible by three.\n    At indices divisible by three, the values are the same as `input_list` but sorted.\n\n    :param input_list: The input list to be modified\n    :return: The modified list as per the problem statement\n    \"\"\"\n\n    # Separate elements at indices divisible by 3 from the rest\n    third_indices = [val for idx, val in enumerate(input_list) if idx % 3 == 0]\n    \n    # Sort the elements that were at indices divisible by 3\n    third_indices.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Counter to keep track of the current index in third_indices\n    third_idx_counter = 0\n    \n    # Iterate over the input list with their indices\n    for idx, val in enumerate(input_list):\n        # If the index is divisible by 3, append the next sorted value\n        if idx % 3 == 0:\n            result.append(third_indices[third_idx_counter])\n            third_idx_counter += 1\n        # Otherwise, append the original value\n        else:\n            result.append(val)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a modified list where elements at indices not divisible by three remain unchanged,\n    while elements at indices divisible by three are replaced with the sorted elements from the original list's indices divisible by three.\n\n    Args:\n        input_list (list): The input list to be modified.\n\n    Returns:\n        list: The modified list as per the problem statement.\n    \"\"\"\n\n    # Separate elements at indices divisible by 3, sort them, and store them in a list\n    third_elements = sorted([input_list[i] for i in range(len(input_list)) if i % 3 == 0])\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to keep track of the current third element to use\n    third_element_index = 0\n    \n    # Iterate over the range of the input list's length\n    for i in range(len(input_list)):\n        # If the index is divisible by 3, append the next sorted third element\n        if i % 3 == 0:\n            result.append(third_elements[third_element_index])\n            third_element_index += 1\n        # Otherwise, append the original element at this index\n        else:\n            result.append(input_list[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list.\n    The new list is identical to `input_list` at indices not divisible by three.\n    At indices divisible by three, the values are from `input_list` but sorted.\n\n    :param input_list: Input list to be processed\n    :return: Processed list as per the problem statement\n    \"\"\"\n\n    # Separate elements at indices divisible by 3 into a list for sorting\n    third_indices = [input_list[i] for i in range(len(input_list)) if i % 3 == 0]\n    \n    # Sort the list of elements from indices divisible by 3\n    third_indices.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to keep track of the current position in the sorted third_indices list\n    third_index_counter = 0\n    \n    # Iterate over the original list with enumerate to access both index and value\n    for i, value in enumerate(input_list):\n        # If the index is divisible by 3, append the next sorted value\n        if i % 3 == 0:\n            result.append(third_indices[third_index_counter])\n            third_index_counter += 1\n        # Otherwise, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list.\n    The new list is identical to `input_list` at indices not divisible by three.\n    At indices divisible by three, the new list's values are the sorted values from `input_list` at those indices.\n\n    Returns:\n        list: The modified list as per the problem statement.\n    \"\"\"\n    # Separate elements at indices divisible by 3\n    third_elements = [input_list[i] for i in range(len(input_list)) if i % 3 == 0]\n    \n    # Sort these elements\n    third_elements.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Counter for keeping track of the current third element to insert\n    third_element_index = 0\n    \n    # Iterate over the original list with enumerate to have both index and value\n    for i, value in enumerate(input_list):\n        # If the index is divisible by 3, append the next sorted third element\n        if i % 3 == 0:\n            result.append(third_elements[third_element_index])\n            third_element_index += 1\n        # Otherwise, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a modified list.\n    The modified list is identical to the input list at indices not divisible by three.\n    At indices divisible by three, the values are the sorted values from the corresponding indices of the input list.\n\n    :param input_list: The input list to be modified\n    :return: The modified list as per the problem statement\n    \"\"\"\n\n    # Separate elements at indices divisible by 3 into a list for sorting\n    third_indices = [input_list[i] for i in range(len(input_list)) if i % 3 == 0]\n    \n    # Sort the elements at third indices\n    sorted_thirds = sorted(third_indices)\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Counter for tracking the current position in sorted_thirds\n    third_index = 0\n    \n    # Iterate over the input list with enumerate to access both index and value\n    for i, value in enumerate(input_list):\n        # If the index is divisible by 3, append the next sorted value\n        if i % 3 == 0:\n            result.append(sorted_thirds[third_index])\n            third_index += 1\n        # Otherwise, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a modified list.\n    The output list is identical to the input list at indices not divisible by three.\n    At indices divisible by three, the output list contains the sorted values from the corresponding input list indices.\n\n    Returns:\n        list: The modified list as described.\n    \"\"\"\n    # Separate elements at indices divisible by 3 and sort them\n    third_elements = sorted([input_list[i] for i in range(len(input_list)) if i % 3 == 0])\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Counter for tracking the current index in the sorted third elements\n    third_elem_index = 0\n    \n    # Iterate over the input list with enumerate to access both index and value\n    for i, val in enumerate(input_list):\n        # If the index is divisible by 3, append the next sorted third element\n        if i % 3 == 0:\n            result.append(third_elements[third_elem_index])\n            third_elem_index += 1\n        # If the index is not divisible by 3, append the original value\n        else:\n            result.append(val)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a list `output_list` such that:\n    - `output_list` is identical to `input_list` at indices not divisible by three.\n    - Values at indices divisible by three in `output_list` are the sorted values from the corresponding indices in `input_list`.\n\n    :param input_list: The input list to be processed\n    :return: The processed list as per the problem statement\n    \"\"\"\n\n    # Separate elements at indices divisible by 3 and sort them\n    third_indices = sorted([val for idx, val in enumerate(input_list) if idx % 3 == 0])\n    \n    # Initialize an empty list to store the result\n    output_list = []\n    \n    # Index to track the current position in third_indices list\n    third_idx_tracker = 0\n    \n    # Iterate over the input list with enumerate to access both index and value\n    for idx, val in enumerate(input_list):\n        # If the index is divisible by 3, append the next sorted value\n        if idx % 3 == 0:\n            output_list.append(third_indices[third_idx_tracker])\n            third_idx_tracker += 1\n        # If the index is not divisible by 3, append the original value\n        else:\n            output_list.append(val)\n    \n    return output_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list `l` and returns a list `l'` such that\n    `l'` is identical to `l` in the indices that are not divisible by three, \n    while its values at the indices that are divisible by three are equal \n    to the values of the corresponding indices of `l`, but sorted.\n\n    :param l: The input list to be processed\n    :return: A new list with every third element sorted from the original list\n    \"\"\"\n\n    # Extract elements at indices divisible by 3, sort them, and store in a list\n    third_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to keep track of the current third element to use\n    third_element_index = 0\n    \n    # Iterate over the input list with both index and value\n    for i, value in enumerate(l):\n        # If the index is divisible by 3, append the next sorted third element\n        if i % 3 == 0:\n            result.append(third_elements[third_element_index])\n            third_element_index += 1\n        # If the index is not divisible by 3, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list `l` and returns a list `l'` such that:\n    - `l'` is identical to `l` in the indices that are not divisible by three.\n    - Its values at the indices that are divisible by three are equal to the values of the corresponding indices of `l`, but sorted.\n\n    :param l: The input list to be processed.\n    :return: A new list with specified sorting at indices divisible by three.\n    \"\"\"\n    # Separate elements at indices divisible by 3\n    every_third = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the separated elements\n    every_third.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Index to track the current position in the sorted 'every_third' list\n    third_index = 0\n    \n    # Iterate over the input list with enumerate to access both index and value\n    for i, value in enumerate(l):\n        # If the index is divisible by 3, append the next sorted element\n        if i % 3 == 0:\n            result.append(every_third[third_index])\n            third_index += 1\n        # Otherwise, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list where values at indices not divisible by three remain unchanged,\n    while values at indices divisible by three are replaced with sorted values from the original list's indices divisible by three.\n\n    Returns:\n        list: The modified list as per the problem statement.\n    \"\"\"\n\n    # Separate elements at indices divisible by three into a separate list\n    third_elements = [input_list[i] for i in range(len(input_list)) if i % 3 == 0]\n    \n    # Sort the elements that were at indices divisible by three\n    third_elements.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to keep track of the current third element to use\n    third_element_index = 0\n    \n    # Iterate over the input list with enumerate to access both index and value\n    for i, value in enumerate(input_list):\n        # If the index is divisible by three, append the next sorted third element\n        if i % 3 == 0:\n            result.append(third_elements[third_element_index])\n            third_element_index += 1\n        # If the index is not divisible by three, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a modified list where:\n    - Elements at indices not divisible by three remain unchanged.\n    - Elements at indices divisible by three are sorted based on their original values.\n\n    :param input_list: The input list to be modified.\n    :return: The modified list.\n    \"\"\"\n    # Separate elements at indices divisible by 3 and sort them\n    third_elements = sorted([input_list[i] for i in range(len(input_list)) if i % 3 == 0])\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Counter for the sorted third elements\n    third_index = 0\n    \n    # Iterate over the range of input list length\n    for i in range(len(input_list)):\n        # If the index is divisible by 3, append the next sorted element\n        if i % 3 == 0:\n            result.append(third_elements[third_index])\n            third_index += 1\n        # Otherwise, append the original element\n        else:\n            result.append(input_list[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a modified list.\n    In the output list, elements at indices not divisible by three remain unchanged.\n    Elements at indices divisible by three are replaced with elements from the same indices in the input list, but sorted among themselves.\n\n    :param input_list: The input list to be modified.\n    :return: The modified list according to the problem's rules.\n    \"\"\"\n\n    # Extract elements at indices divisible by three\n    third_elements = [input_list[i] for i in range(len(input_list)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_third_elements = sorted(third_elements)\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Index to track the current position in sorted_third_elements\n    third_index = 0\n    \n    # Iterate over the range of input list's length\n    for i in range(len(input_list)):\n        # If the index is divisible by three, append the next sorted element\n        if i % 3 == 0:\n            result.append(sorted_third_elements[third_index])\n            third_index += 1\n        # Otherwise, append the original element\n        else:\n            result.append(input_list[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a modified list where indices not divisible by three remain unchanged,\n    while values at indices divisible by three are replaced with sorted values from the original list's corresponding indices.\n\n    :param input_list: The input list to be modified\n    :return: A new list with specified modifications\n    \"\"\"\n\n    # Extract elements at indices divisible by three and sort them\n    sorted_thirds = sorted([val for idx, val in enumerate(input_list) if idx % 3 == 0])\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter for tracking the index in the sorted_thirds list\n    sorted_thirds_idx = 0\n    \n    # Iterate over the input list with both index and value\n    for idx, val in enumerate(input_list):\n        # If the index is divisible by three, append the next value from sorted_thirds\n        if idx % 3 == 0:\n            result.append(sorted_thirds[sorted_thirds_idx])\n            sorted_thirds_idx += 1\n        # Otherwise, append the original value\n        else:\n            result.append(val)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a modified list.\n    The modified list is identical to the input list at indices not divisible by three.\n    At indices divisible by three, the values are the sorted values from the corresponding indices of the input list.\n\n    :param input_list: The input list to be modified\n    :return: The modified list as per the problem statement\n    \"\"\"\n\n    # Extract elements at indices divisible by 3, sort them, and store them in a list\n    third_indices_values = sorted([input_list[i] for i in range(len(input_list)) if i % 3 == 0])\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to keep track of the current index in third_indices_values\n    third_index_counter = 0\n    \n    # Iterate over the input list with enumerate to have both index and value\n    for i, value in enumerate(input_list):\n        # If the index is divisible by 3, append the next value from the sorted list\n        if i % 3 == 0:\n            result.append(third_indices_values[third_index_counter])\n            third_index_counter += 1\n        # If the index is not divisible by 3, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list.\n    The returned list is identical to `input_list` in the indices that are not divisible by three.\n    Its values at the indices that are divisible by three are equal to the values of the corresponding indices of `input_list`, but sorted.\n\n    :param input_list: The input list to be processed.\n    :return: A new list with the specified sorting criteria applied.\n    \"\"\"\n\n    # Separate elements at indices divisible by 3 from the rest\n    third_indices = sorted([val for idx, val in enumerate(input_list) if idx % 3 == 0])\n    other_indices = [val for idx, val in enumerate(input_list) if idx % 3 != 0]\n\n    # Initialize the result list\n    result = []\n\n    # Initialize index trackers for both lists\n    third_idx, other_idx = 0, 0\n\n    # Iterate over the range of the length of the input list\n    for i in range(len(input_list)):\n        # If the current index is divisible by 3, append from third_indices\n        if i % 3 == 0:\n            result.append(third_indices[third_idx])\n            third_idx += 1\n        # Otherwise, append from other_indices\n        else:\n            result.append(other_indices[other_idx])\n            other_idx += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a modified list where:\n    - Elements at indices not divisible by three remain unchanged.\n    - Elements at indices divisible by three are sorted from the original list's elements at these positions.\n\n    :param input_list: The input list to be modified.\n    :return: The modified list as per the problem's requirement.\n    \"\"\"\n\n    # Extract elements at indices divisible by three\n    third_elements = [input_list[i] for i in range(len(input_list)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    third_elements.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to track the current position in the sorted third_elements list\n    third_element_index = 0\n    \n    # Iterate over the indices and values of the input list\n    for i, value in enumerate(input_list):\n        # If the index is divisible by three, append the next sorted third element\n        if i % 3 == 0:\n            result.append(third_elements[third_element_index])\n            third_element_index += 1\n        # Otherwise, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a modified list `output_list`.\n    `output_list` is identical to `input_list` at indices not divisible by three.\n    At indices divisible by three, `output_list` contains the same elements from `input_list`\n    but in sorted order, maintaining their positions at multiples of three.\n\n    :param input_list: The input list to be modified\n    :return: A new list with specified sorting at indices divisible by three\n    \"\"\"\n    # Separate elements at indices divisible by three into a separate list\n    third_indices = [input_list[i] for i in range(len(input_list)) if i % 3 == 0]\n    \n    # Sort the list of elements that were at indices divisible by three\n    third_indices.sort()\n    \n    # Initialize an empty list to store the result\n    output_list = []\n    \n    # Index to track the current element in the sorted third_indices list\n    third_index = 0\n    \n    # Iterate over the range of indices in the input list\n    for i in range(len(input_list)):\n        # If the current index is divisible by three, append the next sorted element\n        if i % 3 == 0:\n            output_list.append(third_indices[third_index])\n            third_index += 1\n        # Otherwise, append the original element from the input list\n        else:\n            output_list.append(input_list[i])\n    \n    return output_list", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 63.77358490566038, "dps_norm": 92.0, "pass@1": 85.0, "profiled": [{"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    :param input_list: The list to extract unique elements from.\n    :return: A new list containing unique elements in ascending order.\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates and then convert back to list\n    unique_list = list(set(input_list))\n    \n    # Sort the list in ascending order\n    unique_list.sort()\n    \n    return unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Returns a new list containing the unique elements from the input list, sorted in ascending order.\n\n    :param input_list: The list to extract unique elements from\n    :return: A sorted list of unique elements\n    \"\"\"\n    return sorted(set(input_list))  # Convert to set for uniqueness, then sort", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return a new list containing the unique elements from the input list in sorted order.\n\n    :param input_list: The input list that may contain duplicate elements.\n    :return: A new sorted list with unique elements.\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list\n    unique_list = list(set(input_list))\n    \n    # Sort the list in ascending order\n    unique_list.sort()\n    \n    return unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): The input list that may contain duplicate elements.\n\n    Returns:\n        list: A new list containing unique elements from the input, sorted in ascending order.\n\n    Example:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates (sets only allow unique elements)\n    unique_set = set(input_list)\n    \n    # Convert the set back to a list and sort it in ascending order\n    sorted_unique_list = sorted(list(unique_set))\n    \n    return sorted_unique_list", "matching_cluster_idx": 3}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to list\n    unique_elements = list(set(input_list))\n    \n    # Sort the list in ascending order\n    unique_elements.sort()\n    \n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to list and sort it\n    return sorted(set(input_list))", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    :param input_list: The input list that may contain duplicate elements.\n    :return: A new list with unique elements in sorted order.\n\n    Examples\n    --------\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_set = set(input_list)\n    \n    # Convert the set back to a list and sort it\n    unique_sorted_list = sorted(list(unique_set))\n    \n    return unique_sorted_list", "matching_cluster_idx": 3}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Returns a new list containing unique elements from the input list, sorted in ascending order.\n\n    :param input_list: A list that may contain duplicate elements\n    :return: A sorted list with unique elements\n    \"\"\"\n    return sorted(set(input_list))", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): The input list that may contain duplicate elements.\n\n    Returns:\n        list: A new list with unique elements sorted in ascending order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_set = set(input_list)\n    \n    # Convert the set back to a list and sort it\n    unique_sorted_list = sorted(list(unique_set))\n    \n    return unique_sorted_list", "matching_cluster_idx": 3}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): A list that may contain duplicate elements.\n\n    Returns:\n        list: A new list containing unique elements from the input, in sorted order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to eliminate duplicates\n    unique_set = set(input_list)\n    \n    # Convert the set back to a list and sort it\n    sorted_unique_list = sorted(list(unique_set))\n    \n    return sorted_unique_list", "matching_cluster_idx": 3}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return a new list containing the unique elements from the input list in ascending order.\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(input_list))", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): A list containing elements of any hashable type.\n\n    Returns:\n        list: A new sorted list with unique elements from the input list.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n\n    # Convert the list to a set to remove duplicates\n    unique_set = set(input_list)\n    \n    # Convert the set back to a list and sort it\n    sorted_unique_list = sorted(list(unique_set))\n    \n    return sorted_unique_list", "matching_cluster_idx": 3}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return a new list containing the unique elements from the input list, sorted in ascending order.\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to list and sort it\n    return sorted(set(input_list))", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): The input list from which to extract unique elements.\n\n    Returns:\n        list: A new list containing unique elements from the input, in ascending order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list\n    unique_elements = list(set(input_list))\n    \n    # Sort the list in ascending order\n    unique_elements.sort()\n    \n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Returns a sorted list of unique elements from the input list.\n    \n    Args:\n    input_list (list): The list from which to extract unique elements.\n    \n    Returns:\n    list: A sorted list of unique elements.\n    \n    Examples:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to list\n    unique_elements = list(set(input_list))\n    \n    # Sort the list in ascending order\n    sorted_unique_elements = sorted(unique_elements)\n    \n    return sorted_unique_elements", "matching_cluster_idx": 3}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): The list from which to extract unique elements.\n\n    Returns:\n        list: A sorted list of unique elements.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates (sets only store unique elements)\n    unique_set = set(input_list)\n    \n    # Convert the set back to a list and sort it in ascending order\n    sorted_unique_list = sorted(list(unique_set))\n    \n    return sorted_unique_list", "matching_cluster_idx": 3}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): A list containing elements of any hashable type.\n\n    Returns:\n        list: A new list with unique elements from the input, sorted in ascending order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to eliminate duplicates\n    unique_set = set(input_list)\n    \n    # Convert the set back to a list and sort it\n    sorted_unique_list = sorted(list(unique_set))\n    \n    return sorted_unique_list", "matching_cluster_idx": 3}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): The input list that may contain duplicate elements.\n\n    Returns:\n        list: A new list with unique elements from the input, in sorted order.\n\n    Examples:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n\n    # Convert the list to a set to remove duplicates, as sets only store unique elements\n    unique_set = set(input_list)\n    \n    # Convert the set back to a list and sort it\n    unique_sorted_list = sorted(list(unique_set))\n    \n    return unique_sorted_list", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): The input list that may contain duplicate elements.\n\n    Returns:\n        list: A new list with unique elements sorted in ascending order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list\n    unique_list = list(set(input_list))\n    \n    # Sort the list in ascending order\n    unique_list.sort()\n    \n    return unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(input_list: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        input_list (list): The list from which to extract unique elements.\n\n    Returns:\n        list: A new list containing unique elements from the input, in ascending order.\n\n    Examples:\n        >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(input_list))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Parameters:\n    n (int): The upper limit (exclusive) for the range of numbers to check.\n\n    Returns:\n    int: The total count of the digit 7 in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize counter for digit 7 appearances\n    for i in range(n):  # Loop through all numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if number is divisible by 11 or 13\n            count += str(i).count('7')  # Convert number to string and count occurrences of '7'\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) to check for divisibility by 11 or 13 and count digit 7 occurrences.\n\n    Returns:\n        int: The total count of digit 7 in numbers less than n that are divisible by 11 or 13.\n    \"\"\"\n\n    def count_digit_seven(num: int) -> int:\n        \"\"\"Helper function to count occurrences of digit 7 in a number.\"\"\"\n        return str(num).count('7')\n\n    count = 0\n    for i in range(n):  # Iterate over numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if divisible by 11 or 13\n            count += count_digit_seven(i)  # Increment count by occurrences of '7' in the current number\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) for the range of numbers to check.\n\n    Returns:\n        int: The total count of the digit 7 in numbers less than n that are divisible by 11 or 13.\n    \"\"\"\n\n    # Initialize a counter for the digit 7 appearances\n    count_digit_7 = 0\n\n    # Loop through all numbers less than n\n    for i in range(n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to a string to easily count the occurrences of '7'\n            str_i = str(i)\n            # Count the occurrences of '7' in the string representation of the number\n            count_digit_7 += str_i.count('7')\n\n    return count_digit_7", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) for checking numbers.\n\n    Returns:\n        int: Count of digit 7 appearances in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize counter for digit 7 appearances\n    for i in range(1, n):  # Loop through numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if divisible by 11 or 13\n            count += str(i).count('7')  # Count '7's in the number as a string\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) for the range of numbers to check.\n\n    Returns:\n        int: The count of digit 7 appearances in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize count of digit 7 appearances\n    for i in range(n):  # Iterate over numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if divisible by 11 or 13\n            count += str(i).count('7')  # Count occurrences of '7' in the string representation of i\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) for the range of numbers to check.\n\n    Returns:\n        int: The count of digit 7 appearances in numbers less than n that are divisible by 11 or 13.\n    \"\"\"\n\n    # Initialize a counter for the digit 7 appearances\n    count_sevens = 0\n\n    # Iterate over all numbers less than n\n    for i in range(n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to a string to easily count the occurrences of '7'\n            str_i = str(i)\n            # Count the occurrences of '7' in the string representation of the number\n            count_sevens += str_i.count('7')\n\n    return count_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) for the range of integers to check.\n\n    Returns:\n        int: The count of digit 7 appearances in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize count for digit 7 appearances\n    for i in range(1, n):  # Iterate over numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if divisible by 11 or 13\n            count += str(i).count('7')  # Count occurrences of '7' in the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n    n (int): The upper limit (exclusive).\n\n    Returns:\n    int: Count of digit 7 in numbers divisible by 11 or 13 below n.\n    \"\"\"\n    count = 0  # Initialize a counter for the digit 7 appearances\n    for i in range(1, n):  # Loop through all numbers below n\n        if i % 11 == 0 or i % 13 == 0:  # Check if divisible by 11 or 13\n            count += str(i).count('7')  # Count occurrences of '7' in the string representation of i\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive).\n\n    Returns:\n        int: The count of digit 7 in numbers divisible by 11 or 13.\n    \"\"\"\n\n    # Initialize a counter for digit 7 appearances\n    count_digit_7 = 0\n    \n    # Loop through all numbers less than n\n    for i in range(n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to a string to easily count occurrences of '7'\n            str_i = str(i)\n            # Count the occurrences of '7' in the string representation of the number\n            count_digit_7 += str_i.count('7')\n    \n    # Return the total count of digit 7\n    return count_digit_7", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n    n (int): The upper limit (exclusive) for the range of numbers to check.\n\n    Returns:\n    int: The count of digit 7 appearances in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize counter for digit 7 appearances\n    for i in range(1, n):  # Iterate over all numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if divisible by 11 or 13\n            count += str(i).count('7')  # Count occurrences of '7' in the string representation of the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) for the range of numbers to check.\n\n    Returns:\n        int: The count of digit 7 appearances in numbers divisible by 11 or 13 below n.\n    \"\"\"\n    count = 0  # Initialize counter for digit 7 appearances\n    for i in range(n):  # Iterate over all integers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if i is divisible by 11 or 13\n            count += str(i).count('7')  # Count occurrences of '7' in the string representation of i\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n    n (int): The upper limit (exclusive).\n\n    Returns:\n    int: The count of digit 7 appearances in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):  # Iterate from 1 up to but not including 'n'\n        if i % 11 == 0 or i % 13 == 0:  # Check divisibility by 11 or 13\n            count += str(i).count('7')  # Count occurrences of '7' in the string representation of the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n    n (int): The upper limit for checking numbers.\n\n    Returns:\n    int: Count of digit 7 appearances in numbers less than n, divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize counter for digit 7 appearances\n    for i in range(1, n):  # Iterate over numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if number is divisible by 11 or 13\n            count += str(i).count('7')  # Increment count by the occurrences of '7' in the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) for the range of numbers to check.\n\n    Returns:\n        int: Count of digit 7 appearances in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize a counter for digit 7 appearances\n    for i in range(n):  # Iterate over all numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if number is divisible by 11 or 13\n            count += str(i).count('7')  # If so, count occurrences of '7' in the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    :param n: The upper limit (exclusive)\n    :return: Count of digit 7 appearances in numbers less than n that are divisible by 11 or 13\n    \"\"\"\n    count = 0  # Initialize count of digit 7 appearances\n    for i in range(1, n):  # Iterate through numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if number is divisible by 11 or 13\n            count += str(i).count('7')  # Increment count by the number of '7's in the number's string representation\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) for checking numbers.\n\n    Returns:\n        int: Count of digit 7 appearances in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize counter for digit 7 appearances\n    for i in range(1, n):  # Loop through numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if divisible by 11 or 13\n            count += str(i).count('7')  # Count occurrences of '7' in the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n    n (int): The upper limit (exclusive).\n\n    Returns:\n    int: The count of digit 7 occurrences in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize count of digit 7 appearances\n    for i in range(n):  # Loop through numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if number is divisible by 11 or 13\n            count += str(i).count('7')  # Increment count by occurrences of '7' in the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive).\n\n    Returns:\n        int: Count of digit 7 appearances in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize count of digit 7 appearances\n    for i in range(1, n):  # Loop through numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if number is divisible by 11 or 13\n            count += str(i).count('7')  # Count occurrences of '7' in the number's string representation\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive) for checking numbers.\n\n    Returns:\n        int: The count of digit 7 appearances in numbers divisible by 11 or 13.\n    \"\"\"\n    count = 0  # Initialize count of digit 7 appearances\n    for i in range(1, n):  # Iterate over numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if number is divisible by 11 or 13\n            count += str(i).count('7')  # Increment count by occurrences of '7' in the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n        n (int): The upper limit (exclusive).\n\n    Returns:\n        int: The count of digit 7 appearances in numbers divisible by 11 or 13 below n.\n    \"\"\"\n    count = 0  # Initialize a counter for the digit 7 appearances\n    for i in range(1, n):  # Loop through all numbers less than n\n        if i % 11 == 0 or i % 13 == 0:  # Check if the number is divisible by 11 or 13\n            count += str(i).count('7')  # If divisible, count the occurrences of '7' in the number's string representation\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 98.0, "profiled": [{"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list `sorted_list` \n    such that `sorted_list` is identical to `input_list` at the odd indices, \n    while its values at the even indices are equal to the values of the even indices \n    of `input_list`, but sorted.\n\n    :param input_list: The input list to be processed\n    :return: A new list with sorted even indices\n    \"\"\"\n\n    # Extract elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements in ascending order\n    even_elements.sort()\n    \n    # Initialize an empty list to store the result\n    sorted_list = []\n    \n    # Initialize an index to track the current even element to insert\n    even_index = 0\n    \n    # Iterate over the range of the length of the input list\n    for i in range(len(input_list)):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            sorted_list.append(even_elements[even_index])\n            even_index += 1\n        # If the index is odd, append the element from the original list\n        else:\n            sorted_list.append(input_list[i])\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list `output_list` \n    such that `output_list` is identical to `input_list` at odd indices, \n    while its values at the even indices are equal to the values of the even indices of `input_list`, but sorted.\n\n    :param input_list: The input list to be processed\n    :return: A new list with sorted even indices\n    \"\"\"\n\n    # Separate even indexed elements from the input list\n    even_indexed_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even indexed elements\n    sorted_even_indexed_elements = sorted(even_indexed_elements)\n    \n    # Initialize an empty list to store the result\n    output_list = []\n    \n    # Initialize a counter to keep track of the current even indexed element to use\n    even_element_index = 0\n    \n    # Iterate over the input list's indices and values\n    for i, value in enumerate(input_list):\n        # If the index is even, append the next sorted even indexed element\n        if i % 2 == 0:\n            output_list.append(sorted_even_indexed_elements[even_element_index])\n            even_element_index += 1\n        # If the index is odd, append the original value\n        else:\n            output_list.append(value)\n    \n    return output_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list.\n    The returned list is identical to `input_list` in the odd indices, \n    while its values at the even indices are equal to the values of the even indices of `input_list`, but sorted.\n\n    :param input_list: Input list to be processed\n    :return: Processed list with even indices sorted\n    \"\"\"\n    # Separate elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements\n    sorted_even_elements = sorted(even_elements)\n    \n    # Initialize an empty list to store the result\n    result_list = []\n    \n    # Counter to keep track of the current position in sorted_even_elements\n    even_counter = 0\n    \n    # Iterate over the indices and values of the input list\n    for i, val in enumerate(input_list):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            result_list.append(sorted_even_elements[even_counter])\n            even_counter += 1\n        # If the index is odd, append the original value\n        else:\n            result_list.append(val)\n    \n    return result_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a new list where values at even indices are sorted \n    while values at odd indices remain unchanged from the original list.\n\n    Args:\n        input_list (list): The input list to be processed.\n\n    Returns:\n        list: A new list with even indices sorted and odd indices unchanged.\n    \"\"\"\n    # Separate elements at even indices\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements\n    even_elements.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize an index to track the current even element to insert\n    even_index = 0\n    \n    # Iterate over the range of input list length\n    for i in range(len(input_list)):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        # If the index is odd, append the original element at this index\n        else:\n            result.append(input_list[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a new list where values at even indices \n    are sorted (among themselves) while values at odd indices remain unchanged.\n\n    Args:\n        input_list (list): The input list to be processed.\n\n    Returns:\n        list: A new list with sorted even indices and unchanged odd indices.\n    \"\"\"\n\n    # Separate elements at even and odd indices\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    odd_elements = [input_list[i] for i in range(1, len(input_list), 2)]\n\n    # Sort the even elements\n    even_elements.sort()\n\n    # Merge the sorted even elements with the unchanged odd elements\n    result = []\n    even_idx, odd_idx = 0, 0\n    for i in range(len(input_list)):\n        if i % 2 == 0:  # Even index\n            result.append(even_elements[even_idx])\n            even_idx += 1\n        else:           # Odd index\n            result.append(odd_elements[odd_idx])\n            odd_idx += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list where:\n    - Values at odd indices remain identical to those in `input_list`.\n    - Values at even indices are the sorted values from the even indices of `input_list`.\n\n    :param input_list: The input list to be processed.\n    :return: A new list with the described sorting and preservation properties.\n    \"\"\"\n\n    # Separate elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements\n    sorted_even_elements = sorted(even_elements)\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Index to track the current even element to insert\n    even_idx = 0\n    \n    # Iterate over the range of input list indices\n    for i in range(len(input_list)):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            result.append(sorted_even_elements[even_idx])\n            even_idx += 1\n        # If the index is odd, append the original element from the input list\n        else:\n            result.append(input_list[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a modified list where:\n    - Values at odd indices remain the same as in the original list.\n    - Values at even indices are the same as in the original list but sorted.\n\n    Args:\n        input_list (list): The input list to be modified.\n\n    Returns:\n        list: The modified list as per the problem statement.\n    \"\"\"\n\n    # Extract elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements\n    even_elements.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to keep track of the current even element to insert\n    even_counter = 0\n    \n    # Iterate over the indices and values of the input list\n    for i, val in enumerate(input_list):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            result.append(even_elements[even_counter])\n            even_counter += 1\n        # If the index is odd, append the original value\n        else:\n            result.append(val)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a list `output_list` \n    such that `output_list` is identical to `input_list` in the odd indices, \n    while its values at the even indices are equal to the values of the even indices of `input_list`, but sorted.\n\n    :param input_list: The input list to be processed.\n    :return: A new list with sorted even indices.\n    \"\"\"\n    # Separate elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements\n    sorted_even_elements = sorted(even_elements)\n    \n    # Initialize an empty list to store the result\n    output_list = []\n    \n    # Initialize a counter to keep track of the current even element to insert\n    even_index = 0\n    \n    # Iterate over the range of input list indices\n    for i in range(len(input_list)):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            output_list.append(sorted_even_elements[even_index])\n            even_index += 1\n        # If the index is odd, append the original element from the input list\n        else:\n            output_list.append(input_list[i])\n    \n    return output_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a new list where:\n    - Values at odd indices remain the same as in the original list.\n    - Values at even indices are the sorted values from the even indices of the original list.\n\n    :param input_list: The input list to be processed.\n    :return: A new list with the described modifications.\n    \"\"\"\n    # Extract elements at even indices, sort them, and store in a list\n    even_sorted = sorted([input_list[i] for i in range(0, len(input_list), 2)])\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to track the current even index value to insert\n    even_index_counter = 0\n    \n    # Iterate over the range of input list indices\n    for i in range(len(input_list)):\n        # If the index is even, append the next even sorted value\n        if i % 2 == 0:\n            result.append(even_sorted[even_index_counter])\n            even_index_counter += 1\n        # If the index is odd, append the original value from the input list\n        else:\n            result.append(input_list[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a list `output_list` \n    such that `output_list` is identical to `input_list` in the odd indices, \n    while its values at the even indices are equal to the values of the even \n    indices of `input_list`, but sorted.\n\n    :param input_list: The input list to be processed\n    :return: A new list with even indices sorted from the original list's even indices\n    \"\"\"\n\n    # Extract elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements in ascending order\n    sorted_even_elements = sorted(even_elements)\n    \n    # Initialize an empty list to store the result\n    output_list = []\n    \n    # Initialize a counter to keep track of the current sorted even element to use\n    even_index = 0\n    \n    # Iterate over the indices and values of the input list\n    for i, value in enumerate(input_list):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            output_list.append(sorted_even_elements[even_index])\n            even_index += 1\n        # If the index is odd, append the original value\n        else:\n            output_list.append(value)\n    \n    return output_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a new list where values at even indices are \n    sorted (while maintaining their even positioning), and values at odd indices remain \n    unchanged from the original list.\n\n    :param input_list: The input list to be processed.\n    :return: A new list with even-indexed elements sorted.\n    \"\"\"\n\n    # Separate elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even-indexed elements\n    sorted_even_elements = sorted(even_elements)\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to keep track of the current even element to insert\n    even_counter = 0\n    \n    # Iterate over the range of the length of the input list\n    for i in range(len(input_list)):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            result.append(sorted_even_elements[even_counter])\n            even_counter += 1\n        # If the index is odd, append the original element from the input list\n        else:\n            result.append(input_list[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a list `output_list` such that:\n    - `output_list` is identical to `input_list` at the odd indices (0-based indexing).\n    - Values at the even indices in `output_list` are equal to the values of the even indices in `input_list`, but sorted.\n\n    :param input_list: The input list to be processed.\n    :return: A new list with even indices sorted based on the original list's even indices.\n    \"\"\"\n\n    # Extract elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements in ascending order\n    sorted_even_elements = sorted(even_elements)\n    \n    # Initialize an empty list to store the result\n    output_list = []\n    \n    # Initialize a counter to keep track of the current sorted even element to insert\n    even_counter = 0\n    \n    # Iterate over the range of the length of the input list\n    for i in range(len(input_list)):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            output_list.append(sorted_even_elements[even_counter])\n            even_counter += 1\n        # If the index is odd, append the original element from the input list\n        else:\n            output_list.append(input_list[i])\n    \n    return output_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a new list where:\n    - Values at odd indices remain identical to the original list.\n    - Values at even indices are the sorted values from the even indices of the original list.\n\n    :param input_list: The input list to process.\n    :return: A new list with even-indexed elements sorted, odd-indexed elements unchanged.\n    \"\"\"\n    # Extract elements at even indices from the input list\n    even_indexed_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even-indexed elements\n    sorted_even_elements = sorted(even_indexed_elements)\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Counter to keep track of the current even-indexed element to insert\n    even_counter = 0\n    \n    # Iterate over the indices and values of the input list\n    for i, value in enumerate(input_list):\n        # If the index is even, append the next sorted even-indexed element\n        if i % 2 == 0:\n            result.append(sorted_even_elements[even_counter])\n            even_counter += 1\n        # If the index is odd, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list `l` and returns a list `l'` such that\n    `l'` is identical to `l` in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of `l`, but sorted.\n\n    Args:\n        l (list): Input list to be processed.\n\n    Returns:\n        list: The modified list with even indices sorted.\n    \"\"\"\n    # Separate elements at even indices from the input list\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even elements in ascending order\n    even_elements.sort()\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize an index to keep track of the current even element to insert\n    even_index = 0\n    \n    # Iterate over the input list with enumerate to access both index and value\n    for i, val in enumerate(l):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        # If the index is odd, append the original value\n        else:\n            result.append(val)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a new list where values at even indices are \n    sorted among themselves, while values at odd indices remain unchanged.\n\n    Args:\n        input_list (list): The input list to be processed.\n\n    Returns:\n        list: A new list with even index values sorted, odd index values unchanged.\n    \"\"\"\n\n    # Separate elements at even indices\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements\n    even_elements.sort()\n    \n    # Initialize an empty list to store the result\n    sorted_list = []\n    \n    # Initialize an index to track the current even element to insert\n    even_index = 0\n    \n    # Iterate over the range of input list indices\n    for i in range(len(input_list)):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            sorted_list.append(even_elements[even_index])\n            even_index += 1\n        # If the index is odd, append the original element at this index\n        else:\n            sorted_list.append(input_list[i])\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a list `output_list` \n    such that `output_list` is identical to `input_list` in the odd indices, \n    while its values at the even indices are equal to the values of the even indices of `input_list`, but sorted.\n\n    :param input_list: The input list to be processed\n    :return: The processed list with even indices sorted\n    \"\"\"\n\n    # Extract elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the extracted even elements\n    sorted_even_elements = sorted(even_elements)\n    \n    # Initialize an empty list to store the result\n    output_list = []\n    \n    # Initialize a counter to keep track of the current even element to insert\n    even_counter = 0\n    \n    # Iterate over the input list with both index and value\n    for i, value in enumerate(input_list):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            output_list.append(sorted_even_elements[even_counter])\n            even_counter += 1\n        # If the index is odd, append the original element\n        else:\n            output_list.append(value)\n    \n    return output_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list `output_list`.\n    `output_list` is identical to `input_list` at the odd indices, while its values at the even indices are equal to the values of the even indices of `input_list`, but sorted.\n\n    :param input_list: The input list to be processed\n    :return: A new list with even indices sorted based on input's even indices\n    \"\"\"\n\n    # Separate elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements\n    even_elements.sort()\n    \n    # Initialize an empty list to store the result\n    output_list = []\n    \n    # Counter to keep track of the current even element to insert\n    even_counter = 0\n    \n    # Iterate over the range of input list indices\n    for i in range(len(input_list)):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            output_list.append(even_elements[even_counter])\n            even_counter += 1\n        # If the index is odd, append the original element from the input list\n        else:\n            output_list.append(input_list[i])\n    \n    return output_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a new list where:\n    - Values at odd indices remain unchanged from the original list.\n    - Values at even indices are the sorted values from the even indices of the original list.\n\n    :param input_list: The input list to process\n    :return: A new list with even indices sorted and odd indices unchanged\n    \"\"\"\n\n    # Extract elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements in ascending order\n    sorted_even_elements = sorted(even_elements)\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize a counter to keep track of the current even element to insert\n    even_counter = 0\n    \n    # Iterate over the input list with both index and value\n    for i, value in enumerate(input_list):\n        # If the index is even, append the next sorted even element\n        if i % 2 == 0:\n            result.append(sorted_even_elements[even_counter])\n            even_counter += 1\n        # If the index is odd, append the original value\n        else:\n            result.append(value)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list and returns a modified list where values at even indices \n    are sorted (among themselves) while values at odd indices remain unchanged.\n\n    Args:\n        input_list (list): The input list to be processed.\n\n    Returns:\n        list: A new list with even-indexed elements sorted and odd-indexed elements unchanged.\n    \"\"\"\n\n    # Separate the list into two lists: one for even indices and one for odd indices\n    evenIndexed = [input_list[i] for i in range(0, len(input_list), 2)]\n    oddIndexed = [input_list[i] for i in range(1, len(input_list), 2)]\n\n    # Sort the list of elements from even indices\n    evenIndexed.sort()\n\n    # Merge the sorted even-indexed elements with the odd-indexed elements\n    # The zip_longest is used to handle lists of different lengths (odd length input list)\n    from itertools import zip_longest\n    result = [val for pair in zip_longest(evenIndexed, oddIndexed) for val in pair if val is not None]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(input_list: list) -> list:\n    \"\"\"\n    This function takes a list `input_list` and returns a new list `output_list` \n    such that `output_list` is identical to `input_list` at odd indices, \n    while its values at the even indices are equal to the values of the even indices of `input_list`, but sorted.\n\n    :param input_list: The input list to be processed\n    :return: A new list with even indices sorted from the original list's even indices\n    \"\"\"\n    # Separate elements at even indices from the input list\n    even_elements = [input_list[i] for i in range(0, len(input_list), 2)]\n    \n    # Sort the even elements in ascending order\n    sorted_even_elements = sorted(even_elements)\n    \n    # Initialize an empty list to store the result\n    output_list = []\n    \n    # Index to track the current position in sorted_even_elements\n    even_idx = 0\n    \n    # Iterate over the input list with both index and value\n    for idx, val in enumerate(input_list):\n        # If the index is even, append the next sorted even element\n        if idx % 2 == 0:\n            output_list.append(sorted_even_elements[even_idx])\n            even_idx += 1\n        # If the index is odd, append the original value\n        else:\n            output_list.append(val)\n    \n    return output_list", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 54.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, efficiently handling large 'n' values to avoid numerics issues.\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Utilize Python's built-in support for arbitrary-precision arithmetic\n    # and the pow() function's ability to compute (base^exponent) % modulus efficiently\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, handling large numbers efficiently.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    # Using the built-in pow function with three arguments, \n    # which computes (base^exponent) % modulus efficiently\n    # to avoid large intermediate results.\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p. This function uses the built-in `pow` function with \n    three arguments to efficiently compute the power with modulus, avoiding \n    potential numeric overflow issues for large `n`.\n\n    Args:\n        n (int): The exponent to which 2 is raised.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p efficiently using exponentiation by squaring.\n\n    Args:\n    n (int): The exponent.\n    p (int): The modulus.\n\n    Returns:\n    int: 2^n modulo p.\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    # Use the built-in pow function with three arguments for efficient modulo computation\n    # The third argument (p) is the modulus, which prevents the numbers from getting too large\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p. This function uses the property of modular arithmetic \n    to efficiently compute the result, avoiding potential numeric overflow for large n.\n\n    Args:\n        n (int): The exponent to which 2 is raised.\n        p (int): The modulo value.\n\n    Returns:\n        int: The result of (2^n) % p.\n    \"\"\"\n    # Use built-in pow function with three arguments, which computes (base^exponent) % modulus efficiently\n    # This approach prevents numeric overflow for large inputs by performing the modulo at each step\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, handling large numbers efficiently using the built-in pow function with three arguments.\n\n    The pow() function with three arguments computes (base^exponent) % modulus efficiently.\n    For this problem, base=2, exponent=n, and modulus=p.\n\n    :param n: The exponent to which 2 is raised.\n    :param p: The modulus.\n    :return: (2^n) % p\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Calculate 2^n modulo p efficiently to avoid numeric overflow.\n\n    Args:\n    n (int): The power to which 2 is raised.\n    p (int): The modulo value.\n\n    Returns:\n    int: The result of 2^n modulo p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    # Use the built-in pow function with three arguments, which computes (base^exponent) % modulus efficiently\n    # This avoids potential numeric overflow for large inputs\n    result = pow(2, n, p)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Compute 2^n modulo p efficiently to avoid numeric overflow.\n\n    Args:\n    - n (int): The exponent.\n    - p (int): The modulus.\n\n    Returns:\n    - int: The result of 2^n modulo p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    # Use the built-in pow function with three arguments, which computes (base^exponent) % modulus efficiently.\n    # This approach avoids potential numeric overflow for large 'n'.\n    result = pow(2, n, p)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Calculate 2^n modulo p efficiently to avoid numeric overflow.\n\n    Args:\n    n (int): The power to which 2 is raised.\n    p (int): The modulus.\n\n    Returns:\n    int: The result of 2^n modulo p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Use Python's built-in pow function, which can compute (base^exponent) % modulus efficiently\n    # This avoids numeric overflow by performing the modulo at each step of the exponentiation\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, avoiding potential numeric overflow by using the properties of modular arithmetic.\n\n    Args:\n    n (int): The exponent to which 2 is raised.\n    p (int): The modulus.\n\n    Returns:\n    int: The result of 2^n modulo p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    # Use the built-in pow function, which can compute (base^exponent) % modulus efficiently,\n    # avoiding potential numeric overflow for large inputs.\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p.\n\n    This function uses the built-in `pow` function with three arguments, \n    which efficiently calculates the power modulo p to avoid large numbers.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, utilizing exponentiation by squaring for efficiency.\n    \n    Parameters:\n    n (int): The exponent.\n    p (int): The modulus.\n    \n    Returns:\n    int: The result of 2^n modulo p.\n    \"\"\"\n    # Utilize built-in pow function with three arguments, \n    # which computes (base^exponent) % modulus efficiently\n    # to avoid potential numerics issues with large numbers.\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, efficiently handling large numbers using exponentiation by squaring.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n    \"\"\"\n    # Use the built-in pow function, which efficiently calculates (base^exponent) % modulus\n    # This approach avoids potential numeric overflow for large inputs\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (efficient computation to avoid numeric overflow).\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n    \"\"\"\n    # Use the built-in pow function with three arguments, which computes (base^exponent) % modulus efficiently\n    # This avoids potential numeric overflow for large n\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p.\n\n    This function efficiently calculates 2 raised to the power of n, \n    then returns the result modulo p to avoid numerical instability \n    with large numbers.\n\n    Args:\n    n (int): The exponent.\n    p (int): The modulo.\n\n    Returns:\n    int: The result of (2^n) % p.\n    \"\"\"\n    # Using built-in pow() with three arguments, which computes (base^exponent) % modulus efficiently\n    # This approach avoids computing the full power first, thus preventing potential numeric overflow\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Calculate 2^n modulo p efficiently to avoid numeric overflow.\n\n    Args:\n    n (int): The exponent.\n    p (int): The modulus.\n\n    Returns:\n    int: The result of 2^n modulo p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    # Use the built-in pow function, which can handle three arguments:\n    #   - the base (2 in this case)\n    #   - the exponent (n)\n    #   - the modulus (p), which prevents numeric overflow\n    result = pow(2, n, p)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p. This function uses the property of modular arithmetic \n    and the built-in `pow` function for efficient computation, avoiding numeric \n    overflow for large inputs.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n    \"\"\"\n    # Use Python's built-in pow function with three arguments, which efficiently \n    # computes (base^exponent) % modulus, avoiding potential overflow.\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (efficient for large numbers).\n\n    **Args:**\n    - `n (int)`: The power to which 2 is raised.\n    - `p (int)`: The modulo base.\n\n    **Returns:**\n    - `int`: The result of 2^n modulo p.\n\n    **Examples:**\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Using built-in pow function with three arguments for efficiency\n    # The third argument is the modulus, which prevents large numbers\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, efficiently handling large numbers to avoid numerics issues.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n\n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    # Use Python's built-in pow function with three arguments, which efficiently calculates (base^exponent) % modulus\n    # This approach avoids numeric issues for large numbers by not calculating the full power first\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, utilizing the property of modular arithmetic\n    to prevent numeric overflow for large inputs.\n\n    Args:\n        n (int): The exponent.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of 2^n modulo p.\n    \"\"\"\n    # Use the built-in pow function, which can compute (base^exponent) % modulus efficiently\n    # to prevent numeric overflow for large inputs.\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 96.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    Parameters:\n    text (str): The input string from which vowels will be removed.\n    \n    Returns:\n    str: The input string with all vowels (both lowercase and uppercase) removed.\n    \"\"\"\n    # Define vowels in both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels from the input string\n    # and then join the characters back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text: str) -> str:\n    \"\"\"\n    Removes all vowels (both lowercase and uppercase) from a given text.\n\n    Args:\n        text (str): The input string from which vowels will be removed.\n\n    Returns:\n        str: The input string with all vowels removed.\n    \"\"\"\n    # Define a string containing all lowercase and uppercase vowels\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to iterate over each character in the text\n    # If the character is not in the vowels string, include it in the new string\n    # Then join all characters back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    Parameters:\n    - text (str): The input string from which vowels will be removed.\n    \n    Returns:\n    - str: The input string with all vowels (both lowercase and uppercase) removed.\n    \"\"\"\n    # Define vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels and then join the characters back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text: str) -> str:\n    \"\"\"\n    Removes all vowels from the input string, regardless of case.\n    \n    Args:\n        text (str): The input string.\n    \n    Returns:\n        str: The input string without vowels.\n    \"\"\"\n    # Define vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels and join the result back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    Parameters:\n    text (str): The input string from which vowels will be removed.\n    \n    Returns:\n    str: The input string with all vowels (both lowercase and uppercase) removed.\n    \"\"\"\n    # Define a string of vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels from the input text\n    # and join the remaining characters back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Removes vowels from a given string and returns the result.\n\n    :param text: The input string from which vowels are to be removed.\n    :return: String without vowels.\n    \"\"\"\n    # Define vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels from the input string\n    # and join the characters back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Removes all vowels from a given string, ignoring case.\n    \n    Args:\n    text (str): The input string.\n    \n    Returns:\n    str: The input string without vowels.\n    \"\"\"\n    # Define vowels in both lower and upper case\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels and then join the result back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    :param text: Input string\n    :return: String without vowels\n    \"\"\"\n    # Define vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to iterate over each character in the text\n    # If the character is not a vowel, include it in the new string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Removes all vowels (both lowercase and uppercase) from a given text.\n\n    Args:\n        text (str): The input string from which vowels are to be removed.\n\n    Returns:\n        str: The input string without vowels.\n    \"\"\"\n    # Define a string of vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels and join the result back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Removes vowels from a given string.\n\n    Args:\n        text (str): The input string from which vowels are to be removed.\n\n    Returns:\n        str: The input string with all vowels (both lowercase and uppercase) removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n\n    # Define vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n\n    # Use a list comprehension to filter out vowels and join back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    Args:\n        text (str): The input string from which vowels are to be removed.\n\n    Returns:\n        str: The input string without vowels.\n    \"\"\"\n    # Define vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels and join the result back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Removes all vowels (both lowercase and uppercase) from the input string.\n\n    Args:\n        text (str): The input string from which vowels are to be removed.\n\n    Returns:\n        str: The input string without any vowels.\n    \"\"\"\n    # Define a string of vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels from the input string\n    # The `if char not in vowels` condition ensures only non-vowel characters are included\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Removes all vowels from the input string.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        str: The input string without vowels.\n    \"\"\"\n    # Define all lowercase and uppercase vowels\n    vowels = 'aeiouAEIOU'\n\n    # Use a list comprehension to filter out vowels from the string\n    # and join the result back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text: str) -> str:\n    \"\"\"\n    Removes all vowels from a given text, regardless of case, and returns the result.\n\n    :param text: The input string to remove vowels from\n    :return: String without vowels\n    \"\"\"\n    # Define vowels in both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels and join back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    :param text: The input string\n    :return: The input string without vowels\n    \"\"\"\n    # Define vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels from the input text\n    # The `if char not in vowels` condition ensures only non-vowel characters are included\n    text_without_vowels = ''.join([char for char in text if char not in vowels])\n    \n    return text_without_vowels", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text: str) -> str:\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \n    :param text: Input string\n    :return: String without vowels\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    Parameters:\n    text (str): The input string from which vowels are to be removed.\n\n    Returns:\n    str: The input string with all vowels (both lowercase and uppercase) removed.\n    \"\"\"\n    # Define vowels in both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension with conditional to filter out vowels\n    # and then join the characters back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    Args:\n        text (str): The input string from which vowels will be removed.\n\n    Returns:\n        str: The input string with all vowels (both lowercase and uppercase) removed.\n    \"\"\"\n    # Define vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels from the input text\n    # and then join the characters back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    Parameters:\n    text (str): The input string from which vowels are to be removed.\n\n    Returns:\n    str: The input string with all vowels (both lowercase and uppercase) removed.\n    \"\"\"\n    # Define a string of vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to iterate over each character in the text\n    # If the character is not in the vowels string, include it in the new string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    :param text: Input string from which vowels will be removed.\n    :return: String without vowels.\n    \"\"\"\n    # Define vowels in both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n    \n    # Use a list comprehension to filter out vowels and join the result back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Args:\n        s0 (str): The first string to compare.\n        s1 (str): The second string to compare.\n\n    Returns:\n        bool: True if both strings contain the same characters, regardless of frequency or order; False otherwise.\n\n    Examples:\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n        True\n        >>> same_chars('abcd', 'dddddddabc')\n        True\n        >>> same_chars('dddddddabc', 'abcd')\n        True\n        >>> same_chars('eabcd', 'dddddddabc')\n        False\n        >>> same_chars('abcd', 'dddddddabce')\n        False\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n        False\n    \"\"\"\n\n    # Convert both strings to sets, which automatically removes duplicates and allows for efficient membership testing\n    # This approach focuses on the uniqueness of characters, not their counts\n    set0 = set(s0)\n    set1 = set(s1)\n\n    # Compare the two sets. If they are equal, it means both strings have the same characters (regardless of how many times each character appears)\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function disregards the quantity of each character, only checking if both strings\n    are composed of the same characters, regardless of their counts or order.\n\n    :param s0: First string to compare\n    :param s1: Second string to compare\n    :return: True if both strings have the same characters, False otherwise\n    \"\"\"\n\n    # Convert both strings to sets, which automatically removes duplicates and \n    # allows for efficient membership testing. This approach ignores character counts.\n    set0 = set(s0)\n    set1 = set(s1)\n\n    # Two strings have the same characters if their sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of frequency and order.\n    \n    Args:\n        s0 (str): The first string to compare.\n        s1 (str): The second string to compare.\n    \n    Returns:\n        bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and \n    # makes the order irrelevant. Then, compare these sets for equality.\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of quantity and order.\n\n    Args:\n        s0 (str): The first string to compare.\n        s1 (str): The second string to compare.\n\n    Returns:\n        bool: True if both strings contain the same characters, False otherwise.\n\n    Examples:\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n        True\n        >>> same_chars('abcd', 'dddddddabc')\n        True\n        >>> same_chars('dddddddabc', 'abcd')\n        True\n        >>> same_chars('eabcd', 'dddddddabc')\n        False\n        >>> same_chars('abcd', 'dddddddabce')\n        False\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n        False\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and allows for efficient membership testing\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Two strings have the same characters if and only if their sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two input strings contain the same characters, \n    disregarding the frequency and order of appearance.\n\n    Args:\n        s0 (str): The first input string.\n        s1 (str): The second input string.\n\n    Returns:\n        bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and \n    # ignores order, then compare these sets for equality.\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first input string.\n    s1 (str): The second input string.\n    \n    Returns:\n    bool: True if s0 and s1 contain the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare\n    # Sets in Python are unordered collections of unique elements, ideal for this comparison\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Compare the two sets for equality\n    # Two sets are equal if and only if every element of each set is contained in the other\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    This function ignores the quantity of characters, only checking if both strings \n    contain the same character set, regardless of character repetition or order.\n\n    Parameters:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets of characters, which automatically removes duplicates\n    # and then compare these sets for equality\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import unittest\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of frequency and order.\n\n    :param s0: The first string to compare.\n    :param s1: The second string to compare.\n    :return: True if both strings consist of the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and ignores order\n    # Then, compare the two sets for equality\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of frequency and order.\n\n    Args:\n        s0 (str): The first string to compare.\n        s1 (str): The second string to compare.\n\n    Returns:\n        bool: True if both strings consist of the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and \n    # ignores order, then compare these sets for equality.\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, disregarding frequency and order.\n\n    Args:\n        s0 (str): The first input string.\n        s1 (str): The second input string.\n\n    Returns:\n        bool: True if both strings contain the same characters, False otherwise.\n\n    Examples:\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n        True\n        >>> same_chars('abcd', 'dddddddabc')\n        True\n        >>> same_chars('dddddddabc', 'abcd')\n        True\n        >>> same_chars('eabcd', 'dddddddabc')\n        False\n        >>> same_chars('abcd', 'dddddddabce')\n        False\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n        False\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and \n    # allows for efficient membership testing. This approach disregards character frequency.\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Two sets are equal if and only if every element is common to both sets.\n    # This comparison is order-independent and frequency-independent.\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, disregarding character counts and order.\n    \n    Args:\n        s0 (str): The first string to compare.\n        s1 (str): The second string to compare.\n    \n    Returns:\n        bool: True if both strings contain the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and ignores order\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Two sets are equal if and only if they have the same elements\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Args:\n        s0 (str): The first input string.\n        s1 (str): The second input string.\n\n    Returns:\n        bool: True if both strings contain the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and allows for efficient membership testing\n    # Then, compare the two sets for equality\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Args:\n        s0 (str): The first string.\n        s1 (str): The second string.\n\n    Returns:\n        bool: True if both strings contain the same characters, regardless of quantity; False otherwise.\n\n    Examples:\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n        True\n        >>> same_chars('abcd', 'dddddddabc')\n        True\n        >>> same_chars('dddddddabc', 'abcd')\n        True\n        >>> same_chars('eabcd', 'dddddddabc')\n        False\n        >>> same_chars('abcd', 'dddddddabce')\n        False\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n        False\n    \"\"\"\n\n    # Convert both strings to sets, which automatically removes duplicates.\n    # This approach is case sensitive and considers 'a' and 'A' as different characters.\n    set0 = set(s0)\n    set1 = set(s1)\n\n    # Two strings have the same characters if their sets are equal.\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "import unittest\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of frequency.\n\n    Args:\n        s0 (str): The first word.\n        s1 (str): The second word.\n\n    Returns:\n        bool: True if both words contain the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates\n    # and then compare the sets for equality\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of frequency and order.\n\n    Args:\n        s0 (str): The first string for comparison.\n        s1 (str): The second string for comparison.\n\n    Returns:\n        bool: True if both strings contain the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and \n    # allows for efficient membership testing. This approach does not consider \n    # the frequency of characters, only their presence.\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Two sets are equal if and only if every element of each set is contained \n    # in the other. This perfectly fits our need to check for same characters.\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Args:\n        s0 (str): The first word.\n        s1 (str): The second word.\n\n    Returns:\n        bool: True if both words consist of the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare\n    # This approach assumes order and quantity of characters do not matter\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of frequency or order.\n\n    Args:\n        s0 (str): The first string to compare.\n        s1 (str): The second string to compare.\n\n    Returns:\n        bool: True if both strings contain the same characters, False otherwise.\n\n    Examples:\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n        True\n        >>> same_chars('abcd', 'dddddddabc')\n        True\n        >>> same_chars('dddddddabc', 'abcd')\n        True\n        >>> same_chars('eabcd', 'dddddddabc')\n        False\n        >>> same_chars('abcd', 'dddddddabce')\n        False\n        >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n        False\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates\n    # and then compare these sets for equality\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    This function ignores the count of characters, only checking if both strings\n    contain the same characters regardless of their frequency or order.\n\n    Parameters:\n    - s0 (str): The first input string.\n    - s1 (str): The second input string.\n\n    Returns:\n    - bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and\n    # allows for efficient membership testing. This approach inherently ignores\n    # the count and order of characters.\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Two sets are considered equal if and only if every element of each set is \n    # contained in the other. This is exactly what we need to check for the \n    # problem's condition.\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, ignoring order and frequency.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and ignores order\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the two sets for equality\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of their frequency or order.\n\n    :param s0: First input string\n    :param s1: Second input string\n    :return: True if both strings contain the same characters, False otherwise\n    \"\"\"\n    # Convert both strings to sets, which automatically removes duplicates and allows for efficient membership testing\n    # Then, compare the two sets for equality\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 94.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert input lists to sets for efficient lookup and to eliminate duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets (i.e., common elements)\n    common_elements = set1 & set2\n    \n    # Convert the set of common elements back to a list and sort it\n    sorted_common_list = sorted(list(common_elements))\n    \n    return sorted_common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list for comparison.\n        l2 (list): The second list for comparison.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert lists to sets to efficiently find common elements\n    common_elements = set(l1) & set(l2)\n    \n    # Convert the set back to a list, sort it, and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n    l1 (list): The first list for comparison.\n    l2 (list): The second list for comparison.\n\n    Returns:\n    list: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert lists to sets to eliminate duplicates and enhance lookup efficiency\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list and sort it\n    sorted_common = sorted(list(common_elements))\n    \n    return sorted_common", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and enable efficient lookup\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets (i.e., the common elements)\n    common_elements = set1 & set2\n    \n    # Convert the set of common elements back to a list and sort it\n    sorted_common_elements = sorted(list(common_elements))\n    \n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert input lists to sets to efficiently find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1 & set2\n    \n    # Convert the set back to a list, sort it, and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \n    :param l1: First list to compare\n    :param l2: Second list to compare\n    :return: A sorted list of unique elements common to both input lists\n    \"\"\"\n    # Convert lists to sets to efficiently find unique common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list and sort it\n    sorted_common = sorted(list(common_elements))\n    \n    return sorted_common", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A new list containing the unique common elements of `l1` and `l2`, sorted in ascending order.\n    \"\"\"\n    # Convert lists to sets to efficiently find unique common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets (i.e., the common elements)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list, sort it, and return the result\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert lists to sets for efficient lookup and to remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1 & set2\n    \n    # Convert back to list, sort, and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique common elements found in both input lists.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n\n    # Convert input lists to sets to efficiently find unique common elements\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Use set intersection to find common elements\n    common_elements = set1 & set2\n\n    # Convert the set back to a list and sort it\n    sorted_common_elements = sorted(list(common_elements))\n\n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert lists to sets for efficient lookup and to remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets (i.e., the common elements)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list and sort it\n    sorted_common = sorted(list(common_elements))\n    \n    return sorted_common", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A new list containing the unique common elements of l1 and l2, sorted in ascending order.\n    \"\"\"\n    # Convert lists to sets to efficiently find common elements and remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets (i.e., the common elements)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list and sort it in ascending order\n    sorted_common_elements = sorted(list(common_elements))\n    \n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list for comparison.\n        l2 (list): The second list for comparison.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert lists to sets for efficient lookup and to remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection (common elements) of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list, sort it, and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list for comparison.\n        l2 (list): The second list for comparison.\n    \n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert lists to sets to remove duplicates and enable efficient intersection\n    set1, set2 = set(l1), set(l2)\n    \n    # Find the intersection (common elements) of the two sets\n    common_elements = set1 & set2\n    \n    # Convert the set back to a list, sort it, and return the result\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert lists to sets to efficiently find unique common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1 & set2\n    \n    # Convert the set back to a list and sort it\n    sorted_common_elements = sorted(list(common_elements))\n    \n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert lists to sets to efficiently find unique common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets (i.e., the common elements)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list and sort it\n    sorted_common = sorted(list(common_elements))\n    \n    return sorted_common", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert lists to sets for efficient lookup and to remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert back to list, sort it, and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \n    :param l1: The first list to compare.\n    :param l2: The second list to compare.\n    :return: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert input lists to sets to efficiently find unique common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list and sort it\n    sorted_common_elements = sorted(list(common_elements))\n    \n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list for comparison.\n        l2 (list): The second list for comparison.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n\n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and enhance lookup efficiency\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list, sort it, and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list for comparison.\n        l2 (list): The second list for comparison.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert lists to sets to remove duplicates and enable efficient lookup\n    set1, set2 = set(l1), set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = set1 & set2\n    \n    # Convert the set back to a list, sort it, and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1 (list): The first list to compare.\n        l2 (list): The second list to compare.\n\n    Returns:\n        list: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert lists to sets for efficient lookup and to eliminate duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets (i.e., common elements)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list and sort it\n    sorted_common_elements = sorted(list(common_elements))\n    \n    return sorted_common_elements", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 51.57986111111111, "dps_norm": 67.77777777777777, "pass@1": 90.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. \n    Assume n > 1 and is not a prime.\n\n    :param n: The input number to find the largest prime factor of.\n    :return: The largest prime factor of n.\n    \"\"\"\n\n    def is_prime(m: int) -> bool:\n        \"\"\"Check if a number m is prime.\"\"\"\n        if m < 2:\n            return False\n        for i in range(2, int(m**0.5) + 1):\n            if m % i == 0:\n                return False\n        return True\n\n    # Start checking from the smallest prime number, 2\n    for i in range(2, n + 1):\n        # If i is a factor of n\n        if n % i == 0:\n            # Check if i is prime\n            if is_prime(i):\n                # Initialize or update the largest prime factor\n                largest_factor = i\n            # Continue dividing n by i until it's no longer divisible\n            while n % i == 0:\n                n //= i\n        # If n is reduced to 1, we've found all factors\n        if n == 1:\n            break\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    :param n: The input number (greater than 1, not a prime)\n    :return: The largest prime factor of n\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the smallest prime number\n    potential_factor = 2\n    while potential_factor <= n:\n        # If n is divisible by potential_factor, it's a factor\n        if n % potential_factor == 0:\n            # Check if it's prime and update n to find the largest\n            if is_prime(potential_factor):\n                largest_factor = potential_factor\n                # Divide n by the found factor to check for larger prime factors\n                while n % potential_factor == 0:\n                    n //= potential_factor\n            else:\n                # If not prime, just divide n by this factor to reduce the problem size\n                while n % potential_factor == 0:\n                    n //= potential_factor\n        potential_factor += 1\n        # If n is reduced to a prime number, it's the largest prime factor\n        if n > 1 and is_prime(n):\n            return n\n    return largest_factor", "matching_cluster_idx": 6}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    :param n: The input number (must be greater than 1 and not a prime)\n    :return: The largest prime factor of n\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the largest possible factor to 2\n    for possible_prime in range(n, 1, -1):\n        # Check if 'possible_prime' is a factor of 'n'\n        if n % possible_prime == 0:\n            # Check if the factor is a prime number\n            if is_prime(possible_prime):\n                return possible_prime\n\n    # If no prime factor found (should not reach here based on the problem's assumptions)\n    return None", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    Assume n > 1 and is not a prime.\n\n    :param n: The input number (greater than 1 and not a prime)\n    :return: The largest prime factor of n\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the smallest prime number\n    for possible_prime in range(2, n + 1):\n        # Check if the current number is prime\n        if is_prime(possible_prime):\n            # Continue checking if 'n' is divisible by the prime, starting from the largest to smallest\n            while n % possible_prime == 0:\n                n //= possible_prime\n                # If 'n' is reduced to 1, the last divisor was the largest prime factor\n                if n == 1:\n                    return possible_prime\n    # If no prime factor is found (theoretical, given the problem's assumptions), return None (this should not happen)\n    return None", "matching_cluster_idx": 6}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    :param n: The input number to find the largest prime factor for.\n    :return: The largest prime factor of n.\n    \"\"\"\n\n    # Initialize the largest factor and divisor\n    largest_factor = None\n    divisor = 2\n\n    # Continue dividing until n is reduced to 1\n    while n > 1:\n        # If n is divisible by divisor, update largest_factor and divide n\n        if n % divisor == 0:\n            largest_factor = divisor\n            n = n // divisor\n        else:\n            # If not divisible, increment divisor (checking for next potential factor)\n            divisor += 1\n\n            # Optimization: Only need to check up to the square root of n\n            # since a larger factor of n would be a multiple of a smaller factor that has already been checked\n            if divisor * divisor > n and n > largest_factor:\n                largest_factor = n\n                break\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    :param n: The input number to find the largest prime factor for.\n    :return: The largest prime factor of n.\n    \"\"\"\n\n    def is_prime(candidate: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if candidate < 2:\n            return False\n        for i in range(2, int(candidate ** 0.5) + 1):\n            if candidate % i == 0:\n                return False\n        return True\n\n    # Start checking from the largest possible factor to the smallest\n    for possible_prime in range(n, 1, -1):\n        # Check if 'possible_prime' is indeed a prime number and if it's a factor of n\n        if n % possible_prime == 0 and is_prime(possible_prime):\n            # If both conditions are met, return this prime as it's the largest\n            return possible_prime", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    Assume n > 1 and is not a prime.\n\n    :param n: The input number\n    :return: The largest prime factor of n\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the smallest prime number\n    for potential_factor in range(2, n + 1):\n        # Check if the potential factor is indeed a factor of n\n        if n % potential_factor == 0:\n            # If it's also a prime, and since we're going up, the last one will be the largest\n            if is_prime(potential_factor):\n                largest_so_far = potential_factor\n    return largest_so_far", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    Assume n > 1 and is not a prime.\n\n    :param n: The input number\n    :return: The largest prime factor of n\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the smallest prime number, 2\n    for potential_factor in range(2, n + 1):\n        # If the number is a factor of n\n        if n % potential_factor == 0:\n            # Check if it's prime and if so, keep updating the largest prime factor found\n            if is_prime(potential_factor):\n                largest_factor = potential_factor\n            # If we've found a factor, divide n to reduce the search space for the next iterations\n            while n % potential_factor == 0:\n                n //= potential_factor\n        # If n has been reduced to 1, we've found all its prime factors\n        if n == 1:\n            break\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. \n    Assume n > 1 and is not a prime.\n\n    :param n: The input number (must be greater than 1 and not prime)\n    :return: The largest prime factor of n\n    \"\"\"\n    def is_prime(candidate: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if candidate < 2:\n            return False\n        for i in range(2, int(candidate ** 0.5) + 1):\n            if candidate % i == 0:\n                return False\n        return True\n\n    # Start checking from 2, the smallest prime number\n    for potential_factor in range(n, 1, -1):\n        # Check if 'potential_factor' is a factor of 'n'\n        if n % potential_factor == 0:\n            # Verify if the factor is prime\n            if is_prime(potential_factor):\n                # If it's prime, it's the largest prime factor due to the descending order of the loop\n                return potential_factor", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    :param n: The number to find the largest prime factor of.\n    :return: The largest prime factor of n.\n    \"\"\"\n\n    # Helper function to check if a number is prime\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if num is a prime number.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start from the largest possible factor to find the largest prime factor first\n    for possible_prime in range(n, 1, -1):\n        # Check if 'possible_prime' is a factor of 'n'\n        if n % possible_prime == 0:\n            # Check if the factor is prime\n            if is_prime(possible_prime):\n                # If it's prime, return it as the largest prime factor\n                return possible_prime\n\n    # If no prime factor is found (this should not happen given the problem's assumptions)\n    return None", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    \n    Assumes n > 1 and is not a prime.\n\n    :param n: The number to find the largest prime factor for\n    :return: The largest prime factor of n\n    \"\"\"\n\n    # Helper function to check if a number is prime\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if num is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from 2, the smallest prime number\n    potential_factor = 2\n\n    # Continue checking until we've fully divided n\n    while potential_factor * potential_factor <= n:\n        # If n is divisible by potential_factor, it's a factor\n        if n % potential_factor == 0:\n            # Check if it's prime\n            if is_prime(potential_factor):\n                # If prime, store it and continue to see if there's a larger one\n                largest_factor = potential_factor\n            # Divide n to reduce the problem size\n            n //= potential_factor\n        else:\n            # If not divisible, increment potential_factor\n            potential_factor += 1\n            # Only care about potential factors that are prime for efficiency\n            while not is_prime(potential_factor):\n                potential_factor += 1\n\n    # After the loop, if n > 1, then n itself is a prime factor (the largest)\n    if n > 1:\n        return n\n    else:\n        return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    Assume n > 1 and is not a prime.\n\n    :param n: The input number to find the largest prime factor of\n    :return: The largest prime factor of n\n    \"\"\"\n\n    def is_prime(candidate: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if candidate < 2:\n            return False\n        for i in range(2, int(candidate ** 0.5) + 1):\n            if candidate % i == 0:\n                return False\n        return True\n\n    # Start checking from the smallest prime number, 2\n    for potential_factor in range(2, n + 1):\n        # Check if 'potential_factor' is a factor of 'n'\n        if n % potential_factor == 0:\n            # Check if the factor is prime and if so, keep updating 'largest_prime'\n            if is_prime(potential_factor):\n                largest_prime = potential_factor\n            # Since we're going from smallest to largest, the last prime factor we find will be the largest\n            # So, no need to check the rest if we've found one, just move to the next potential factor of 'n'\n            while n % potential_factor == 0:\n                n //= potential_factor\n        # If 'n' is reduced to 1, we've found all its prime factors\n        if n == 1:\n            break\n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. \n    Assume n > 1 and is not a prime.\n\n    :param n: The input number to find the largest prime factor of.\n    :return: The largest prime factor of n.\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the largest possible factor to 2\n    for possible_factor in range(n, 1, -1):\n        # Check if 'possible_factor' is a factor of 'n'\n        if n % possible_factor == 0:\n            # Check if the factor is prime\n            if is_prime(possible_factor):\n                # If it's prime, return it as the largest prime factor\n                return possible_factor\n\n    # If no prime factor is found (shouldn't happen given the problem's assumptions), return None\n    # This is theoretically unreachable based on the problem statement but included for completeness\n    return None", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    :param n: The input number to find the largest prime factor for\n    :return: The largest prime factor of n\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the smallest prime number\n    for i in range(2, n + 1):\n        # If i is a factor of n\n        if n % i == 0:\n            # Check if i is prime\n            if is_prime(i):\n                # Initialize largest_prime as i if it's the first prime factor found\n                largest_prime = i\n            # Check the corresponding quotient for being prime\n            quotient = n // i\n            if is_prime(quotient):\n                # Update largest_prime if the quotient is larger and prime\n                largest_prime = max(largest_prime, quotient) if 'largest_prime' in locals() else quotient\n    return largest_prime", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    \n    Assume:\n    - n > 1\n    - n is not a prime number\n    \n    :param n: Input number\n    :return: Largest prime factor of n\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the largest possible factor to the smallest\n    for possible_factor in range(n, 1, -1):\n        # Check if 'possible_factor' is indeed a factor of 'n'\n        if n % possible_factor == 0:\n            # Check if the factor is a prime number\n            if is_prime(possible_factor):\n                # If it's prime, return it as the largest prime factor\n                return possible_factor\n\n    # This should not be reached given the problem's assumptions\n    raise ValueError(\"No prime factor found for n, which contradicts the problem's assumptions.\")", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. \n    Assume n > 1 and is not a prime.\n\n    :param n: The input number to find the largest prime factor for.\n    :return: The largest prime factor of n.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"\n        Helper function to check if a number is prime.\n        :param num: Number to check for primality.\n        :return: True if num is prime, False otherwise.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Starting from the smallest prime number, 2\n    potential_factor = 2\n    while potential_factor <= n:\n        # If n is divisible by potential_factor and it's prime, update n and check again\n        if n % potential_factor == 0:\n            if is_prime(potential_factor):\n                largest_factor = potential_factor\n            n = n // potential_factor\n        else:\n            # If not divisible, increment potential_factor\n            # Since we've only checked up to the square root in is_prime, we do the same here for efficiency\n            potential_factor += 1 if potential_factor < 3 else 2  # Increment by 1 for 2, then by 2 to only check odd numbers\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    Assume n > 1 and is not a prime.\n\n    :param n: The input number\n    :return: The largest prime factor of n\n    \"\"\"\n\n    # Helper function to check if a number is prime\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the smallest prime number, 2\n    for potential_factor in range(2, n + 1):\n        # If n is divisible by the potential factor\n        while n % potential_factor == 0:\n            # Divide n by the potential factor\n            n = n // potential_factor\n            # If the remaining n is 1, the last divisor was the largest prime factor\n            if n == 1:\n                return potential_factor\n            # Check if the potential factor is prime\n            if is_prime(potential_factor):\n                # If it's prime, it's the largest prime factor so far\n                largest_so_far = potential_factor\n        # Only check up to the square root of n for efficiency\n        if potential_factor > int(n**0.5) + 1:\n            break\n    # If n itself is a prime number greater than the square root of the original n\n    if is_prime(n):\n        return n\n    # Otherwise, return the largest prime factor found\n    return largest_so_far", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: The input number\n    :return: The largest prime factor of n\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the largest possible factor to 2\n    for potential_factor in range(n, 1, -1):\n        # Check if the number is a factor of n\n        if n % potential_factor == 0:\n            # Check if the factor is a prime number\n            if is_prime(potential_factor):\n                return potential_factor\n\n    # If no prime factor found (should not happen given the problem's assumptions)\n    return None", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. \n    Assume n > 1 and is not a prime.\n\n    :param n: The input number to find the largest prime factor for\n    :return: The largest prime factor of n\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_factors(num: int) -> list:\n        \"\"\"Generate all prime factors of a number.\"\"\"\n        i = 2\n        factors = []\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n                factors.append(i)\n        if num > 1:\n            factors.append(num)\n        return factors\n\n    # Ensure input assumption is not violated\n    if n <= 1:\n        raise ValueError(\"Input number must be greater than 1\")\n\n    # Generate all prime factors and return the largest one\n    factors = prime_factors(n)\n    return max(factors)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    :param n: The input number to find the largest prime factor for.\n    :return: The largest prime factor of n.\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        \"\"\"\n        Helper function to check if a number is prime.\n        \n        :param num: Number to check for primality.\n        :return: True if num is prime, False otherwise.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Start checking from the smallest prime number, 2\n    for i in range(2, n + 1):\n        # If i is a factor of n\n        if n % i == 0:\n            # Check if i is prime\n            if is_prime(i):\n                # If it's prime, update the largest prime factor\n                largest_factor = i\n            # Continue dividing n by i until it's no longer divisible\n            while n % i == 0:\n                n //= i\n        # If n is reduced to 1, all factors have been found\n        if n == 1:\n            break\n\n    return largest_factor", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 56.298701298701296, "dps_norm": 50.0, "pass@1": 77.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string. \n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' when 'y' is at the end of the string.\n    \n    Parameters:\n    s (str): The input string to count vowels in.\n    \n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    # Convert the string to lowercase to handle both lower and uppercase vowels\n    s = s.lower()\n    \n    # Initialize a counter for vowels\n    count = 0\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if the character is a vowel\n        if char in 'aeiou':\n            count += 1\n        # Special case for 'y' when it's at the end of the string\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n            \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in a given string.\n    Vowels considered are 'a', 'e', 'i', 'o', 'u', and 'y' when at the end.\n\n    Parameters:\n    s (str): The input string to count vowels in.\n\n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    # Convert string to lowercase for case-insensitive comparison\n    s = s.lower()\n    \n    # Initialize vowel count\n    count = 0\n    \n    # Check each character in the string\n    for i, char in enumerate(s):\n        # 'y' is a vowel only if it's at the end of the string\n        if (char in 'aeiou') or (char == 'y' and i == len(s) - 1):\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in the given string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u' (case-insensitive).\n    'y' is also considered a vowel when it appears at the end of the string.\n\n    Parameters:\n    s (str): The input string to count vowels from.\n\n    Returns:\n    int: The total count of vowels in the string.\n    \"\"\"\n\n    # Convert the string to lower case to make the function case-insensitive\n    s = s.lower()\n    \n    # Initialize a counter for vowels\n    count = 0\n    \n    # Define vowels (including 'y' as a special case at the end of the string)\n    vowels = 'aeiou'\n    \n    # Check each character in the string\n    for i, char in enumerate(s):\n        # If the character is a vowel (or 'y' at the end of the string), increment the counter\n        if char in vowels or (char == 'y' and i == len(s) - 1):\n            count += 1\n    \n    # Return the total vowel count\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in the input string.\n    'y' is considered a vowel only when it appears at the end of the word.\n    The search for vowels is case-insensitive.\n\n    Parameters:\n    s (str): The input word to count vowels from.\n\n    Returns:\n    int: The total count of vowels in the string.\n    \"\"\"\n    # Convert the input string to lower case to make the function case-insensitive\n    s = s.lower()\n    \n    # Initialize a counter for vowels\n    count = 0\n    \n    # Check if 'y' is at the end of the string and adjust the string for general vowel check\n    if s.endswith('y'):\n        count += 1  # Increment count if 'y' is at the end\n        s = s[:-1]  # Remove the last character for the general vowel check\n    \n    # Define the set of vowels (excluding 'y' since it's handled separately)\n    vowels = set('aeiou')\n    \n    # Iterate over each character in the modified string\n    for char in s:\n        # Check if the character is a vowel and increment the counter if so\n        if char in vowels:\n            count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "import unittest\ndef vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given word. Vowels include 'a', 'e', 'i', 'o', 'u',\n    and 'y' is considered a vowel only if it appears at the end of the word.\n\n    Parameters:\n    s (str): The input string (word) to count vowels in.\n\n    Returns:\n    int: The total count of vowels in the string.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n\n    # Convert to lowercase for case-insensitive comparison\n    s = s.lower()\n    \n    # Define vowels (including 'y' for the special case)\n    vowels = 'aeiou'\n    \n    # Initialize counter for vowels\n    count = 0\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if character is a vowel (and 'y' at the end)\n        if (char in vowels) or (char == 'y' and i == len(s) - 1):\n            count += 1  # Increment vowel count if condition met\n            \n    return count", "matching_cluster_idx": 2}, {"solution": "import unittest\ndef vowels_count(s):\n    \"\"\"Returns the count of vowels in a given string. 'y' is considered a vowel only if at the end.\"\"\"\n    s = s.lower()  # Convert to lowercase for case-insensitive comparison\n    count = sum(1 for char in s[:-1] if char in 'aeiou')  # Count vowels excluding the last character\n    if s and s[-1].lower() in 'aeiouy':  # Check if the string is not empty and its last char is a vowel (including 'y')\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string, where 'y' is considered a vowel only at the end.\n\n    Args:\n        s (str): The input string to count vowels in.\n\n    Returns:\n        int: The number of vowels in the string.\n    \"\"\"\n    # Convert to lower case to simplify the vowel check\n    s = s.lower()\n    \n    # Initialize vowel count\n    count = 0\n    \n    # Check each character in the string\n    for i, char in enumerate(s):\n        # If the character is one of the standard vowels, increment the count\n        if char in 'aeiou':\n            count += 1\n        # Special case for 'y': if it's at the end of the string, increment the count\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given word. \n    'y' is considered a vowel only when it's at the end of the word.\n    \n    Parameters:\n    s (str): The input word.\n    \n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    # Convert to lower case for case-insensitive comparison\n    s = s.lower()\n    \n    # Initialize count of vowels\n    count = 0\n    \n    # Set of vowels (without 'y')\n    vowels = set('aeiou')\n    \n    # Iterate over the characters in the string\n    for i, char in enumerate(s):\n        # Check if character is a vowel (or 'y' at the end)\n        if char in vowels or (char == 'y' and i == len(s) - 1):\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in the input string.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' when at the end of the word.\n    The function is case-insensitive.\n\n    Parameters:\n    s (str): Input word\n\n    Returns:\n    int: Number of vowels in the input string\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n\n    # Convert to lowercase for case-insensitive comparison\n    s = s.lower()\n    \n    # Initialize count of vowels\n    count = 0\n    \n    # Define vowels (including 'y' for a special case)\n    vowels = set('aeiou')\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n        # Special case for 'y' at the end of the word\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Calculate the number of vowels in a given word. Vowels considered are 'a', 'e', 'i', 'o', 'u', \n    and 'y' if it's at the end of the word. The function is case-insensitive.\n\n    Parameters:\n    s (str): The input word to count vowels in.\n\n    Returns:\n    int: The number of vowels in the word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lower case for case-insensitive comparison\n    s = s.lower()\n    \n    # Initialize a counter for vowels\n    count = 0\n    \n    # Define the set of vowels (including 'y' for a special case)\n    vowels = set('aeiou')\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n        # Special case for 'y' at the end of the string\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string.\n    'y' is considered a vowel only if it's at the end of the string.\n    \n    Parameters:\n    s (str): The input string to count vowels in.\n    \n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    # Convert to lower case to simplify vowel checking\n    s = s.lower()\n    \n    # Initialize vowel count\n    count = 0\n    \n    # Check for 'y' at the end of the string\n    if s.endswith('y'):\n        count += 1\n        # Since we've counted 'y', remove it for the rest of the check\n        s = s[:-1]\n    \n    # Define the set of standard vowels\n    vowels = set('aeiou')\n    \n    # Count all occurrences of standard vowels in the string\n    count += sum(1 for char in s if char in vowels)\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in the input string `s`. \n    'y' is considered a vowel only when it appears at the end of `s`.\n\n    Parameters:\n    - `s (str)`: The input word to count vowels in.\n\n    Returns:\n    - `(int)`: The number of vowels in `s`.\n    \"\"\"\n    # Convert to lower case to simplify vowel checks\n    s = s.lower()\n    \n    # Define vowels (including 'y' for conditional check later)\n    vowels = 'aeiouy'\n    \n    # Initialize vowel count\n    count = 0\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if character is a vowel\n        if char in vowels:\n            # Special case for 'y': only count if at the end of the string\n            if char == 'y' and i != len(s) - 1:\n                continue\n            # Increment count for each found vowel\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string, considering 'y' as a vowel only when it's at the end of the word.\n\n    Parameters:\n    s (str): The input string to count vowels from.\n\n    Returns:\n    int: The total number of vowels in the string.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n\n    # Convert to lowercase for case-insensitive comparison\n    s = s.lower()\n    \n    # Initialize vowel count to 0\n    count = 0\n    \n    # Define vowels (excluding 'y' for now)\n    vowels = 'aeiou'\n    \n    # Count vowels in the string excluding the last character\n    for char in s[:-1]:\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' or a vowel, then increment count if true\n    if s and (s[-1] in vowels or (s[-1] == 'y' and len(s) > 1 or s == 'y')):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string.\n    'y' is considered a vowel only when it appears at the end of the string.\n    \n    Parameters:\n    s (str): The input string to count vowels from.\n    \n    Returns:\n    int: The total count of vowels in the string.\n    \"\"\"\n    # Convert to lowercase to simplify the vowel check\n    s = s.lower()\n    \n    # Define the set of vowels (excluding 'y' for now)\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Initialize the vowel count\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if 'y' is at the end of the string and increment count if so\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string, considering 'y' as a vowel only when it's at the end.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    # Convert the string to lowercase to handle both lower and uppercase vowels\n    s = s.lower()\n    \n    # Initialize a counter for vowels\n    count = 0\n    \n    # Define the set of vowels (excluding 'y' for now)\n    vowels = set('aeiou')\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if the character is a vowel (not 'y' yet) or if it's 'y' and at the end of the string\n        if char in vowels or (char == 'y' and i == len(s) - 1):\n            # If the condition is met, increment the vowel count\n            count += 1\n    \n    # Return the total count of vowels\n    return count", "matching_cluster_idx": 3}, {"solution": "import unittest\ndef vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string, considering 'y' as a vowel \n    only if it appears at the end of the string.\n\n    Parameters:\n    s (str): The input string to count vowels from.\n\n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    # Convert to lowercase for case-insensitive comparison\n    s = s.lower()\n    \n    # Initialize vowel count\n    count = 0\n    \n    # Set of vowels (excluding 'y' since it's conditionally counted)\n    vowels = set('aeiou')\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if character is a vowel (excluding the conditional 'y')\n        if char in vowels:\n            count += 1\n        # Special case for 'y' at the end of the string\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string, treating 'y' as a vowel only if it's at the end of the string.\n    \n    Parameters:\n    - `s` (str): The input string to count vowels from.\n    \n    Returns:\n    - `int`: The total count of vowels in the string.\n    \"\"\"\n    # Convert the string to lowercase for case-insensitive comparison\n    s = s.lower()\n    \n    # Initialize vowel count to 0\n    count = 0\n    \n    # Define vowels (excluding 'y' for now)\n    vowels = 'aeiou'\n    \n    # Count all occurrences of standard vowels\n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string and increment count if so\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string.\n    \n    A vowel is considered as 'a', 'e', 'i', 'o', 'u'. 'y' is also a vowel but \n    only when it is at the end of the given word. The function is case-insensitive.\n\n    Parameters:\n    s (str): The input string to count vowels from.\n\n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    # Convert the string to lower case for case-insensitive comparison\n    s = s.lower()\n    \n    # Define vowels (excluding 'y' since its condition is special)\n    vowels = 'aeiou'\n    \n    # Initialize a counter for vowels\n    count = 0\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if the character is a vowel or if it's 'y' at the end of the string\n        if char in vowels or (char == 'y' and i == len(s) - 1):\n            # If the condition is met, increment the vowel count\n            count += 1\n    \n    # Return the total count of vowels\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in the given string.\n    'y' is considered a vowel only when it appears at the end of the string.\n    The function is case-insensitive.\n\n    Parameters:\n    s (str): The input string to count vowels in.\n\n    Returns:\n    int: The number of vowels in the string.\n    \"\"\"\n    s = s.lower()  # Convert to lowercase for case-insensitive comparison\n    vowels = 'aeiou'\n    count = sum(1 for char in s[:-1] if char in vowels)  # Count vowels excluding the last character\n    if s and s[-1].lower() in vowels + 'y':  # Check if the string is not empty and the last char is a vowel or 'y'\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given string.\n    Vowels considered are 'a', 'e', 'i', 'o', 'u', and 'y' (if at the end of the string).\n    \n    Parameters:\n    s (str): The input string to count vowels from.\n    \n    Returns:\n    int: The total count of vowels in the string.\n    \"\"\"\n    # Convert to lowercase for case-insensitive comparison\n    s = s.lower()\n    \n    # Initialize vowel count to 0\n    count = 0\n    \n    # Define vowels (including 'y' for conditional check later)\n    vowels = 'aeiouy'\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if character is in vowels\n        if char in vowels:\n            # If it's 'y', only count if it's at the end of the string\n            if char == 'y' and i != len(s) - 1:\n                continue\n            # Increment count for each vowel found\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings \n    being less than the other list. If both lists have the same total \n    number of characters, returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with fewer total characters or the first list if totals are equal.\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(string) for string in lst1)\n    total_chars_lst2 = sum(len(string) for string in lst2)\n    \n    # Compare the totals and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with fewer total characters in all its strings.\n    If both lists have the same total, returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with fewer total characters.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate total characters in a list of strings.'''\n        return sum(len(s) for s in lst)\n\n    # Calculate total characters for each list\n    total1, total2 = total_chars(lst1), total_chars(lst2)\n\n    # Return the list with fewer total characters, defaulting to lst1 on equality\n    return lst1 if total1 <= total2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings \n    less than the other list. If both lists have the same total number of \n    characters, returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with fewer total characters or the first list if totals are equal.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate the total number of characters in a list of strings.'''\n        return sum(len(s) for s in lst)\n\n    if total_chars(lst1) <= total_chars(lst2):\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with a total number of characters in all its strings less than the other.\n    If both lists have the same total number of characters, returns the first list.\n\n    Args:\n        lst1 (list): The first list of strings.\n        lst2 (list): The second list of strings.\n\n    Returns:\n        list: The list with fewer total characters, or the first list if totals are equal.\n    '''\n    def total_chars(lst):\n        \"\"\"Helper function to calculate total characters in a list of strings.\"\"\"\n        return sum(len(string) for string in lst)\n\n    if total_chars(lst1) <= total_chars(lst2):\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of chars in all strings less than the other.\n    If totals are equal, returns the first list.\n\n    Args:\n        lst1 (list): First list of strings.\n        lst2 (list): Second list of strings.\n\n    Returns:\n        list: The list with fewer total characters.\n    '''\n    # Calculate total characters in each list\n    total_chars_lst1 = sum(len(string) for string in lst1)\n    total_chars_lst2 = sum(len(string) for string in lst2)\n\n    # Return the list with fewer total characters, or the first list if they're equal\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings less than the other list.\n    If the total characters in both lists are equal, returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with fewer total characters or the first list if totals are equal.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate the total number of characters in a list of strings.'''\n        return sum(len(s) for s in lst)\n\n    return lst1 if total_chars(lst1) <= total_chars(lst2) else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings being less than the other.\n    If both lists have the same total number of characters, returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with fewer total characters, or the first list if totals are equal.\n    '''\n    def total_chars(lst):\n        \"\"\"Helper function to calculate the total number of characters in a list of strings.\"\"\"\n        return sum(len(s) for s in lst)\n\n    if total_chars(lst1) <= total_chars(lst2):\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings less than the other list.\n    If both lists have the same total number of characters, returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with fewer total characters, or the first list if totals are equal.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate the total characters in a list of strings.'''\n        return sum(len(s) for s in lst)\n\n    total1, total2 = total_chars(lst1), total_chars(lst2)\n    \n    # Return the list with fewer total characters, or lst1 if totals are equal\n    return lst1 if total1 <= total2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings \n    being less than or equal to the other list. If both lists have the same \n    total number of characters, returns the first list.\n\n    Args:\n        lst1 (list): The first list of strings.\n        lst2 (list): The second list of strings.\n\n    Returns:\n        list: The list with the lesser or equal total number of characters.\n    '''\n    def total_chars(lst):\n        \"\"\"Helper function to calculate the total number of characters in a list of strings.\"\"\"\n        return sum(len(s) for s in lst)\n\n    # Calculate total characters for each list\n    total1, total2 = total_chars(lst1), total_chars(lst2)\n    \n    # Return the list with the lesser or equal total, preferring lst1 in case of a tie\n    return lst1 if total1 <= total2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with fewer total characters. If totals are equal, returns lst1.\n\n    Args:\n        lst1 (list[str]): The first list of strings.\n        lst2 (list[str]): The second list of strings.\n\n    Returns:\n        list[str]: The list with fewer total characters, or lst1 if totals are equal.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate total characters in a list of strings.'''\n        return sum(len(s) for s in lst)\n\n    total1, total2 = total_chars(lst1), total_chars(lst2)\n    return lst1 if total1 <= total2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings being less than the other list.\n    If both lists have the same total number of characters, returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with fewer total characters or the first list if totals are equal.\n    '''\n\n    # Calculate the total number of characters in all strings of lst1\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    \n    # Calculate the total number of characters in all strings of lst2\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Return lst1 if its total characters are less than or equal to lst2's\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with fewer total characters in all its strings.\n    If both lists have the same total, returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with fewer total characters or the first list if totals are equal.\n    '''\n\n    # Calculate total characters in lst1\n    total_chars_lst1 = sum(len(string) for string in lst1)\n    \n    # Calculate total characters in lst2\n    total_chars_lst2 = sum(len(string) for string in lst2)\n    \n    # Return lst1 if its total characters are less than or equal to lst2's\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings \n    less than the other list. If both lists have the same total number of \n    characters, returns the first list.\n\n    Args:\n        lst1 (list[str]): The first list of strings.\n        lst2 (list[str]): The second list of strings.\n\n    Returns:\n        list[str]: The list with fewer total characters or `lst1` if totals are equal.\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(string) for string in lst1)\n    total_chars_lst2 = sum(len(string) for string in lst2)\n\n    # Return the list with fewer total characters, preferring lst1 in case of a tie\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings being less than or equal to the other list.\n    If both lists have the same total number of characters, returns the first list.\n\n    Args:\n        lst1 (list): The first list of strings.\n        lst2 (list): The second list of strings.\n\n    Returns:\n        list: The list with the smaller or equal total character count.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate the total number of characters in a list of strings.'''\n        return sum(len(string) for string in lst)\n\n    total1, total2 = total_chars(lst1), total_chars(lst2)\n    return lst1 if total1 <= total2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with a total number of characters in all its strings less than \n    the other list. If both lists have the same total number of characters, \n    returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with the lesser total number of characters.\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(string) for string in lst1)\n    total_chars_lst2 = sum(len(string) for string in lst2)\n\n    # Return the list with the lesser total number of characters, \n    # or the first list if totals are equal\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of chars in all its strings less than the other list.\n    If both lists have the same total number of chars, returns the first list.\n\n    Args:\n        lst1 (list[str]): The first list of strings.\n        lst2 (list[str]): The second list of strings.\n\n    Returns:\n        list[str]: The list with fewer total characters.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate the total number of chars in a list of strings.'''\n        return sum(len(string) for string in lst)\n\n    total1, total2 = total_chars(lst1), total_chars(lst2)\n    \n    # If both lists have the same total, return the first list\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with a total number of characters in all its strings less than the other list.\n    If both lists have the same total number of characters, returns the first list.\n\n    Args:\n        lst1 (list): The first list of strings.\n        lst2 (list): The second list of strings.\n\n    Returns:\n        list: The list with fewer total characters or the first list if totals are equal.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate total characters in a list of strings.'''\n        return sum(len(s) for s in lst)\n\n    total1, total2 = total_chars(lst1), total_chars(lst2)\n    \n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with fewer total characters across all its strings.\n    In case of a tie, returns the first list.\n    \n    Parameters:\n    - lst1 (list): The first list of strings.\n    - lst2 (list): The second list of strings.\n    \n    Returns:\n    - list: The list with fewer total characters or lst1 in case of a tie.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate total characters in a list of strings.'''\n        return sum(len(s) for s in lst)\n    \n    if total_chars(lst1) <= total_chars(lst2):\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with a total number of characters in all its strings less than \n    the other list. If both lists have an equal total, returns the first list.\n\n    Args:\n        lst1 (list): The first list of strings.\n        lst2 (list): The second list of strings.\n\n    Returns:\n        list: The list with fewer total characters, or the first list if totals are equal.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate total characters in a list of strings.'''\n        return sum(len(string) for string in lst)\n\n    # Calculate total characters for each list\n    total1, total2 = total_chars(lst1), total_chars(lst2)\n    \n    # Return the list with fewer total characters, or the first list if totals are equal\n    return lst1 if total1 <= total2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all its strings being less than the other.\n    If both lists have the same total number of characters, returns the first list.\n\n    Parameters:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: The list with fewer total characters, or lst1 if totals are equal.\n    '''\n    def total_chars(lst):\n        '''Helper function to calculate total characters in a list of strings.'''\n        return sum(len(s) for s in lst)\n\n    total1, total2 = total_chars(lst1), total_chars(lst2)\n    return lst1 if total1 <= total2 else lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 79.6039603960396, "dps_norm": 49.166666666666664, "pass@1": 72.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, this function adds up all even elements that are located at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices. If no such elements exist, returns 0.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7])\n        0\n        >>> add([10, 20, 30, 40])\n        20\n    \"\"\"\n    # Use enumerate to get both index and value, filter for odd indices and even values, then sum the results\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        14\n        >>> add([3, 1, 7, 9])\n        0\n    \"\"\"\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the list using enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # If both conditions are met, add the value to the sum\n            total_sum += value\n    \n    # Return the calculated sum\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements found at odd indices in the list.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the even value at an odd index to the total sum\n            total_sum += value\n    \n    # Return the total sum of even elements at odd indices\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: Sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        14\n        >>> add([11, 13, 15])  # No even numbers at odd indices\n        0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd (using the modulus operator %)\n        # and if the value at this index is even\n        if index % 2 != 0 and value % 2 == 0:\n            # If both conditions are true, add the value to the total sum\n            total_sum += value\n    \n    # Return the total sum of even elements at odd indices\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, this function adds up the even elements \n    that are located at odd indices (0-based indexing).\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: Sum of even elements at odd indices. If no such elements exist, returns 0.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7])\n        0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the sum\n            total_sum += value\n    \n    # Return the total sum\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, adds the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements found at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        14\n    \"\"\"\n    # Use enumerate to get both index and value from the list\n    # Filter for even numbers at odd indices and sum them up\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, this function adds up the even elements \n    that are located at odd indices (0-based indexing).\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd (using modulus operator) and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # If both conditions are true, add the value to the total sum\n            total_sum += value\n    \n    # Return the total sum after iterating over the entire list\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the even value at an odd index to the sum\n            total_sum += value\n    \n    # Return the calculated sum\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, add the even elements that are at odd indices.\n\n    **Examples:**\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd (using modulo operator) and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the even value at an odd index to the total sum\n            total_sum += value\n    \n    # Return the total sum of even elements at odd indices\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "import unittest\ndef add(lst):\n    \"\"\"\n    Calculates the sum of even elements at odd indices in a given list.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: Sum of even elements at odd indices.\n    \"\"\"\n    # Use list comprehension to filter even elements at odd indices and sum them\n    return sum(\n        element \n        for index, element in enumerate(lst) \n        if index % 2 != 0 and element % 2 == 0\n    )", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices (0-indexed).\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    # Use list comprehension to filter even numbers at odd indices, then sum them\n    # Python uses 0-based indexing, so odd indices are where the index % 2 != 0\n    return sum(num for idx, num in enumerate(lst) if idx % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: Sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7])\n        0\n        >>> add([10, 20, 30, 40])\n        20\n    \"\"\"\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the list using enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd (using modulus operator)\n        # and if the value at that index is even\n        if index % 2 != 0 and value % 2 == 0:\n            # If both conditions are met, add the value to the sum\n            total_sum += value\n    \n    # Return the total sum of even elements at odd indices\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, adds the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        14\n        >>> add([7, 3, 9, 1])  # No even numbers at odd indices\n        0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, adds the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, this function adds the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices. If no such elements exist, returns 0.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7])\n        0\n        >>> add([10, 20, 30, 40])\n        20\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if list is non-empty\n    if len(lst) == 0:\n        raise ValueError(\"List must not be empty\")\n    \n    # Check if all elements in the list are integers\n    if not all(isinstance(item, int) for item in lst):\n        raise ValueError(\"All elements in the list must be integers\")\n    \n    # Use list comprehension to filter even elements at odd indices and sum them\n    # Python uses 0-based indexing, so odd indices are at index 1, 3, 5, ...\n    # The expression `lst[i] for i in range(len(lst)) if i % 2 != 0 and lst[i] % 2 == 0` \n    # generates even elements at odd indices, and `sum()` adds them together\n    return sum(lst[i] for i in range(len(lst)) if i % 2 != 0 and lst[i] % 2 == 0)", "matching_cluster_idx": 1}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, adds the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements found at odd indices in the list.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list using enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # If both conditions are met, add the value to the sum\n            total_sum += value\n    \n    # Return the total sum of even elements at odd indices\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the even value at an odd index to the total sum\n            total_sum += value\n    \n    # Return the total sum\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        14\n        >>> add([1, 3, 5, 7])  # No even numbers at odd indices\n        0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, \n    add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: Sum of even numbers at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        14\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the even value at an odd index to the sum\n            total_sum += value\n            \n    # Return the total sum\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers, adds the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices. If no such elements exist, returns 0.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7])\n        0\n    \"\"\"\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # If both conditions are met, add the value to the total sum\n            total_sum += value\n    \n    # Return the total sum after iterating over the entire list\n    return total_sum", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 3.0, "profiled": []}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 97.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list (nested lists) and returns \n    a list of tuples representing the coordinates (row, column) of each occurrence.\n    The coordinates are sorted first by row in ascending order, then by column in descending order.\n\n    Args:\n        lst (list of lists): A 2D list (nested lists) of integers.\n        x (int): The target integer to find in the list.\n\n    Returns:\n        list of tuples: A list of (row, column) coordinates where `x` is found.\n    \"\"\"\n\n    # Initialize an empty list to store coordinates\n    coordinates = []\n\n    # Iterate over each row in the list with its index\n    for row_idx, row in enumerate(lst):\n        # Find all occurrences of 'x' in the current row\n        for col_idx, val in enumerate(row):\n            if val == x:\n                # Append the coordinate as a tuple (row, column)\n                coordinates.append((row_idx, col_idx))\n\n    # First, sort coordinates by row in ascending order\n    # Then, for rows with the same index, sort by column in descending order\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n\n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list and returns a list of tuples representing coordinates.\n    \n    Args:\n        lst (list): A 2D list (nested lists) of integers.\n        x (int): The target integer to find.\n    \n    Returns:\n        list: A list of tuples, where each tuple is a coordinate (row, column) in the format (int, int), \n              starting with 0. Coordinates are sorted first by row in ascending order, then by column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the 2D list with enumerate to get both index and value of each sublist (row)\n    for row_index, row in enumerate(lst):\n        # For each row, iterate over the elements with enumerate to get both index and value\n        for col_index, element in enumerate(row):\n            # Check if the current element matches the target integer\n            if element == x:\n                # If it matches, append the coordinate as a tuple to the list\n                coordinates.append((row_index, col_index))\n    \n    # First, sort the coordinates by row in ascending order\n    # Then, for rows with the same index, sort by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list and returns a list of coordinates (row, column) \n    sorted by row in ascending order and then by column in descending order.\n\n    Args:\n        lst (list): A 2D list (nested lists) of varying column lengths.\n        x (int): The integer to find within the 2D list.\n\n    Returns:\n        list: A list of tuples, each representing a coordinate (row, column) where `x` was found.\n    \"\"\"\n\n    # Initialize an empty list to store the coordinates of 'x'\n    coordinates = []\n\n    # Iterate over each row in the list with its index (starting from 0)\n    for row_idx, row in enumerate(lst):\n        # Iterate over each element in the row with its index (starting from 0)\n        for col_idx, elem in enumerate(row):\n            # Check if the current element matches the target integer 'x'\n            if elem == x:\n                # If it matches, append its coordinate (row, column) to the list\n                coordinates.append((row_idx, col_idx))\n\n    # First, sort the coordinates by row in ascending order\n    # Then, for rows that are the same, sort by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list and returns \n    a list of tuples representing coordinates (row, column) sorted \n    by row in ascending order and then by column in descending order.\n    \n    Parameters:\n    lst (list): A 2D list (nested lists) of integers.\n    x (int): The integer to be searched.\n    \n    Returns:\n    list: A list of tuples containing coordinates of `x` in the input list.\n    \"\"\"\n    \n    # Initialize an empty list to store the coordinates of 'x'\n    coordinates = []\n    \n    # Iterate over each row in the list with its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_index, elem in enumerate(row):\n            # Check if the current element matches the target integer 'x'\n            if elem == x:\n                # If a match is found, append its coordinates to the list\n                coordinates.append((row_index, col_index))\n    \n    # First, sort the coordinates by row in ascending order\n    # Then, for rows with the same index, sort by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list (lst) and an integer (x), find all occurrences of x in lst.\n    Return a list of tuples representing coordinates (row, column) where x is found,\n    sorted first by row (ascending) and then by column (descending).\n\n    Args:\n        lst (list): A 2D list of integers\n        x (int): The target integer to find\n\n    Returns:\n        list: A list of tuples [(row, column)] where x is found, sorted as described.\n    \"\"\"\n    # Initialize an empty list to store coordinates\n    coordinates = []\n\n    # Iterate over the 2D list with enumerate to get both index (row) and value (sublist)\n    for row_idx, sublist in enumerate(lst):\n        # For each sublist, iterate with enumerate to get both index (column) and value\n        for col_idx, val in enumerate(sublist):\n            # Check if the current value matches the target integer x\n            if val == x:\n                # If it matches, append the coordinate (row, column) to the list\n                coordinates.append((row_idx, col_idx))\n\n    # Sort the coordinates: First by row (ascending), then by column (descending)\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n\n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a nested list (similar to a matrix)\n    and returns a list of tuples representing coordinates (row, column) where `x` is found.\n    Coordinates are sorted first by row in ascending order, then by column in descending order.\n\n    Args:\n        lst (list of lists): A 2D list of integers (nested list)\n        x (int): The target integer to find\n\n    Returns:\n        list of tuples: [(row, column), ...] where `x` is found, sorted by row ascending, then column descending\n    \"\"\"\n    # Initialize an empty list to store the coordinates of 'x'\n    coordinates = []\n    \n    # Iterate over the rows in the list (enumerate provides both index and value)\n    for row_index, row in enumerate(lst):\n        # For each row, find the column indices where 'x' is present\n        for col_index in [i for i, val in enumerate(row) if val == x]:\n            # Append the coordinate as a tuple (row, column) to the list\n            coordinates.append((row_index, col_index))\n    \n    # First, sort the coordinates by row in ascending order\n    # Then, for coordinates with the same row, sort by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a nested list (similar to a matrix)\n    and returns a list of tuples representing coordinates (row, column) where `x` is found.\n    The coordinates are sorted first by row in ascending order, then by column in descending order.\n\n    Args:\n        lst (list of lists): A 2D list where each row may have a different number of columns.\n        x (int): The integer to search for.\n\n    Returns:\n        list of tuples: [(row, column), ...] where `x` is found, sorted by row ascending, then column descending.\n    \"\"\"\n\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over the rows in the list with their index (starting at 0)\n    for row_index, row in enumerate(lst):\n        # For each row, iterate over the elements with their index\n        for col_index, element in enumerate(row):\n            # Check if the current element matches the target integer\n            if element == x:\n                # If it matches, append the coordinate to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates: first by row in ascending order, then by column in descending order\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n\n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer x in a 2D list and returns their coordinates.\n    \n    Parameters:\n    lst (list of lists): A 2D list with varying column lengths.\n    x (int): The integer to find in the list.\n    \n    Returns:\n    list of tuples: Coordinates (row, column) of x in the list, sorted by row ascending and then column descending.\n    \"\"\"\n    \n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the rows in the list with their index (starting from 0)\n    for row_index, row in enumerate(lst):\n        # Find the column indices of all occurrences of x in the current row\n        column_indices = [i for i, value in enumerate(row) if value == x]\n        \n        # For each occurrence, add the coordinate as a tuple to the list\n        coordinates.extend([(row_index, col_index) for col_index in column_indices])\n    \n    # Sort the coordinates: first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list (nested lists of varying length)\n    and returns a list of tuples representing coordinates (row, column) where `x` is found.\n    \n    Coordinates are sorted first by row in ascending order, and then by column in descending order.\n\n    Args:\n        lst (list): A 2D list of integers (nested lists of varying lengths)\n        x (int): The target integer to find in the list\n\n    Returns:\n        list: A list of tuples (row, column) where `x` is found, sorted by row ascending and then column descending.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of 'x'\n    coordinates = []\n    \n    # Iterate over each row in the list along with its index (row number)\n    for row_idx, row in enumerate(lst):\n        # Iterate over each element in the row along with its index (column number)\n        for col_idx, elem in enumerate(row):\n            # Check if the current element matches the target 'x'\n            if elem == x:\n                # If it matches, append its coordinates to the list\n                coordinates.append((row_idx, col_idx))\n    \n    # First, sort the coordinates by row in ascending order\n    # Then, for rows with the same number, sort by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list and returns their coordinates.\n    \n    Coordinates are returned as a list of tuples (row, column), starting with 0.\n    The list is sorted first by row in ascending order, then by column in descending order.\n    \n    Args:\n        lst (list): A 2D list (nested lists) of integers.\n        x (int): The integer to find in the list.\n    \n    Returns:\n        list: A list of tuples, each representing the (row, column) of `x` in `lst`.\n    \"\"\"\n\n    # Initialize an empty list to store the coordinates of `x`\n    coordinates = []\n\n    # Iterate over each row in the list along with its index (starting from 0)\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of `x` in the current row\n        for col_index, element in enumerate(row):\n            if element == x:\n                # If `x` is found, append its coordinate to the list\n                coordinates.append((row_index, col_index))\n\n    # First, sort coordinates by row in ascending order\n    # Then, for rows with the same index, sort by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer x in a 2D list (nested lists of varying length),\n    returning a list of coordinates (row, column) where x is found.\n    \n    The returned list is sorted first by row in ascending order, then by column in descending order.\n    \n    Parameters:\n    - lst (list): A 2D list (list of lists) of integers\n    - x (int): The target integer to find\n    \n    Returns:\n    - list: A list of tuples, each tuple being a coordinate (row, column) where x is found\n    \"\"\"\n    # Initialize an empty list to store coordinates of found integers\n    coordinates = []\n    \n    # Iterate over each row in the list along with its index (row number)\n    for row_idx, row in enumerate(lst):\n        # For each occurrence of x in the row, calculate its column index from the right (for descending order prep)\n        for col_idx in [len(row) - 1 - i for i, val in enumerate(reversed(row)) if val == x]:\n            # Store the coordinate as a tuple and add it to the list\n            coordinates.append((row_idx, col_idx))\n    \n    # First, sort coordinates by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list and returns a list of tuples,\n    representing coordinates (row, column) where `x` is found. Coordinates are\n    sorted first by row in ascending order, then by column in descending order.\n\n    Args:\n        lst (list of lists): A 2D list with variable column lengths.\n        x (int): The integer to find in the list.\n\n    Returns:\n        list of tuples: [(row, column), ...] where `x` is found, sorted by row asc, column desc.\n    \"\"\"\n    # Initialize an empty list to store coordinates of found integers\n    coordinates = []\n    \n    # Iterate over each row in the list with its index\n    for row_idx, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_idx, elem in enumerate(row):\n            # Check if the current element matches the target integer\n            if elem == x:\n                # If match found, append the coordinate to the list\n                coordinates.append((row_idx, col_idx))\n    \n    # First, sort coordinates by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list (nested lists of varying lengths)\n    and returns a list of tuples representing coordinates (row, column) where `x` is found.\n    The coordinates are sorted first by row (ascending) and then by column (descending within each row).\n\n    Parameters:\n    - `lst`: A 2D list of integers with rows of varying lengths.\n    - `x`: The integer to be searched within `lst`.\n\n    Returns:\n    - A list of tuples, each representing the (row, column) coordinates of `x` in `lst`.\n    \"\"\"\n    # Initialize an empty list to store coordinates of found integers\n    coordinates = []\n\n    # Iterate over each row in the list with its index (starting from 0)\n    for row_idx, row in enumerate(lst):\n        # For each row, find the indices of all occurrences of `x`\n        for col_idx in [i for i, val in enumerate(row) if val == x]:\n            # Append the coordinate tuple to the list\n            coordinates.append((row_idx, col_idx))\n\n    # Sort the coordinates: First by row (ascending), then by column (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer x in a 2D list (nested lists) and returns\n    a list of tuples representing coordinates (row, column) of x. The list is\n    sorted by row in ascending order, and within each row, coordinates are sorted\n    by column in descending order.\n\n    Parameters:\n    - lst (list of lists): A 2D list of integers with variable column lengths.\n    - x (int): The target integer to find in the 2D list.\n\n    Returns:\n    - list of tuples: [(row, column), ...] where 'row' and 'column' are 0-indexed.\n    \"\"\"\n    # Initialize an empty list to store coordinates of x\n    coordinates = []\n    \n    # Iterate over each row in the list with its index\n    for row_idx, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        for col_idx in [i for i, val in enumerate(row) if val == x]:\n            # Append the coordinate as a tuple to the list\n            coordinates.append((row_idx, col_idx))\n    \n    # First, sort by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a nested list (similar to a matrix)\n    and returns a list of tuples representing the coordinates (row, column) of `x`.\n    \n    The returned list is sorted first by row in ascending order, and then for each row,\n    the coordinates are sorted by column in descending order.\n\n    Parameters:\n    - lst (list of lists): A 2D list with potentially varying column counts per row.\n    - x (int): The integer to find within the 2D list.\n\n    Returns:\n    - list of tuples: [(row, column), ...] representing the locations of `x`.\n    \"\"\"\n\n    # Initialize an empty list to store the coordinates of `x`\n    coordinates = []\n\n    # Iterate over each row in the list along with its index (starting from 0)\n    for y, row in enumerate(lst):\n        # For each row, iterate over the elements along with their column index\n        for col, val in enumerate(row):\n            # Check if the current element matches the target value `x`\n            if val == x:\n                # If it matches, append the coordinate (row, column) to the list\n                coordinates.append((y, col))\n\n    # First, sort the coordinates by row in ascending order\n    # Then, for each row, sort the coordinates by column in descending order\n    # This is achieved by first sorting by column in reverse, then by row\n    coordinates.sort(key=lambda coord: (-coord[1], coord[0]))\n    # Since Python's sort is stable, we can sort again to get the final order right\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a nested list (2D data) \n    and returns a list of coordinates (row, column) where `x` is found.\n    \n    The returned list is sorted first by row in ascending order, \n    and then by column in descending order for each row.\n\n    Parameters:\n    - lst (list of lists): 2D data structure (nested lists)\n    - x (int): The integer to search for\n\n    Returns:\n    - list of tuples: Coordinates (row, column) where `x` is found\n    \"\"\"\n\n    # Initialize an empty list to store coordinates of 'x'\n    coordinates = []\n\n    # Iterate over each row in the list with its index\n    for row_idx, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_idx, elem in enumerate(row):\n            # Check if the current element matches the target integer 'x'\n            if elem == x:\n                # If a match is found, append the coordinates to the list\n                coordinates.append((row_idx, col_idx))\n\n    # First, sort the coordinates by row in ascending order\n    # Then, for each row, sort the columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list (nested lists with varying column lengths) and an integer x,\n    find all occurrences of x and return a list of tuples representing coordinates \n    (row, column) where x is found. The list is sorted first by row (ascending) \n    and then by column (descending within each row).\n\n    Args:\n        lst (list): A 2D list of integers with variable column lengths.\n        x (int): The integer to be searched within the list.\n\n    Returns:\n        list: A list of tuples [(row, column)] where x is found, sorted by row asc, then column desc.\n    \"\"\"\n\n    # Initialize an empty list to store the coordinates of 'x'\n    coordinates = []\n\n    # Iterate over each row in the list with its index\n    for row_index, row in enumerate(lst):\n        # Find the indices of all occurrences of 'x' in the current row\n        column_indices = [i for i, val in enumerate(row) if val == x]\n        \n        # For each occurrence, append a tuple of (row, column) to the coordinates list\n        for col_index in column_indices:\n            coordinates.append((row_index, col_index))\n\n    # First, sort the coordinates by row in ascending order\n    # Then, for rows with the same index, sort by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list (nested lists) \n    and returns a list of coordinates (row, column) where `x` is found.\n    \n    The returned list is sorted first by row in ascending order, and then \n    for each row, the columns are sorted in descending order.\n    \n    Parameters:\n    lst (list of lists): A 2D list (nested lists) of integers.\n    x (int): The integer to search for in the 2D list.\n    \n    Returns:\n    list of tuples: Coordinates (row, column) where `x` is found, \n                    sorted by row asc, then column desc.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list (with index for row number)\n    for row_idx, row in enumerate(lst):\n        # Find all occurrences of `x` in the current row\n        for col_idx, val in enumerate(row):\n            if val == x:\n                # Append the coordinate, but store column first to simplify sorting\n                coordinates.append((col_idx, row_idx))\n    \n    # Sort the coordinates: first by row (ascending), then by column (descending)\n    coordinates.sort(key=lambda coord: (coord[1], coord[0] * -1))\n    \n    # Since we initially stored (col, row) for sorting, reverse each tuple now\n    coordinates = [(row, col) for col, row in coordinates]\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a nested list (similar to a matrix)\n    and returns a list of tuples representing the coordinates (row, column) of `x`.\n    The coordinates are sorted by row in ascending order, and within each row,\n    coordinates are sorted by column in descending order.\n\n    Args:\n        lst (list): A 2D list (nested list) of integers.\n        x (int): The integer to find in the list.\n\n    Returns:\n        list: A list of tuples [(row, column)] where `x` is found, sorted as described.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of x\n    coordinates = []\n\n    # Iterate over each row in the list with its index\n    for row_idx, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        for col_idx, elem in enumerate(row):\n            if elem == x:\n                # If x is found, append its coordinate to the list\n                coordinates.append((row_idx, col_idx))\n\n    # First, sort the coordinates by row in ascending order\n    # Then, for rows with the same index, sort by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of integer `x` in a 2D list and returns a list of tuples representing coordinates (row, column) \n    where the integer is found. The list is sorted by row in ascending order and by column in descending order within each row.\n\n    Args:\n        lst (list): A 2-dimensional list (nested lists) with variable column lengths.\n        x (int): The integer to search for in the list.\n\n    Returns:\n        list: A list of tuples [(row, column)] where `x` is found, sorted by row ascending and column descending.\n    \"\"\"\n    # Initialize an empty list to store coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list with its index (starting from 0)\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of `x` in the current row and store their indices\n        col_indices = [i for i, val in enumerate(row) if val == x]\n        \n        # For each found column index, add a coordinate tuple to the list\n        for col_index in col_indices:\n            coordinates.append((row_index, col_index))\n    \n    # First, sort by row in ascending order; then by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.75257731958764, "dps_norm": 34.285714285714285, "pass@1": 63.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet down by two places, \n    where the shift is multiplied by two (i.e., each letter shifts 2*2=4 places down).\n\n    Parameters:\n    s (str): The input string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n    \"\"\"\n\n    # Define the English alphabet (both lowercase and uppercase)\n    alphabet_lower = 'abcdefghijklmnopqrstuvwxyz'\n    alphabet_upper = alphabet_lower.upper()\n\n    # Initialize an empty string to store the encrypted result\n    encrypted_string = ''\n\n    # Define the shift (two multiplied by two as per the problem statement)\n    shift = 2 * 2  # Resulting shift is 4 places down\n\n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an uppercase letter\n        if char in alphabet_upper:\n            # Find the position in the alphabet for the character, apply the shift, \n            # and ensure we wrap around the alphabet if necessary\n            encrypted_char = alphabet_upper[(alphabet_upper.index(char) + shift) % len(alphabet_upper)]\n            encrypted_string += encrypted_char\n        # Check if the character is a lowercase letter\n        elif char in alphabet_lower:\n            # Same process as for uppercase, but for lowercase letters\n            encrypted_char = alphabet_lower[(alphabet_lower.index(char) + shift) % len(alphabet_lower)]\n            encrypted_string += encrypted_char\n        else:\n            # If the character is not a letter (e.g., punctuation, digit), \n            # add it to the encrypted string as is\n            encrypted_string += char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by shifting each letter down the alphabet by 4 places.\n    \n    Parameters:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    \n    for char in s:\n        if char.isalpha():  # Check if character is a letter\n            shift = 4  # Shift amount\n            idx = alphabet.index(char.lower())  # Get index in alphabet, case-insensitive\n            new_idx = (idx + shift) % 26  # Apply shift, wrapping around if necessary\n            if char.isupper():  # Preserve original case\n                encrypted += alphabet[new_idx].upper()\n            else:\n                encrypted += alphabet[new_idx]\n        else:\n            encrypted += char  # Non-alphabet characters remain unchanged\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet.\n    The rotation shifts each letter down by 2 * 2 = 4 places in the alphabet.\n\n    Args:\n        s (str): The input string to be encrypted.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    # Define the shift value as per the problem statement (2 multiplied to 2 places)\n    shift_value = 2 * 2  # This equals 4\n\n    # Initialize an empty string to store the encrypted result\n    encrypted_string = \"\"\n\n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an uppercase letter\n        if char.isupper():\n            # Find the position in the alphabet (A=0, B=1, ..., Z=25)\n            # Apply the shift, take the modulus to wrap around the alphabet, and convert back to a character\n            encrypted_char = chr((ord(char) - ord('A') + shift_value) % 26 + ord('A'))\n        # Check if the character is a lowercase letter\n        elif char.islower():\n            # Same logic as above but for lowercase letters\n            encrypted_char = chr((ord(char) - ord('a') + shift_value) % 26 + ord('a'))\n        # If the character is not a letter (e.g., number, punctuation, whitespace), leave it unchanged\n        else:\n            encrypted_char = char\n        \n        # Append the encrypted (or unchanged) character to the result\n        encrypted_string += encrypted_char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet.\n    The rotation shifts each letter down by two places multiplied by two (i.e., 2*2=4 places down).\n\n    Args:\n        s (str): The input string to be encrypted.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    # Define the original alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Calculate the shift (as per the problem statement, two multiplied by two)\n    shift = 2 * 2  # This equals 4\n    \n    # Initialize an empty string to store the encrypted result\n    encrypted = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an alphabet letter (to ignore punctuation, spaces, etc.)\n        if char.isalpha():\n            # Find the position in the alphabet for the character (adjust for 'a' or 'A' offset)\n            pos = alphabet.index(char.lower())\n            \n            # Calculate the new position with the shift, wrapping around if necessary\n            new_pos = (pos + shift) % len(alphabet)\n            \n            # Preserve the original case (lower or upper) while appending the encrypted character\n            if char.isupper():\n                encrypted += alphabet[new_pos].upper()\n            else:\n                encrypted += alphabet[new_pos]\n        else:\n            # If not a letter, append as is (for punctuation, spaces, etc.)\n            encrypted += char\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s: str) -> str:\n    \"\"\"\n    Encrypts a given string by shifting each letter down the alphabet by 2 * 2 = 4 places.\n\n    Args:\n        s (str): The input string to be encrypted.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_string = ''\n\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            shift = 4  # Shift down by 2 * 2 = 4 places\n            char_index = alphabet.index(char.lower())  # Get the index of the character in the alphabet\n            new_index = (char_index + shift) % 26  # Calculate the new index, wrapping around if necessary\n            if char.isupper():  # Preserve the original case\n                encrypted_string += alphabet[new_index].upper()\n            else:\n                encrypted_string += alphabet[new_index]\n        else:\n            encrypted_string += char  # Non-alphabetical characters remain unchanged\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s: str) -> str:\n    \"\"\"\n    Encrypts a given string by rotating the alphabet down by two positions \n    multiplied by two places for each character.\n\n    Args:\n    s (str): The input string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_string = \"\"\n\n    for char in s:\n        if char.isalpha():  # Check if character is a letter\n            # Find the position in the alphabet for the character\n            position = alphabet.index(char.lower())\n            \n            # Calculate the new position (down by two multiplied to two places)\n            new_position = (position + 2 * 2) % 26\n            \n            # Preserve the original case\n            if char.isupper():\n                encrypted_string += alphabet[new_position].upper()\n            else:\n                encrypted_string += alphabet[new_position]\n        else:\n            # If not a letter, add as is (e.g., spaces, punctuation)\n            encrypted_string += char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet.\n    The rotation shifts letters down by 2 * 2 = 4 places in the alphabet.\n    \n    Parameters:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[4:] + alphabet[:4]  # Shift alphabet down by 4 places\n    table = str.maketrans(alphabet + alphabet.upper(), shifted_alphabet + shifted_alphabet.upper())\n    return s.translate(table)", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet.\n    The rotation shifts each letter down by 2 * 2 = 4 places.\n\n    Args:\n        s (str): The input string to be encrypted.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    # Define the shift value as per the problem statement (2 * 2)\n    shift = 2 * 2\n    \n    # Initialize an empty string to store the encrypted result\n    encrypted_string = \"\"\n\n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an uppercase letter\n        if char.isupper():\n            # Calculate the ASCII value of the encrypted character\n            # The formula: (ASCII value of 'A' + (ASCII value of char - ASCII value of 'A' + shift) % 26)\n            encrypted_char = chr((ord('A') + (ord(char) - ord('A') + shift) % 26))\n        # Check if the character is a lowercase letter\n        elif char.islower():\n            # Similar calculation as above but for lowercase letters\n            encrypted_char = chr((ord('a') + (ord(char) - ord('a') + shift) % 26))\n        # If the character is not a letter, leave it unchanged\n        else:\n            encrypted_char = char\n        \n        # Append the encrypted character to the result string\n        encrypted_string += encrypted_char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating its alphabet down by two multiplied to two places.\n    \n    Parameters:\n    s (str): Input string to encrypt.\n    \n    Returns:\n    str: Encrypted string.\n    \"\"\"\n    # Define the original alphabet (both lowercase and uppercase)\n    alphabet_lower = 'abcdefghijklmnopqrstuvwxyz'\n    alphabet_upper = alphabet_lower.upper()\n    \n    # Calculate the shift (two multiplied to two places)\n    shift = 2 * 2  # As per the problem statement\n    \n    # Initialize an empty string to store the encrypted result\n    encrypted_string = \"\"\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an alphabet (either lowercase or uppercase)\n        if char.isalpha():\n            # Determine whether to use the lowercase or uppercase alphabet\n            if char.islower():\n                ref_alphabet = alphabet_lower\n            else:\n                ref_alphabet = alphabet_upper\n            \n            # Find the index of the character in the reference alphabet\n            idx = ref_alphabet.index(char)\n            \n            # Apply the rotation (handle wrap-around for 'y' to 'a' or 'z' to 'a')\n            encrypted_idx = (idx + shift) % len(ref_alphabet)\n            \n            # Append the encrypted character to the result string\n            encrypted_string += ref_alphabet[encrypted_idx]\n        else:\n            # If not an alphabet, append as is (for spaces, punctuation, etc.)\n            encrypted_string += char\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet down by two places \n    multiplied by two, effectively shifting each letter four positions down.\n\n    Parameters:\n    s (str): The input string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_string = ''\n\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Find the position in alphabet for the character, shift it, and wrap around if necessary\n            shifted_pos = (alphabet.index(char.lower()) + 4) % 26\n            \n            # Preserve the original case\n            if char.isupper():\n                encrypted_string += alphabet[shifted_pos].upper()\n            else:\n                encrypted_string += alphabet[shifted_pos]\n        else:\n            encrypted_string += char  # Non-alphabetical characters remain unchanged\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet down by 2 multiplied to two places.\n    \n    Parameters:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Function to shift a character while handling wrap-around\n    def shift_char(c, shift):\n        if c.isalpha():\n            index = alphabet.index(c.lower())\n            new_index = (index + shift) % 26  # % 26 handles wrap-around\n            return alphabet[new_index] if c.islower() else alphabet[new_index].upper()\n        else:\n            return c  # Non-alphabet characters are not shifted\n    \n    # Calculate the shift value (2 multiplied to two places)\n    shift = 2 * 2  # As per the problem statement\n    \n    # Apply the shift to each character in the string\n    encrypted = ''.join(shift_char(c, shift) for c in s)\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet downwards \n    by a shift of 2^2 (4) places.\n\n    Args:\n        s (str): The input string to be encrypted.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    shift = 2 ** 2  # Calculate the shift (4 in this case)\n    encrypted_string = \"\"\n\n    for char in s:\n        # Check if character is an uppercase letter\n        if char.isupper():\n            # Calculate the ASCII value after shifting, wrap around if necessary\n            encrypted_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        # Check if character is a lowercase letter\n        elif char.islower():\n            # Calculate the ASCII value after shifting, wrap around if necessary\n            encrypted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n        # If not a letter, leave the character unchanged (e.g., punctuation, digits)\n        else:\n            encrypted_char = char\n\n        encrypted_string += encrypted_char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by shifting each alphabet character down by 4 places.\n\n    Parameters:\n    s (str): The input string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[4:] + alphabet[:4]  # Shift alphabet down by 4 places\n    table = str.maketrans(alphabet + alphabet.upper(), shifted_alphabet + shifted_alphabet.upper())\n    return s.translate(table)", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by shifting each letter down the alphabet by 2 * 2 places.\n    \n    Parameters:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    shift = 2 * 2  # Calculate the shift value\n    encrypted_string = \"\"\n\n    for char in s:\n        # Check if character is an uppercase letter\n        if char.isupper():\n            # Calculate new position in alphabet, wrap around if necessary\n            new_position = (ord(char) - ord('A') + shift) % 26 + ord('A')\n            encrypted_string += chr(new_position)\n        # Check if character is a lowercase letter\n        elif char.islower():\n            # Calculate new position in alphabet, wrap around if necessary\n            new_position = (ord(char) - ord('a') + shift) % 26 + ord('a')\n            encrypted_string += chr(new_position)\n        else:\n            # If not a letter, add as is (spaces, punctuation, etc.)\n            encrypted_string += char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s: str) -> str:\n    \"\"\"\n    Encrypts a given string by rotating the alphabet downwards by 2 * 2 = 4 places.\n\n    Args:\n    s (str): The input string to be encrypted.\n\n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_string = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an alphabet letter\n        if char.isalpha():\n            # Find the position in the alphabet for the character (adjust for 'a' or 'A' base)\n            position = alphabet.index(char.lower())\n            # Calculate new position, rotating it down by 4 places, handling wrap-around\n            new_position = (position + 4) % len(alphabet)\n            # Preserve the original case (lower/upper) of the character\n            if char.isupper():\n                encrypted_string += alphabet[new_position].upper()\n            else:\n                encrypted_string += alphabet[new_position]\n        else:\n            # If not a letter, add it as is (for spaces, punctuation, numbers, etc.)\n            encrypted_string += char\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet.\n    The rotation shifts each letter down by two positions twice (effective shift of 4 places).\n    \n    Parameters:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the original alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Determine the effective shift (two multiplied by two places)\n    shift = 2 * 2  # As per problem statement\n    \n    # Create a dictionary mapping original characters to shifted ones\n    shift_mapping = str.maketrans(alphabet, alphabet[shift:] + alphabet[:shift])\n    \n    # Apply the shift to the input string (preserving case)\n    encrypted = ''\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                encrypted += char.translate(shift_mapping)\n            else:\n                encrypted += char.translate(shift_mapping).upper()\n        else:\n            encrypted += char  # Non-alphabetic characters remain unchanged\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet.\n    The rotation shifts letters down by 2 * 2 = 4 places.\n    \n    Parameters:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the base alphabet (lowercase and uppercase)\n    alphabet_lower = 'abcdefghijklmnopqrstuvwxyz'\n    alphabet_upper = alphabet_lower.upper()\n    \n    # Define the shift amount (2 multiplied to two places as per problem statement)\n    shift = 2 * 2  # This equals 4\n    \n    # Initialize an empty string to store the encrypted result\n    encrypted = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an alphabet letter\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            if char.islower():\n                # Find the position in the lowercase alphabet and apply the shift\n                position = alphabet_lower.index(char)\n                new_position = (position + shift) % 26  # % 26 to wrap around the alphabet\n                encrypted += alphabet_lower[new_position]\n            else:\n                # Same process for uppercase letters\n                position = alphabet_upper.index(char)\n                new_position = (position + shift) % 26\n                encrypted += alphabet_upper[new_position]\n        else:\n            # If not a letter, just append as is (e.g., punctuation, spaces)\n            encrypted += char\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet down by 4 places for each character.\n    \n    Parameters:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_string = ''\n    \n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            # Find the position in alphabet for the character (accounting for both lower and upper case)\n            pos = alphabet.index(char.lower())\n            # Calculate new position (shifting down by 4 places), handling wrap-around\n            new_pos = (pos + 4) % 26\n            \n            # Preserve the original case\n            if char.isupper():\n                encrypted_string += alphabet[new_pos].upper()\n            else:\n                encrypted_string += alphabet[new_pos]\n        else:\n            # If not a letter, add as is (for spaces, punctuation, etc.)\n            encrypted_string += char\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet down by two multiplied to two places.\n    \n    Args:\n        s (str): The input string to be encrypted.\n    \n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    # Define the original alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Calculate the shift (two multiplied to two places)\n    shift = 2 ** 2  # This equals 4, as per the problem's requirement\n    \n    # Initialize an empty string to store the encrypted result\n    encrypted = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an alphabet letter\n        if char.isalpha():\n            # Find the position in the alphabet for the character (considering both lowercase and uppercase)\n            if char.islower():\n                position = alphabet.index(char)\n            else:\n                position = alphabet.index(char.lower())\n            \n            # Apply the shift, ensuring wrap-around for positions beyond 'z' or 'Z'\n            new_position = (position + shift) % len(alphabet)\n            \n            # Append the encrypted character to the result (maintaining original case)\n            if char.islower():\n                encrypted += alphabet[new_position]\n            else:\n                encrypted += alphabet[new_position].upper()\n        else:\n            # If the character is not a letter, append it as is (for punctuation, spaces, etc.)\n            encrypted += char\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by shifting the alphabet downward by 4 places.\n    \n    Parameters:\n    s (str): Input string for encryption.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the base alphabet (lowercase and uppercase)\n    alphabet_lower = 'abcdefghijklmnopqrstuvwxyz'\n    alphabet_upper = alphabet_lower.upper()\n    \n    # Define the shift amount (as per the problem statement: 2 * 2)\n    shift = 2 * 2\n    \n    # Initialize an empty string to store the encrypted result\n    encrypted = \"\"\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an alphabet letter (either case)\n        if char.isalpha():\n            # Determine whether the character is uppercase or lowercase\n            if char.islower():\n                # Find the position in the lowercase alphabet, shift, and append to encrypted\n                encrypted += alphabet_lower[(alphabet_lower.index(char) + shift) % 26]\n            else:\n                # Do the same for uppercase letters\n                encrypted += alphabet_upper[(alphabet_upper.index(char) + shift) % 26]\n        else:\n            # If not a letter, append as is (for spaces, punctuation, etc.)\n            encrypted += char\n    \n    return encrypted", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 76.80933852140078, "dps_norm": 55.833333333333336, "pass@1": 99.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of a given list of integers.\n    Returns None if there is no such element (list is empty or has less than two unique elements).\n\n    :param lst: A list of integers\n    :return: The 2nd smallest integer in the list, or None\n    \"\"\"\n    # Remove duplicates by converting to set and then sort the set\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # Return the second element (index 1) of the sorted list of unique elements\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    Returns None if the list has less than two unique elements.\n\n    :param lst: A list of integers\n    :return: The 2nd smallest integer, or None\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_elements = set(lst)\n    \n    # If the set has less than 2 elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Remove the smallest element\n    unique_elements.remove(min(unique_elements))\n    \n    # The smallest element in the updated set is the 2nd smallest of the original list\n    return min(unique_elements)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a given list of integers.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        int or None: The 2nd smallest integer in the list, or None if no such element exists.\n    \"\"\"\n    # Remove duplicates by converting to set, then sort the set\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if the list has at least two unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    else:\n        # The 2nd smallest element is at index 1 (since indexing starts at 0)\n        return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        int or None: The 2nd smallest integer in the list, or None if there's no such element.\n    \"\"\"\n    # Remove duplicates by converting the list to a set, then sort the set\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if the list has at least two unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # The 2nd smallest element is the second item in the sorted list (index 1)\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    Returns None if the list has less than two distinct elements.\n\n    :param lst: A list of integers.\n    :return: The 2nd smallest integer or None.\n    \"\"\"\n    # Remove duplicates by converting to set and then sort the set\n    unique_elements = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_elements) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    \n    Args:\n    - lst (list): A list of integers.\n    \n    Returns:\n    - int or None: The 2nd smallest element if exists, otherwise None.\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_nums = set(lst)\n    \n    # If the set contains less than 2 unique elements, return None\n    if len(unique_nums) < 2:\n        return None\n    \n    # Remove the smallest element\n    unique_nums.remove(min(unique_nums))\n    \n    # The smallest element in the updated set is the 2nd smallest of the original list\n    return min(unique_nums)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        int or None: The 2nd smallest element if it exists, otherwise None.\n    \"\"\"\n    # Check if the list has less than 2 unique elements\n    if len(set(lst)) < 2:\n        return None\n    \n    # Remove duplicates by converting to set and sort the list\n    sorted_lst = sorted(set(lst))\n    \n    # If the list has at least 2 elements after removing duplicates, return the 2nd element\n    if len(sorted_lst) > 1:\n        return sorted_lst[1]\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    :param lst: List of integers\n    :return: The second smallest integer or None\n    \"\"\"\n    # Check if the list is empty or contains less than 2 unique elements\n    if len(set(lst)) < 2:\n        return None\n    \n    # Remove duplicates by converting to set and sort the elements\n    sorted_lst = sorted(set(lst))\n    \n    # Since sets are used, the list now contains unique elements in ascending order\n    # The second smallest element is at index 1 (since indexing starts at 0)\n    return sorted_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n\n    :param lst: A list of integers\n    :return: The 2nd smallest integer or None\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_nums = set(lst)\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_nums) < 2:\n        return None\n    \n    # Sort the unique numbers and return the second element (index 1)\n    return sorted(unique_nums)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int or None: The 2nd smallest integer in the list, or None if not found.\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_nums = set(lst)\n    \n    # If the set has less than 2 unique elements, return None\n    if len(unique_nums) < 2:\n        return None\n    \n    # Sort the set in ascending order and return the 2nd element\n    return sorted(unique_nums)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    Returns None if there is no such element (i.e., list has less than 2 distinct elements or is empty).\n\n    :param lst: A list of integers\n    :return: The 2nd smallest integer in the list, or None\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_elements = set(lst)\n    \n    # If the set contains less than 2 elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Sort the set in ascending order and return the 2nd element (index 1)\n    return sorted(unique_elements)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    Returns None if the list has less than two distinct elements.\n    \n    :param lst: A list of integers\n    :return: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_nums = set(lst)\n    \n    # If the list has less than two unique elements, return None\n    if len(unique_nums) < 2:\n        return None\n    \n    # Sort the unique numbers and return the second smallest\n    return sorted(unique_nums)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a given list of integers.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        int or None: The 2nd smallest integer in the list, or None if no such element exists.\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_elements = set(lst)\n    \n    # If the set contains less than 2 unique elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Sort the unique elements in ascending order\n    sorted_unique = sorted(unique_elements)\n    \n    # The 2nd smallest element is the second item in the sorted list (index 1)\n    return sorted_unique[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    Returns None if the list has less than two distinct elements.\n\n    :param lst: A list of integers\n    :return: The 2nd smallest integer in the list, or None\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_nums = set(lst)\n    \n    # If the set has less than two elements, return None\n    if len(unique_nums) < 2:\n        return None\n    \n    # Sort the set in ascending order and return the second element\n    return sorted(unique_nums)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n\n    :param lst: A list of integers\n    :return: The 2nd smallest integer or None\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_elements = set(lst)\n    \n    # If the set contains less than 2 unique elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Remove the smallest element\n    unique_elements.remove(min(unique_elements))\n    \n    # The smallest element in the updated set is the 2nd smallest of the original list\n    return min(unique_elements)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    Returns None if there is no such element.\n\n    :param lst: A list of integers.\n    :return: The 2nd smallest integer in the list, or None.\n    \"\"\"\n    # Remove duplicates by converting to set and then back to list\n    unique_lst = list(set(lst))\n    \n    # If list is empty or only contains one unique element, return None\n    if len(unique_lst) < 2:\n        return None\n    \n    # Sort the list of unique elements in ascending order\n    unique_lst.sort()\n    \n    # The 2nd smallest element is the one at index 1 in the sorted list\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    int or None: The 2nd smallest element if it exists, otherwise None.\n    \"\"\"\n    # Check if list has less than 2 unique elements\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    \n    # Remove the smallest element from the set of unique elements\n    unique_elements.remove(min(unique_elements))\n    \n    # The smallest remaining element is the 2nd smallest overall\n    return min(unique_elements)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    Returns None if there is no 2nd smallest element (list is empty or has less than 2 unique elements).\n\n    :param lst: A list of integers\n    :return: The 2nd smallest integer in the list, or None\n    \"\"\"\n    # Remove duplicates by converting to set and sort the list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if the list has at least two unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # Return the 2nd smallest element (index 1 in 0-based indexing)\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        int or None: The 2nd smallest integer if it exists, otherwise None.\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_nums = set(lst)\n    \n    # If there are less than 2 unique numbers, return None\n    if len(unique_nums) < 2:\n        return None\n    \n    # Sort the unique numbers and return the second one (index 1)\n    return sorted(unique_nums)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in a list of integers.\n    Returns None if the list has less than two distinct elements.\n\n    :param lst: A list of integers\n    :return: The 2nd smallest integer or None\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_elements = set(lst)\n    \n    # If the set has less than two elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Sort the unique elements in ascending order\n    sorted_unique_elements = sorted(unique_elements)\n    \n    # Return the second smallest element (index 1 in the sorted list)\n    return sorted_unique_elements[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 87.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list where each element i is a formatted string indicating \n    the number of odd digits in the i'th string of the input.\n\n    Parameters:\n    lst (list): List of strings, each consisting only of digits.\n\n    Returns:\n    list: Formatted list of strings describing the count of odd digits.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        # Count the odd digits in the current string\n        odd_digits_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Format the output string with the odd digits count\n        output_string = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        \n        result.append(output_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of \n    odd elements in the string i of the input.\" where all the i's should \n    be replaced by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list[str]): A list of strings, each consisting of only digits.\n\n    Returns:\n        list[str]: A list of formatted strings as per the problem statement.\n    \"\"\"\n\n    def count_odd_digits(s):\n        \"\"\"Helper function to count odd digits in a string.\"\"\"\n        return sum(1 for digit in s if int(digit) % 2 != 0)\n\n    result = []\n    for idx, string in enumerate(lst, start=1):\n        odd_digits = count_odd_digits(string)\n        # Replace 'i' with the number of odd digits in the string for formatting\n        formatted_string = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        result.append(formatted_string)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements <count>n the str<count>ng <count> of the <count>nput.\" where \n    <count> is the number of odd digits in the i'th string of the input.\n    \n    Parameters:\n    lst (list): A list of strings consisting only of digits.\n    \n    Returns:\n    list: A list of formatted strings describing the count of odd digits.\n    \"\"\"\n    result = []\n    for index, string in enumerate(lst, start=1):\n        # Count the number of odd digits in the current string\n        odd_digit_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Construct the output string embedding the odd digit count\n        output_string = f\"the number of odd elements {odd_digit_count}n the str{odd_digit_count}ng {odd_digit_count} of the {odd_digit_count}nput.\"\n        \n        # Append the constructed string to the result list\n        result.append(output_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be replaced \n    by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list): A list of strings, each consisting of only digits.\n\n    Returns:\n        list: A list of formatted strings with odd digit counts inserted.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        # Count the odd digits in the current string\n        odd_digits = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Replace 'i' in the template string with the count of odd digits\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        formatted_string = template.format(odd_digits, odd_digits, odd_digits, odd_digits)\n        \n        result.append(formatted_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of \n    odd elements in the string i of the input.\" where all the i's should \n    be replaced by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list): A list of strings, each consisting of only digits.\n\n    Returns:\n        list: A list of formatted strings as per the problem statement.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        # Count the number of odd digits in the current string\n        odd_digits_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Replace 'i' in the template with the count of odd digits and construct the output string\n        output_template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output_string = output_template.format(odd_digits_count, odd_digits_count, odd_digits_count, odd_digits_count)\n        \n        result.append(output_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be \n    replaced by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list[str]): A list of strings consisting only of digits.\n\n    Returns:\n        list[str]: A list of formatted strings describing the count of odd digits.\n    \"\"\"\n    result = []\n    for string in lst:\n        # Count the number of odd digits in the string\n        odd_digits_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Format the output string replacing 'i' with the count of odd digits\n        formatted_string = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        \n        result.append(formatted_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be replaced \n    by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list): A list of strings where each string consists of only digits.\n\n    Returns:\n        list: A list of formatted strings with odd digit counts replacing 'i's.\n    \"\"\"\n\n    def count_odd_digits(s):\n        \"\"\"Helper function to count odd digits in a string.\"\"\"\n        return sum(1 for digit in s if int(digit) % 2 != 0)\n\n    result = []\n    for i, string in enumerate(lst, start=1):\n        odd_digits = count_odd_digits(string)\n        # Replace 'i' with the count of odd digits in the template string\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        result.append(template.format(odd_digits, odd_digits, odd_digits, odd_digits))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be replaced \n    by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list): A list of strings, each consisting of only digits.\n\n    Returns:\n        list: A list of formatted strings as per the problem statement.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        # Count odd digits in the current string\n        odd_digits_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Replace 'i' with the count of odd digits in the output string template\n        output_string = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        \n        result.append(output_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be replaced \n    by the number of odd digits in the i'th string of the input.\n\n    Parameters:\n    lst (list): A list of strings, each consisting of only digits.\n\n    Returns:\n    list: A list of strings with formatted output as per the problem statement.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        # Count the number of odd digits in the current string\n        odd_digits = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Replace 'i' with the count of odd digits in the output string\n        output_string = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        \n        result.append(output_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of \n    odd elements in the string i of the input.\" where all the i's should \n    be replaced by the number of odd digits in the i'th string of the input.\n\n    Parameters:\n    lst (list): A list of strings, each string consisting of only digits.\n\n    Returns:\n    list: A list of formatted strings as per the problem statement.\n    \"\"\"\n\n    def count_odd_digits(s):\n        \"\"\"Helper function to count odd digits in a string.\"\"\"\n        return sum(1 for digit in s if int(digit) % 2 != 0)\n\n    result = []\n    for idx, string in enumerate(lst, start=1):\n        odd_digit_count = count_odd_digits(string)\n        # Replace 'i' with the odd digit count in the template string\n        output_string = f\"the number of odd elements {odd_digit_count}n the str{odd_digit_count}ng {odd_digit_count} of the {odd_digit_count}nput.\"\n        result.append(output_string)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of \n    odd elements in the string i of the input.\" where all the i's should \n    be replaced by the number of odd digits in the i'th string of the input.\n\n    Parameters:\n    lst (list): A list of strings consisting of only digits.\n\n    Returns:\n    list: A list of formatted strings as per the problem statement.\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst, start=1):\n        # Count the odd digits in the current string\n        odd_digits_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        \n        # Replace 'i's in the template with the count of odd digits\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        formatted_string = template.format(odd_digits_count, odd_digits_count, odd_digits_count, odd_digits_count)\n        \n        result.append(formatted_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be replaced \n    by the number of odd digits in the i'th string of the input.\n\n    Parameters:\n    lst (list): A list of strings, each consisting of only digits.\n\n    Returns:\n    list: A list of strings with formatted sentences describing the count of odd digits.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        # Count odd digits in the current string\n        odd_digits_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Replace 'i's with the count of odd digits in the sentence template\n        sentence = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        result.append(sentence)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be replaced \n    by the number of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        # Count the number of odd digits in the current string\n        odd_digits_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Replace 'i' in the output string with the count of odd digits\n        output_string = f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\"\n        \n        result.append(output_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of \n    odd elements in the string i of the input.\" where all the i's should \n    be replaced by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list): A list of strings, where each string consists of only digits.\n\n    Returns:\n        list: A list of strings with formatted sentences.\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst, start=1):\n        # Count the number of odd digits in the string\n        odd_digit_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        \n        # Replace 'i' in the template with the odd digit count for each occurrence\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        sentence = template.format(odd_digit_count, odd_digit_count, odd_digit_count, odd_digit_count)\n        \n        result.append(sentence)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of \n    odd elements in the string i of the input.\" where all the i's should \n    be replaced by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list): A list of strings where each string consists only of digits.\n\n    Returns:\n        list: A list of strings with the specified format.\n    \"\"\"\n    def count_odd_digits(s):\n        \"\"\"Helper function to count odd digits in a string.\"\"\"\n        return sum(1 for digit in s if int(digit) % 2 != 0)\n\n    result = []\n    for i, string in enumerate(lst, start=1):\n        odd_digits = count_odd_digits(string)\n        # Use string formatting to replace 'i' with the number of odd digits\n        formatted_string = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        result.append(formatted_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits,\n    return a list. Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Parameters:\n    lst (list): A list of strings, each consisting of only digits.\n\n    Returns:\n    list: A list of formatted strings describing the count of odd digits in each input string.\n    \"\"\"\n    # Initialize an empty list to store the results\n    result = []\n\n    # Iterate over each string in the input list\n    for s in lst:\n        # Count the number of odd digits in the current string\n        odd_digits = sum(1 for digit in s if int(digit) % 2 != 0)\n        \n        # Format the output string replacing 'i' with the count of odd digits\n        output = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        \n        # Append the formatted string to the result list\n        result.append(output)\n\n    # Return the list of formatted strings\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of \n    odd elements in the string i of the input.\" where all the i's should \n    be replaced by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list): A list of strings, each consisting of only digits.\n\n    Returns:\n        list: A list of strings as per the problem's format requirement.\n    \"\"\"\n    def count_odd_digits(s):\n        \"\"\"Counts the number of odd digits in a given string of digits.\"\"\"\n        return sum(1 for digit in s if int(digit) % 2 != 0)\n\n    result = []\n    for i, string in enumerate(lst, start=1):\n        odd_count = count_odd_digits(string)\n        # Replace all occurrences of 'i' with the odd count in the output string\n        output_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            odd_count, odd_count, odd_count, odd_count\n        )\n        result.append(output_string)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be replaced \n    by the number of odd digits in the i'th string of the input.\n\n    Parameters:\n    lst (list): A list of strings, each consisting of only digits.\n\n    Returns:\n    list: A list of formatted strings with the count of odd digits replacing 'i's.\n    \"\"\"\n    result = []\n    for string in lst:\n        # Count the number of odd digits in the string\n        odd_digits_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Replace 'i's with the count of odd digits in the output string\n        output_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            odd_digits_count, odd_digits_count, odd_digits_count, odd_digits_count\n        )\n        \n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of odd \n    elements in the string i of the input.\" where all the i's should be \n    replaced by the number of odd digits in the i'th string of the input.\n\n    Args:\n        lst (list): A list of strings, each consisting of only digits.\n\n    Returns:\n        list: A list of formatted strings as per the problem statement.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        # Count the number of odd digits in the current string\n        odd_digit_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Replace 'i' in the output template with the odd digit count\n        # and append to the result list\n        result.append(\n            \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n                odd_digit_count, odd_digit_count, odd_digit_count, odd_digit_count\n            )\n        )\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, \n    return a list. Each element i of the output should be \"the number of \n    odd elements in the string i of the input.\" where all the i's should \n    be replaced by the number of odd digits in the i'th string of the input.\n\n    Parameters:\n    lst (list): A list of strings, each consisting only of digits.\n\n    Returns:\n    list: A list of strings as per the problem's description.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        # Count the number of odd digits in the current string\n        odd_digit_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        \n        # Replace 'i' in the output template with the odd digit count\n        output_template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        output_string = output_template.format(odd_digit_count, odd_digit_count, odd_digit_count, odd_digit_count)\n        \n        result.append(output_string)\n    \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 55.52325581395349, "dps_norm": 64.0, "pass@1": 60.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two strings of parentheses in some order\n    to achieve a balanced string.\n\n    Args:\n        lst (list): A list of two strings, each consisting of '(' or ')'.\n\n    Returns:\n        str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n\n    Examples:\n        >>> match_parens(['()(', ')'])\n        'Yes'\n        >>> match_parens([')', ')'])\n        'No'\n    '''\n\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Concatenate in both possible orders and check for balance\n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n\n    # Check each concatenated string for balance\n    if is_balanced(concat1) or is_balanced(concat2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two lists of parentheses can be concatenated in an order \n    that results in a balanced string of parentheses.\n\n    Args:\n    lst (list): A list containing two strings of parentheses.\n\n    Returns:\n    str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n    '''\n\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Check all possible concatenations\n    combos = [lst[0] + lst[1], lst[1] + lst[0]]\n    for combo in combos:\n        if is_balanced(combo):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two lists of parentheses can be concatenated in any order to form a balanced string.\n    \n    Args:\n        lst (list): A list containing two strings of parentheses.\n        \n    Returns:\n        str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n    '''\n    \n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n    \n    # Check all possible concatenations\n    combos = [lst[0] + lst[1], lst[1] + lst[0]]\n    \n    # Check if any of the combinations are balanced\n    for combo in combos:\n        if is_balanced(combo):\n            return 'Yes'\n    \n    # If none are balanced, return 'No'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it is possible to concatenate two strings of parentheses in some order\n    to get a balanced string.\n\n    Args:\n        lst (list): A list of two strings, each consisting of '(' or ')'.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Concatenate the strings in both possible orders and check if either is balanced\n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n    \n    return 'Yes' if is_balanced(concat1) or is_balanced(concat2) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two strings consisting of parentheses can be concatenated in some order \n    to form a string with balanced parentheses.\n\n    Args:\n        lst (list): A list of two strings containing '(' or ')'.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n\n    Examples:\n        >>> match_parens(['()(', ')'])\n        'Yes'\n        >>> match_parens([')', ')'])\n        'No'\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Check all permutations of the list (both orders of the strings)\n    for s1, s2 in [lst, lst[::-1]]:\n        # Concatenate the strings in the current order\n        concatenated = s1 + s2\n        # Check if the concatenated string is balanced\n        if is_balanced(concatenated):\n            return 'Yes'\n    # If no balanced concatenation is found after checking both orders\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two lists of parentheses in some order \n    to get a balanced string of parentheses.\n\n    Args:\n        lst (list): A list containing two strings of parentheses.\n\n    Returns:\n        str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Calculate the difference in the number of open and close parentheses for each string\n    open_diff = [s.count('(') - s.count(')') for s in lst]\n    \n    # Check all possible concatenations\n    combinations = [lst[0] + lst[1], lst[1] + lst[0]]\n    for combo in combinations:\n        # If the total difference is not zero, the string cannot be balanced\n        total_diff = sum(open_diff)\n        if total_diff != 0:\n            continue\n        # Check if the concatenated string is balanced\n        if is_balanced(combo):\n            return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two strings of parentheses in some order\n    to form a balanced string.\n\n    Args:\n        lst (list): A list containing two strings of '(' or ')' characters.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Check all possible concatenations\n    combinations = [lst[0] + lst[1], lst[1] + lst[0]]\n    for combo in combinations:\n        if is_balanced(combo):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two lists of parentheses in any order\n    to form a balanced string.\n\n    Args:\n        lst (list): A list of two strings, each consisting of '(' or ')'.\n\n    Returns:\n        str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Generate all possible concatenations of the input strings\n    concat_options = [lst[0] + lst[1], lst[1] + lst[0]]\n\n    # Check if any of the concatenations result in a balanced string\n    for option in concat_options:\n        if is_balanced(option):\n            return 'Yes'\n\n    # If no balanced string is found, return 'No'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two strings of parentheses in some order \n    to get a string with balanced parentheses.\n\n    Args:\n    lst (list): A list of two strings, each consisting of '(' or ')'.\n\n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a single string has balanced parentheses.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Count the total imbalance (difference between open and close parentheses)\n    total_open = lst[0].count('(') + lst[1].count('(')\n    total_close = lst[0].count(')') + lst[1].count(')')\n\n    # If total imbalance is not zero, it's impossible to balance\n    if abs(total_open - total_close) != 0:\n        return 'No'\n\n    # Check both concatenation orders\n    return 'Yes' if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two strings of parentheses can be concatenated in any order to form a balanced string.\n\n    Args:\n        lst (list): A list of two strings, each containing only '(' or ')'.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a single string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Check all possible concatenations\n    for s1, s2 in [lst, lst[::-1]]:  # lst[::-1] reverses the order of the list\n        # Concatenate and check\n        if is_balanced(s1 + s2):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two lists of parentheses can be concatenated in some order to form a balanced string.\n\n    Args:\n        lst (list): A list of two strings consisting of '(' or ')'.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n\n    Examples:\n        >>> match_parens(['()(', ')'])\n        'Yes'\n        >>> match_parens([')', ')'])\n        'No'\n    '''\n\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Calculate the net balance of each string (opening - closing)\n    balance = [s.count('(') - s.count(')') for s in lst]\n\n    # Check all possible concatenation orders\n    orders = [\"\".join(lst), \"\".join(reversed(lst))]\n    for order in orders:\n        if is_balanced(order):\n            return 'Yes'\n\n    # If no order results in a balanced string, return 'No'\n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two lists of parentheses can be concatenated in an order to form a balanced string.\n\n    Args:\n        lst (list): A list of two strings consisting of '(' or ')' only.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Concatenate in both possible orders and check for balance\n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n    \n    return 'Yes' if is_balanced(concat1) or is_balanced(concat2) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two strings of parentheses can be concatenated in some order to form a balanced string.\n\n    Args:\n        lst (list): A list containing two strings of parentheses.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n\n    Examples:\n        >>> match_parens(['()(', ')'])\n        'Yes'\n        >>> match_parens([')', ')'])\n        'No'\n    '''\n\n    # Count the total number of open and close parentheses in both strings\n    total_open = lst[0].count('(') + lst[1].count('(')\n    total_close = lst[0].count(')') + lst[1].count(')')\n\n    # If the total number of open and close parentheses are not equal, they cannot be balanced\n    if total_open != total_close:\n        return 'No'\n\n    # Check each possible concatenation order\n    for s1, s2 in [lst, lst[::-1]]:\n        # Initialize a stack to track the balance\n        stack = []\n        \n        # Concatenate the strings in the current order and check for balance\n        for char in s1 + s2:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:  # If there's no matching open parenthesis, it's not balanced\n                    break\n                stack.pop()\n        else:\n            # If the loop completes without breaking and the stack is empty, the string is balanced\n            if not stack:\n                return 'Yes'\n\n    # If no balanced concatenation is found after checking both orders, return 'No'\n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two strings of parentheses can be concatenated in any order to form a balanced string.\n\n    Args:\n    lst (list): A list containing two strings, each consisting of '(' or ')'.\n\n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n\n    Examples:\n    >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n    'No'\n    '''\n\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Check all possible concatenations\n    for s1, s2 in [(lst[0], lst[1]), (lst[1], lst[0])]:\n        # Concatenate the strings\n        full_s = s1 + s2\n        # Check if the concatenated string is balanced\n        if is_balanced(full_s):\n            return 'Yes'\n    # If no balanced concatenation is found\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two lists of parentheses can be concatenated in any order to form a balanced string.\n\n    Args:\n        lst (list): A list containing two strings of '(' and ')' characters.\n\n    Returns:\n        str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Calculate total balance (open - close) for each string\n    balance1 = lst[0].count('(') - lst[0].count(')')\n    balance2 = lst[1].count('(') - lst[1].count(')')\n\n    # Check all possible concatenations\n    orders = [lst[0] + lst[1], lst[1] + lst[0]]\n    for order in orders:\n        if is_balanced(order):\n            return 'Yes'\n\n    # If no balanced string is found\n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two strings of parentheses in some order\n    to form a balanced (good) string.\n\n    Args:\n        lst (list): A list of two strings, each consisting of '(' or ')' only.\n\n    Returns:\n        str: 'Yes' if a good string can be formed, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def can_form_balanced(s1, s2):\n        \"\"\"Checks if concatenating s1 and s2 (in any order) can form a balanced string.\"\"\"\n        return is_balanced(s1 + s2) or is_balanced(s2 + s1)\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings\")\n    \n    for s in lst:\n        if not set(s).issubset({'(', ')'}):\n            raise ValueError(\"Input strings must consist of '(' or ')' only\")\n\n    return 'Yes' if can_form_balanced(lst[0], lst[1]) else 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two strings of parentheses in some order \n    to form a balanced (good) string.\n\n    Args:\n    lst (list): A list of two strings, each consisting of '(' or ')' only.\n\n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a single string is balanced.\"\"\"\n        return s.count('(') == s.count(')') and all(s[:i+1].count('(') >= s[:i+1].count(')') for i in range(len(s)))\n\n    # Check all permutations of concatenating the two strings\n    for s1, s2 in [lst, lst[::-1]]:  # lst and its reverse to cover both orders\n        if is_balanced(s1 + s2):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two strings of parentheses in some order \n    to form a balanced (good) string.\n\n    Args:\n        lst (list): A list of two strings, each consisting of '(' or ')' only.\n\n    Returns:\n        str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:  # If negative, there's an extra ')'\n                    return False\n        return balance == 0  # Balanced if ending balance is 0\n\n    def can_form_balanced(s1, s2):\n        \"\"\"Checks if concatenating s1 and s2 in any order can form a balanced string.\"\"\"\n        # Concatenate in both possible orders and check\n        return is_balanced(s1 + s2) or is_balanced(s2 + s1)\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n    if not all(set(s).issubset('()') for s in lst):\n        raise ValueError(\"Input strings must consist of '(' and ')' only.\")\n\n    return 'Yes' if can_form_balanced(*lst) else 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it's possible to concatenate two strings of parentheses in some order \n    to form a balanced string.\n\n    Args:\n    lst (list): A list containing two strings of parentheses.\n\n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n\n    Examples:\n    >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n    'No'\n    '''\n\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Calculate the total balance (difference between open and close parentheses)\n    total_open = lst[0].count('(') + lst[1].count('(')\n    total_close = lst[0].count(')') + lst[1].count(')')\n\n    # If the total is not balanced, it's impossible to balance\n    if abs(total_open - total_close) > 1 or (total_open == 1 and total_close == 0) or (total_open == 0 and total_close == 1):\n        return 'No'\n\n    # Check both possible concatenations\n    return 'Yes' if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    Checks if two lists of parentheses can be concatenated in any order to form a balanced string.\n\n    Args:\n        lst (list): A list containing two strings of '(' or ')'.\n\n    Returns:\n        str: 'Yes' if the strings can be concatenated to form a balanced string, 'No' otherwise.\n    '''\n    def is_balanced(s):\n        \"\"\"Helper function to check if a string of parentheses is balanced.\"\"\"\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    # Check all possible concatenations\n    combos = [lst[0] + lst[1], lst[1] + lst[0]]\n    for combo in combos:\n        if is_balanced(combo):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 47.93103448275862, "dps_norm": 85.0, "pass@1": 79.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): A positive integer indicating the number of maximum numbers to return.\n\n    Returns:\n        list: A sorted list of the k maximum numbers in arr.\n    \"\"\"\n    # Check if k is not greater than the length of arr\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of arr\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array (which are the k max numbers)\n    # and then sort this subset in ascending order as per the problem's requirement\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List of integers\n    :type arr: list[int]\n    :param k: Positive integer\n    :type k: int\n    :return: Sorted list of the maximum k numbers\n    :rtype: list[int]\n    \"\"\"\n    # Check if k is within bounds\n    if not (0 <= k <= len(arr)):\n        raise ValueError(\"k is out of bounds\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Returns a sorted list of length k with the maximum k numbers in arr.\n\n    :param arr: List of integers\n    :param k: Positive integer, 0 <= k <= len(arr)\n    :return: Sorted list of the maximum k numbers\n    \"\"\"\n    # Check if k is within the valid range\n    if not 0 <= k <= len(arr):\n        raise ValueError(\"k is out of range. It should be between 0 and the length of the array.\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array\n    return sorted(sorted_arr[:k])  # Sort again to ensure output is in ascending order as per examples", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Parameters:\n    arr (list): A list of integers.\n    k (int): A positive integer indicating the number of maximum numbers to return.\n\n    Returns:\n    list: A sorted list of the maximum k numbers in arr.\n    \"\"\"\n    # Check if k is within the bounds of the array length\n    if not 0 <= k <= len(arr):\n        raise ValueError(\"k is out of bounds\")\n\n    # Sort the array in descending order and select the first k elements\n    max_k_numbers = sorted(arr, reverse=True)[:k]\n    \n    # Sort the selected k numbers in ascending order as per the problem's requirement\n    max_k_numbers = sorted(max_k_numbers)\n    \n    return max_k_numbers", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List of integers\n    :param k: Positive integer indicating the number of max numbers to return\n    :return: Sorted list of length k with the maximum k numbers in arr\n    \"\"\"\n    # Check if k is not greater than the length of the array\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Parameters:\n    arr (list): A list of integers.\n    k (int): A positive integer.\n\n    Returns:\n    list: A sorted list of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Check if k is not greater than the length of the array\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements from the sorted array\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Parameters:\n    arr (list): A list of integers.\n    k (int): A positive integer representing the length of the output list.\n\n    Returns:\n    list: A sorted list of length k containing the maximum k numbers from arr.\n    \"\"\"\n    # Check if k is within the bounds of the array length\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n\n    # Sort the array in descending order to prioritize maximum numbers\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Slice the sorted array up to k to get the k maximum numbers\n    max_k_numbers = sorted_arr[:k]\n    \n    # Sort the k maximum numbers in ascending order as per the problem statement\n    max_k_numbers = sorted(max_k_numbers)\n    \n    return max_k_numbers", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: A list of integers\n    :param k: A positive integer\n    :return: A sorted list of the maximum k numbers in arr\n    \"\"\"\n    # Check if k is not greater than the length of the array\n    k = min(k, len(arr))  # Adjust k to prevent indexing errors\n\n    # Sort the array in descending order and select the first k elements\n    max_k_elements = sorted(arr, reverse=True)[:k]\n    \n    # Sort the selected k elements in ascending order as per the problem's output requirement\n    sorted_max_k_elements = sorted(max_k_elements)\n    \n    return sorted_max_k_elements", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: Array of integers\n    :type arr: list[int]\n    :param k: Positive integer\n    :type k: int\n    :return: Sorted list of length k with the maximum k numbers in arr\n    :rtype: list[int]\n    \"\"\"\n    # Check if k is not greater than the length of the array\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array (the maximum k numbers)\n    # Slice up to k to ensure we don't go out of bounds if k equals the array length\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, \n    return a sorted list of length k with the maximum k numbers in arr.\n    \n    Parameters:\n    arr (list): A list of integers\n    k (int): The number of maximum numbers to return\n    \n    Returns:\n    list: A sorted list of the k maximum numbers in arr\n    \"\"\"\n    # Check if k is within the bounds of the array length\n    if k > len(arr):\n        raise ValueError(\"k cannot be larger than the length of the array\")\n    \n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr_desc = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array, then sort them in ascending order\n    return sorted(sorted_arr_desc[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: A list of integers\n    :type arr: list[int]\n    :param k: A positive integer\n    :type k: int\n    :return: A sorted list of length k with the maximum k numbers in arr\n    :rtype: list[int]\n    \"\"\"\n    # Check if k is within the bounds of the array length\n    if not 0 <= k <= len(arr):\n        raise ValueError(\"k is out of bounds\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Slice the sorted array to get the first k elements (the maximum k numbers)\n    max_k_numbers = sorted_arr[:k]\n    \n    # Sort these k numbers in ascending order as per the problem's output requirement\n    result = sorted(max_k_numbers)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): A positive integer.\n\n    Returns:\n        list: A sorted list of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Check if k is within valid range\n    if not 0 <= k <= len(arr):\n        raise ValueError(\"k is out of range. It should be between 0 and the length of the array.\")\n\n    # Sort the array in descending order and select the first k elements\n    max_k_numbers = sorted(arr, reverse=True)[:k]\n    \n    # Sort the selected k numbers in ascending order as per the problem's requirement\n    max_k_numbers = sorted(max_k_numbers)\n    \n    return max_k_numbers", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, \n    return a sorted list of length k with the maximum k numbers in arr.\n\n    Parameters:\n    arr (list): A list of integers.\n    k (int): A positive integer indicating the length of the output list.\n\n    Returns:\n    list: A sorted list of the maximum k numbers in arr.\n    \"\"\"\n    # Check if k is within the valid range\n    if not 0 <= k <= len(arr):\n        raise ValueError(\"k is out of range. It should be between 0 and the length of arr.\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array (the maximum k numbers)\n    # Slice the list up to k, and then sort this slice in ascending order as per problem's output examples\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): A positive integer representing the number of maximum numbers to return.\n\n    Returns:\n        list: A sorted list of the k maximum numbers in arr.\n\n    Raises:\n        ValueError: If k is larger than the length of arr or if k is less than 0.\n    \"\"\"\n    if k > len(arr) or k < 0:\n        raise ValueError(\"k must be within the range of the array's length and non-negative.\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array, then sort them in ascending order\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): A positive integer.\n\n    Returns:\n        list: A sorted list of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Check if k is within the valid range\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k is out of range. 0 <= k <= len(arr)\")\n\n    # Sort the array in descending order and select the first k elements\n    max_k_nums = sorted(arr, reverse=True)[:k]\n    \n    # Sort the selected k numbers in ascending order as per the problem statement\n    max_k_nums_sorted = sorted(max_k_nums)\n    \n    return max_k_nums_sorted", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List of integers\n    :param k: Positive integer, 0 <= k <= len(arr)\n    :return: Sorted list of length k with the maximum k numbers in arr\n    \"\"\"\n    # Validate input (optional but recommended for robustness)\n    if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\n        raise ValueError(\"arr must be a list of integers\")\n    if not isinstance(k, int) or k < 0 or k > len(arr):\n        raise ValueError(\"k must be an integer, 0 <= k <= len(arr)\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array (the maximum k numbers)\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 4}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List of integers\n    :type arr: list[int]\n    :param k: Positive integer\n    :type k: int\n    :return: Sorted list of length k with the maximum k numbers\n    :rtype: list[int]\n    \"\"\"\n    # Validate input range for k\n    if not 0 <= k <= len(arr):\n        raise ValueError(\"k is out of range. It should be between 0 and the length of the array.\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Returns a sorted list of length k with the maximum k numbers in arr.\n\n    :param arr: Input array of integers\n    :type arr: list[int]\n    :param k: Positive integer specifying the length of the output list\n    :type k: int\n    :return: Sorted list of the maximum k numbers\n    :rtype: list[int]\n    \"\"\"\n    # Check if k is within valid range\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k is out of range. It should be 0 <= k <= len(arr)\")\n\n    # Sort the array in descending order to get the maximum numbers first\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements of the sorted array\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): A positive integer.\n\n    Returns:\n        list: A sorted list of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Check if k is not larger than the array length\n    k = min(k, len(arr))\n    \n    # Sort the array in descending order and select the first k elements\n    max_k_elements = sorted(arr, reverse=True)[:k]\n    \n    # Sort the selected k elements in ascending order as per the problem's output requirement\n    sorted_max_k_elements = sorted(max_k_elements)\n    \n    return sorted_max_k_elements", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List of integers\n    :param k: Positive integer, where 0 <= k <= len(arr)\n    :return: Sorted list of the maximum k numbers in arr\n    \"\"\"\n    # Check if k is within the valid range\n    if not 0 <= k <= len(arr):\n        raise ValueError(\"k is out of range. It should be between 0 and the length of the array.\")\n    \n    # Sort the array in descending order and select the first k elements\n    max_k_numbers = sorted(arr, reverse=True)[:k]\n    \n    # Sort the selected k numbers in ascending order as per the problem's requirement\n    sorted_max_k_numbers = sorted(max_k_numbers)\n    \n    return sorted_max_k_numbers", "matching_cluster_idx": 5}]}, "HumanEval/121": {"dps": 78.02690582959642, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of all odd elements in even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    # Use list comprehension to filter odd numbers at even indices (0-based indexing)\n    # and then sum the results\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of all odd elements in even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # If both conditions are true, add the value to the sum\n            total_sum += value\n    \n    # Return the calculated sum\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of odd elements in even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Parameters:\n    lst (list): A list of integers\n\n    Returns:\n    int: The sum of odd elements in even positions (0-indexed)\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for idx, val in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if idx % 2 == 0 and val % 2 != 0:\n            # Add the odd value to the sum if conditions are met\n            total_sum += val\n    \n    # Return the calculated sum\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of odd elements at even positions (0-indexed).\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    # Use list comprehension to filter odd numbers at even indices and sum them up\n    # The expression `enumerate(lst)` returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over the sequence (`lst`).\n    # The condition `if idx % 2 == 0 and val % 2 != 0` ensures we only sum odd numbers at even indices\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of all odd elements in even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    # Use enumerate to get both index and value while iterating over the list\n    # Filter to include only odd numbers at even indices\n    # Sum up the filtered numbers\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to get both index and value\n    for idx, val in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if idx % 2 == 0 and val % 2 != 0:\n            # If both conditions are met, add the value to the total sum\n            total_sum += val\n    \n    # Return the total sum of odd elements in even positions\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Parameters:\n    lst (list): A non-empty list of integers.\n    \n    Returns:\n    int: The sum of odd elements in even positions (0-indexed).\n    \n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the list using enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # If both conditions are met, add the value to the sum\n            total_sum += value\n    \n    # Return the total sum of odd elements in even positions\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of all odd elements in even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    # Use enumerate to get both index and value while iterating over the list\n    # Filter for even indices (0-based indexing, so even indices are where index % 2 == 0)\n    # Sum the values that are odd (value % 2 != 0)\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: The sum of odd elements at even positions (0-indexed).\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the odd value at an even position to the sum\n            total_sum += value\n    \n    # Return the total sum of odd values at even positions\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Parameters:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of all odd elements at even positions.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n\n    # Use list comprehension with enumerate to filter and sum odd numbers at even indices\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the list using enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the odd value at an even position to the total sum\n            total_sum += value\n    \n    # Return the total sum of odd elements at even positions\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Parameters:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: Sum of odd elements at even positions (0-indexed).\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Use list comprehension to filter odd numbers at even indices and sum them\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of odd elements at even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list using enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is even (0-based indexing, so even indexes are even numbers)\n        if index % 2 == 0:\n            # Check if the value is odd\n            if value % 2 != 0:\n                # Add the odd value at an even position to the total sum\n                total_sum += value\n                \n    # Return the total sum of odd values at even positions\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of all odd elements at even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    # Use enumerate to get both index and value from the list\n    # Filter for even indices (0-based, so even indices are where index % 2 == 0)\n    # Then filter for odd values (where value % 2 != 0)\n    # Sum up the remaining values\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of all odd elements at even positions (0-indexed).\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    # Use list comprehension to filter odd numbers at even indices and sum them up\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Parameters:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of all odd elements in even positions (0-indexed).\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Use list comprehension to filter odd numbers at even indices and sum them up\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Returns the sum of all odd elements in even positions within a given list.\n    \n    Parameters:\n    lst (list): A non-empty list of integers.\n    \n    Returns:\n    int: Sum of odd elements at even positions.\n    \"\"\"\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # If both conditions are true, add the value to the sum\n            total_sum += value\n    \n    # Return the calculated sum\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 99.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function filters out strings with odd lengths from the input list, \n    then returns the resulting list sorted first by string length in ascending order, \n    and then alphabetically for strings of the same length.\n\n    Parameters:\n    lst (list): A list of strings.\n\n    Returns:\n    list: Filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in lst if len(string) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function filters a list of strings to remove those with odd lengths,\n    then returns the resulting list sorted by string length in ascending order.\n    For strings of the same length, alphabetical order is used.\n\n    Parameters:\n    lst (list): A list of strings\n\n    Returns:\n    list: Filtered and sorted list of strings\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(input_list):\n    \"\"\"\n    This function filters out strings with odd lengths from the input list,\n    then returns the resulting list sorted first by string length (ascending) \n    and then alphabetically for strings of the same length.\n\n    Parameters:\n    input_list (list): A list of strings.\n\n    Returns:\n    list: The filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in input_list if len(string) % 2 == 0]\n    \n    # Sort the list first by string length (ascending) and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list, \n    then returns the resulting list sorted by string length in ascending order, \n    and alphabetically for strings of the same length.\n\n    Args:\n        lst (list): A list of strings.\n\n    Returns:\n        list: A sorted list of strings with only even-length strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths from a list, \n    then returns the resulting list sorted by string length (ascending) \n    and alphabetically for strings of the same length.\n\n    Args:\n        lst (list[str]): Input list of strings\n\n    Returns:\n        list[str]: Filtered and sorted list of strings\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in lst if len(string) % 2 == 0]\n    \n    # Sort the list first by string length (ascending), then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(input_list):\n    \"\"\"\n    This function filters out strings with odd lengths from the input list,\n    sorts the remaining strings first by their lengths in ascending order,\n    and then alphabetically for strings of the same length.\n\n    Parameters:\n    input_list (list): A list of strings.\n\n    Returns:\n    list: Filtered and sorted list of strings.\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in input_list if len(string) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function filters out strings with odd lengths from the input list,\n    then returns the remaining strings in a sorted order. The sorting order\n    is first by the length of the strings (ascending) and then alphabetically\n    for strings of the same length.\n\n    Parameters:\n    lst (list): A list of strings\n\n    Returns:\n    list: A filtered and sorted list of strings\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in lst if len(string) % 2 == 0]\n    \n    # Sort the list first by string length and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list, \n    then returns the resulting list sorted by string length (ascending) \n    and alphabetically for strings of the same length.\n\n    Parameters:\n    lst (list): A list of strings\n\n    Returns:\n    list: Filtered and sorted list of strings\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by string length (ascending) and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(input_list):\n    \"\"\"\n    This function filters out strings with odd lengths from the input list,\n    then returns the resulting list sorted by string length in ascending order.\n    If two strings have the same length, they are sorted alphabetically.\n\n    Parameters:\n    input_list (list): A list of strings.\n\n    Returns:\n    list: Filtered and sorted list of strings.\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in input_list if len(string) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "import unittest\ndef sorted_list_sum(lst):\n    \"\"\"\n    Filter out strings with odd lengths and sort the remaining list by \n    string length in ascending order, then alphabetically if lengths are equal.\n\n    Parameters:\n    - lst (list): A list of strings.\n\n    Returns:\n    - list: Filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in lst if len(string) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(input_list):\n    \"\"\"\n    Filters out strings with odd lengths from the input list, \n    then returns the resulting list sorted by string length in ascending order, \n    and for strings of the same length, sorted alphabetically.\n\n    Args:\n        input_list (list): A list of strings.\n\n    Returns:\n        list: The filtered and sorted list of strings.\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in input_list if len(string) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function filters out strings with odd lengths from the input list, \n    then returns the resulting list sorted first by string length in ascending order, \n    and then alphabetically for strings of the same length.\n\n    Parameters:\n    lst (list): A list of strings\n\n    Returns:\n    list: Filtered and sorted list of strings\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(input_list):\n    \"\"\"\n    This function filters a list of strings to exclude those with odd lengths,\n    then returns the remaining list sorted by string length in ascending order.\n    For strings of the same length, it sorts alphabetically.\n\n    Args:\n        input_list (list): A list of strings.\n\n    Returns:\n        list: Filtered and sorted list of strings.\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in input_list if len(string) % 2 == 0]\n    \n    # Sort the list first by the length of the strings and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths from the input list, \n    sorts the remaining strings first by their lengths in ascending order, \n    and then alphabetically if lengths are equal.\n\n    Args:\n        lst (list[str]): The input list of strings.\n\n    Returns:\n        list[str]: The filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in lst if len(string) % 2 == 0]\n    \n    # Sort the remaining strings first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(input_list):\n    \"\"\"\n    Filters out strings with odd lengths from the input list, \n    then returns the resulting list sorted by string length in ascending order, \n    and alphabetically for strings of the same length.\n\n    Args:\n        input_list (list[str]): The input list of strings.\n\n    Returns:\n        list[str]: The filtered and sorted list of strings.\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in input_list if len(string) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function filters out strings with odd lengths from the input list,\n    sorts the remaining strings first by their lengths in ascending order, \n    and then alphabetically for strings of the same length.\n\n    Parameters:\n    lst (list): A list of strings\n\n    Returns:\n    list: A sorted list of strings with only even-length strings\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in lst if len(string) % 2 == 0]\n    \n    # Sort the list: first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Filters out strings with odd lengths from the input list, \n    then returns the resulting list sorted by string length in ascending order. \n    For strings of the same length, sorting is done alphabetically.\n\n    Parameters:\n    lst (list): A list of strings\n\n    Returns:\n    list: Filtered and sorted list of strings\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(input_list):\n    \"\"\"\n    This function filters a list of strings to exclude those with odd lengths,\n    then returns the resulting list sorted first by string length in ascending order,\n    and for strings of the same length, sorted alphabetically.\n\n    Parameters:\n    input_list (list): A list of strings.\n\n    Returns:\n    list: Filtered and sorted list of strings.\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in input_list if len(string) % 2 == 0]\n    \n    # Sort the remaining strings first by length and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function filters out strings with odd lengths from the input list, \n    then returns the resulting list sorted first by string length in ascending order, \n    and for strings of the same length, sorted alphabetically.\n\n    Parameters:\n    lst (list): A list of strings\n\n    Returns:\n    list: Filtered and sorted list of strings\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in lst if len(string) % 2 == 0]\n    \n    # Sort the list: first by length of strings, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(input_list):\n    \"\"\"\n    Filters out strings with odd lengths from the input list, \n    then returns the resulting list sorted by string length in ascending order, \n    and alphabetically for strings of the same length.\n\n    Parameters:\n    input_list (list): A list of strings\n\n    Returns:\n    list: Filtered and sorted list of strings\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [string for string in input_list if len(string) % 2 == 0]\n    \n    # Sort the list first by string length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 53.305084745762706, "dps_norm": 73.75, "pass@1": 87.0, "profiled": [{"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n    - `n`: The number to check.\n    \n    Returns:\n    - `True` if `n` is not prime, `False` otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    \n    # Check from 2 to the square root of n\n    # This is an optimization to reduce the number of checks\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:  # If n is divisible by any number, it's not prime\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Identifies if a number is not prime.\n    \n    Args:\n    - `n` (int): The number to check.\n    \n    Returns:\n    - `bool`: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Check divisibility up to sqrt(n)\n        if n % i == 0:  # If divisible, it's not prime\n            return True\n    return False  # If no divisors found, it's prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n    - n (int): The number to check.\n\n    Returns:\n    - bool: True if n is not prime, False if n is prime.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Check divisibility up to sqrt(n)\n        if n % i == 0:  # If n is divisible by any number between 2 and sqrt(n), it's not prime\n            return True\n    return False  # If no divisors found, n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Identifies if a given number is not prime.\n    \n    :param n: The number to check.\n    :return: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Only need to check up to the square root of n\n        if n % i == 0:  # If n is divisible by any number between 2 and its square root, it's not prime\n            return True\n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n    - n (int): The number to check.\n\n    Returns:\n    - bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    \n    # Check divisibility up to the square root of n\n    # because a larger factor of the number would be a multiple of a smaller factor that has already been checked\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:  # If n is divisible by any number between 2 and its square root, it's not prime\n            return True\n    \n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Checks if a number is not prime.\n    \n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    \"\"\"\n    # Handle edge cases: numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    # This is an optimization since a larger factor of the number would be a multiple of smaller factor that has already been checked\n    for i in range(2, int(n ** 0.5) + 1):\n        # If n is divisible by any number between 2 and sqrt(n), it's not prime\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Identifies if a number is not prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    \n    # Check divisibility from 2 to the square root of n\n    # because a larger factor of the number would be a multiple of smaller factor that has already been checked\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:  # If n is divisible by any number between 2 and sqrt(n), it's not prime\n            return True\n    \n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Check divisibility up to sqrt(n)\n        if n % i == 0:  # If n is divisible by any number, it's not prime\n            return True\n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Only need to check up to the square root of n\n        if n % i == 0:  # If n is divisible by any number, it's not prime\n            return True\n    return False  # If no divisors are found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n        n (int): Number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Check up to the square root of n\n        if n % i == 0:  # If n is divisible by any number between 2 and sqrt(n), it's not prime\n            return True\n    return False  # If no divisors found, n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n    - `n` (int): The number to check.\n\n    Returns:\n    - `bool`: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Only need to check up to the square root\n        if n % i == 0:  # If divisible by any number, it's not prime\n            return True\n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Identifies if a given integer is not a prime number.\n    \n    Args:\n        n (int): The number to check.\n    \n    Returns:\n        bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Check divisibility up to the square root of n\n        if n % i == 0:  # If n is divisible by any number, it's not prime\n            return True\n    return False  # If no divisors found, n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, not a prime\n    return False  # No divisors found, is a prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n    n (int): The number to check for primality.\n\n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Check up to the square root of n\n        if n % i == 0:  # If n is divisible by any number, it's not prime\n            return True\n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n    - `n`: The number to check.\n    \n    Returns:\n    - `True` if `n` is not a prime number, `False` otherwise.\n    \"\"\"\n    if n <= 1:  # 0 and 1 are not prime numbers\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Only check up to the square root of n\n        if n % i == 0:  # If n is divisible by any number between 2 and its square root, it's not prime\n            return True\n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Check divisibility up to sqrt(n)\n        if n % i == 0:  # If n is divisible by any number, it's not prime\n            return True\n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Checks if a number is not prime.\n\n    :param n: The number to check.\n    :return: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Only need to check up to the square root\n        if n % i == 0:  # If n is divisible by any number, it's not prime\n            return True\n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n**0.5) + 1):  # Only need to check up to the square root of n\n        if n % i == 0:  # If n is divisible by any number, it's not prime\n            return True\n    return False  # If no divisors found, n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n    \n    Args:\n        n (int): The number to check.\n    \n    Returns:\n        bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    \n    # Check divisibility from 2 to the square root of n\n    # as a larger factor of the number would be a multiple of smaller factor that has already been checked\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:  # If n is divisible by any number between 2 and sqrt(n), it's not prime\n            return True\n    \n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n: int) -> bool:\n    \"\"\"\n    Identifies if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if `n` is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:  # Numbers less than or equal to 1 are not prime\n        return True\n    for i in range(2, int(n ** 0.5) + 1):  # Check divisibility up to the square root of n\n        if n % i == 0:  # If n is divisible by any number between 2 and sqrt(n), it's not prime\n            return True\n    return False  # If no divisors found, n is prime, so return False for is_not_prime", "matching_cluster_idx": 4}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 94.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Parameters:\n    - numbers (list): A list of integers.\n    - n (int): The number of largest integers to return.\n\n    Returns:\n    - list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Ensure n is not larger than the list length\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    # This function returns them in descending order by default\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from a given list of numbers in descending order.\n\n    :param numbers: A list of integers.\n    :param n: The number of largest integers to return.\n    :return: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    # Return the largest n numbers in descending order (which is the default order for nlargest)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers and return them in descending order.\n\n    Args:\n    - numbers (list): A list of integers.\n    - n (int): The number of largest integers to find.\n\n    Returns:\n    - list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Ensure n is not larger than the list of numbers to avoid indexing errors\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    # This function returns the n largest elements from the iterable specified by the key function\n    # By default, the key function is the identity, so it works directly with numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Since heapq.nlargest already returns the numbers in descending order, \n    # we can directly return the result\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from the input list in descending order.\n\n    :param numbers: A list of integers\n    :param n: The number of largest integers to return\n    :return: A list of the n largest integers in descending order\n    \"\"\"\n    # Check if n is not greater than the list length to avoid index errors\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Parameters:\n    - `numbers`: A list of integers.\n    - `n`: The number of largest integers to find.\n\n    Returns:\n    - A list of the n largest integers in descending order.\n    \"\"\"\n    # Check if n is not larger than the list length\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n\nnumbers = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: A list of integers.\n    :type numbers: list[int]\n    :param n: The number of largest integers to find.\n    :type n: int\n    :return: A list of the n largest integers in descending order.\n    :rtype: list[int]\n    \"\"\"\n    # Ensure n is not larger than the list length to avoid index errors\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers in a list of numbers.\n\n    Args:\n    - numbers (list): A list of integers.\n    - n (int): The number of largest integers to find.\n\n    Returns:\n    - list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Ensure n is not larger than the list length to avoid index errors\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from the input list in descending order.\n\n    :param numbers: A list of integers\n    :param n: The number of largest integers to return\n    :return: A list of the n largest integers in descending order\n    \"\"\"\n    # Ensure n is not larger than the list length to avoid index errors\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements in the list\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from a given list of numbers in descending order.\n\n    :param numbers: A list of integers\n    :param n: The number of largest integers to return\n    :return: A list of the n largest integers in descending order\n    \"\"\"\n    # Ensure n is not larger than the list length to avoid index errors\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: A list of integers.\n    :type numbers: list\n    :param n: The number of largest integers to find.\n    :type n: int\n    :return: A list of the n largest integers in descending order.\n    :rtype: list\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements in the list\n    # This function returns the n largest elements from the iterable specified by the key function.\n    # Here, since we are dealing with integers, no key function is needed.\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from a given list of numbers in descending order.\n\n    :param numbers: A list of integers.\n    :param n: The number of largest integers to return.\n    :return: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements in the list\n    largest_n = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order (which is the default for nlargest)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from the input list in descending order.\n\n    :param numbers: The list of numbers to search.\n    :type numbers: list[int]\n    :param n: The number of largest integers to return.\n    :type n: int\n    :return: A list of the n largest integers in descending order.\n    :rtype: list[int]\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: A list of integers\n    :param n: The number of largest integers to find\n    :return: A list of the n largest integers in descending order\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements in the list\n    largest_n = heapq.nlargest(n, numbers)\n    \n    # Return the result\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: A list of integers.\n    :type numbers: list\n    :param n: The number of largest integers to find.\n    :type n: int\n    :return: A list of the n largest integers in descending order.\n    :rtype: list\n    \"\"\"\n    # Ensure n is not larger than the list of numbers\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from a given list of numbers in descending order.\n\n    :param numbers: A list of integers.\n    :param n: The number of largest integers to return.\n    :return: A list of the n largest integers in descending order.\n    \"\"\"\n    # Ensure n is not larger than the list of numbers\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    # Return the n largest numbers in descending order\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Return the n largest integers from the given list of numbers in descending order.\n\n    :param numbers: A list of integers\n    :param n: The number of largest integers to return\n    :return: List of the n largest integers in descending order\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the result directly since nlargest returns in descending order\n    return largest_numbers\nnumbers = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        numbers (list): A list of integers.\n        n (int): The number of largest integers to find.\n\n    Returns:\n        list: A list of the n largest integers in descending order.\n\n    Example:\n        >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n        [85, 75, 65]\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a list of numbers.\n\n    Parameters:\n    - `numbers` (list): A list of integers.\n    - `n` (int): The number of largest integers to find.\n\n    Returns:\n    - `list`: A list of the n largest integers in descending order.\n    \"\"\"\n    # Ensure n is not larger than the list length to avoid indexing errors\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    # This function returns the n largest elements from the iterable specified by the key function\n    # Here, we use no key function (i.e., identity function), meaning the integers are compared as is\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n    - numbers (list): A list of integers.\n    - n (int): The number of largest integers to find.\n\n    Returns:\n    - list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Ensure n is not larger than the list length\n    n = min(n, len(numbers))\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_nums = heapq.nlargest(n, numbers)\n    \n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from a given list of numbers in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to return\n    :return: List of n largest integers in descending order\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order (nlargest already returns in descending)\n    return largest_n", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 73.84353741496598, "dps_norm": 55.5, "pass@1": 58.0, "profiled": [{"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function calculates the minimum number of rotations (greater than 0) \n    required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    if not s:  # Edge case: Empty string\n        return 0\n    \n    length = len(s)\n    for i in range(1, length):  # Start from 1 rotation as per the problem statement\n        if s[i:] + s[:i] == s:  # Check if the string matches after rotation\n            return i  # Return the minimum number of rotations\n    \n    # If no match is found, the string is not periodic or only matches at full length\n    # For non-empty strings, at least one rotation (equal to its length) will always match\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of rotations needed to match the original string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required. If no rotation is needed (i.e., the string is asymmetric and doesn't match itself with any rotation), returns the length of the string as the minimum rotations to get back to the original state.\n    \"\"\"\n    if len(s) == 0:  # Edge case: Empty string\n        return 0\n    \n    # Concatenate the string with itself to easily find rotations\n    ss = s + s\n    \n    # Find the substring (which is a rotation of s) that matches s and is not the original position\n    for i in range(1, len(s)):\n        if ss[i:i+len(s)] == s:\n            # Found a match, return the number of rotations\n            return i\n    \n    # If no match is found within the first half of the concatenated string (excluding the original position),\n    # the string doesn't have a rotation that matches itself in less than its length; return its length\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(input_string):\n    \"\"\"\n    Calculates the minimum rotations needed to match the original string.\n\n    :param input_string: The input string to be checked.\n    :return: The minimum number of rotations required.\n    \"\"\"\n    if not input_string:  # Edge case: Empty string\n        return 0\n    \n    length = len(input_string)\n    for i in range(1, length):  # Start from 1 rotation as per problem statement\n        if input_string[i:] + input_string[:i] == input_string:\n            return i  # Return the first match, which will be the minimum\n    \n    return length  # If no rotation matches except full rotation (which is not less than length)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Calculate the minimum number of rotations to match the original string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    if len(s) == 0:  # Edge case: Empty string\n        return 0\n    \n    # Concatenate the string with itself to consider all rotations\n    double_s = s + s\n    \n    # Find the first occurrence of 's' in 'double_s' excluding the first character\n    # This effectively finds the shortest rotation that matches the original string\n    for i in range(1, len(s) + 1):\n        if double_s[i:i+len(s)] == s:\n            return i  # Return the minimum rotation found\n\n    # If no rotation matches (shouldn't happen for non-empty strings due to problem nature)\n    return -1  # Indicates an error or invalid input", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Calculate the minimum rotations needed to match the original string.\n    \n    Args:\n    - `s (str)`: The input string.\n    \n    Returns:\n    - `int`: Minimum rotations required (greater than 0).\n    \"\"\"\n    if len(s) == 0:  # Edge case: empty string\n        return 0\n    \n    for rotations in range(1, len(s)):  # Start from 1 rotation as per problem statement\n        rotated_s = s[rotations:] + s[:rotations]  # Rotate the string\n        if rotated_s == s:  # Check if rotation matches the original\n            return rotations  # Return the minimum rotations found\n    \n    return len(s)  # If no match found other than full rotation, return full length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations to get the same string.\n    \n    This function works by checking each possible rotation of the string \n    and returning the first one that matches the original string, \n    excluding the rotation of 0 (the original string itself).\n    \"\"\"\n    # Check if input is a string\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Edge case: string of length 0 or 1 always returns 0 because \n    # no rotation (or just 1 for length 1, but we ignore 0 rotations)\n    if len(s) <= 1:\n        return 0 if len(s) == 0 else 1\n\n    # Iterate through possible rotations, ignoring the 0th rotation\n    for i in range(1, len(s)):\n        # Rotate the string by slicing\n        rotated_s = s[i:] + s[:i]\n        \n        # Check if the rotated string matches the original\n        if rotated_s == s:\n            # If it does, return the number of rotations\n            return i\n\n    # If no matching rotation is found (which is theoretically impossible \n    # for non-empty strings since a string will always match itself \n    # after a full set of rotations), return the full length as a default\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Calculates the minimum number of rotations greater than 0 to match the original string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        int: The minimum number of rotations required.\n    \"\"\"\n    if len(set(s)) == 1:  # All characters are the same\n        return 1\n    \n    # Concatenate the string with itself to simulate rotation\n    ss = s + s\n    \n    # Find the first occurrence of the original string in the concatenated string\n    # The index of this occurrence (minus the length of the original string) gives the minimum rotations\n    for i in range(1, len(s)):\n        if ss[i:i+len(s)] == s:\n            return i\n\n    # If no rotation matches (should not happen for non-uniform strings, but a safe return)\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        int: Minimum rotations required. If no rotation results in the same string, returns the length of the string.\n    \"\"\"\n    if len(s) == 0:  # Edge case: Empty string\n        return 0\n    \n    # Concatenate the string with itself to simulate rotations\n    double_s = s + s\n    \n    # Slice through the concatenated string to find the first occurrence of the original string (excluding the first match at index 0)\n    for i in range(1, len(s)):\n        if double_s[i:i+len(s)] == s:\n            return i  # Return the index, which represents the minimum number of rotations\n    \n    # If no match is found within the length of the string, \n    # it implies the string doesn't have a repeating pattern within its length that matches the original string\n    # The minimum non-zero rotations for such a case would essentially be the length of the string itself\n    # because after len(s) rotations, it will be the same as the original string\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function calculates the minimum number of rotations (greater than 0) \n    required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations.\n    \"\"\"\n    if len(s) == 0:  # Edge case: Empty string\n        return 0\n\n    # Concatenate the string with itself to easily find rotations\n    double_s = s + s\n    \n    # Check for each possible rotation if it matches the original string\n    for i in range(1, len(s)):  # Start from 1 rotation as per the problem statement\n        # Slice the doubled string to get a rotation and compare with the original\n        if double_s[i:i+len(s)] == s:\n            return i  # Return the number of rotations if match found\n\n    # If no match is found within the length of the string, \n    # it means the string is already the minimum rotation of itself\n    # This typically applies to strings with unique permutations like \"abc\"\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function calculates the minimum number of rotations (greater than 0) \n    required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations needed.\n    \"\"\"\n    # Check if the string is empty\n    if not s:\n        raise ValueError(\"Input string cannot be empty\")\n\n    # The minimum number of rotations will be the length of the string \n    # divided by the length of the substring that, when repeated, \n    # forms the original string. This is based on the property of cyclic \n    # strings where a rotation that matches the original after a certain \n    # number of steps implies the string can be formed by repeating a \n    # smaller substring. The minimum positive rotation is thus 1 times \n    # this substring length, except in cases where the string consists of \n    # all identical characters, where the 'minimum' as per the problem \n    # statement (greater than 0) is the length of the string itself for \n    # a full rotation, but for all identical characters, we consider the \n    # minimum effective rotation as 1 for practical purposes, so we need \n    # to handle this edge case.\n\n    # Check if all characters are the same\n    if len(set(s)) == 1:  # set(s) will contain unique characters\n        return 1\n\n    # Find the minimum length of the substring that, when repeated, \n    # gives the original string. This is essentially finding the Greatest \n    # Common Divisor (GCD) of the length of the string and a potential \n    # rotation step, but due to the nature of the problem, we look for \n    # the smallest divisor greater than 1, which effectively divides the \n    # string length without remainder, indicating a full cycle.\n    for i in range(2, len(s) + 1):  # Start from 2 to ensure > 0 rotations\n        if len(s) % i == 0:  # Check for divisor\n            # Verify if the string can be reconstructed by repeating \n            # the substring of the found length\n            if s[:i] * (len(s) // i) == s:\n                return i  # Return the minimum rotation length\n\n    # If no such divisor is found (which should not happen for any valid string), \n    # the full length of the string is considered for a full cycle, but \n    # since we need a rotation greater than 0 and this scenario is more \n    # theoretical given the above checks, we handle it for completeness.\n    return len(s)", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Calculates the minimum number of rotations required to get the same string.\n    \n    :param s: Input string\n    :return: Minimum number of rotations > 0\n    \"\"\"\n    def is_same_string(rotated_s, original_s):\n        \"\"\"Helper function to check if two strings are the same.\"\"\"\n        return rotated_s == original_s\n\n    rotations = 1\n    original_s = s\n    while True:\n        # Rotate the string by one character to the right\n        s = s[-1] + s[:-1]\n        \n        # Check if the rotated string is the same as the original\n        if is_same_string(s, original_s) and rotations > 0:\n            return rotations\n        \n        # Increment rotation count\n        rotations += 1\n\n        # If we've reached the length of the string, no smaller rotation will work\n        if rotations > len(s):\n            return len(s)  # Default to length if no smaller rotation found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: Minimum number of rotations needed.\n    \"\"\"\n    # Check if the string is empty or has only one character\n    if len(s) < 2:\n        return 0  # No rotations needed for strings of length 0 or 1\n    \n    # Initialize the minimum rotations to the length of the string\n    # This is the maximum possible rotations before repeating the original string\n    min_rotations = len(s)\n    \n    # Check each possible rotation\n    for i in range(1, len(s)):\n        # Rotate the string by i positions\n        rotated_s = s[i:] + s[:i]\n        \n        # If the rotated string is the same as the original and i is less than current min_rotations\n        if rotated_s == s and i < min_rotations:\n            # Update the minimum rotations\n            min_rotations = i\n    \n    # If no rotation other than the full length results in the same string, return the length of the string\n    # This handles cases like \"abcd\" where no rotation (other than full) matches\n    if min_rotations == len(s):\n        for i in range(1, len(s)):\n            if s[i:] + s[:i] != s:\n                return len(s)  # Default to full length if no lesser rotation matches\n        return 1  # If all rotations match (e.g., \"aaaa\"), return 1 as per the problem statement\n    else:\n        return min_rotations", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations greater than 0 required to get the same string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: Minimum number of rotations needed. If no rotation (other than the string itself) \n         results in the same string, it returns the length of the string.\n    \"\"\"\n    if len(s) == 0:  # Edge case: empty string\n        return 0\n    \n    for i in range(1, len(s)):  # Start from 1 rotation, as per the problem statement\n        rotated_s = s[i:] + s[:i]  # Rotate the string by i positions\n        if rotated_s == s:  # Check if the rotated string is the same as the original\n            return i  # Return the minimum rotations found\n    \n    # If no rotation results in the same string (e.g., for unique permutations like \"abc\"), \n    # the minimum rotation to get the \"same\" string would be equal to its length.\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required. If the string is the same when rotated by one position, returns 1.\n    \"\"\"\n    # Check if the string is empty\n    if not s:\n        raise ValueError(\"Input string cannot be empty\")\n    \n    # Double the string to easily check for rotations\n    doubled_s = s + s\n    \n    # Check for the minimum rotation, starting from 1 rotation\n    for i in range(1, len(s)):\n        # If the substring of the doubled string equals the original string, it's a rotation\n        if doubled_s[i:i+len(s)] == s:\n            # Return the number of rotations which is the current index\n            return i\n    \n    # If no rotation (other than the full length which is not counted as per problem) is found, \n    # but considering the problem's assertion, if all characters are the same, it counts as 1 rotation\n    if len(set(s)) == 1:\n        return 1\n    \n    # If all else fails, it means the string does not form a cycle with less than full length rotations\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Calculates the minimum number of rotations needed for the string to return to its original state.\n    \n    This is achieved by finding the first repetition of the string when concatenated with itself.\n    The minimum rotation is then the length of the substring before the first repetition, \n    considering only rotations greater than 0.\n    \"\"\"\n    # Concatenate the string with itself to find the first repetition\n    double_s = s + s\n    \n    # Iterate through the concatenated string to find the first occurrence of the original string\n    # starting from the second character (index 1) to ensure rotation is > 0\n    for i in range(1, len(s)):\n        if double_s[i:i+len(s)] == s:\n            # Return the index of the first match as the minimum rotations required\n            return i\n    \n    # If no rotation is found within the length of the string, return the length of the string\n    # This would be the case for a string that doesn't repeat within its double (e.g., \"abc\")\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function calculates the minimum number of rotations (greater than 0) \n    required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations needed. If no rotation is needed (i.e., \n         the string is asymmetric and doesn't repeat itself with any rotation), \n         it returns the length of the string as all rotations would be unique.\n    \"\"\"\n    if len(s) == 0:\n        raise ValueError(\"Input string cannot be empty\")\n\n    # Find the length of the string\n    str_len = len(s)\n    \n    # Check for each possible rotation if the rotated string is the same as the original\n    for i in range(1, str_len):\n        # Rotate the string by i positions\n        rotated_s = s[i:] + s[:i]\n        \n        # If the rotated string is the same as the original, return the number of rotations\n        if rotated_s == s:\n            return i\n    \n    # If no matching rotation is found (all rotations are unique), return the length of the string\n    # This also covers the case where the string doesn't change with any rotation (e.g., \"aaaa\")\n    # Because in such cases, technically, rotating the full length once would return the string to itself\n    return str_len", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    This function calculates the minimum number of rotations (greater than 0) \n    required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations.\n    \"\"\"\n    if len(s) == 0:  # Edge case: Empty string\n        return 0\n\n    # Concatenate the string with itself to consider all rotations\n    double_s = s + s\n    \n    # Find the first occurrence of the original string in the concatenated string\n    # The index of this occurrence (minus the length of the original string) gives \n    # the minimum number of rotations needed, considering the string can be rotated \n    # in both clockwise and counter-clockwise directions.\n    for i in range(1, len(s)):\n        if double_s[i:i+len(s)] == s:\n            return i\n\n    # If no rotation is found that results in the original string (other than a full rotation),\n    # return the length of the string as the minimum number of rotations, since rotating \n    # the string by its length brings it back to itself, but this is the maximum case.\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to return to the same string.\n    \n    :param s: The input string.\n    :return: Minimum number of rotations (greater than 0) to get the same string.\n    \"\"\"\n    # If the string is empty or has only one character, no rotations are needed\n    if len(s) <= 1:\n        return 1  # Default for non-rotatable strings, adhering to the problem's > 0 requirement\n    \n    # Concatenate the string with itself to simulate rotation\n    ss = s + s\n    \n    # Find the first occurrence of the original string in the concatenated string\n    # This effectively finds the minimum number of rotations needed to match the original string again\n    for i in range(1, len(s)):\n        if ss[i:i+len(s)] == s:\n            return i\n\n    # If no match is found within the first full rotation (which should never happen with this logic),\n    # default to the length of the string (a full rotation), but since we need > 0 and this is the minimum,\n    # it technically fulfills the problem's requirement in an edge case where the above fails unexpectedly.\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(input_string: str) -> int:\n    \"\"\"\n    Calculates the minimum number of rotations needed to replicate the input string.\n\n    Args:\n    - `input_string` (str): The string to be rotated.\n\n    Returns:\n    - `int`: The minimum number of rotations greater than 0.\n    \"\"\"\n    if len(set(input_string)) == 1:  # All characters are the same\n        return 1\n    \n    for rotations in range(1, len(input_string)):\n        if input_string == input_string[rotations:] + input_string[:rotations]:\n            return rotations\n    \n    return len(input_string)  # If no rotation other than full length matches", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(input_str):\n    \"\"\"\n    Calculates the minimum number of rotations (greater than 0) required \n    to get the same string.\n\n    Args:\n        input_str (str): The input string.\n\n    Returns:\n        int: Minimum number of rotations. Returns `None` if input is not a string.\n    \"\"\"\n    if not isinstance(input_str, str):\n        return None  # or raise TypeError, as per requirement\n\n    str_len = len(input_str)\n    for i in range(1, str_len):  # Start from 1 rotation\n        if input_str[i:] + input_str[:i] == input_str:\n            return i  # Found the minimum rotation count\n    return str_len  # If no smaller rotation works, a full rotation is the minimum", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 80.64516129032258, "dps_norm": 95.55555555555556, "pass@1": 75.0, "profiled": [{"solution": "def remove_Occ(input_str, char):\n    \"\"\"\n    Removes the first and last occurrences of `char` from `input_str`.\n    \n    Parameters:\n    - input_str (str): The original string.\n    - char (str): A single character to be removed.\n    \n    Returns:\n    - str: The modified string with first and last occurrences of `char` removed.\n    \"\"\"\n    # Find indices of the first and last occurrence of char\n    try:\n        first_occurrence = input_str.index(char)\n    except ValueError:\n        first_occurrence = -1  # char not found\n    \n    try:\n        last_occurrence = input_str.rindex(char)\n    except ValueError:\n        last_occurrence = -1  # char not found if also not in first_occurrence\n    \n    # If char is found, remove its first and last occurrences\n    if first_occurrence != -1 and last_occurrence != -1:\n        if first_occurrence == last_occurrence:  # Only one occurrence\n            return input_str.replace(char, '', 1)\n        else:\n            return input_str[:first_occurrence] + input_str[first_occurrence+1:last_occurrence] + input_str[last_occurrence+1:]\n    else:\n        return input_str  # Return original string if char not found", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n    - input_string (str): The original string.\n    - char (str): A single character to be removed.\n\n    Returns:\n    - str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occurrence_index = input_string.find(char)\n    \n    # Find the last occurrence index of the character\n    last_occurrence_index = input_string.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence_index == -1:\n        return input_string\n    \n    # If the first and last occurrences are the same (only one occurrence), \n    # remove it by concatenating the substrings around it\n    if first_occurrence_index == last_occurrence_index:\n        return input_string[:first_occurrence_index] + input_string[first_occurrence_index+1:]\n    \n    # If there are multiple occurrences, remove the first and last by concatenating \n    # the substrings before the first, between them, and after the last occurrence\n    else:\n        return input_string[:first_occurrence_index] + input_string[first_occurrence_index+1:last_occurrence_index] + input_string[last_occurrence_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n        input_string (str): The original string.\n        char (str): The character to be removed (first and last occurrences).\n\n    Returns:\n        str: The modified string with first and last occurrence of `char` removed.\n    \"\"\"\n    # Find indices of the first and last occurrence of the character\n    try:\n        first_occurrence = input_string.index(char)\n        last_occurrence = input_string.rindex(char)\n    except ValueError:\n        # If the character is not found, return the original string\n        return input_string\n\n    # Remove first occurrence\n    if first_occurrence == last_occurrence:\n        # If there's only one occurrence, remove it and return\n        return input_string.replace(char, '', 1)\n    else:\n        # Remove first occurrence\n        temp_string = input_string[:first_occurrence] + input_string[first_occurrence+1:]\n        \n        # Remove last occurrence from the temporary string\n        last_occurrence = temp_string.rindex(char)\n        result_string = temp_string[:last_occurrence] + temp_string[last_occurrence+1:]\n        \n        return result_string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n        input_string (str): The original string.\n        char (str): The character to be removed.\n\n    Returns:\n        str: The modified string with first and last occurrences of 'char' removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occurrence_index = input_string.find(char)\n    \n    # Find the last occurrence index of the character\n    last_occurrence_index = input_string.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence_index == -1:\n        return input_string\n    \n    # If the first and last occurrences are the same (only one occurrence exists), \n    # remove it by slicing around it\n    if first_occurrence_index == last_occurrence_index:\n        return input_string[:first_occurrence_index] + input_string[first_occurrence_index+1:]\n    \n    # If there are multiple occurrences, slice out the first and last occurrences\n    else:\n        return input_string[:first_occurrence_index] + input_string[first_occurrence_index+1:last_occurrence_index] + input_string[last_occurrence_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n        input_str (str): The original string.\n        char (str): The character to be removed (first and last occurrences).\n\n    Returns:\n        str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occurrence_index = input_str.find(char)\n    \n    # Find the last occurrence index of the character\n    last_occurrence_index = input_str.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence_index == -1:\n        return input_str\n    \n    # If there's only one occurrence, remove it and return\n    if first_occurrence_index == last_occurrence_index:\n        return input_str.replace(char, '', 1)\n    \n    # Slice the string to exclude the first and last occurrences of the character\n    modified_str = (input_str[:first_occurrence_index] + \n                    input_str[first_occurrence_index+1:last_occurrence_index] + \n                    input_str[last_occurrence_index+1:])\n    \n    return modified_str", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n        input_string (str): The original string to modify.\n        char (str): The character to remove (first and last occurrence).\n\n    Returns:\n        str: The modified string with first and last occurrence of `char` removed.\n    \"\"\"\n    if not input_string or not char or len(char) != 1:\n        return input_string  # or raise ValueError, depending on your preference\n\n    # Find indices of first and last occurrence of the character\n    first_occurrence = input_string.find(char)\n    last_occurrence = input_string.rfind(char)\n\n    # If the character is not found, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return input_string\n\n    # If first and last occurrence are the same (only one occurrence), remove it\n    if first_occurrence == last_occurrence:\n        return input_string.replace(char, '', 1)\n    \n    # Remove first and last occurrence\n    return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n        input_string (str): The original string.\n        char (str): A single character to be removed.\n\n    Returns:\n        str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    # Find indices of the first and last occurrence of the character\n    try:\n        first_occurrence = input_string.index(char)\n        last_occurrence = input_string.rindex(char)\n    except ValueError:\n        # If the character is not found, return the original string\n        return input_string\n\n    # If the first and last occurrence are the same (only one occurrence exists), \n    # remove it by returning the string around it\n    if first_occurrence == last_occurrence:\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:]\n    \n    # Remove the first and last occurrence by slicing the string\n    else:\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to be removed from the string.\n\n    Returns:\n    str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occurrence = s.find(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return s\n    \n    # Find the last occurrence index of the character\n    last_occurrence = s.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence+1:]\n    \n    # If there are multiple occurrences, remove the first and last ones\n    else:\n        return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n    \n    Parameters:\n    input_str (str): The original input string.\n    char (str): The character to remove.\n    \n    Returns:\n    str: The modified string.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occ_index = input_str.find(char)\n    \n    # If the character is found\n    if first_occ_index != -1:\n        # Find the last occurrence index of the character\n        last_occ_index = input_str.rfind(char)\n        \n        # If there's more than one occurrence, remove both\n        if first_occ_index != last_occ_index:\n            return input_str[:first_occ_index] + input_str[first_occ_index+1:last_occ_index] + input_str[last_occ_index+1:]\n        # If there's only one occurrence, remove it\n        else:\n            return input_str[:first_occ_index] + input_str[first_occ_index+1:]\n    else:\n        # If the character is not found, return the original string\n        return input_str", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Args:\n        input_string (str): The original string to modify.\n        char (str): The character to remove (first and last occurrences).\n\n    Returns:\n        str: Modified string with first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the first and last index of the character\n    try:\n        first_occurrence = input_string.index(char)\n        last_occurrence = input_string.rindex(char)\n        \n        # If first and last occurrences are the same (only one occurrence exists), \n        # return the string without that character\n        if first_occurrence == last_occurrence:\n            return input_string.replace(char, '', 1)\n        \n        # Return the string with first and last occurrences removed\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]\n    \n    except ValueError:\n        # If the character is not found in the string, return the original string\n        return input_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n        input_string (str): The original string.\n        char (str): The character to be removed.\n\n    Returns:\n        str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the indices of the first and last occurrence of the character\n    first_occurrence = input_string.find(char)\n    last_occurrence = input_string.rfind(char)\n\n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return input_string\n\n    # If the first and last occurrences are the same (only one occurrence), \n    # return the string without that character\n    if first_occurrence == last_occurrence:\n        return input_string.replace(char, '', 1)\n\n    # Remove the first and last occurrences\n    modified_string = (input_string[:first_occurrence] + \n                       input_string[first_occurrence+1:last_occurrence] + \n                       input_string[last_occurrence+1:])\n\n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n        input_string (str): The original string.\n        char (str): The character to be removed from the start and end.\n\n    Returns:\n        str: The modified string with first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occurrence = input_string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return input_string\n    \n    # Find the last occurrence index of the character\n    last_occurrence = input_string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_occurrence == last_occurrence:\n        return input_string.replace(char, '', 1)\n    \n    # Remove the first and last occurrences\n    modified_string = (input_string[:first_occurrence] + \n                       input_string[first_occurrence+1:last_occurrence] + \n                       input_string[last_occurrence+1:])\n    \n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n    \n    Parameters:\n    s (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The modified string with first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occurrence_index = s.find(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence_index == -1:\n        return s\n    \n    # Find the last occurrence index of the character\n    last_occurrence_index = s.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_occurrence_index == last_occurrence_index:\n        return s.replace(char, '', 1)\n    \n    # Slice the string to exclude the first and last occurrences\n    # (include up to but not including the first, and start from the last + 1 to the end)\n    return s[:first_occurrence_index] + s[first_occurrence_index+1:last_occurrence_index] + s[last_occurrence_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n        input_string (str): The original string to modify.\n        char (str): The character to remove (first and last occurrences).\n\n    Returns:\n        str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    # Find indices of first and last occurrence of the character\n    try:\n        first_occurrence_index = input_string.index(char)\n        last_occurrence_index = input_string.rindex(char)\n        \n        # If first and last occurrence are the same (only one occurrence exists), \n        # remove only that one\n        if first_occurrence_index == last_occurrence_index:\n            return input_string.replace(char, '', 1)\n        \n        # Remove first occurrence\n        modified_string = input_string[:first_occurrence_index] + input_string[first_occurrence_index + 1:]\n        \n        # Adjust index for last occurrence due to the first removal\n        last_occurrence_index -= 1 if first_occurrence_index < last_occurrence_index else 0\n        \n        # Remove last occurrence from the modified string\n        modified_string = modified_string[:last_occurrence_index] + modified_string[last_occurrence_index + 1:]\n        \n        return modified_string\n    \n    except ValueError:\n        # If the character is not found, return the original string\n        return input_string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    - s (str): The input string.\n    - char (str): The character to be removed.\n\n    Returns:\n    - str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occurrence = s.find(char)\n    \n    # Find the last occurrence index of the character\n    last_occurrence = s.rfind(char)\n    \n    # If the character is found and it appears more than once\n    if first_occurrence != -1 and first_occurrence != last_occurrence:\n        # Remove the first and last occurrences\n        return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    # If the character is found but appears only once\n    elif first_occurrence != -1:\n        # Remove the single occurrence\n        return s[:first_occurrence] + s[first_occurrence+1:]\n    else:\n        # Character not found, return original string\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Args:\n        input_string (str): The original string.\n        char (str): The character to be removed.\n\n    Returns:\n        str: The modified string with first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the first occurrence index\n    first_occurrence_index = input_string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence_index == -1:\n        return input_string\n    \n    # Find the last occurrence index\n    last_occurrence_index = input_string.rfind(char)\n    \n    # Handle the case where there's only one occurrence of the character\n    if first_occurrence_index == last_occurrence_index:\n        return input_string.replace(char, '', 1)\n    \n    # Slice the string to remove the first and last occurrences\n    modified_string = (input_string[:first_occurrence_index] + \n                       input_string[first_occurrence_index+1:last_occurrence_index] + \n                       input_string[last_occurrence_index+1:])\n    \n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Args:\n        input_string (str): The original string.\n        char (str): The character to be removed (first and last occurrence).\n\n    Returns:\n        str: The modified string after removal.\n    \"\"\"\n    # Find indices of the first and last occurrence of the character\n    try:\n        first_occurrence = input_string.index(char)\n        last_occurrence = len(input_string) - 1 - input_string[::-1].index(char)\n        \n        # Slice the string to exclude the first and last occurrence of the character\n        if first_occurrence == last_occurrence:  # If only one occurrence exists\n            return input_string.replace(char, '', 1)\n        else:\n            return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]\n    \n    except ValueError:  # Handle the case when the character is not found\n        return input_string  # Return the original string if char not found", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(input_str, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n    \n    Parameters:\n    input_str (str): The original string from which characters will be removed.\n    char (str): The character to be removed from the first and last positions.\n    \n    Returns:\n    str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occurrence = input_str.find(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return input_str\n    \n    # Find the last occurrence index of the character\n    last_occurrence = input_str.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_occurrence == last_occurrence:\n        return input_str.replace(char, '', 1)\n    \n    # Remove the first occurrence\n    str_after_first_removal = input_str[:first_occurrence] + input_str[first_occurrence+1:]\n    \n    # Remove the last occurrence from the updated string\n    # Adjust the last_occurrence index since we've altered the string\n    adjusted_last_occurrence = last_occurrence - (last_occurrence > first_occurrence)\n    result = str_after_first_removal[:adjusted_last_occurrence] + str_after_first_removal[adjusted_last_occurrence+1:]\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(input_str, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Args:\n        input_str (str): The input string.\n        char (str): The character to be removed.\n\n    Returns:\n        str: The modified string with first and last occurrence of `char` removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occ_index = input_str.find(char)\n    \n    # If the character is not found, return the original string\n    if first_occ_index == -1:\n        return input_str\n    \n    # Find the last occurrence index of the character\n    last_occ_index = input_str.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_occ_index == last_occ_index:\n        return input_str.replace(char, '', 1)\n    \n    # Otherwise, remove the first and last occurrences\n    else:\n        # Slice the string to exclude the first occurrence\n        str_without_first = input_str[:first_occ_index] + input_str[first_occ_index+1:]\n        \n        # Slice the resulting string to exclude the last occurrence of the character\n        # Note: The last occurrence's position may change after removing the first one\n        str_without_last = str_without_first[:str_without_first.rfind(char)] + str_without_first[str_without_first.rfind(char)+1:]\n        \n        return str_without_last", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(input_str, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the input string.\n\n    Parameters:\n    - input_str (str): The original string.\n    - char (str): The character to be removed.\n\n    Returns:\n    - str: The modified string with first and last occurrence of the character removed.\n    \"\"\"\n    # Find the first occurrence index of the character\n    first_occurrence = input_str.find(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return input_str\n    \n    # Find the last occurrence index of the character\n    last_occurrence = input_str.rfind(char)\n    \n    # If first and last occurrences are the same (i.e., only one occurrence), \n    # return the string without this character\n    if first_occurrence == last_occurrence:\n        return input_str.replace(char, '', 1)\n    \n    # Otherwise, remove both the first and the last occurrence\n    else:\n        return input_str[:first_occurrence] + input_str[first_occurrence+1:last_occurrence] + input_str[last_occurrence+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 43.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of its rows.\n\n    Args:\n    - matrix (list of lists): Input matrix to be sorted.\n\n    Returns:\n    - list of lists: Sorted matrix according to the sum of its rows.\n    \"\"\"\n    # Use the built-in sorted function with a custom key\n    # The key is a lambda function that calculates the sum of each row\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix (list of lists): A 2D list of integers representing the matrix.\n    \n    Returns:\n        list of lists: The input matrix with rows sorted by their sum in ascending order.\n    \"\"\"\n    # Use built-in sorted function with a custom key that calculates the sum of each row\n    # The sorted function maintains the relative order of items with equal sort keys (stable sort)\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of its rows.\n    \n    Args:\n    - matrix (list of lists): Input matrix to be sorted.\n    \n    Returns:\n    - list of lists: Sorted matrix.\n    \"\"\"\n    # Check if input is a list of lists (basic matrix validation)\n    if not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Input must be a list of lists.\")\n    \n    # Use sorted() with a custom key to sort rows by their sum\n    sorted_matrix = sorted(matrix, key=sum)\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): A 2D list of integers representing the matrix.\n\n    Returns:\n        list of lists: The input matrix sorted by row sums in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom key to sort the matrix rows\n    # The key is a lambda function that calculates the sum of each row\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): Input matrix, where each inner list represents a row.\n\n    Returns:\n        list of lists: Sorted matrix by row sums in ascending order.\n    \"\"\"\n    # Calculate the sum of each row and store it as a tuple with the original row\n    row_sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the rows based on their sums\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n    \n    # Return the sorted rows (discard the sums)\n    return [row for _, row in sorted_row_sums]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): A 2D list of integers representing the matrix.\n\n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    # Calculate the sum of each row and store it as a tuple with the original row\n    row_sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the rows based on the sum\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n    \n    # Return the sorted matrix (extract the original rows from the sorted tuples)\n    return [row for _, row in sorted_row_sums]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix based on the sum of its rows in ascending order.\n\n    Args:\n        matrix (list[list[int]]): A 2D list of integers representing the matrix.\n\n    Returns:\n        list[list[int]]: The input matrix sorted by row sums in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom key to sort the matrix rows\n    # The key function calculates the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix (list of lists): A 2D list of integers representing the matrix.\n\n    Returns:\n        list of lists: The input matrix sorted by row sums in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom key to sort the matrix rows\n    # The key function calculates the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): Input matrix to be sorted.\n\n    Returns:\n        list of lists: Sorted matrix by row sum in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom key to sort the matrix rows\n    # The key function calculates the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    :param matrix: A 2D list of integers\n    :return: Sorted 2D list (matrix) by row sums in ascending order\n    \"\"\"\n    # Calculate the sum of each row and store it as a tuple with the original row\n    row_sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the rows based on their sums\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n    \n    # Return the sorted matrix (extract the original rows from the sorted tuples)\n    return [row for _, row in sorted_row_sums]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): Input matrix to be sorted.\n\n    Returns:\n        list of lists: Sorted matrix.\n    \"\"\"\n    # Use the built-in sorted function with a custom sorting key\n    # The key is a lambda function that calculates the sum of each row\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    :param matrix: A 2D list of integers\n    :return: Sorted 2D list by row sums in ascending order\n    \"\"\"\n    # Use the built-in sorted function with a custom sorting key\n    # The key is a lambda function that calculates the sum of each row\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix (list of lists): A 2D list representing the matrix.\n        \n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    # Use the built-in sorted function with a custom key that sums each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): Input matrix, where each inner list represents a row.\n\n    Returns:\n        list of lists: Sorted matrix based on row sums in ascending order.\n    \"\"\"\n    # Calculate the sum of each row and store it along with the row in a tuple\n    row_sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the rows based on their sums\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n    \n    # Return the sorted matrix (extracting just the rows from the tuples)\n    return [row for _, row in sorted_row_sums]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix (list of lists): Input matrix where each inner list represents a row.\n\n    Returns:\n        list of lists: The input matrix sorted by the sum of its rows in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom key to sort the matrix rows\n    # The key function calculates the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    - matrix (list of lists): Input matrix, where each inner list represents a row.\n\n    Returns:\n    - list of lists: Sorted matrix based on row sums in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom key to sort the matrix rows\n    # The key function calculates the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix (list of lists): A 2D list of integers.\n\n    Returns:\n        list of lists: The input matrix sorted by row sum in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom key to sort the matrix rows\n    # The key function calculates the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix (list of lists): Input matrix where each inner list represents a row.\n\n    Returns:\n        list of lists: The input matrix sorted by the sum of its rows in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom key that calculates the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): A 2D list of integers representing the matrix.\n\n    Returns:\n        list of lists: The input matrix sorted by row sums in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom key to sort the matrix rows\n    # The key function calculates the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n    - matrix (list of lists): A 2D list of integers representing the matrix.\n\n    Returns:\n    - list of lists: The input matrix sorted by row sums in ascending order.\n    \"\"\"\n    # Use the built-in sorted function with a custom sorting key\n    # The key is a lambda function that calculates the sum of each row\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 90.79268292682927, "dps_norm": 94.375, "pass@1": 65.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Validates if input string contains sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    - text (str): Input string to be checked\n    \n    Returns:\n    - bool: True if the string consists of lowercase letters and underscores, False otherwise\n    \"\"\"\n    # Regular expression pattern: one or more lowercase letters (a-z) optionally followed by an underscore,\n    # this pattern repeated one or more times, ensuring the whole string matches from start to end\n    pattern = r'^([a-z]+_)*[a-z]+$'\n    \n    # Use fullmatch to ensure the entire string matches the pattern\n    return bool(re.fullmatch(pattern, text))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string consists of sequences of lowercase letters \n    joined with underscores.\n\n    Args:\n    input_string (str): The input string to be checked.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Split the string by underscore to check each sequence separately\n    sequences = input_string.split(\"_\")\n    \n    # For each sequence, check if all characters are lowercase letters\n    for sequence in sequences:\n        # If any sequence is not entirely made of lowercase letters, return False\n        if not sequence.islower() or not sequence.isalpha():\n            return False\n    \n    # If all checks pass, the string adheres to the rule\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string consists of sequences of lowercase letters joined with underscores.\n    \n    Args:\n        input_string (str): The input string to be checked.\n    \n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular Expression Pattern:\n    # ^           : Start of the string\n    # [a-z]+      : One or more lowercase letters\n    # (_[a-z]+)*  : Zero or more occurrences of an underscore followed by one or more lowercase letters\n    # $           : End of the string\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Check if the entire input string matches the pattern\n    if re.fullmatch(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string consists of sequences of lowercase letters joined with underscores.\n\n    Args:\n    input_string (str): The input to be validated.\n\n    Returns:\n    bool: True if the input string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match sequences of lowercase letters joined by underscores\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Using fullmatch to ensure the entire string matches the pattern\n    return bool(re.fullmatch(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string consists of sequences of lowercase letters joined by underscores.\n    \n    Args:\n    input_string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match one or more lowercase letters or an underscore\n    # The whole string must match this pattern from start to end, hence the ^ and $\n    pattern = r'^[a-z_]+$', \n    # Adjusted pattern to strictly enforce sequences of letters joined by underscores\n    # This ensures at least one letter is present and underscores don't lead, trail, or double\n    strict_pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Using the strict pattern for the function\n    return bool(re.match(strict_pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Validates if the input string consists of sequences of lowercase letters \n    joined by an underscore.\n\n    Args:\n    - input_string (str): The input to be validated.\n\n    Returns:\n    - bool: True if the input string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match sequences of lowercase letters \n    # joined by underscores, ensuring the entire string matches this pattern\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.fullmatch to ensure the whole string matches the pattern\n    if re.fullmatch(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    \"\"\"\n    Checks if the input string consists of sequences of lowercase letters joined by underscores.\n    \n    Parameters:\n    - `input_string` (str): The input string to be checked.\n    \n    Returns:\n    - `bool`: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern: \n    # - ^ asserts the start of the line\n    # - [a-z]+ matches one or more lowercase letters\n    # - (_[a-z]+)* matches zero or more occurrences of an underscore followed by one or more lowercase letters\n    # - $ asserts the end of the line\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.fullmatch to ensure the entire string matches the pattern\n    return bool(re.fullmatch(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n    - input_string (str): The string to be checked.\n\n    Returns:\n    - bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match one or more lowercase letters (a-z) \n    # optionally followed by an underscore and then again one or more lowercase letters\n    pattern = r\"^([a-z]+_)*[a-z]+$\"\n    \n    # Use fullmatch to ensure the entire string matches the pattern\n    if re.fullmatch(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string is composed of sequences of lowercase letters joined with underscores.\n\n    Args:\n        input_string (str): The input string to check.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular Expression Pattern:\n    # - ^ asserts the start of the line\n    # - (lowercase letters (a-z) one or more times (+)) \n    #   optionally followed by an underscore and the pattern repeats (*)\n    # - $ asserts the end of the line, ensuring the whole string must match\n    pattern = r'^([a-z]+_)*[a-z]+$'\n    \n    # re.fullmatch ensures the entire string must match the pattern, not just a part of it\n    return bool(re.fullmatch(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Validates if the input string contains only sequences of lowercase letters joined with underscores.\n\n    Args:\n        input_string (str): The input string to be validated.\n\n    Returns:\n        bool: True if the string consists of lowercase letters and underscores, False otherwise.\n    \"\"\"\n    # Remove all underscores from the string to check for lowercase letters sequence\n    no_underscore_str = input_string.replace(\"_\", \"\")\n    \n    # Check if all characters in the modified string are lowercase\n    has_only_lowercase = no_underscore_str.islower()\n    \n    # Additionally, check if the original string does not start or end with an underscore\n    # and does not have consecutive underscores\n    valid_underscore_usage = not (input_string.startswith(\"_\") or input_string.endswith(\"_\") or \"__\" in input_string)\n    \n    # Return True if both conditions are met, False otherwise\n    return has_only_lowercase and valid_underscore_usage", "matching_cluster_idx": 4}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        input_string (str): The input to be validated.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match sequences of lowercase letters joined with underscores\n    pattern = r\"^([a-z]+_)*[a-z]+$\"\n    \n    # Use fullmatch to ensure the entire string matches the pattern\n    return bool(re.fullmatch(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text: str) -> bool:\n    \"\"\"\n    Validate if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n    - `text (str)`: The input string to be validated.\n\n    Returns:\n    - `bool`: True if the string consists of lowercase letters and underscores, False otherwise.\n    \"\"\"\n    # Split the input string by underscore to check each sequence\n    sequences = text.split(\"_\")\n    \n    # All sequences must pass the condition (being all lowercase) for the function to return True\n    for sequence in sequences:\n        # If any sequence is not all lowercase or if the sequence is empty (in case of multiple consecutive underscores or leading/trailing underscore), return False\n        if not sequence.islower() or not sequence:\n            return False\n    \n    # If the loop completes without returning False, the string is valid\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string consists of sequences of lowercase letters joined with underscores.\n    \n    Args:\n    input_string (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match one or more lowercase letters or an underscore\n    pattern = r'^([a-z]+_)*[a-z]+$'\n    \n    # Check if the entire input string matches the pattern\n    if re.fullmatch(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    \"\"\"\n    Checks if input string consists of sequences of lowercase letters joined with underscores.\n    \n    Args:\n        input_string (str): The input string to be checked.\n    \n    Returns:\n        bool: True if string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match one or more lowercase letters or an underscore\n    pattern = r'^[a-z_]*$'\n    \n    # Regular expression pattern to ensure at least one sequence of letters exists and \n    # underscores are only used to join (not at start, end, or consecutively)\n    detailed_pattern = r'^([a-z]+_)*[a-z]+$'\n    \n    # Check if string matches both conditions: only contains allowed characters and follows the sequence rule\n    return bool(re.match(detailed_pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    \"\"\"\n    Checks if the input string consists of sequences of lowercase letters joined with underscores.\n\n    Args:\n        input_string (str): The string to be checked.\n\n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match sequences of lowercase letters joined with underscores\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(input_string):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    input_string (str): The input to be checked.\n    \n    Returns:\n    bool: True if the string consists of lowercase letters and underscores, False otherwise.\n    \"\"\"\n    # Split the input string by underscores\n    sequences = input_string.split(\"_\")\n    \n    # Check each sequence to ensure it's all lowercase letters\n    for sequence in sequences:\n        # If any sequence is not all lowercase letters, return False\n        if not sequence.islower() or not sequence.isalpha():\n            return False\n            \n    # If all sequences pass the check, return True\n    return True", "matching_cluster_idx": 5}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string consists of sequences of lowercase letters joined by underscores.\n\n    Args:\n    - input_string (str): The string to be checked.\n\n    Returns:\n    - bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match one or more lowercase letters and optionally followed by an underscore\n    # and this pattern can repeat, ensuring the entire string must match this rule from start to end.\n    pattern = r\"^([a-z]+_)*[a-z]+$\"\n    \n    # Use full-match with the regular expression to check if the entire string fits the pattern\n    if re.fullmatch(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string consists of sequences of lowercase letters \n    joined with an underscore.\n\n    Args:\n    - input_string (str): The input string to check.\n\n    Returns:\n    - bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match sequences of lowercase letters \n    # joined with underscores, ensuring the whole string matches from start to end\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use fullmatch to ensure the entire string matches the pattern\n    return bool(re.fullmatch(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Validates if a string consists of sequences of lowercase letters joined by underscores.\n    \n    Args:\n    - input_string (str): The input string to be validated.\n    \n    Returns:\n    - bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern for one or more lowercase letters optionally \n    # followed by an underscore, repeated until the end of the string\n    pattern = r\"^([a-z]+_)*[a-z]+$\"\n    \n    # Using fullmatch to ensure the entire string matches the pattern\n    return bool(re.fullmatch(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string: str) -> bool:\n    \"\"\"\n    Checks if the input string consists of sequences of lowercase letters joined by underscores.\n    \n    Args:\n    input_string (str): The input to be validated.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match one or more lowercase letters ([a-z]+) \n    # followed optionally by an underscore and more letters, across the entire string (^...$)\n    pattern = r\"^([a-z]+_)*[a-z]+$\"\n    \n    # Using fullmatch to ensure the entire string matches the pattern, not just a part of it\n    if re.fullmatch(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 68.18181818181819, "dps_norm": 82.0, "pass@1": 80.0, "profiled": [{"solution": "def test_duplicate(arr):\n    \"\"\"\n    Solution Approach: Leveraging Python's set data structure for efficiency.\n    A set in Python is an unordered collection of unique elements.\n    If the lengths of the original list and its set conversion differ, there were duplicates.\n    \"\"\"\n    # Convert the input list to a set, automatically removing any duplicates\n    arr_set = set(arr)\n    \n    # Compare the lengths of the original list and the set\n    # If they are not equal, the original list contained duplicates\n    return len(arr) != len(arr_set)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if a list of integers contains any duplicate element.\n\n    Args:\n    - nums (list): A list of integers.\n\n    Returns:\n    - bool: True if the list contains duplicates, False otherwise.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        bool: True if the array contains any duplicate element, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if there are any duplicate elements in the given list of integers.\n\n    Args:\n    - nums (list): A list of integers.\n\n    Returns:\n    - bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Create an empty set to store unique elements\n    unique_nums = set()\n    \n    # Iterate through each number in the input list\n    for num in nums:\n        # If the number is already in the set, it's a duplicate\n        if num in unique_nums:\n            return True  # Return immediately if a duplicate is found\n        unique_nums.add(num)  # Add the number to the set if it's new\n    \n    # If the loop completes without finding duplicates, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    Checks if there are any duplicate elements in the given array.\n\n    Args:\n    - array (list): A list of integers.\n\n    Returns:\n    - bool: True if the array contains at least one duplicate, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # Then compare the lengths. If they're not equal, there were duplicates.\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks for duplicate elements in a given integer array.\n    \n    Args:\n        arr (list): List of integers.\n    \n    Returns:\n        bool: True if duplicates found, False otherwise.\n    \"\"\"\n    seen = set()  # Initialize an empty set to store unique elements\n    for num in arr:  # Iterate over each number in the array\n        if num in seen:  # If the number is already in the set\n            return True  # Return True, indicating a duplicate found\n        seen.add(num)  # Otherwise, add the number to the set\n    return False  # If the loop completes without finding a duplicate, return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    Checks if there are any duplicate elements in the given array of integers.\n\n    Args:\n        array (list): A list of integers.\n\n    Returns:\n        bool: True if the array contains any duplicate element, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # Then compare the lengths; if they're not equal, there were duplicates\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        bool: True if the array contains duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If lengths differ, then there were duplicates in the original list\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    Checks if there are any duplicate elements in the given array.\n\n    Args:\n        array (list): A list of integers.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates and compare lengths\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n        array (list): A list of integers.\n\n    Returns:\n        bool: True if the array contains duplicate elements, False otherwise.\n    \"\"\"\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate element.\n\n    Parameters:\n    - `arr` (list): A list of integers.\n\n    Returns:\n    - `bool`: True if the array contains at least one duplicate, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if there are any duplicate elements in the given array of integers.\n\n    Args:\n    - arr (list): A list of integers.\n\n    Returns:\n    - bool: True if the array contains duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If lengths differ after conversion, then there were duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if there are any duplicate elements in the given array of integers.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If the lengths are not equal, then there were duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        bool: True if the array contains duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If lengths differ, then there were duplicates in the original list\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if there are any duplicate elements in the given array of integers.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        bool: True if the list contains at least one duplicate element, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If the lengths differ, then there were duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array):\n    \"\"\"\n    Checks if there are duplicate elements in the given array of integers.\n\n    Args:\n        array (list): A list of integers.\n\n    Returns:\n        bool: True if the array contains duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If lengths differ, then there were duplicates in the original list\n    return len(array) != len(set(array))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if there are any duplicate elements in the given array.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks for duplicate elements in a given array of integers.\n\n    Args:\n    - arr (list): A list of integers\n\n    Returns:\n    - bool: True if duplicates are found, False otherwise\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If the lengths differ, then there were duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if there are any duplicate elements in the given list of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        bool: True if the list contains duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If the lengths differ, then there were duplicates\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if there are any duplicate elements in the given array.\n    \n    Parameters:\n    arr (list): The input list of integers to be checked for duplicates.\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # Then compare the lengths. If they're not equal, there were duplicates.\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 91.15384615384616, "dps_norm": 92.0, "pass@1": 63.0, "profiled": [{"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of integers or floats.\n\n    Returns:\n        The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list is empty. Cannot find smallest number.\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a given list of numbers.\n\n    Args:\n    - numbers (list): A list of integers or floats.\n\n    Returns:\n    - The smallest number in the list.\n\n    Raises:\n    - ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list of integers.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The smallest integer in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n    \n    # Using built-in min function for simplicity and efficiency\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:  # Check if list is empty\n        raise ValueError(\"Input list is empty\")\n    \n    # Using built-in min() function for simplicity and efficiency\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:  # Check if list is empty\n        raise ValueError(\"Input list is empty\")\n    \n    # Using built-in min() function for simplicity and efficiency\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers (int or float).\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list of numbers.\n\n    Args:\n        numbers (list): A list of numbers (int or float).\n\n    Returns:\n        The smallest number found in the list, or None if the list is empty.\n\n    Raises:\n        ValueError: If the input list is not a list or if the list contains non-numeric values.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list.\")\n\n    # Check if list is not empty and contains only numeric values\n    if len(numbers) == 0 or not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"List must not be empty and contain only integers or floats.\")\n\n    # Use built-in min function to find the smallest number\n    return min(numbers)", "matching_cluster_idx": 0}, {"solution": "def smallest_num(num_list):\n    \"\"\"\n    Finds the smallest number in a given list of numbers.\n\n    Args:\n        num_list (list): A list of integers or floats.\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not num_list:  # Check if the list is empty\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Using built-in min function for simplicity and efficiency\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list containing numbers (int or float).\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n        TypeError: If the list contains non-numeric values.\n    \"\"\"\n    # Check if list is empty\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n\n    # Check if all elements in the list are numeric\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise TypeError(\"List contains non-numeric values\")\n\n    # Use built-in min function to find the smallest number\n    return min(numbers)", "matching_cluster_idx": 0}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list is empty. Cannot find smallest number.\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a list of numbers.\n\n    Args:\n        numbers (list): A list of numbers (int or float).\n\n    Returns:\n        int or float: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n        TypeError: If the list contains non-numeric values.\n    \"\"\"\n    # Check if list is empty\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n\n    # Attempt to find the smallest number, assuming all elements are numeric\n    try:\n        return min(numbers)\n    except TypeError:\n        # If a TypeError occurs, the list contains non-numeric values\n        raise TypeError(\"List contains non-numeric values\")", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n    \n    :param numbers: List of integers or floats.\n    :return: The smallest number, or None if the list is empty.\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return None\n    return min(numbers)  # Use built-in min() function for efficiency", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Using built-in min() function for simplicity and efficiency\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    This function finds the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers (int or float).\n\n    Returns:\n        The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "import unittest\ndef smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    return min(numbers)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 68.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Filters tuples from a list where every element in the tuple is divisible by `k`.\n\n    Args:\n        tuples_list (list): List of tuples to filter.\n        k (int): Divisor.\n\n    Returns:\n        list: List of tuples with all elements divisible by `k`.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Finds and returns tuples from a list where all elements in the tuple are divisible by k.\n\n    Args:\n        tuple_list (list): A list of tuples.\n        k (int): The divisor.\n\n    Returns:\n        list: A list of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    # Use list comprehension to filter tuples\n    return [t for t in tuple_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples from `tuple_list` where all elements in each tuple are divisible by `k`.\n\n    Args:\n        tuple_list (list): A list of tuples.\n        k (int): The divisor.\n\n    Returns:\n        list: A list of tuples where every element is divisible by `k`.\n    \"\"\"\n    # Use list comprehension to filter tuples\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Filters a list of tuples to include only those where all elements are divisible by k.\n\n    Args:\n    - tuples_list (list): A list of tuples, where each tuple contains integers.\n    - k (int): The divisor to check for.\n\n    Returns:\n    - list: A list of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    # Use list comprehension to filter tuples\n    # A tuple is included if all its elements are divisible by k (i.e., the remainder when divided by k is 0)\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds and returns tuples from the given list where all elements are divisible by k.\n\n    Args:\n        tuples_list (list): A list of tuples.\n        k (int): The divisor to check against.\n\n    Returns:\n        list: A list of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, divisor):\n    \"\"\"\n    Identifies tuples in a list where every element is divisible by a given divisor.\n\n    Args:\n    - tuples_list (list): A list of tuples, each containing integers.\n    - divisor (int): The number by which all elements in a tuple must be divisible.\n\n    Returns:\n    - list: A list of tuples where every element in each tuple is divisible by the divisor.\n    \"\"\"\n    # Use list comprehension to filter tuples\n    # A tuple is included if all its elements are divisible by the divisor\n    return [t for t in tuples_list if all(element % divisor == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n    - tuples_list (list): A list of tuples to search through.\n    - k (int): The divisor to check against.\n\n    Returns:\n    - list: A list of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    # Use list comprehension to filter tuples\n    # A tuple is included if all its elements are divisible by k\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Filter tuples where all elements are divisible by k.\n\n    Args:\n    - tuples_list (list): A list of tuples.\n    - k (int): The divisor.\n\n    Returns:\n    - list: A list of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function filters a list of tuples to find tuples where all elements are divisible by k.\n\n    Parameters:\n    - `tuples_list` (list): A list of tuples.\n    - `k` (int): The divisor to check against.\n\n    Returns:\n    - `list`: A list of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Filters a list of tuples to include only those where every element is divisible by `k`.\n\n    Args:\n    - `tuples_list` (list of tuples): The input list containing tuples of integers.\n    - `k` (int): The divisor to check for in each tuple's elements.\n\n    Returns:\n    - `list of tuples`: A list of tuples where every element in each tuple is divisible by `k`.\n    \"\"\"\n    # Use list comprehension to filter tuples based on the condition\n    # that all elements in a tuple are divisible by `k`\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function filters a list of tuples and returns only those tuples \n    where all elements are divisible by a given number `k`.\n\n    Parameters:\n    tuples_list (list): A list of tuples to be filtered.\n    k (int): The divisor number.\n\n    Returns:\n    list: A list of tuples where all elements in each tuple are divisible by `k`.\n    \"\"\"\n    # Use list comprehension to filter tuples\n    # A tuple is included in the output if all its elements are divisible by k\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds and returns tuples from the given list where all elements are divisible by k.\n\n    Args:\n        tuples_list (list): A list of tuples to search through.\n        k (int): The divisor to check for.\n\n    Returns:\n        list: A list of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, divisor):\n    \"\"\"\n    Filters a list of tuples to find those where all elements are divisible by a given divisor.\n\n    Args:\n        tuples_list (list): A list of tuples, each containing integers.\n        divisor (int): The number by which all elements in the result tuples must be divisible.\n\n    Returns:\n        list: A list of tuples where every element in each tuple is divisible by the divisor.\n    \"\"\"\n    # Use list comprehension to filter tuples\n    # A tuple is included in the output if all its elements are divisible by the divisor\n    return [t for t in tuples_list if all(element % divisor == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds and returns tuples from `tuples_list` where all elements are divisible by `k`.\n\n    Args:\n    - `tuples_list`: A list of tuples.\n    - `k`: The divisor to check against.\n\n    Returns:\n    - A list of tuples where each element in the tuple is divisible by `k`.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples in the given list where all elements are divisible by k.\n    \n    Args:\n        tuples_list (list): List of tuples to search through.\n        k (int): The divisor to check against.\n    \n    Returns:\n        list: List of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    This function filters a list of tuples to find tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list): A list of tuples.\n    k (int): The divisor to check against.\n\n    Returns:\n    list: A list of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    # Use list comprehension to filter tuples based on the condition\n    # that all elements in a tuple are divisible by k\n    return [t for t in tuple_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n    - tuples_list (list): A list of tuples to search through.\n    - k (int): The divisor to check for.\n\n    Returns:\n    - list: A list of tuples where every element in each tuple is divisible by k.\n    \"\"\"\n    # Use list comprehension with all() to filter tuples\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Filter tuples where all elements are divisible by k.\n\n    Args:\n    - tuples_list (list): List of tuples to filter.\n    - k (int): Divisor.\n\n    Returns:\n    - list: Tuples with all elements divisible by k.\n    \"\"\"\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Filter tuples from a list where every element in the tuple is divisible by k.\n\n    Args:\n        tuples_list (list): A list of tuples.\n        k (int): The divisor to check for.\n\n    Returns:\n        list: List of tuples where all elements in each tuple are divisible by k.\n    \"\"\"\n    # Use list comprehension to filter tuples\n    # For each tuple, check if all elements are divisible by k using the all() function and a generator expression\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Filter tuples from a list where all elements in each tuple are divisible by k.\n\n    Parameters:\n    - tuples_list (list): A list of tuples\n    - k (int): The divisor\n\n    Returns:\n    - list: A list of tuples where all elements in each tuple are divisible by k\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]\ntuples_list = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.74019607843137, "dps_norm": 86.42857142857142, "pass@1": 71.0, "profiled": [{"solution": "def freq_count(input_list):\n    \"\"\"\n    Compute the frequency of each element in a list.\n\n    Args:\n        input_list (list): A list containing elements of any hashable type.\n\n    Returns:\n        dict: A dictionary where keys are the unique elements from the input list\n              and values are their respective frequency counts.\n    \"\"\"\n    freq_dict = {}  # Initialize an empty dictionary to store frequencies\n    for item in input_list:  # Iterate over each item in the input list\n        if item in freq_dict:  # Check if the item is already a key in the dictionary\n            freq_dict[item] += 1  # If it is, increment its count by 1\n        else:\n            freq_dict[item] = 1  # If not, add it as a key with a count of 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of all elements in the input list.\n\n    Args:\n    - input_list (list): The list containing elements to count.\n\n    Returns:\n    - dict: Dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency_dict = {}\n\n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency_dict[element] = 1\n\n    # Return the dictionary containing the frequency of all elements\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of each element in the input list.\n    \n    Args:\n        input_list (list): A list containing elements of any hashable type.\n    \n    Returns:\n        dict: A dictionary where keys are the unique elements from the input list and values are their corresponding frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already a key in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the input list.\n\n    Args:\n        input_list (list): A list containing elements of any hashable type.\n\n    Returns:\n        dict: A dictionary where keys are elements from the input list and values are their respective frequencies.\n    \"\"\"\n    return dict(Counter(input_list))", "matching_cluster_idx": 6}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Computes the frequency of all elements in a list.\n    \n    Args:\n    - input_list (list): The input list containing elements of any hashable type.\n    \n    Returns:\n    - dict: A dictionary where keys are the unique elements from the input list and values are their respective frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    # Return the dictionary containing the frequency of all elements\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of each element in the input list.\n    \n    Parameters:\n    - input_list (list): The list containing elements to count.\n    \n    Returns:\n    - freq_dict (dict): Dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    freq_dict = {}  # Initialize an empty dictionary to store frequencies\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already a key in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Returns a dictionary with elements from the input list as keys and their frequencies as values.\n    \n    Parameters:\n    input_list (list): The list of elements to calculate frequencies from.\n    \n    Returns:\n    dict: Dictionary where keys are unique elements from the input list and values are their respective frequencies.\n    \"\"\"\n    frequency_dict = {}\n    for element in input_list:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Returns a dictionary with frequency of each element in the input list.\n    \n    Parameters:\n    input_list (list): The list of elements to count frequencies for.\n    \n    Returns:\n    dict: Dictionary where keys are the unique elements from the list and values are their respective frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store element frequencies\n    freq_dict = {}\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is new, add it to the dictionary with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of all elements in a list and return as a dictionary.\n\n    Args:\n        input_list (list): The list containing elements of any hashable type.\n\n    Returns:\n        dict: A dictionary where keys are the unique elements from the list and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency_dict = {}\n\n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency_dict[element] = 1\n\n    # Return the dictionary containing the frequency of all elements\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of all elements in a list.\n\n    Args:\n        input_list (list): The list containing elements to count.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n\n    Example:\n        >>> freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])\n        {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n    # Initialize an empty dictionary to store frequencies\n    freq_dict = {}\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of each element in the input list.\n\n    Args:\n        input_list (list): A list containing elements of any hashable type.\n\n    Returns:\n        dict: A dictionary where keys are the unique elements from the list and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency_dict = {}\n\n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency_dict[element] = 1\n\n    # Return the dictionary containing the frequency of all elements\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the input list.\n    \n    Parameters:\n    input_list (list): The list of elements to count frequencies from.\n    \n    Returns:\n    dict: Dictionary where keys are elements from the list and values are their respective frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store element frequencies\n    frequency_dict = {}\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency_dict[element] = 1\n    \n    # Return the dictionary containing element frequencies\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the input list.\n\n    :param input_list: The list to calculate element frequencies from.\n    :return: A dictionary where keys are unique elements from the list and values are their respective frequencies.\n    \"\"\"\n    freq_dict = {}\n    for element in input_list:\n        if element in freq_dict:\n            # If the element is already in the dictionary, increment its count\n            freq_dict[element] += 1\n        else:\n            # If the element is not in the dictionary, add it with a count of 1\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of each element in the input list.\n    \n    Parameters:\n    input_list (list): The list containing elements to count frequencies for.\n    \n    Returns:\n    dict: A dictionary with unique elements as keys and their frequencies as values.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of all elements in a list.\n    \n    Args:\n        input_list (list): A list containing elements of any hashable type.\n    \n    Returns:\n        dict: Dictionary with unique elements as keys and their frequencies as values.\n    \"\"\"\n    freq_dict = {}  # Initialize an empty dictionary to store frequencies\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already a key in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    return freq_dict\ninput_list = [10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of each element in the input list.\n\n    Args:\n        input_list (list): A list containing elements of any hashable type.\n\n    Returns:\n        dict: Dictionary with unique elements as keys and their frequencies as values.\n    \"\"\"\n    # Initialize an empty dictionary to store element frequencies\n    freq_dict = {}\n\n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the input list.\n\n    :param input_list: The list of elements to count frequencies from.\n    :return: Dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for item in input_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of all elements in a list.\n    \n    Args:\n        input_list (list): A list containing elements of any hashable type.\n    \n    Returns:\n        dict: A dictionary where keys are unique elements from the list and values are their frequencies.\n    \"\"\"\n    frequency_dict = {}  # Initialize an empty dictionary to store frequencies\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already a key in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    Calculate the frequency of each element in the input list and return it as a dictionary.\n\n    Args:\n        input_list (list): A list of elements.\n\n    Returns:\n        dict: A dictionary where keys are unique elements from the input list and values are their frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store element frequencies\n    freq_dict = {}\n\n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    \"\"\"\n    This function calculates the frequency of each element in the given list\n    and returns the result as a dictionary.\n\n    Parameters:\n    input_list (list): The list from which to calculate element frequencies.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their respective frequencies.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency_dict = {}\n\n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already a key in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # If the element is not a key, add it with a count of 1\n        else:\n            frequency_dict[element] = 1\n\n    # Return the dictionary containing the frequency of all elements\n    return frequency_dict", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/94": {"dps": 74.17682926829268, "dps_norm": 59.0, "pass@1": 59.0, "profiled": [{"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second element in the given list.\n\n    Args:\n        tuple_list (list[tuple]): A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first element of the tuple with the minimum second element.\n    \"\"\"\n    # Check if the list is empty\n    if not tuple_list:\n        raise ValueError(\"List cannot be empty\")\n\n    # Use the min function with a custom key to find the tuple with the smallest second value\n    # The key argument of the min function specifies that we want to compare based on the second element of each tuple (index 1)\n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuple_list (list): A list of tuples, where each tuple contains at least two values.\n\n    Returns:\n        The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:  # Check if the list is empty\n        raise ValueError(\"Input list is empty\")\n    \n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we want to compare based on the second element of each tuple (index 1)\n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Finds the first value of the tuple with the smallest second value in a list of tuples.\n\n    Args:\n        tuples_list (list[tuple]): A list of tuples, where each tuple contains at least two elements.\n            The second element of each tuple is expected to be comparable (e.g., numbers, strings, etc.).\n\n    Returns:\n        The first element of the tuple with the smallest second value. If the input list is empty, returns `None`.\n    \"\"\"\n    if not tuples_list:\n        # Return None for an empty list\n        return None\n    \n    # Use the min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we want to compare based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second element in a list of tuples.\n\n    Args:\n    - tuples_list (list): A list of tuples where each tuple has at least two elements.\n\n    Returns:\n    - The first element of the tuple with the smallest second value.\n\n    Raises:\n    - ValueError: If the input list is empty.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we're comparing based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n\n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples_list (list): A list of tuples where the second element of each tuple is comparable (e.g., numbers).\n\n    Returns:\n        The first element of the tuple with the smallest second value. If the input list is empty, returns None.\n\n    Raises:\n        ValueError: If the input is not a list or if the list contains non-tuple elements.\n        IndexError: If the tuples in the list do not have at least two elements.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(tuples_list, list):\n        raise ValueError(\"Input must be a list.\")\n\n    # Check if list is not empty\n    if len(tuples_list) == 0:\n        return None\n\n    # Check if all elements in the list are tuples and have at least two elements\n    if not all(isinstance(item, tuple) and len(item) >= 2 for item in tuples_list):\n        raise IndexError(\"All list elements must be tuples with at least two elements.\")\n\n    # Use min function with a key to find the tuple with the smallest second value\n    # The key argument of the min function specifies that we want to compare based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n\n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 1}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    - tuples_list (list): A list of tuples where each tuple contains at least two values.\n\n    Returns:\n    - The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples_list:  # Check if the list is empty\n        raise ValueError(\"Input list is empty\")\n\n    # Use the built-in min function with a key to find the tuple with the smallest second value\n    # The key specifies that we are interested in the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples_list (list): A list of tuples, where each tuple's second element is comparable (e.g., numbers).\n\n    Returns:\n        The first element of the tuple with the smallest second element. If the list is empty, returns None.\n    \"\"\"\n    if not tuples_list:  # Check if the list is empty\n        return None\n    \n    # Use the min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we're comparing based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second element in the list.\n\n    Args:\n        tuples_list (list): A list of tuples, where each tuple contains at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second value.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"Input list is empty\")\n\n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we want to compare based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n\n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    - tuples_list (list): A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n    - The first element of the tuple with the minimum second value.\n\n    Raises:\n    - ValueError: If input list is empty or if tuples do not have at least two elements.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"Input list is empty.\")\n    \n    # Ensure all tuples have at least two elements\n    if not all(len(t) >= 2 for t in tuples_list):\n        raise ValueError(\"All tuples must have at least two elements.\")\n\n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we want to minimize based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value in the list.\n\n    Args:\n    tuples_list (list): A list of tuples, where each tuple contains at least two elements.\n\n    Returns:\n    The first element of the tuple with the minimum second value.\n    \"\"\"\n    if not tuples_list:  # Check if the list is empty\n        raise ValueError(\"Input list is empty\")\n\n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key=lambda x: x[1] tells min to compare tuples based on their second element (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    This function finds the tuple with the smallest second value in a list of tuples\n    and returns the first value of that tuple.\n\n    Args:\n        tuples_list (list): A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second value.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Use the min function with a custom key to find the tuple with the smallest second value\n    # The key function specifies that we're comparing based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n\n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second element in the list.\n\n    Args:\n        tuples_list (list): A list of tuples, where each tuple contains at least two elements.\n\n    Returns:\n        The first element of the tuple with the minimum second element.\n    \"\"\"\n    if not tuples_list:  # Check if the list is empty\n        raise ValueError(\"Input list is empty\")\n\n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we want to compare based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n\n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value in the list.\n\n    Args:\n        tuples_list (list): A list of tuples where the second element of each tuple is comparable (e.g., numbers).\n\n    Returns:\n        The first element of the tuple with the smallest second value. If the input list is empty, returns None.\n    \"\"\"\n    if not tuples_list:  # Check if the list is empty\n        return None\n    \n    # Use the min function with a custom key to find the tuple with the smallest second value\n    # The key=lambda x: x[1] tells min to compare tuples based on their second element\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "import unittest\ndef index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the given list.\n\n    Args:\n        tuples_list (list): A list of tuples, where each tuple contains at least two values.\n\n    Returns:\n        The first element of the tuple with the minimum second value.\n    \"\"\"\n    if not tuples_list:  # Check for empty list\n        return None\n    \n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument of the min function specifies that we are interested in the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second element in the list.\n    \n    Args:\n        tuples_list (list): A list of tuples, where each tuple's second element is comparable (e.g., numbers, strings).\n    \n    Returns:\n        The first element of the tuple with the smallest second element.\n    \n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"Input list is empty\")\n    \n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key=lambda x: x[1] tells min to compare based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value from a given list of tuples.\n\n    :param tuples_list: A list of tuples, where each tuple contains at least two values.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples_list:  # Check if the list is empty\n        raise ValueError(\"Input list is empty\")\n    \n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we're comparing based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Args:\n        tuple_list (list[tuple]): List of tuples where the second element of each tuple is comparable.\n    \n    Returns:\n        The first element of the tuple with the minimum second value.\n    \"\"\"\n    if not tuple_list:  # Check if the list is empty\n        raise ValueError(\"Input list is empty\")\n    \n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we want to compare based on the second element of each tuple (index 1)\n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value in the list.\n    \n    Parameters:\n    tuples_list (list): A list of tuples, where each tuple contains at least two values.\n    \n    Returns:\n    The first element of the tuple with the minimum second value.\n    \"\"\"\n    # Check if the list is empty\n    if not tuples_list:\n        raise ValueError(\"List cannot be empty\")\n    \n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument of the min function specifies that we want to compare tuples based on their second element (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    Args:\n        tuples_list (list[tuple]): A list of tuples where the second element of each tuple is comparable.\n        \n    Returns:\n        The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples_list:  # Check if the list is empty\n        raise ValueError(\"Input list is empty\")\n    \n    # Use the built-in min function with a key to find the tuple with the smallest second value\n    # The key argument specifies that we're comparing based on the second element of each tuple (index 1)\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    \n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second element in a list of tuples.\n\n    :param tuples_list: List of tuples where each tuple contains at least two elements.\n    :return: The first element of the tuple with the minimum second element value.\n    \"\"\"\n    # Check if the input list is empty\n    if not tuples_list:\n        raise ValueError(\"Input list is empty\")\n\n    # Use the built-in min function with a custom key to find the tuple with the smallest second value\n    # The key argument specifies that we are interested in the second element of each tuple (index 1)\n    # min returns the first minimum element it encounters in case of multiple minima\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n\n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 56.66666666666666, "dps_norm": 54.285714285714285, "pass@1": 74.0, "profiled": [{"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculates the number of divisors of a given integer n.\n    \n    :param n: The number for which to count divisors.\n    :return: The number of divisors of n.\n    \"\"\"\n    # Initialize divisor count to 0\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment the count\n        if n % i == 0:\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Returns the number of divisors of the given integer `n`.\n\n    :param n: The input integer.\n    :return: The count of divisors of `n`.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Initialize divisor count to 0\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment the count\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "import unittest\ndef divisor(n: int) -> int:\n    \"\"\"\n    Calculates the number of divisors for a given integer n.\n    \n    Args:\n    n (int): The number to find divisors for.\n    \n    Returns:\n    int: The count of divisors for n.\n    \"\"\"\n    # Initialize divisor count to 0\n    count = 0\n    \n    # We only need to check up to the square root of n\n    # because a larger factor of the number must be a multiple of smaller factor that has already been checked\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If n is a perfect square, don't count its square root twice\n            if n // i == i:\n                count += 1\n            else:\n                count += 2  # One for the factor found, one for its corresponding factor\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n        n (int): The number for which to find the divisors.\n\n    Returns:\n        int: The number of divisors of n.\n\n    Raises:\n        TypeError: If n is not an integer.\n        ValueError: If n is less than 1.\n    \"\"\"\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize count of divisors\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            count += 1  # Increment count if i is a divisor\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer `n`.\n    \n    Args:\n    - `n` (int): The input integer for which to find the number of divisors.\n    \n    Returns:\n    - `int`: The number of divisors of `n`.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Initialize divisor count, including 1 and the number itself\n    count = 2 if n > 1 else 1\n    \n    # Only need to check up to the square root of n for factors\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If n is a perfect square, don't double count the square root\n            if i * i != n:\n                count += 2\n            else:\n                count += 1\n                \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The total number of divisors of n.\n\n    Raises:\n        TypeError: If n is not an integer.\n        ValueError: If n is less than 1.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize count of divisors\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n    - n (int): The input integer.\n\n    Returns:\n    - int: The number of divisors of n.\n\n    Example:\n    >>> divisor(15)\n    4\n    \"\"\"\n    # Initialize count with 0, assuming no divisors initially\n    count = 0\n    \n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If i is a divisor, increment the count\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n    - n (int): The input integer for which to find the number of divisors.\n\n    Returns:\n    - int: The total count of divisors for the given integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize count with 0. This variable will store the number of divisors.\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check each potential divisor.\n    for i in range(1, n + 1):\n        # If n is divisible by i, then i is a divisor. Increment the count.\n        if n % i == 0:\n            count += 1\n    \n    # Return the total count of divisors found.\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n    - n (int): The input integer for which to find the number of divisors.\n\n    Returns:\n    - int: The total count of divisors for `n`.\n    \"\"\"\n    # Initialize count of divisors to 0\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If i is a divisor, increment the count\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n    n (int): The input integer.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Initialize count of divisors\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if 'i' is a divisor of 'n'\n        if n % i == 0:\n            # If 'i' is a divisor, increment the count\n            count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n    \n    :param n: The input integer.\n    :return: The number of divisors of n.\n    \"\"\"\n    # Initialize counter for divisors\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment the counter\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Parameters:\n    - `n` (int): The input integer.\n\n    Returns:\n    - `count` (int): The total number of divisors of `n`.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if 'i' is a divisor of 'n'\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The input integer.\n    \n    Returns:\n    int: The count of divisors of n.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Initialize divisor count, starting with 1 and n as divisors\n    count = 2 if n > 1 else 1\n    \n    # Only need to check up to the square root of n for efficiency\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, n//i is also a divisor\n            # Count both, but if they are the same (perfect square), count once\n            count += 2 if i != n // i else 1\n            \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    # Initialize counter for divisors\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If i is a divisor, increment the count\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Args:\n    - n (int): The input integer for which divisors are to be counted.\n\n    Returns:\n    - int: The total number of divisors of n.\n\n    Raises:\n    - ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize divisor count with 0\n    count = 0\n    \n    # Only need to check up to the square root of n for efficiency\n    for i in range(1, int(n**0.5) + 1):\n        # Check if i is a divisor\n        if n % i == 0:\n            # If n is a square number, don't count its square root twice\n            if i * i != n:\n                count += 2\n            else:\n                count += 1\n                \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Args:\n    - `n (int)`: The input integer.\n\n    Returns:\n    - `int`: The number of divisors of `n`.\n\n    Raises:\n    - `TypeError`: If input `n` is not an integer.\n    - `ValueError`: If input `n` is less than 1.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 1:\n        raise ValueError(\"Input integer must be positive.\")\n\n    # Initialize divisor count with 0\n    count = 0\n    \n    # Only need to check up to the square root of n\n    # because a larger factor of the number would be a multiple of smaller factor that has already been checked\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If n is a perfect square, don't double count its square root\n            if i * i != n:\n                count += 2  # Count both i and n // i\n            else:\n                count += 1  # Only count the square root once\n                \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors of a given integer `n`.\n\n    Args:\n    - `n` (int): The input integer for which the number of divisors is to be found.\n\n    Returns:\n    - `int`: The total count of divisors for `n`.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Initialize divisor count to 0\n    count = 0\n    \n    # Only need to check up to the square root of n for efficiency\n    # because a larger factor of the number would be a multiple of smaller factor that has already been checked\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If n is a perfect square, don't double count its square root\n            if i * i != n:\n                count += 2\n            else:\n                count += 1\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Calculate the number of divisors for a given integer `n`.\n\n    Args:\n        n (int): The number for which to find the divisors.\n\n    Returns:\n        int: The number of divisors of `n`.\n    \"\"\"\n    # Initialize count of divisors to 0\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment the count\n        if n % i == 0:\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer n.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The number of divisors of n.\n\n    Raises:\n    TypeError: If n is not an integer.\n    ValueError: If n is less than 1.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize count of divisors\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            count += 1  # Increment count if i is a divisor\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors for a given integer n.\n\n    Parameters:\n    n (int): The input integer.\n\n    Returns:\n    int: The number of divisors of n.\n\n    Raises:\n    TypeError: If n is not an integer.\n    ValueError: If n is less than 1.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize count of divisors\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 50.205128205128204, "dps_norm": 60.0, "pass@1": 74.0, "profiled": [{"solution": "def frequency_lists(lists):\n    \"\"\"\n    Calculate the frequency of each element in a flattened list of lists.\n    \n    Args:\n        lists (list of lists): Input list containing lists of elements.\n    \n    Returns:\n        dict: Dictionary with unique elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use dictionary comprehension with a generator expression to count frequencies\n    frequency_dict = {item: flattened_list.count(item) for item in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "from typing import List, Dict\nfrom collections import Counter\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    This function calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        lists (List[List[int]]): A list containing multiple lists of integers.\n\n    Returns:\n        Dict[int, int]: A dictionary where keys are unique elements from the input lists and values are their respective frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency_dict = dict(Counter(flattened_list))\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    This function takes a list of lists, flattens it, and returns a dictionary with the frequency of each element.\n\n    :param lists: A list of lists containing elements (can be of any hashable type)\n    :return: A dictionary where keys are unique elements from the input lists and values are their respective frequencies\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use dictionary comprehension with a conditional to ensure all elements are counted\n    # The get() method of dictionaries returns the value for the given key if it exists in the dictionary. If not, it inserts the key with a specified value (in this case, 0) and returns that value.\n    frequency_dict = {}\n    for item in flattened_list:\n        frequency_dict[item] = frequency_dict.get(item, 0) + 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from typing import List, Dict\nfrom collections import Counter\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Compute the frequency of each element in a flattened list of lists.\n\n    Args:\n    - nested_list: A list of lists containing integers.\n\n    Returns:\n    - A dictionary where keys are unique elements from the flattened list and values are their respective frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency_dict = dict(Counter(flattened_list))\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n    \n    Args:\n        lists (list of lists): A list containing lists of elements.\n    \n    Returns:\n        dict: A dictionary where keys are unique elements from the flattened list and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use dictionary comprehension with a conditional to count the frequency of each element\n    frequency_dict = {item: flattened_list.count(item) for item in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "from typing import List, Dict\nfrom collections import Counter\nimport itertools\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Calculate the frequency of each element in a flattened list of lists.\n    \n    Args:\n    nested_list (List[List[int]]): A list containing lists of integers.\n    \n    Returns:\n    Dict[int, int]: A dictionary where keys are the unique elements from the input\n                    and values are their respective frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = list(itertools.chain(*nested_list))\n    \n    # Use Counter to count the frequency of each element\n    frequency_dict = dict(Counter(flattened_list))\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    This function calculates the frequency of each element in a flattened list of lists.\n    \n    Parameters:\n    - lists (list): A list containing lists of elements.\n    \n    Returns:\n    - dict: A dictionary where keys are the unique elements from the flattened list and values are their respective frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in lists for element in sublist]\n    \n    # Use dictionary comprehension with a conditional to count frequency of each element\n    frequency_dict = {element: flattened_list.count(element) for element in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "from typing import List, Dict\nfrom collections import Counter\ndef frequency_lists(lists_of_lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    This function calculates the frequency of each element in a \n    flattened list of lists and returns the result in a dictionary.\n\n    Args:\n    - lists_of_lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    - Dict[int, int]: A dictionary where keys are the unique integers \n                      from the input lists and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists_of_lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency_dict = Counter(flattened_list)\n    \n    return dict(frequency_dict)  # Convert back to regular dict for consistency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    This function calculates the frequency of each element in a flattened list of lists.\n    \n    Parameters:\n    - lists (list): A list containing sublists of elements.\n    \n    Returns:\n    - dict: A dictionary where keys are the unique elements from the flattened list and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Initialize an empty dictionary to store element frequencies\n    frequency_dict = {}\n    \n    # Iterate over each item in the flattened list\n    for item in flattened_list:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    This function calculates the frequency of each element in a flattened list of lists.\n    \n    Args:\n        lists (list of lists): A list containing multiple lists of elements.\n        \n    Returns:\n        dict: A dictionary where keys are unique elements from the input and values are their respective frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in lists for element in sublist]\n    \n    # Use dictionary comprehension to count the frequency of each element\n    frequency_dict = {element: flattened_list.count(element) for element in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Calculate the frequency of each element in a flattened list of lists.\n\n    Args:\n        lists (list): A list containing lists of elements.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use dictionary comprehension with a conditional to count frequency\n    frequency_dict = {item: flattened_list.count(item) for item in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "from typing import List, Dict\nfrom collections import defaultdict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Compute the frequency of each element in a flattened list of lists.\n\n    Args:\n    - lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    - Dict[int, int]: A dictionary where keys are unique elements from the input lists\n                      and values are their respective frequencies.\n    \"\"\"\n    # Initialize a dictionary to store element frequencies, default value is 0\n    freq_dict = defaultdict(int)\n    \n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in lists for element in sublist]\n    \n    # Iterate over each element in the flattened list and update its frequency\n    for element in flattened_list:\n        freq_dict[element] += 1\n    \n    # Convert defaultdict back to regular dictionary for consistency (optional but clearer for API)\n    return dict(freq_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Compute the frequency of each element in a flattened list of lists.\n    \n    Args:\n        lists (list of lists): A list containing multiple sublists.\n        \n    Returns:\n        dict: A dictionary where keys are unique elements from the flattened list and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use dictionary comprehension with a conditional to count frequency of each element\n    frequency_dict = {item: flattened_list.count(item) for item in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "def frequency_lists(lists_of_lists):\n    \"\"\"\n    This function calculates the frequency of each element in a flattened list of lists.\n    \n    Args:\n        lists_of_lists (list): A list containing multiple lists of elements.\n        \n    Returns:\n        dict: A dictionary where keys are the unique elements from the input and values are their frequencies.\n    \"\"\"\n    \n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in lists_of_lists for element in sublist]\n    \n    # Use dictionary comprehension with a conditional to count the frequency of each element\n    frequency_dict = {element: flattened_list.count(element) for element in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Calculate the frequency of each element in a flattened list of lists.\n\n    Args:\n    - lists (list): A list of lists containing elements of any hashable type.\n\n    Returns:\n    - dict: A dictionary where keys are the unique elements from the flattened list and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use a dictionary comprehension with a conditional to count the frequency of each element\n    frequency_dict = {item: flattened_list.count(item) for item in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Finds frequency of each element in a flattened list of lists, returned in a dictionary.\n\n    Args:\n        lists (list of lists): Input list containing lists of elements.\n\n    Returns:\n        dict: Dictionary with unique elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use dictionary comprehension with a conditional to count frequency of each element\n    frequency_dict = {element: flattened_list.count(element) for element in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "from typing import List, Dict\nfrom collections import Counter\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    This function calculates the frequency of each element in a flattened list of lists.\n    \n    Args:\n    lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    Dict[int, int]: A dictionary where keys are the unique elements from the input lists and values are their frequencies.\n    \"\"\"\n    \n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in lists for element in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency_dict = dict(Counter(flattened_list))\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists_of_lists):\n    \"\"\"\n    This function calculates the frequency of each element in a flattened list of lists.\n    \n    Args:\n    lists_of_lists (list): A list containing lists of elements.\n    \n    Returns:\n    dict: A dictionary where keys are unique elements from the input lists and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists_of_lists for item in sublist]\n    \n    # Use dictionary comprehension with a conditional to create a frequency dictionary\n    frequency_dict = {item: flattened_list.count(item) for item in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    This function calculates the frequency of each element in a flattened list of lists.\n    \n    Args:\n        nested_list (List[List[int]]): A list containing lists of integers.\n    \n    Returns:\n        Dict[int, int]: A dictionary where keys are unique elements from the input lists and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency_dict = dict(Counter(flattened_list))\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    \"\"\"\n    Calculate the frequency of each element in a flattened list of lists.\n    \n    Args:\n    - nested_list (list): A list of lists containing elements (hashable types)\n    \n    Returns:\n    - dict: A dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use a dictionary comprehension with enumerate to count the frequency of each element\n    # Since Python 3.7, dictionaries maintain insertion order, so we don't need OrderedDict\n    frequency_dict = {item: flattened_list.count(item) for item in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}]}, "Mbpp/106": {"dps": 42.62987012987013, "dps_norm": 84.16666666666666, "pass@1": 72.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n        lst (list): The list to be appended\n        tup (tuple): The tuple to which the list will be appended\n        \n    Returns:\n        tuple: A new tuple with list elements appended to the tuple\n    \"\"\"\n    return tup + tuple(lst)  # Convert list to tuple for concatenation", "matching_cluster_idx": 5}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input list to the input tuple.\n    \n    Args:\n    - input_list (list): The list of elements to be appended.\n    - input_tuple (tuple): The initial tuple to which elements will be appended.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the original tuple followed by the elements from the input list.\n    \"\"\"\n    # Convert the input tuple to a list to enable append operations\n    combined_list = list(input_tuple)\n    \n    # Extend the list with elements from the input list\n    combined_list.extend(input_list)\n    \n    # Convert the list back to a tuple for the return type consistency\n    result_tuple = tuple(combined_list)\n    \n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(list_to_add, tuple_original):\n    \"\"\"\n    Appends all elements from the given list to the given tuple.\n    \n    Args:\n        list_to_add (list): The list of elements to be appended.\n        tuple_original (tuple): The original tuple to which elements will be added.\n    \n    Returns:\n        tuple: A new tuple containing all elements from the original tuple followed by the list elements.\n    \"\"\"\n    # Convert the tuple to a list to enable append operation\n    list_temp = list(tuple_original)\n    \n    # Extend the temporary list with elements from the given list\n    list_temp.extend(list_to_add)\n    \n    # Convert the list back to a tuple for the return type consistency\n    result_tuple = tuple(list_temp)\n    \n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends the given list to the given tuple and returns the result as a new tuple.\n    \n    Args:\n        input_list (list): The list to be appended.\n        input_tuple (tuple): The original tuple.\n    \n    Returns:\n        tuple: A new tuple containing all elements from the original tuple followed by the list elements.\n    \"\"\"\n    # Convert the tuple to a list to enable append operation (since tuples are immutable in Python)\n    combined_list = list(input_tuple)\n    \n    # Extend the list with the input list elements\n    combined_list.extend(input_list)\n    \n    # Convert the combined list back to a tuple for the return type consistency\n    result_tuple = tuple(combined_list)\n    \n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input_list to the input_tuple.\n    \n    Since tuples in Python are immutable, this function returns a new tuple \n    rather than modifying the original tuple in place.\n    \n    Parameters:\n    - input_list (list): The list of elements to be appended\n    - input_tuple (tuple): The original tuple to which elements are added\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the input_tuple followed by input_list\n    \"\"\"\n    # Convert the tuple to a list to enable append operations\n    combined_list = list(input_tuple)\n    \n    # Extend the list with elements from the input_list\n    combined_list.extend(input_list)\n    \n    # Convert the list back to a tuple before returning\n    return tuple(combined_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n        lst (list): The list to append.\n        tup (tuple): The tuple to which the list is appended.\n    \n    Returns:\n        tuple: A new tuple containing all elements from `tup` followed by all elements from `lst`.\n    \"\"\"\n    # Convert the tuple to a list to enable appending\n    combined_list = list(tup)\n    \n    # Append each element from the given list to the combined list\n    combined_list.extend(lst)\n    \n    # Convert the combined list back to a tuple and return\n    return tuple(combined_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements of the input list to the input tuple.\n    \n    Args:\n    - input_list (list): The list of elements to append.\n    - input_tuple (tuple): The original tuple to which elements will be appended.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the original tuple followed by the list elements.\n    \"\"\"\n    # Convert the tuple to a list to enable appending (since tuples are immutable)\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the list with all elements from the input list\n    list_from_tuple.extend(input_list)\n    \n    # Convert the list back to a tuple for the return (as per problem statement)\n    result_tuple = tuple(list_from_tuple)\n    \n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends all elements from the given list to the given tuple.\n    \n    Args:\n        lst (list): The list of elements to append.\n        tup (tuple): The tuple to which elements will be appended.\n    \n    Returns:\n        tuple: A new tuple containing all elements from `tup` followed by all elements from `lst`.\n    \"\"\"\n    # Since tuples are immutable, we convert the tuple to a list to allow appending\n    list_from_tuple = list(tup)\n    \n    # Extend the new list with the given list\n    list_from_tuple.extend(lst)\n    \n    # Convert the list back to a tuple and return it\n    return tuple(list_from_tuple)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input_list to the input_tuple.\n    \n    Args:\n    - input_list (list): The list of elements to be appended.\n    - input_tuple (tuple): The original tuple to which elements will be appended.\n    \n    Returns:\n    - tuple: A new tuple with elements from the input_tuple followed by elements from the input_list.\n    \"\"\"\n    # Convert the input_tuple to a list to enable append operation\n    list_copy = list(input_tuple)\n    \n    # Extend the list_copy with all elements from input_list\n    list_copy.extend(input_list)\n    \n    # Convert the modified list back to a tuple and return it\n    return tuple(list_copy)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input_list to the input_tuple.\n    \n    Args:\n        input_list (list): The list of elements to be appended.\n        input_tuple (tuple): The original tuple to which elements will be added.\n    \n    Returns:\n        tuple: A new tuple containing all elements from the original tuple followed by the list elements.\n    \"\"\"\n    # Convert the tuple to a list (since tuples are immutable in Python)\n    combined_list = list(input_tuple)\n    \n    # Extend the list with the input_list elements\n    combined_list.extend(input_list)\n    \n    # Convert the combined list back to a tuple and return it\n    return tuple(combined_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input_list to the input_tuple.\n    \n    Args:\n        input_list (list): The list of elements to append.\n        input_tuple (tuple): The original tuple to which elements will be added.\n    \n    Returns:\n        tuple: A new tuple containing all elements from the original tuple followed by elements from the input list.\n    \"\"\"\n    # Convert the input tuple to a list to enable appending (since tuples are immutable)\n    list_result = list(input_tuple)\n    \n    # Extend the list with all elements from the input list\n    list_result.extend(input_list)\n    \n    # Convert the result back to a tuple and return it\n    return tuple(list_result)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input_list to the input_tuple.\n    \n    Args:\n        input_list (list): The list of elements to append.\n        input_tuple (tuple): The base tuple to which elements will be appended.\n    \n    Returns:\n        tuple: A new tuple containing all elements from the input_tuple followed by input_list.\n    \"\"\"\n    # Convert the input_tuple to a list to enable append operation\n    combined_list = list(input_tuple)\n    \n    # Extend the list with elements from input_list\n    combined_list.extend(input_list)\n    \n    # Convert the combined list back to a tuple and return\n    return tuple(combined_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends all elements from the given list to the given tuple.\n    \n    Args:\n    - lst (list): The list of elements to be appended.\n    - tup (tuple): The tuple to which elements will be appended.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the original tuple followed by all elements from the list.\n    \"\"\"\n    # Convert the tuple to a list (since tuples are immutable in Python)\n    list_from_tuple = list(tup)\n    \n    # Extend the list with elements from the input list\n    list_from_tuple.extend(lst)\n    \n    # Convert the list back to a tuple and return it\n    return tuple(list_from_tuple)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends the given list to the given tuple and returns the new tuple.\n\n    Args:\n    - input_list (list): The list to be appended.\n    - input_tuple (tuple): The original tuple.\n\n    Returns:\n    - tuple: A new tuple with the input_list appended to input_tuple.\n    \"\"\"\n    # Convert the tuple to a list to enable append operation\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the list with the input_list elements\n    list_from_tuple.extend(input_list)\n    \n    # Convert the list back to a tuple and return\n    return tuple(list_from_tuple)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends elements from a list to a tuple.\n\n    Args:\n    - input_list (list): The list of elements to append.\n    - input_tuple (tuple): The original tuple to which elements will be appended.\n\n    Returns:\n    - tuple: A new tuple containing all elements from the original tuple followed by the list elements.\n    \"\"\"\n    # Convert the tuple to a list to enable appending\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the list with elements from the input list\n    list_from_tuple.extend(input_list)\n    \n    # Convert the list back to a tuple before returning\n    return tuple(list_from_tuple)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements of the input list to the input tuple.\n    \n    Args:\n        input_list (list): The list of elements to be appended.\n        input_tuple (tuple): The original tuple to which elements will be appended.\n    \n    Returns:\n        tuple: A new tuple containing all elements from the original tuple followed by the list elements.\n    \"\"\"\n    # Convert the tuple to a list (since tuples are immutable in Python)\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the new list with elements from the input list\n    list_from_tuple.extend(input_list)\n    \n    # Convert the list back to a tuple and return it\n    return tuple(list_from_tuple)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends the input_list to the input_tuple and returns the resulting tuple.\n\n    Args:\n        input_list (list): The list to be appended.\n        input_tuple (tuple): The original tuple.\n\n    Returns:\n        tuple: A new tuple with the input_list appended to the input_tuple.\n    \"\"\"\n    # Convert the tuple to a list to enable append operation\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the list with the elements from the input_list\n    list_from_tuple.extend(input_list)\n    \n    # Convert the list back to a tuple and return it\n    return tuple(list_from_tuple)", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input list to the input tuple.\n    \n    Args:\n    - input_list (list): List of elements to append.\n    - input_tuple (tuple): Original tuple to which elements will be appended.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the original tuple and the input list.\n    \"\"\"\n    # Convert the input tuple to a list to enable append operations\n    result_list = list(input_tuple)\n    \n    # Extend the list with elements from the input list\n    result_list.extend(input_list)\n    \n    # Convert the list back to a tuple for the return\n    result_tuple = tuple(result_list)\n    \n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input list to the input tuple.\n    \n    Args:\n        input_list (list): The list of elements to append.\n        input_tuple (tuple): The original tuple to which elements will be appended.\n    \n    Returns:\n        tuple: A new tuple containing all elements from the original tuple followed by the list elements.\n    \"\"\"\n    # Convert the input tuple to a list to enable append operations\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the new list with elements from the input list\n    list_from_tuple.extend(input_list)\n    \n    # Convert the list back to a tuple for the return\n    result_tuple = tuple(list_from_tuple)\n    \n    return result_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input_list to the input_tuple.\n    \n    Args:\n        input_list (list): The list of elements to be appended.\n        input_tuple (tuple): The original tuple to which elements will be added.\n    \n    Returns:\n        tuple: A new tuple containing all elements from the original tuple followed by the list elements.\n    \"\"\"\n    # Convert the input tuple to a list (since tuples are immutable in Python)\n    combined_list = list(input_tuple)\n    \n    # Extend the list with elements from the input list\n    combined_list.extend(input_list)\n    \n    # Convert the combined list back to a tuple and return it\n    return tuple(combined_list)", "matching_cluster_idx": 4}]}, "Mbpp/108": {"dps": null, "dps_norm": null, "pass@1": 6.0, "profiled": []}, "Mbpp/111": {"dps": 79.76923076923077, "dps_norm": 84.375, "pass@1": 60.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements among all sublists in a given list of lists.\n    \n    Parameters:\n    - nested_lists (list of lists): A list containing multiple sublists of elements.\n    \n    Returns:\n    - list: A list of elements common to all sublists. The order may vary based on set operations.\n    \"\"\"\n    # Ensure input is a list of lists\n    if not all(isinstance(sublist, list) for sublist in nested_lists):\n        raise ValueError(\"Input must be a list of lists\")\n    \n    # Handle the edge case where the input list of lists is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize the set of common elements with the first sublist\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists to find the intersection\n    for sublist in nested_lists[1:]:\n        common_elements &= set(sublist)  # Update common_elements to be the intersection with the current sublist\n    \n    # Convert the set back to a list and return it\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in all sublists within a given nested list.\n    \n    Parameters:\n    - nested_lists (list): A list of lists containing integers.\n    \n    Returns:\n    - set: A set of integers common to all sublists.\n    \"\"\"\n    # Check if input list is empty\n    if not nested_lists:\n        return set()\n    \n    # Initialize common elements with the first sublist\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the rest of the sublists\n    for sublist in nested_lists[1:]:\n        # Update common_elements to include only elements present in both the current common_elements and the current sublist\n        common_elements &= set(sublist)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n    \n    :param nested_lists: List of lists containing integers\n    :return: List of integers common across all nested lists\n    \"\"\"\n    # Check if input list is empty\n    if not nested_lists:\n        return []\n\n    # Initialize common elements with the first inner list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining inner lists\n    for inner_list in nested_lists[1:]:\n        # Update common_elements to include only elements present in both current common_elements and the inner_list\n        common_elements &= set(inner_list)\n    \n    # Convert the set back to a list and return it\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in all sublists within the given nested list structure.\n    \n    Args:\n        nested_lists (list): A list containing lists of integers.\n        \n    Returns:\n        list: A list of integers that are common across all sublists.\n    \"\"\"\n    # Check if input list is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize the set of common elements with the first sublist\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Update common_elements to include only elements present in both the current common_elements and the current sublist\n        common_elements &= set(sublist)\n        \n    # Convert the set back to a list and return it\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in all nested lists.\n\n    Args:\n        nested_lists (list of lists): A list containing multiple sublists of integers.\n\n    Returns:\n        list: A list of integers common to all sublists. Order of elements may vary.\n\n    Example:\n        >>> set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]))\n        {12, 18}\n    \"\"\"\n\n    # Check if input list is empty\n    if not nested_lists:\n        return []\n\n    # Initialize set with the first sublist for efficient lookups\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the rest of the sublists\n    for sublist in nested_lists[1:]:\n        # Update common_elements to include only elements present in both the current common set and the new sublist\n        common_elements &= set(sublist)\n\n    # Convert set back to list (as per function's return type) and return\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements across all sublists in a given nested list.\n    \n    Parameters:\n    - nested_lists (list of lists): A list containing one or more sublists of elements.\n    \n    Returns:\n    - list: A list of elements common to all sublists. If no common elements are found, an empty list is returned.\n    \"\"\"\n    # Check if the input list is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize the set of common elements with the first sublist\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Update the common_elements set to include only elements present in both the current common_elements and the current sublist\n        common_elements &= set(sublist)\n        \n        # If no common elements are found, break the loop to return an empty list\n        if not common_elements:\n            break\n    \n    # Convert the set back to a list and return it\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in all sublists within a given list of lists.\n    \n    Parameters:\n    nested_lists (list of lists): A list containing multiple lists of elements.\n    \n    Returns:\n    list: A list of elements common to all sublists. The order of elements may vary.\n    \"\"\"\n    # Check if input list is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize the set of common elements with the first sublist\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Update the common_elements set to include only elements present in both the current common_elements and the current sublist\n        common_elements &= set(sublist)\n    \n    # Convert the set back to a list and return it\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Returns a set of elements common to all lists in the provided nested list structure.\n\n    :param nested_lists: A list containing multiple lists of elements.\n    :return: A set of common elements.\n    \"\"\"\n    # Ensure input is a list to prevent potential errors\n    if not isinstance(nested_lists, list):\n        raise ValueError(\"Input must be a list of lists.\")\n\n    # Convert all sublists to sets for efficient lookups and intersection operations\n    set_lists = [set(sublist) for sublist in nested_lists if isinstance(sublist, list)]\n\n    # Check if all elements in the input were indeed lists\n    if len(set_lists) != len(nested_lists):\n        raise ValueError(\"All elements in the input must be lists.\")\n\n    # If no lists are provided, return an empty set\n    if not set_lists:\n        return set()\n\n    # Use the set intersection operation to find common elements across all sets\n    common_elements = set_lists[0]\n    for s in set_lists[1:]:\n        common_elements &= s\n\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find common elements in all inner lists within a given nested list structure.\n\n    Args:\n    - `nested_lists` (list): A list containing multiple lists of elements.\n\n    Returns:\n    - `set`: A set of elements common to all inner lists.\n    \"\"\"\n    # Base case: If the input list is empty, return an empty set\n    if not nested_lists:\n        return set()\n\n    # Initialize the set of common elements with the first inner list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining inner lists\n    for inner_list in nested_lists[1:]:\n        # Update common_elements to include only elements present in both the current common set and the inner list\n        common_elements &= set(inner_list)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns a set of elements common to all sublists.\n    \n    :param nested_lists: A list containing multiple lists\n    :type nested_lists: list[list]\n    :return: A set of common elements\n    :rtype: set\n    \"\"\"\n    # Check if input list is empty\n    if not nested_lists:\n        return set()\n    \n    # Initialize common_elements with the first sublist, assuming all sublists are non-empty\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the rest of the sublists\n    for sublist in nested_lists[1:]:\n        # Update common_elements to include only elements present in both common_elements and the current sublist\n        common_elements &= set(sublist)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in all sublists within a given list of lists.\n    \n    Args:\n    - nested_lists (list of lists): A list containing sublists of elements.\n    \n    Returns:\n    - list: A list of elements common to all sublists.\n    \"\"\"\n    # Base case: If the input list is empty, there are no common elements\n    if not nested_lists:\n        return []\n    \n    # Initialize the set of common elements with the first sublist\n    # Using a set for efficient lookups\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Update common_elements to include only elements present in both the current common_elements and the current sublist\n        common_elements &= set(sublist)\n        \n        # If no common elements are found, break the loop\n        if not common_elements:\n            break\n    \n    # Convert the set back to a list and return it\n    # The conversion is to match the problem's output expectation\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in all nested lists.\n\n    Args:\n        nested_lists (list): A list of lists containing integers.\n\n    Returns:\n        list: A list of integers common across all nested lists.\n    \"\"\"\n    # Check if input list is empty\n    if not nested_lists:\n        return []\n\n    # Initialize common elements with the first sublist\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Update common_elements to include only elements present in both the current common_elements and the current sublist\n        common_elements &= set(sublist)\n    \n    # Convert the set back to a list and return it, maintaining the original order of appearance\n    return [element for element in nested_lists[0] if element in common_elements]", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in all sublists within a given nested list structure.\n    \n    Parameters:\n    - nested_lists (list of lists): A list containing multiple sublists of elements.\n    \n    Returns:\n    - set: A set of elements common to all sublists.\n    \"\"\"\n    # Check if input list is empty\n    if not nested_lists:\n        return set()\n    \n    # Initialize the set of common elements with the first sublist\n    # We use a set for efficient lookups and to eliminate duplicates\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Update the common_elements set to include only elements present in both the current common_elements and the current sublist\n        common_elements &= set(sublist)\n        \n        # If no common elements are found, break the loop to avoid further unnecessary iterations\n        if not common_elements:\n            break\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in all sublists within a given list of lists.\n    \n    Args:\n    nested_lists (list): A list containing multiple lists of elements.\n    \n    Returns:\n    list: A list of elements common to all sublists. The order of elements is based on their first occurrence in the first sublist.\n    \"\"\"\n    # Check if input list is empty\n    if not nested_lists:\n        return []\n\n    # Initialize common_elements with the first sublist for initial comparison\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Update common_elements to include only elements present in both current common_elements and the current sublist\n        common_elements &= set(sublist)\n        \n    # Convert set back to list, preserving original order of elements as much as possible\n    # by re-checking against the first sublist\n    ordered_common_elements = [element for element in nested_lists[0] if element in common_elements]\n    \n    return ordered_common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Find common elements in multiple nested lists.\n\n    Args:\n    - lists (list of lists): A list containing multiple lists of integers.\n\n    Returns:\n    - list: A list of integers common to all input lists.\n    \"\"\"\n    # Check if input list is empty\n    if not lists:\n        return []\n\n    # Initialize set of common elements with the first list\n    common_elements = set(lists[0])\n    \n    # Iterate over the rest of the lists\n    for lst in lists[1:]:\n        # Update common_elements to include only elements present in both current list and previous common elements\n        common_elements &= set(lst)\n    \n    # Convert the set back to a list (as per problem's return type expectation) and return\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Returns a set of elements common to all lists within the nested list.\n\n    :param nested_lists: A list of lists containing elements to compare.\n    :return: A set of common elements.\n    \"\"\"\n    # Check if input is a list and not empty\n    if not isinstance(nested_lists, list) or len(nested_lists) == 0:\n        return set()\n\n    # Initialize common_elements with the set of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists to find common elements\n    for lst in nested_lists[1:]:\n        # Check if lst is indeed a list\n        if not isinstance(lst, list):\n            raise ValueError(\"All elements of the input must be lists.\")\n        # Update common_elements to include only elements present in both current common_elements and lst\n        common_elements &= set(lst)\n    \n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in all sublists within a given nested list structure.\n\n    Parameters:\n    - nested_lists (list of lists): A list containing multiple sublists of elements.\n\n    Returns:\n    - set: A set of elements common to all sublists.\n    \"\"\"\n    # Check if input list is empty\n    if not nested_lists:\n        return set()\n\n    # Initialize the set of common elements with the first sublist\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining sublists\n    for sublist in nested_lists[1:]:\n        # Update common_elements to include only elements present in both the current common_elements and the current sublist\n        common_elements &= set(sublist)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n    \n    Args:\n    lists (list of lists): A list containing nested lists with elements of any hashable type.\n    \n    Returns:\n    list: A list of elements common to all nested lists, in the order they first appear.\n    \"\"\"\n    # Base case: If the input list is empty, there are no common elements\n    if not lists:\n        return []\n    \n    # Initialize the set of common elements with the first list\n    # Using a set for efficient lookups\n    common_elements = set(lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in lists[1:]:\n        # Update common_elements to include only elements present in both the current list and the previous common elements\n        common_elements &= set(lst)\n        \n        # If no common elements are found, break the loop\n        if not common_elements:\n            break\n    \n    # Reconstruct the list of common elements in the order they first appear in the first list\n    common_ordered = [element for element in lists[0] if element in common_elements]\n    \n    return common_ordered", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in all sublists within a given list of lists.\n    \n    Args:\n        nested_lists (list of lists): A list containing lists of elements.\n        \n    Returns:\n        list: A list of elements common to all sublists. The order of elements is based on their first occurrence in the input lists.\n    \"\"\"\n    # Base case: If the input list is empty, there are no common elements\n    if not nested_lists:\n        return []\n    \n    # Start with the set of the first sublist to initialize common elements\n    common = set(nested_lists[0])\n    \n    # Iterate over the rest of the sublists\n    for sublist in nested_lists[1:]:\n        # Update common by keeping only elements present in both current common and the current sublist\n        common &= set(sublist)\n        \n        # If no common elements are found, break the loop early\n        if not common:\n            break\n    \n    # Convert the set back to a list, preserving the original order of first seen elements\n    result = [element for element in nested_lists[0] if element in common]\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Returns a list of elements common to all nested lists.\n    \n    :param nested_lists: A list containing multiple lists of elements.\n    :return: A list of common elements.\n    \"\"\"\n    # Base case: If the input list is empty, there are no common elements.\n    if not nested_lists:\n        return []\n    \n    # Initialize the set of common elements with the first list.\n    # Using a set for efficient lookups.\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists.\n    for lst in nested_lists[1:]:\n        # Update common_elements to include only elements present in both \n        # the current common_elements set and the current list.\n        common_elements &= set(lst)\n        \n    # Convert the set back to a list and return it.\n    # The conversion is to match the output type with the problem statement.\n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 45.0, "profiled": [{"solution": "def sum_of_proper_divisors(num):\n    \"\"\"Calculates the sum of proper divisors for a given number.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            if num // i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + num // i\n    return sum_divisors\ndef amicable_numbers_sum(n):\n    \"\"\"Sums all amicable numbers from 1 to n.\"\"\"\n    amicable_sum = 0\n    for i in range(1, n+1):\n        # Calculate sum of proper divisors for i\n        sum_i = sum_of_proper_divisors(i)\n        # Check if sum_i is within range, not equal to i, and if i is sum of its proper divisors\n        if i < n and sum_i <= n and sum_i != i and sum_of_proper_divisors(sum_i) == i:\n            # If both are amicable, add both to the sum if they are not the same\n            if i != sum_i:\n                amicable_sum += i + sum_i\n            else:\n                amicable_sum += i  # In case of a perfect pair that's the same\n    return amicable_sum // 2 if amicable_sum % 2 == 0 else amicable_sum  # Ensure each pair is counted once", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n (excluding n).\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + n // i\n    return sum_divisors\ndef is_amicable(a):\n    \"\"\"Checks if a number is amicable.\"\"\"\n    b = sum_of_proper_divisors(a)\n    return sum_of_proper_divisors(b) == a and a != b\ndef amicable_numbers_sum(limit):\n    \"\"\"Sums all amicable numbers from 1 to the specified limit.\"\"\"\n    return sum(a for a in range(1, limit + 1) if is_amicable(a))", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors for a given number.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and a != b and sum_of_proper_divisors(b) == a:\n            # Since amicable numbers come in pairs, add both to the sum if a < b\n            if a < b:\n                amicable_sum += a + b\n            # If a > b, the pair's sum would have been added in a previous iteration\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors for a number.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:  # Check if divisors are different\n                sum_divisors += n // i\n    return sum_divisors\ndef is_amicable(a):\n    \"\"\"Check if a number is amicable.\"\"\"\n    b = sum_of_proper_divisors(a)\n    return sum_of_proper_divisors(b) == a and a != b\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"\n    Calculate the sum of proper divisors for a number n.\n    \n    :param n: The number to calculate the sum of its proper divisors.\n    :return: The sum of proper divisors of n.\n    \"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + n // i\n    return sum_divisors\ndef is_amicable(a, b):\n    \"\"\"\n    Check if two numbers are amicable.\n    \n    :param a: The first number.\n    :param b: The second number.\n    :return: True if a and b are amicable, False otherwise.\n    \"\"\"\n    return sum_of_proper_divisors(a) == b and sum_of_proper_divisors(b) == a and a != b\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to a specified number.\n    \n    :param limit: The upper limit (inclusive) to check for amicable numbers.\n    :return: The sum of all amicable numbers within the specified range.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and is_amicable(a, b):\n            amicable_sum += a + b\n            # Ensure not to count the pair twice if a==b (which is not the case for amicable numbers by definition)\n    return amicable_sum // 2  # Divide by 2 to avoid counting each pair twice", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Returns the sum of proper divisors for n.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Calculates the sum of all amicable numbers from 1 to the specified limit.\n\n    :param limit: The upper limit for checking amicable numbers.\n    :return: Sum of all amicable numbers up to the limit.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and a != b and sum_of_proper_divisors(b) == a:\n            # Check if both a and b are within the limit and are amicable\n            if a < b:  # Add the pair only once\n                amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"\n    Calculates the sum of proper divisors for a given number n.\n    \n    :param n: The input number.\n    :return: Sum of proper divisors of n.\n    \"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + n // i\n    return sum_divisors\ndef is_amicable(a):\n    \"\"\"\n    Checks if a number 'a' is amicable.\n    \n    :param a: The number to check.\n    :return: True if 'a' is amicable, False otherwise.\n    \"\"\"\n    b = sum_of_proper_divisors(a)\n    return a != b and sum_of_proper_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sums all amicable numbers from 1 to the specified limit.\n    \n    :param limit: The upper limit (inclusive).\n    :return: Sum of all amicable numbers up to the limit.\n    \"\"\"\n    return sum(num for num in range(1, limit + 1) if is_amicable(num))", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"\n    Calculate the sum of proper divisors for a number n.\n    :param n: The number to calculate the sum of its proper divisors for.\n    :return: Sum of proper divisors of n.\n    \"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to the specified limit.\n    :param limit: The upper limit (inclusive) for the range to check for amicable numbers.\n    :return: Sum of all amicable numbers within the given range.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and a != b and sum_of_proper_divisors(b) == a:\n            # Check if both numbers are within the limit and are amicable\n            amicable_pair_sum = a + b\n            # Since pairs are counted twice, but we only want unique sums, \n            # we add the sum of the pair if it's not already included\n            if a < b and amicable_sum != amicable_sum + a:  \n                amicable_sum += amicable_pair_sum\n            elif a > b and amicable_sum != amicable_sum + b:\n                amicable_sum += amicable_pair_sum\n    return amicable_sum // 2  # Divide by 2 to avoid double counting of pairs", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors for a given number n.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sums all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and a != b and sum_of_proper_divisors(b) == a:\n            # Check if both numbers are amicable and within the limit, then add them\n            amicable_sum += a + b\n    # Since each pair is counted twice, no need for further adjustments here given the problem's constraints\n    return amicable_sum // 2  # Divide by 2 to avoid counting each pair twice", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"\n    Calculates the sum of proper divisors for a given number.\n    \n    :param n: The input number.\n    :return: Sum of proper divisors (excluding the number itself).\n    \"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i != n:  # Check if divisors are different\n                sum_divisors += i + n // i\n            else:\n                sum_divisors += i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sums all amicable numbers from 1 to a specified limit.\n    \n    :param limit: The upper limit (inclusive) for checking amicable numbers.\n    :return: Sum of all amicable numbers within the given range.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and a != b and sum_of_proper_divisors(b) == a:\n            # Ensure a is less than b to avoid double counting\n            if a < b:\n                amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculates the sum of proper divisors for a given number.\"\"\"\n    sum_div = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:  # Check if divisors are different\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sums all amicable numbers from 1 to the specified limit.\n    \n    An amicable number is a number for which the sum of its proper divisors is equal to another number, \n    and the sum of that other number's proper divisors is equal to the original number.\n    \n    Parameters:\n    limit (int): The upper limit for checking amicable numbers.\n    \n    Returns:\n    int: The sum of all amicable numbers up to the specified limit.\n    \"\"\"\n    amicable_sum = 0\n    for num in range(2, limit + 1):  # Start from 2, as 1 is not considered\n        sum_div = sum_of_divisors(num)\n        if sum_div > 1 and sum_div <= limit:  # Ensure sum_div is within range and not 1\n            sum_div_sum = sum_of_divisors(sum_div)\n            if sum_div_sum == num and sum_div != num:  # Check for amicable pair\n                amicable_sum += num + sum_div\n                # Since we're checking all numbers up to the limit, each pair will be counted twice\n                # except when a number is an amicable pair with itself (which is not the case here, given the problem's nature)\n    return amicable_sum // 2  # Divide by 2 to avoid double counting of pairs", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(num):\n    \"\"\"Calculates the sum of proper divisors for a given number.\"\"\"\n    divisors_sum = 1  # Start with 1 since 1 is a divisor of every number\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            if i * i != num:  # Check if divisors are different\n                divisors_sum += i + num // i\n            else:\n                divisors_sum += i  # If divisors are the same (e.g., sqrt(num))\n    return divisors_sum\ndef amicable_numbers_sum(n):\n    \"\"\"\n    Sums all amicable numbers from 1 to n.\n\n    :param n: The upper limit (inclusive) for checking amicable numbers.\n    :return: Sum of all amicable numbers within the specified range.\n    \"\"\"\n    total_sum = 0\n    amicable_nums = set()  # Use a set to avoid duplicates\n    \n    for i in range(1, n + 1):\n        div_sum = sum_of_proper_divisors(i)\n        if div_sum <= n and div_sum != i:  # Ensure div_sum is within range and not the same as i\n            if sum_of_proper_divisors(div_sum) == i:  # Check for amicable pair\n                pair = tuple(sorted((i, div_sum)))  # Sort to ensure uniqueness in set\n                amicable_nums.add(pair)\n    \n    # Sum all unique amicable numbers found\n    for pair in amicable_nums:\n        total_sum += sum(pair)\n    \n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number n.\"\"\"\n    sum_div = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i * i != n:  # If divisors are different, add both\n                sum_div += n // i\n    return sum_div\ndef is_amicable(a):\n    \"\"\"Checks if a number `a` is amicable.\"\"\"\n    b = sum_of_divisors(a)\n    return sum_of_divisors(b) == a and a != b\ndef amicable_numbers_sum(limit):\n    \"\"\"Sums all amicable numbers from 1 to a specified `limit`.\"\"\"\n    return sum(num for num in range(1, limit+1) if is_amicable(num))", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors for a given number.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:  # To avoid adding the square root twice\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sums all amicable numbers from 1 to the specified limit.\n    \n    :param limit: Upper limit (inclusive) for checking amicable numbers.\n    :return: Sum of all amicable numbers within the range.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and a != b:  # Ensuring a and b are distinct\n            if sum_of_proper_divisors(b) == a:\n                amicable_sum += a + b\n                # Since they come in pairs, add both if they are amicable\n    return amicable_sum // 2  # Divide by 2 to avoid double-counting pairs", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number n.\"\"\"\n    sum_div = 1  # Since 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum_div += i\n            else:\n                sum_div += i + n // i\n    return sum_div\ndef is_amicable(a, b):\n    \"\"\"Check if two numbers are amicable.\"\"\"\n    return sum_of_divisors(a) == b and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to a specified number.\n\n    Args:\n        limit (int): The upper limit for checking amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers up to the limit.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_divisors(a)\n        if a < b <= limit and is_amicable(a, b):\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def proper_divisors_sum(n):\n    \"\"\"Calculate the sum of proper divisors of a number.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:  # Check if divisors are different\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to the specified limit.\n    \n    :param limit: The upper limit for the range of numbers to check.\n    :return: The sum of all amicable numbers within the specified range.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = proper_divisors_sum(a)\n        if b <= limit and proper_divisors_sum(b) == a and a < b:\n            # Check for amicable pair and ensure a < b to avoid double counting\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"\n    Calculates the sum of proper divisors for a given number.\n    \n    :param n: The input number.\n    :return: Sum of proper divisors of n.\n    \"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Calculates the sum of all amicable numbers from 1 to the specified limit.\n    \n    :param limit: Upper limit for checking amicable numbers.\n    :return: Sum of all amicable numbers up to the limit.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and sum_of_proper_divisors(b) == a and a < b:\n            # Check if both numbers are amicable and within the limit, and a < b to avoid counting pairs twice\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                sum_divisors += i\n            else:\n                sum_divisors += i + n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_pairs = set()\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and a != b and sum_of_proper_divisors(b) == a:\n            # Add both numbers of the amicable pair to the set\n            amicable_pairs.update((a, b))\n    return sum(amicable_pairs)", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors for a given number n.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:  # To avoid adding square root twice\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sums all amicable numbers from 1 to a specified limit.\n    \n    An amicable number is a number for which the sum of its proper positive divisors \n    (excluding the number itself) is equal to another number, for which the sum of \n    its proper positive divisors (excluding the number itself) equals the original number.\n\n    Parameters:\n    - limit (int): The upper limit for the range of numbers to check.\n\n    Returns:\n    - int: The sum of all amicable numbers within the specified range.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_proper_divisors(a)\n        if b <= limit and a != b and sum_of_proper_divisors(b) == a:\n            # Ensure the pair (a, b) is only counted once\n            if a < b:\n                amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors for a given number n.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i != n:  # If i is not the square root of n\n                sum_divisors += i + n // i\n            else:\n                sum_divisors += i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to the specified limit.\n\n    A pair of numbers are amicable if the sum of the proper divisors of each\n    is equal to the other number. Proper divisors exclude the number itself.\n\n    :param limit: The upper limit (inclusive) for the range to check.\n    :return: The sum of all amicable numbers within the specified range.\n    \"\"\"\n    amicable_sum = 0\n    for i in range(1, limit + 1):\n        # Check if i has an amicable pair within the limit\n        sum_i = sum_of_proper_divisors(i)\n        if sum_i != i and sum_i <= limit:\n            # Check if the sum of proper divisors of sum_i equals i\n            if sum_of_proper_divisors(sum_i) == i:\n                # Ensure the pair is counted only once\n                if i <= sum_i:\n                    amicable_sum += i + sum_i\n    return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 83.0, "profiled": [{"solution": "def long_words(n, sentence):\n    \"\"\"\n    Identifies words in a sentence that are longer than n characters.\n    \n    Parameters:\n    n (int): Minimum length for a word to be considered \"long\".\n    sentence (str): Input sentence to search for long words in.\n    \n    Returns:\n    list: Words from the sentence that exceed the specified length.\n    \"\"\"\n    # Split the input sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    long_word_list = [word for word in words if len(word) > n]\n    \n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters in a given sentence.\n\n    Args:\n        n (int): Minimum word length.\n        sentence (str): Sentence to search for long words.\n\n    Returns:\n        list: List of words longer than n characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    longer_words = [word for word in words if len(word) > n]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words that are longer than n characters from a given list of words in a sentence.\n\n    Args:\n        n (int): The minimum length of words to be found.\n        sentence (str): The input sentence to search for long words.\n\n    Returns:\n        list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    longer_than_n = [word for word in words if len(word) > n]\n    \n    return longer_than_n", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Finds and returns words that are longer than n characters from a given sentence.\n\n    Parameters:\n    - min_length (int): The minimum length of words to be included in the result.\n    - sentence (str): The input sentence from which words are extracted.\n\n    Returns:\n    - list: A list of words longer than `min_length` characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than min_length\n    return [word for word in words if len(word) > min_length]", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Finds and returns words longer than min_length from a given sentence.\n\n    Args:\n        min_length (int): The minimum length for a word to be included.\n        sentence (str): The input sentence from which to extract words.\n\n    Returns:\n        list: A list of words longer than min_length.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than min_length\n    longer_words = [word for word in words if len(word) > min_length]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Finds words longer than a specified minimum length from a given sentence.\n\n    Parameters:\n    - `min_length` (int): The minimum length of words to be included.\n    - `sentence` (str): The input sentence from which words are extracted.\n\n    Returns:\n    - list: A list of words that are longer than `min_length` characters.\n    \"\"\"\n    # Split the input sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than min_length\n    longer_words = [word for word in words if len(word) > min_length]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, text):\n    \"\"\"\n    Finds words longer than a specified minimum length in a given text.\n\n    Parameters:\n    - min_length (int): The minimum length of words to be found.\n    - text (str): The text from which to extract long words.\n\n    Returns:\n    - list: A list of words from the text that are longer than min_length characters.\n    \"\"\"\n    # Split the input text into a list of words\n    words = text.split()\n    \n    # Use a list comprehension to filter words longer than min_length\n    long_words_list = [word for word in words if len(word) > min_length]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds and returns words longer than n characters from a given sentence.\n\n    Args:\n        n (int): The minimum length of words to be included in the output.\n        sentence (str): The input string containing multiple words separated by spaces.\n\n    Returns:\n        list: A list of words from the input sentence that are longer than n characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    longer_words = [word for word in words if len(word) > n]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters in a given sentence.\n\n    Parameters:\n    n (int): The minimum length of words to be found.\n    sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    list: A list of words from the sentence that are longer than n characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    longer_words = [word for word in words if len(word) > n]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters in a given sentence.\n\n    Args:\n        n (int): The minimum length of words to be found.\n        sentence (str): The input sentence to search for words.\n\n    Returns:\n        list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    longer_words = [word for word in words if len(word) > n]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the input sentence that are longer than n characters.\n\n    Parameters:\n    - n (int): The minimum length of words to be included in the output.\n    - sentence (str): The input sentence from which to extract words.\n\n    Returns:\n    - list[str]: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Finds all words longer than `min_length` characters in a given `sentence`.\n\n    Args:\n        min_length (int): The minimum length a word must have to be included.\n        sentence (str): The input sentence to search for words.\n\n    Returns:\n        list: A list of words longer than `min_length` characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than min_length\n    longer_words = [word for word in words if len(word) > min_length]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Finds words longer than min_length characters in a given sentence.\n\n    Args:\n        - min_length (int): Minimum length of words to be found.\n        - sentence (str): Input sentence to search for words.\n\n    Returns:\n        - list: A list of words longer than min_length characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than min_length\n    longer_words = [word for word in words if len(word) > min_length]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Finds words longer than min_length in a given sentence.\n\n    Args:\n        min_length (int): Minimum length of words to be included in the output.\n        sentence (str): Input sentence from which words are extracted.\n\n    Returns:\n        list: A list of words longer than min_length.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words longer than min_length\n    longer_words = [word for word in words if len(word) > min_length]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Returns a list of words from the input sentence that are longer than min_length.\n\n    Args:\n        min_length (int): Minimum length for a word to be included in the output.\n        sentence (str): Input string containing space-separated words.\n\n    Returns:\n        list: Words longer than min_length characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than min_length\n    longer_words = [word for word in words if len(word) > min_length]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words that are longer than n characters from a given list of words.\n\n    Args:\n        n (int): The minimum length of words to be found.\n        sentence (str): The input sentence from which to extract words.\n\n    Returns:\n        list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Use a list comprehension to filter words longer than n characters\n    longer_words = [word for word in words if len(word) > n]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Finds words longer than a specified minimum length in a given sentence.\n\n    Args:\n        min_length (int): The minimum length for a word to be included.\n        sentence (str): The input sentence from which to extract words.\n\n    Returns:\n        list: A list of words longer than `min_length` characters.\n    \"\"\"\n    # Split the sentence into individual words\n    words = sentence.split()\n    \n    # Filter words based on their length\n    longer_words = [word for word in words if len(word) > min_length]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Finds words longer than a specified minimum length in a given sentence.\n\n    Parameters:\n    - min_length (int): The minimum length for a word to be considered.\n    - sentence (str): The input sentence to search for long words.\n\n    Returns:\n    - list: A list of words from the sentence that are longer than min_length.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words based on the minimum length\n    long_words_list = [word for word in words if len(word) > min_length]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, text):\n    \"\"\"\n    Returns a list of words from the input text that are longer than min_length characters.\n\n    Args:\n        min_length (int): The minimum length a word must have to be included in the output.\n        text (str): The input text from which to extract words.\n\n    Returns:\n        list[str]: A list of words longer than min_length characters.\n    \"\"\"\n    # Split the input text into words (assuming spaces separate words)\n    words = text.split()\n    \n    # Filter words based on the minimum length requirement\n    longer_words = [word for word in words if len(word) > min_length]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(min_length, sentence):\n    \"\"\"\n    Returns a list of words longer than min_length from the given sentence.\n\n    Parameters:\n    - min_length (int): Minimum length for a word to be included in the result.\n    - sentence (str): The input sentence to find long words from.\n\n    Returns:\n    - list: A list of words that are longer than min_length.\n    \"\"\"\n    # Split the input sentence into a list of words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than min_length\n    return [word for word in words if len(word) > min_length]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/130": {"dps": 91.99551569506727, "dps_norm": 82.5, "pass@1": 65.0, "profiled": [{"solution": "def max_occurrences(input_list):\n    \"\"\"\n    Returns the item with the maximum frequency in the input list.\n\n    :param input_list: A list containing elements of any hashable type.\n    :return: The item that appears most frequently in the list.\n    \"\"\"\n    if not input_list:  # Handle empty list\n        return None\n\n    # Create a dictionary to store frequency of each item\n    frequency_dict = {}\n    for item in input_list:\n        frequency_dict[item] = frequency_dict.get(item, 0) + 1\n\n    # Find the item with the maximum frequency\n    max_item = max(frequency_dict, key=frequency_dict.get)\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(input_list):\n    \"\"\"\n    Returns the item with the maximum frequency in the input list.\n    \n    If multiple items share the maximum frequency, the function returns the one \n    that appears first in the list.\n\n    Parameters:\n    input_list (list): A list of items (can be of any hashable type).\n\n    Returns:\n    The item with the maximum frequency.\n    \"\"\"\n    if not input_list:  # Edge case: Empty list\n        return None\n    \n    frequency_dict = {}  # Dictionary to store item frequencies\n    max_item = input_list[0]  # Initialize with the first item\n    max_count = 0  # Initialize max frequency counter\n    \n    # Count occurrences of each item\n    for item in input_list:\n        frequency_dict[item] = frequency_dict.get(item, 0) + 1\n    \n    # Find item with maximum frequency\n    for item, count in frequency_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item\ninput_list = [2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2]", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Returns the item with the maximum frequency in the given list.\n    \n    In case of a tie, the item that appears first in the list is returned.\n    \n    Parameters:\n    lst (list): The input list to find the maximum frequency item in.\n    \n    Returns:\n    The item with the maximum frequency.\n    \"\"\"\n    if not lst:  # Edge case: Empty list\n        return None\n    \n    freq_counter = Counter(lst)\n    max_freq = max(freq_counter.values())\n    \n    # Find the first item with max frequency (in case of ties, returns the first occurrence)\n    for item, freq in freq_counter.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n    \n    Parameters:\n    input_list (list): A list of items (can be of any hashable type)\n    \n    Returns:\n    The item with the maximum frequency in the list\n    \"\"\"\n    # Ensure the input is a list\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if the list is empty\n    if len(input_list) == 0:\n        return None  # or raise ValueError(\"List is empty\"), depending on your preference\n    \n    # Count the frequency of each item using Counter\n    frequency_count = Counter(input_list)\n    \n    # Find the item with the maximum frequency\n    # The max function with key argument is used, where key is the dict's value (frequency)\n    max_item = max(frequency_count, key=frequency_count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Args:\n        input_list (list): The input list containing elements of any hashable type.\n\n    Returns:\n        The item with the maximum frequency. If there are multiple items with the same \n        maximum frequency, one of them is returned (the first one encountered).\n    \"\"\"\n    # Count the occurrences of each item in the list\n    frequency_count = Counter(input_list)\n    \n    # Find the maximum frequency\n    max_frequency = max(frequency_count.values())\n    \n    # Find the first item with the maximum frequency\n    max_item = next(item for item, frequency in frequency_count.items() if frequency == max_frequency)\n    \n    return max_item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    This function finds the item with the maximum frequency in a given list.\n\n    Parameters:\n    - lst (list): The input list that can contain any hashable types.\n\n    Returns:\n    - The item with the maximum frequency in the list. If there are multiple items with the same maximum frequency, \n      it returns one of them. The choice depends on the implementation of the Counter class from the collections module.\n    \"\"\"\n    if not lst:  # Check if the list is empty\n        return None  # or raise an exception, depending on your requirements\n    \n    # Use Counter to count the frequency of each item\n    freq_counter = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(freq_counter, key=freq_counter.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    input_list (list): The input list containing elements of any hashable type.\n    \n    Returns:\n    The item with the highest frequency. If multiple items have the same highest frequency, \n    one of them is returned (the first encountered in the list in case of Python 3.7+).\n    \"\"\"\n    # Count the frequency of each item\n    freq_count = Counter(input_list)\n    \n    # Find the maximum frequency\n    max_freq = max(freq_count.values())\n    \n    # Find the first item with the maximum frequency (in case of multiple, returns one)\n    max_occurrence_item = next(item for item, freq in freq_count.items() if freq == max_freq)\n    \n    return max_occurrence_item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    input_list (list): The input list to search in.\n    \n    Returns:\n    The item with the maximum frequency. If there are multiple items with the same \n    maximum frequency, returns any one of them.\n    \"\"\"\n    if not input_list:  # Check if list is empty\n        raise ValueError(\"Input list is empty\")\n    \n    # Count occurrences of each item\n    freq_count = Counter(input_list)\n    \n    # Find the item with the maximum frequency\n    max_freq_item = max(freq_count, key=freq_count.get)\n    \n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    In case of multiple items with the same maximum frequency, \n    returns one of them (no guarantee which one due to dictionary's nature in Python).\n\n    Parameters:\n    input_list (list): The input list of items.\n\n    Returns:\n    The item with the maximum frequency in the input list.\n    \"\"\"\n    if not input_list:  # Check if list is empty\n        return None\n    \n    frequency_count = Counter(input_list)\n    max_item = max(frequency_count, key=frequency_count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a list.\n\n    Parameters:\n    - lst (list): The input list containing elements of any hashable type.\n\n    Returns:\n    - The item with the highest frequency. If multiple items share the max frequency, \n      returns the one encountered first in the list.\n    \"\"\"\n    if not lst:  # Edge case: empty list\n        return None\n    \n    # Count occurrences of each item\n    freq_counter = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_freq_item = max(freq_counter, key=freq_counter.get)\n    \n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    input_list (list): The list of items to check.\n    \n    Returns:\n    The item with the highest frequency. If multiple items share the same \n    highest frequency, the function returns one of them.\n    \"\"\"\n    # Count occurrences of each item\n    frequency_count = Counter(input_list)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency_count, key=frequency_count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    This function finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    - lst (list): The input list containing elements of any hashable type.\n    \n    Returns:\n    - The item with the maximum frequency in the list.\n    - If multiple items share the maximum frequency, the function returns one of them.\n    \"\"\"\n    if not lst:  # Edge case: Empty list\n        return None\n    \n    # Create a dictionary to store the frequency of each item\n    frequency_dict = {}\n    \n    # Iterate over the list to count the frequency of each item\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency_dict, key=frequency_dict.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    This function identifies the item with the maximum frequency in a given list.\n    \n    Parameters:\n    - input_list (list): The input list containing elements of any hashable type.\n    \n    Returns:\n    - The item with the maximum frequency. If multiple items have the same maximum frequency,\n      it returns the one encountered first in the list.\n    \"\"\"\n    # Count occurrences of each item in the list\n    frequency_count = Counter(input_list)\n    \n    # Identify the item with the maximum frequency\n    # max() with key argument set to dict.get allows us to find the key (item) with the maximum value (frequency)\n    max_item = max(frequency_count, key=frequency_count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    input_list (list): The list to search for the item with the maximum frequency.\n    \n    Returns:\n    The item with the maximum frequency in the input_list.\n    If there are multiple items with the same maximum frequency, it returns any one of them.\n    \"\"\"\n    if not input_list:  # Check if the list is empty\n        return None\n    \n    # Use Counter to count the frequency of each item\n    freq_counter = Counter(input_list)\n    \n    # Find the item with the maximum frequency\n    max_item = max(freq_counter, key=freq_counter.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    This function finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): The input list containing elements of any hashable type.\n    \n    Returns:\n    The item with the maximum frequency in the list.\n    If there are multiple items with the same maximum frequency, \n    it returns the one that appears first in the list.\n    \"\"\"\n    if not lst:  # Check if list is empty\n        raise ValueError(\"Input list is empty\")\n    \n    # Create a dictionary to store frequency of each item\n    frequency_dict = {}\n    for item in lst:\n        frequency_dict[item] = frequency_dict.get(item, 0) + 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency_dict, key=frequency_dict.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    - `input_list` (list): A list of items (hashable types supported by Counter).\n    \n    Returns:\n    - The item with the maximum frequency in `input_list`.\n    \"\"\"\n    # Count occurrences of each item\n    frequency_counts = Counter(input_list)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency_counts, key=frequency_counts.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    If there are multiple items with the same maximum frequency, \n    the function returns the one that appears first in the list.\n\n    Parameters:\n    lst (list): The input list containing elements of any hashable type.\n\n    Returns:\n    The item with the maximum frequency in the list.\n    \"\"\"\n    # Count occurrences of each item\n    freq_count = Counter(lst)\n    \n    # Find the maximum frequency\n    max_freq = max(freq_count.values())\n    \n    # Find the first item with the maximum frequency (preserving original order)\n    for item, freq in freq_count.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(input_list):\n    \"\"\"\n    This function finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    - input_list (list): A list of items (can be of any hashable type).\n    \n    Returns:\n    - The item with the maximum frequency in the list. If there's a tie, returns any of the most frequent items.\n    \"\"\"\n    if not input_list:  # Check if the list is empty\n        return None\n    \n    # Create a dictionary to store frequency of each item\n    frequency_dict = {}\n    \n    # Populate the frequency dictionary\n    for item in input_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency_dict, key=frequency_dict.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): The input list containing elements of any hashable type.\n    \n    Returns:\n    The item with the maximum frequency in the list. If there are multiple items \n    with the same maximum frequency, it returns the one encountered first in the list.\n    \"\"\"\n    if not lst:  # Edge case: empty list\n        return None\n    \n    # Count the frequency of each item\n    freq_count = Counter(lst)\n    \n    # Find the maximum frequency\n    max_freq = max(freq_count.values())\n    \n    # Return the first item with the maximum frequency\n    for item, freq in freq_count.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(input_list):\n    \"\"\"\n    Returns the item with the maximum frequency in the input list.\n    \n    Parameters:\n    - input_list (list): The input list of items.\n    \n    Returns:\n    - item (any): The item with the highest frequency in the list.\n    \"\"\"\n    # Check if list is empty\n    if not input_list:\n        raise ValueError(\"Input list is empty\")\n    \n    # Create a dictionary to store item frequencies\n    freq_dict = {}\n    \n    # Populate the frequency dictionary\n    for item in input_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(freq_dict, key=freq_dict.get)\n    \n    return max_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 6.0, "profiled": []}, "Mbpp/140": {"dps": 83.69565217391305, "dps_norm": 82.5, "pass@1": 84.0, "profiled": [{"solution": "def extract_singly(nested_iterable):\n    \"\"\"\n    Flattens a nested iterable of iterables into a single set of numbers.\n    \n    :param nested_iterable: A list or tuple containing lists, tuples, or other iterables of numbers.\n    :return: A set of unique numbers from the nested iterable.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each item in the nested iterable\n    for item in nested_iterable:\n        # Assuming each item is an iterable (like list, tuple, etc.), iterate over its elements\n        for num in item:\n            # Check if the element is a number (int or float) before adding to the set\n            if isinstance(num, (int, float)):\n                unique_numbers.add(num)\n    \n    return unique_numbers", "matching_cluster_idx": 2}, {"solution": "def extract_singly(tuples_list):\n    \"\"\"\n    This function takes a list of tuples as input, \n    extracts all unique numbers from these tuples, \n    and returns them as a set.\n\n    :param tuples_list: A list containing tuples of numbers.\n    :return: A set of unique numbers.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple in the input list\n    for tup in tuples_list:\n        # Add all numbers from the current tuple to the set\n        # Since sets automatically eliminate duplicates, \n        # only unique numbers will be stored\n        unique_numbers.update(tup)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Extracts unique numbers from a nested list (or tuple) structure into a set.\n\n    Args:\n        nested_list (list): A list containing lists or tuples of numbers.\n\n    Returns:\n        set: A set of unique numbers found in the nested structure.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each sublist (or tuple) in the main list\n    for sublist in nested_list:\n        # Extend the set with numbers from the current sublist\n        # Since sets automatically eliminate duplicates, only unique numbers are kept\n        unique_numbers.update(sublist)\n    \n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    This function takes a list of tuples (or lists) as input, \n    flattens it, and returns a set of unique numbers.\n\n    Parameters:\n    - list_of_tuples: A list containing tuples or lists of numbers.\n\n    Returns:\n    - A set of unique numbers.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple (or list) in the input list\n    for item in list_of_tuples:\n        # Extend the set with numbers from the current tuple (or list)\n        # The set data structure automatically handles uniqueness\n        unique_numbers.update(item)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    This function takes a list of tuples as input, \n    flattens it, and returns a set of unique numbers.\n    \n    Args:\n        list_of_tuples (list): A list containing tuples of numbers.\n    \n    Returns:\n        set: A set of unique numbers from the input list of tuples.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple in the list of tuples\n    for tup in list_of_tuples:\n        # Extend the set with the numbers from the current tuple\n        # Since sets automatically eliminate duplicates, \n        # we directly add all elements to it\n        unique_numbers.update(tup)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(lists_of_numbers):\n    \"\"\"\n    This function takes a list of lists (or tuples, as they are iterable) of numbers\n    and returns a set containing all unique numbers found across all inner lists.\n\n    :param lists_of_numbers: A list containing lists or tuples of numbers\n    :return: A set of unique numbers\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each inner list (or tuple) in the main list\n    for inner_list in lists_of_numbers:\n        # Update the set with numbers from the current inner list\n        # Since sets automatically eliminate duplicates, this ensures uniqueness\n        unique_numbers.update(inner_list)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_iterable):\n    \"\"\"\n    Extracts all unique numbers from a list of iterables (like lists, tuples, etc.) into a single set.\n\n    Args:\n        nested_iterable (iterable of iterables): A list containing iterables (lists, tuples, etc.) of numbers.\n\n    Returns:\n        set: A set of unique numbers found in all nested iterables.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each iterable in the nested_iterable\n    for iterable in nested_iterable:\n        # Extend the set with numbers from the current iterable\n        # Since sets automatically eliminate duplicates, this ensures uniqueness\n        unique_numbers.update(iterable)\n    \n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_iterable):\n    \"\"\"\n    Flattens a list of iterables (tuples, lists, etc.) into a set of unique numbers.\n\n    Args:\n        nested_iterable (list): A list containing iterables of integers.\n\n    Returns:\n        set: A set of unique integers from the nested iterables.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each iterable in the nested list\n    for iterable in nested_iterable:\n        # Extend the set with numbers from the current iterable\n        # Since sets automatically eliminate duplicates, uniqueness is maintained\n        unique_numbers.update(iterable)\n    \n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list_of_tuples):\n    \"\"\"\n    This function takes a list of tuples as input, \n    extracts all unique numbers into a set, and returns it.\n\n    Parameters:\n    - nested_list_of_tuples (list): A list containing tuples of numbers.\n\n    Returns:\n    - set: A set of unique numbers found in the input tuples.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple in the list\n    for tup in nested_list_of_tuples:\n        # Update the set with numbers from the current tuple\n        # Since sets automatically eliminate duplicates, \n        # only unique numbers will be stored\n        unique_numbers.update(tup)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        nested_list (list): A list containing lists or tuples of numbers.\n\n    Returns:\n        set: A set of unique numbers from the nested list.\n    \"\"\"\n    # Use a set comprehension to ensure uniqueness of numbers\n    # and a nested loop (implicitly through the * operator) to flatten the list\n    return set(num for inner in nested_list for num in inner)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_iterable):\n    \"\"\"\n    Flatten a list of lists (or tuples) into a set of unique numbers.\n\n    Args:\n        nested_iterable (list or tuple): A list/tuple containing lists/tuples of numbers.\n\n    Returns:\n        set: A set of unique numbers from the nested iterable.\n    \"\"\"\n    return set(num for inner in nested_iterable for num in inner)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lists_of_numbers):\n    \"\"\"\n    This function takes a list of tuples (or lists) of numbers and returns a set of unique numbers.\n\n    :param lists_of_numbers: A list containing tuples (or lists) of numbers.\n    :return: A set of unique numbers found in the input.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple (or list) in the input list\n    for numbers in lists_of_numbers:\n        # Update the set with the numbers from the current tuple (or list)\n        # Since sets automatically eliminate duplicates, this ensures uniqueness\n        unique_numbers.update(numbers)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(lists_of_numbers):\n    \"\"\"\n    This function takes a list of tuples (or lists) of numbers and returns a set containing all unique numbers.\n\n    Args:\n        lists_of_numbers (list): A list containing tuples or lists of integers.\n\n    Returns:\n        set: A set of unique integers.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple/list in the input list\n    for numbers in lists_of_numbers:\n        # Add all numbers from the current tuple/list to the set\n        # Since sets automatically eliminate duplicates, this ensures uniqueness\n        unique_numbers.update(numbers)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_iterable):\n    \"\"\"\n    Flattens a nested iterable of numbers into a single set of numbers.\n\n    Args:\n        nested_iterable (iterable of iterables): A list or tuple containing lists, tuples, or other iterables of numbers.\n\n    Returns:\n        set: A set of unique numbers from the nested iterable.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each item in the nested iterable\n    for item in nested_iterable:\n        # Assuming each item is an iterable (like list, tuple, etc.), extend our set with its elements\n        # Since sets automatically handle uniqueness, duplicates are ignored\n        unique_numbers.update(item)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(tuples_list):\n    \"\"\"\n    This function takes a list of tuples as input, \n    flattens it into a single collection of numbers, \n    and returns them as a set to ensure uniqueness.\n\n    Args:\n        tuples_list (list): A list containing tuples of numbers.\n\n    Returns:\n        set: A set of unique numbers.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Extend the set with numbers from the current tuple\n        unique_numbers.update(tup)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    This function takes a list of tuples (or lists) as input, \n    flattens it, and returns a set of unique numbers.\n    \n    Parameters:\n    - nested_list (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    - set: A set of unique numbers from the input list.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each sublist (or tuple) in the nested list\n    for sublist in nested_list:\n        # Extend the set with numbers from the current sublist\n        # The set data structure automatically handles uniqueness\n        unique_numbers.update(sublist)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(tuples_list):\n    \"\"\"\n    Extract unique numbers from a list of tuples into a set.\n\n    Args:\n    tuples_list (list): A list containing tuples of numbers.\n\n    Returns:\n    set: A set of unique numbers found in the input tuples.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Update the set with numbers from the current tuple\n        unique_numbers.update(tup)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    This function takes a list of tuples as input, \n    flattens it into a single collection, \n    and returns the unique elements as a set.\n\n    :param list_of_tuples: A list containing tuples of numbers\n    :return: A set of unique numbers\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple in the list\n    for tup in list_of_tuples:\n        # Extend the set with the numbers from the current tuple\n        # Since sets automatically handle uniqueness, no duplicates will be stored\n        unique_numbers.update(tup)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    Extracts unique numbers from a list of tuples into a set.\n\n    Args:\n        list_of_tuples (list): A list containing tuples of numbers.\n\n    Returns:\n        set: A set of unique numbers found in the tuples.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple in the list\n    for tup in list_of_tuples:\n        # Update the set with the numbers from the current tuple\n        # Since sets automatically eliminate duplicates, this ensures uniqueness\n        unique_numbers.update(tup)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    \"\"\"\n    This function takes a list of tuples as input, \n    flattens it, and returns a set of unique numbers.\n\n    :param list_of_tuples: A list containing tuples of numbers\n    :return: A set of unique numbers\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate over each tuple in the list of tuples\n    for tup in list_of_tuples:\n        # Extend the set with the numbers from the current tuple\n        # Since sets automatically eliminate duplicates, uniqueness is maintained\n        unique_numbers.update(tup)\n    \n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 6}]}, "Mbpp/141": {"dps": 98.4920634920635, "dps_norm": 52.5, "pass@1": 64.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: List of elements to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    # Find the size of the array\n    n = len(arr)\n    \n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(n, 0, -1):\n        \n        # Find index of the maximum element in arr[0..curr_size]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != curr_size-1:\n            \n            # First flip 'max_index'\n            if max_index != 0:\n                arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n                \n            # Now move the maximum number to end by reversing current array\n            arr = arr[:curr_size][::-1] + arr[curr_size:]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n\n    :param arr: List of integers to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    cur_size = len(arr)\n    \n    # Start from the complete array and one by one reduce current size by one\n    while cur_size > 1:\n        # Find index of the maximum element in arr[0..cur_size]\n        max_index = arr.index(max(arr[0:cur_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != cur_size-1:\n            # First flip 'max_index'\n            if max_index != 0:\n                arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n            \n            # Now move the maximum number to end by reversing current array\n            arr = arr[:cur_size][::-1] + arr[cur_size:]\n        \n        # Reduce current size by one\n        cur_size -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(input_list):\n    \"\"\"\n    Sorts a list of elements in ascending order.\n\n    Args:\n    - input_list (list): A list containing elements (assumed to be comparable).\n\n    Returns:\n    - list: A new list with the elements sorted in ascending order.\n    \"\"\"\n    return sorted(input_list)", "matching_cluster_idx": 7}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    :param arr: The input list of integers\n    :return: The sorted list in ascending order\n    \"\"\"\n    n = len(arr)\n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(n, 0, -1):\n        # Find index of the maximum element in arr[0..curr_size]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != curr_size-1:\n            # First flip 'max_index'\n            arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n            # Now move the maximum number to end by reversing current array\n            arr = arr[:curr_size][::-1] + arr[curr_size:]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: The list of elements to be sorted\n    :return: A new list with the elements sorted in ascending order\n    \"\"\"\n    arr = arr[:]  # Create a copy to avoid modifying the original list\n    cur_size = len(arr)\n    \n    while cur_size > 1:\n        # Find the index of the maximum element in arr[0..cur_size]\n        mi = arr.index(max(arr[0:cur_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if mi != cur_size-1:\n            # First flip 'mi'\n            arr = arr[:mi+1][::-1] + arr[mi+1:]\n            # Now move the maximum number to end by reversing current array\n            arr = arr[:cur_size][::-1] + arr[cur_size:]\n        \n        # Reduce cur_size by one for next iteration\n        cur_size -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: The input list of integers\n    :return: The sorted list in ascending order\n    \"\"\"\n    # Initialize array length\n    n = len(arr)\n    \n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(n, 0, -1):\n        \n        # Find index of the maximum element in arr[0..curr_size]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != curr_size-1:\n            \n            # First flip 'max_index'\n            if max_index != 0:\n                # Flip from the beginning to max_index\n                arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n                \n            # Now move the maximum number to end by reversing current array\n            arr = arr[:curr_size][::-1] + arr[curr_size:]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: The list of elements to be sorted.\n    :return: A new sorted list in ascending order.\n    \"\"\"\n    arr = arr[:]  # Create a copy to avoid modifying the original list\n    n = len(arr)\n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(n, 0, -1):\n        # Find index of the maximum element in arr[0..curr_size]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != curr_size-1:\n            # First flip 'max_index'\n            if max_index != 0:\n                arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n            # Now move the maximum number to end by reversing current array\n            arr = arr[:curr_size][::-1] + arr[curr_size:]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: The input list to be sorted\n    :return: A new sorted list in ascending order\n    \"\"\"\n    arr = arr[:]  # Create a copy to avoid modifying the original list\n    n = len(arr)\n    while n > 1:\n        # Find the maximum element in the unsorted part of the list\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip it to the end\n        if max_idx != n - 1:\n            # First, flip the maximum element to the beginning\n            if max_idx != 0:\n                arr[:max_idx + 1] = reversed(arr[:max_idx + 1])\n            # Then, flip it to the end of the unsorted part\n            arr[:n] = reversed(arr[:n])\n        n -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Sorts a list of elements in ascending order.\n\n    This function utilizes the Pancake Sort algorithm, which is a variation of the selection sort.\n    It's notably inefficient on large lists (O(n^3) in the worst case) but can be educational for\n    its unique approach of flipping sections of the list.\n\n    :param lst: List of elements to be sorted (elements must be comparable).\n    :return: A new list with elements sorted in ascending order.\n    \"\"\"\n    # Create a copy to maintain the original list unchanged\n    lst_copy = lst[:]\n    n = len(lst_copy)\n\n    # Iterate over the list from end to start\n    for size in range(n, 0, -1):\n        # Find index of the maximum element in lst[0..size]\n        max_index = lst_copy.index(max(lst_copy[0:size]))\n        \n        # Move the maximum element to end of current unsorted array if it's not already at the end\n        if max_index != size-1:\n            # If max element is not at the beginning, flip it to the beginning first\n            if max_index != 0:\n                # Flip from the beginning to the max element\n                lst_copy[:max_index+1] = reversed(lst_copy[:max_index+1])\n            # Now, flip from the beginning to the unsorted array's end to move max to the end\n            lst_copy[:size] = reversed(lst_copy[:size])\n    \n    return lst_copy", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    :param lst: List of elements to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    # Initialize the size of the unsorted portion of the list\n    n = len(lst)\n    \n    # Start from the complete list and one by one reduce current size by one\n    for size in range(n, 0, -1):\n        # Find index of the maximum element in lst[0..size]\n        max_index = lst.index(max(lst[0:size]))\n        \n        # Move the maximum element to end of current unsorted array if it's not already at the end\n        if max_index != size-1:\n            # First flip 'max_index'\n            if max_index != 0:\n                lst[:max_index+1] = reversed(lst[:max_index+1])\n            # Now move the maximum number to end by reversing current array\n            lst[:size] = reversed(lst[:size])\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: A new list with the elements sorted in ascending order.\n    \"\"\"\n    arr = arr[:]  # Create a copy to avoid modifying the original list\n    n = len(arr)\n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(n, 0, -1):\n        # Find index of the maximum element in arr[0..curr_size]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != curr_size-1:\n            # First flip 'max_index'\n            arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n            # Now move the maximum number to end by reversing current array\n            arr = arr[:curr_size][::-1] + arr[curr_size:]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: List of elements to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    cur_size = len(arr)\n    while cur_size > 1:\n        # Find index of the maximum element in arr[0..cur_size]\n        mi = arr.index(max(arr[0:cur_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if mi != cur_size-1:\n            # First flip 'mi'\n            arr = arr[:mi+1][::-1] + arr[mi+1:]\n            \n            # Now move the maximum number to end by reversing current array\n            arr = arr[:cur_size][::-1] + arr[cur_size:]\n        \n        # Reduce cur_size by one as last element is now in place\n        cur_size -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: List of elements to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    cur_size = len(arr)\n    \n    # Start from the complete array and one by one reduce current size by one\n    while cur_size > 1:\n        # Find index of the maximum element in arr[0..cur_size]\n        mi = arr.index(max(arr[0:cur_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if mi != cur_size-1:\n            # First flip 'mi'\n            arr = arr[:mi+1][::-1] + arr[mi+1:]\n            # Now move the maximum number to end by reversing current array\n            arr = arr[:cur_size][::-1] + arr[cur_size:]\n        \n        # Reduce current size by one\n        cur_size -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order.\n\n    :param arr: List of elements to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    cur_size = len(arr)\n    while cur_size > 1:\n        # Find index of the maximum element in arr[0..cur_size-1]\n        mi = arr.index(max(arr[0:cur_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if mi != cur_size-1:\n            # First flip 'mi'\n            if mi != 0:\n                arr = arr[:mi+1][::-1] + arr[mi+1:]\n            # Now move the maximum number to end by reversing current array\n            arr = arr[:cur_size][::-1] + arr[cur_size:]\n        \n        # Reduce cur_size by one for next iteration\n        cur_size -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts an array of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: The list of elements to be sorted\n    :return: The sorted list\n    \"\"\"\n    cur_size = len(arr)\n    \n    # Start from the complete array and one by one reduce current size by one\n    while cur_size > 1:\n        # Find index of the maximum element in arr[0..cur_size]\n        mi = arr.index(max(arr[0:cur_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if mi != cur_size-1:\n            # First flip 'mi'\n            if mi != 0:\n                # Flip from 0 to 'mi'\n                arr = arr[:mi+1][::-1] + arr[mi+1:]\n            # Now move the maximum number to end by reversing current array\n            arr = arr[:cur_size][::-1] + arr[cur_size:]\n        \n        # Reduce cur_size by one for next iteration\n        cur_size -= 1\n        \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: A new sorted list in ascending order.\n    \"\"\"\n    arr = arr[:]  # Create a copy to avoid modifying the original list\n    n = len(arr)\n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(n, 0, -1):\n        # Find index of the maximum element in arr[0..curr_size]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != curr_size-1:\n            # First flip 'max_index'\n            arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n            # Now move the maximum number to end by reversing current array\n            arr = arr[:curr_size][::-1] + arr[curr_size:]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Sorts a list of elements in ascending order.\n\n    :param lst: List of elements to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    cur_size = len(lst)\n    while cur_size > 1:\n        # Find index of the maximum element in lst[0..cur_size]\n        mi = lst.index(max(lst[0:cur_size]))\n        \n        # Move the maximum element to end of current unsorted array if it's not already at the end\n        if mi != cur_size-1:\n            # First flip 'mi'\n            if mi != 0:\n                lst = lst[:mi+1][::-1] + lst[mi+1:]\n            # Now move the maximum number to end by reversing current array\n            lst = lst[:cur_size][::-1] + lst[cur_size:]\n        cur_size -= 1\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: The list of elements to be sorted.\n    :return: The sorted list.\n    \"\"\"\n    # Initialize array length\n    n = len(arr)\n    \n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(n, 0, -1):\n        \n        # Find index of the maximum element in arr[0..curr_size]\n        max_index = arr.index(max(arr[0:curr_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != curr_size-1:\n            \n            # First flip 'max_index'\n            if max_index != 0:\n                # Reverse from 0 to max_index\n                arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n            \n            # Now move the maximum number to end by reversing current array\n            arr = arr[:curr_size][::-1] + arr[curr_size:]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: List of elements to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    # Initialize the size of the unsorted portion of the array\n    curr_size = len(arr)\n    \n    # Continue iterating until the entire array is sorted\n    while curr_size > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        max_index = arr.index(max(arr[:curr_size]))\n        \n        # If the maximum element is not at the end of the unsorted portion, flip it to the end\n        if max_index != curr_size - 1:\n            # If the maximum element is not at the beginning, first flip it to the beginning\n            if max_index != 0:\n                # Flip from the beginning to the maximum element\n                arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            \n            # Flip from the beginning to the end of the unsorted portion to move the max to the end\n            arr[:curr_size] = reversed(arr[:curr_size])\n        \n        # Reduce the size of the unsorted portion for the next iteration\n        curr_size -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements in ascending order using the Pancake Sort algorithm.\n\n    :param arr: List of integers to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    cur_size = len(arr)\n    \n    # Start from the complete array and one by one reduce current size by one\n    while cur_size > 1:\n        # Find index of the maximum element in arr[0..cur_size]\n        mi = arr.index(max(arr[0:cur_size]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if mi != cur_size-1:\n            # First flip 'mi'\n            if mi != 0:\n                arr = arr[:mi+1][::-1] + arr[mi+1:]\n            \n            # Now move the maximum number to end by reversing current array\n            arr = arr[:cur_size][::-1] + arr[cur_size:]\n        \n        # Reduce cur_size by one for next iteration\n        cur_size -= 1\n    \n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 78.71999999999998, "dps_norm": 66.25, "pass@1": 88.0, "profiled": [{"solution": "def find_even_pair(nums):\n    \"\"\"\n    This function calculates the number of pairs of integers in a list that XOR to an even number.\n    \n    The XOR of two integers is even if both integers are even or both are odd.\n    Thus, the problem simplifies to counting the number of pairs where both elements have the same parity.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The number of pairs of integers that XOR to an even number.\n    \"\"\"\n    # Separate the numbers into two lists based on their parity\n    evens = [num for num in nums if num % 2 == 0]\n    odds = [num for num in nums if num % 2 != 0]\n    \n    # Calculate the number of pairs for evens and odds separately\n    # The formula to calculate the number of pairs in a set of n elements is n*(n-1)//2\n    even_pairs = len(evens) * (len(evens) - 1) // 2\n    odd_pairs = len(odds) * (len(odds) - 1) // 2\n    \n    # Return the total number of pairs that xor to an even number\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    :param numbers: List of integers\n    :return: Number of pairs that XOR to an even number\n    \"\"\"\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # XOR of two numbers is even if both numbers are even or both are odd\n            if (numbers[i] % 2 == 0 and numbers[j] % 2 == 0) or (numbers[i] % 2 != 0 and numbers[j] % 2 != 0):\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    Args:\n    - nums (list): A list of integers.\n    \n    Returns:\n    - int: The number of pairs of integers that XOR to an even number.\n    \"\"\"\n    # Initialize count for even and odd numbers, since XOR of two even or two odd numbers is even\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs: each even number can pair with every other even number, and each odd with every odd\n    # The formula for combinations is n*(n-1)//2, but since we're counting pairs across two groups (evens and odds),\n    # we calculate for each group separately and sum them up.\n    even_pairs = even_count * (even_count - 1) // 2 if even_count > 1 else 0\n    odd_pairs = odd_count * (odd_count - 1) // 2 if odd_count > 1 else 0\n    \n    # Return the total number of pairs that XOR to an even number\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    A pair of integers (a, b) xor to an even number if and only if both a and b have the same parity (either both odd or both even),\n    since odd ^ odd = even and even ^ even = even.\n\n    :param nums: A list of integers\n    :return: The number of pairs of integers that xor to an even number\n    \"\"\"\n\n    # Initialize counters for odd and even numbers\n    odd_count = 0\n    even_count = 0\n\n    # Count the occurrences of odd and even numbers\n    for num in nums:\n        if num % 2 == 0:  # If the number is even\n            even_count += 1\n        else:  # If the number is odd\n            odd_count += 1\n\n    # Calculate the number of pairs that xor to an even number\n    # This is the sum of the number of ways to choose 2 from the odd numbers and the number of ways to choose 2 from the even numbers\n    # Using the combination formula C(n, 2) = n * (n - 1) / 2\n    even_pair_count = (odd_count * (odd_count - 1) // 2) + (even_count * (even_count - 1) // 2)\n\n    return even_pair_count", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    A pair of integers (a, b) satisfies the condition if (a ^ b) % 2 == 0.\n    This happens for pairs where both numbers are either both even or both odd.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The number of pairs of integers in the list that xor to an even number.\n    \"\"\"\n    # Separate the list into even and odd numbers\n    evens = [num for num in nums if num % 2 == 0]\n    odds = [num for num in nums if num % 2 != 0]\n    \n    # Calculate the number of pairs that can be formed from even and odd numbers separately\n    # The formula for combinations (n choose 2) is n*(n-1)//2\n    even_pairs = len(evens) * (len(evens) - 1) // 2 if len(evens) > 1 else 0\n    odd_pairs = len(odds) * (len(odds) - 1) // 2 if len(odds) > 1 else 0\n    \n    # The total number of pairs that xor to an even number is the sum of even and odd pairs\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    :param nums: A list of integers.\n    :return: The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    # For each unique pair in the list\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # Check if the XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    :param nums: List of integers\n    :return: Number of pairs that XOR to an even number\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # XOR of two numbers is even if both numbers are even or both are odd\n            if (nums[i] % 2 == 0 and nums[j] % 2 == 0) or (nums[i] % 2 != 0 and nums[j] % 2 != 0):\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The number of pairs of integers that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Check if the xor of the pair is even (i.e., the result is divisible by 2)\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Since (even ^ even) and (odd ^ odd) always result in even, \n    and (even ^ odd) always results in odd, we can simplify this \n    to counting the number of pairs of same parity (both even or both odd).\n    \n    Parameters:\n    - nums: A list of integers.\n    \n    Returns:\n    - An integer representing the number of pairs of integers in the list \n      that xor to an even number.\n    \"\"\"\n    # Initialize counters for even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate the number of pairs of the same parity\n    # The formula to calculate the number of pairs in a set of n elements is n*(n-1)//2\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    # Return the total number of pairs that xor to an even number\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    :param numbers: A list of integers.\n    :return: The number of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # A pair XORs to an even number if both are either both even or both odd\n            if (numbers[i] % 2 == 0 and numbers[j] % 2 == 0) or (numbers[i] % 2 != 0 and numbers[j] % 2 != 0):\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    Since XOR of two integers results in an even number if both integers are either both even or both odd,\n    this function counts all possible pairs of integers in the list that meet this criterion.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The number of pairs of integers that XOR to an even number.\n    \"\"\"\n    # Separate numbers into even and odd lists\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    odd_numbers = [num for num in numbers if num % 2 != 0]\n\n    # Calculate the number of pairs of even numbers and odd numbers separately\n    # The formula for combinations (n choose k) is n! / [k!(n-k)!], but since we need pairs (k=2),\n    # this simplifies to n*(n-1)//2 for each category\n    even_pairs = len(even_numbers) * (len(even_numbers) - 1) // 2\n    odd_pairs = len(odd_numbers) * (len(odd_numbers) - 1) // 2\n\n    # The total number of pairs that XOR to an even number is the sum of even and odd pairs\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    :param numbers: A list of integers.\n    :return: An integer representing the count of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    # Generate all possible pairs of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Check if the XOR of the current pair results in an even number\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    :param nums: A list of integers.\n    :return: The number of pairs whose XOR is even.\n    \"\"\"\n    # Initialize counters for even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    # Count the occurrence of even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The XOR of two numbers is even if both are even or both are odd.\n    # Calculate the number of pairs for even and odd numbers separately.\n    even_pairs = (even_count * (even_count - 1)) // 2 if even_count > 1 else 0\n    odd_pairs = (odd_count * (odd_count - 1)) // 2 if odd_count > 1 else 0\n    \n    # Return the total number of pairs whose XOR is even\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    A number is even if its least significant bit is 0. \n    The XOR operation (^) yields 1 for each bit position where the bits of the two operands are different.\n    Therefore, for the result of `a ^ b` to be even, `a` and `b` must have the same least significant bit (both 0 or both 1).\n    \n    :param nums: A list of integers.\n    :return: The number of pairs of integers in the list that xor to an even number.\n    \"\"\"\n\n    # Separate numbers into two lists based on their least significant bit\n    even_nums = [num for num in nums if num % 2 == 0]  # Numbers ending in 0\n    odd_nums = [num for num in nums if num % 2 != 0]   # Numbers ending in 1\n\n    # Calculate the number of pairs that can be formed within each group (since XOR of two even or two odd numbers is even)\n    # The formula for combinations (n choose 2) is n*(n-1)//2\n    import math\n    even_pairs = math.comb(len(even_nums), 2) if len(even_nums) > 1 else 0\n    odd_pairs = math.comb(len(odd_nums), 2) if len(odd_nums) > 1 else 0\n\n    # Return the total number of pairs that xor to an even number\n    return even_pairs + odd_pairs", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The number of pairs whose XOR result is even.\n    \"\"\"\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # XOR of two numbers is even if both are even or both are odd\n            if (numbers[i] % 2 == 0 and numbers[j] % 2 == 0) or (numbers[i] % 2 != 0 and numbers[j] % 2 != 0):\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n    - numbers (list): A list of integers.\n\n    Returns:\n    - int: The number of pairs of integers that xor to an even number.\n    \"\"\"\n    count = 0\n    # For each pair of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Check if the xor of the pair is even (i.e., result is divisible by 2)\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers: list[int]) -> int:\n    \"\"\"\n    Counts the number of pairs in `numbers` where `a ^ b` is even.\n    \n    Since `a ^ b` is even if both `a` and `b` are even or both are odd,\n    we can simply count the number of even and odd integers separately\n    and calculate the sum of pairs for each parity group.\n    \n    :param numbers: A list of integers\n    :return: The number of pairs where XOR result is even\n    \"\"\"\n    # Initialize counters for even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in numbers:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate the number of pairs for each parity (even-even, odd-odd)\n    # The formula for combinations is nC2 = n*(n-1)//2, where n is the count of a group\n    even_pairs = even_count * (even_count - 1) // 2 if even_count > 1 else 0\n    odd_pairs = odd_count * (odd_count - 1) // 2 if odd_count > 1 else 0\n    \n    # Return the total number of pairs with an even XOR result\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    - nums (list): A list of integers.\n    \n    Returns:\n    - int: The number of pairs of integers that xor to an even number.\n    \"\"\"\n    even_count = sum(1 for num in nums if num % 2 == 0)\n    odd_count = len(nums) - even_count\n    \n    # Since XOR of two even or two odd numbers is even, we calculate pairs for both cases\n    even_pairs = even_count * (even_count - 1) // 2  # Combination formula C(n, 2) = n*(n-1)/2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    This function calculates the number of pairs of integers in the input list 'nums' \n    that result in an even number when XOR (^) operation is applied.\n\n    Args:\n    - nums (list): A list of integers.\n\n    Returns:\n    - int: The count of pairs that XOR to an even number.\n    \"\"\"\n    even_count = sum(1 for num in nums if num % 2 == 0)  # Count of even numbers\n    odd_count = len(nums) - even_count  # Count of odd numbers\n\n    # Since XOR of two even or two odd numbers is even, we calculate pairs as follows:\n    # - For even numbers: even_count * (even_count - 1) // 2 (combinations without repetition)\n    # - For odd numbers: odd_count * (odd_count - 1) // 2 (combinations without repetition)\n    even_pairs = even_count * (even_count - 1) // 2 if even_count > 1 else 0\n    odd_pairs = odd_count * (odd_count - 1) // 2 if odd_count > 1 else 0\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    Args:\n        numbers (list): A list of integers.\n    \n    Returns:\n        int: The count of integer pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    # Generate all possible pairs in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Check if the XOR of the pair is even\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/226": {"dps": 79.6124031007752, "dps_norm": 47.142857142857146, "pass@1": 79.0, "profiled": [{"solution": "def odd_values_string(s):\n    \"\"\"\n    This function takes a string as input and returns a new string \n    containing only the characters at even index positions from the original string.\n\n    :param s: Input string\n    :return: String with characters at even index positions\n    \"\"\"\n    return ''.join([char for idx, char in enumerate(s) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    This function takes a string as input and returns a new string containing only characters at even index positions.\n    \n    :param input_str: The input string from which characters at odd indexes will be removed.\n    :return: A string with characters from the even indexes of the input string.\n    \"\"\"\n    # Use Python's slicing feature to get characters at even indexes (0::2 means start at the beginning, \n    # go to the end, and step by 2, effectively skipping odd indexes)\n    return input_str[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    This function takes an input string, iterates over it, and returns a new string \n    containing only the characters at even index positions (0-indexed, meaning the \n    first character is considered to be at an even index).\n\n    :param input_str: The input string from which characters at odd indexes will be removed.\n    :return: A new string with characters only from even index positions.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result_str = \"\"\n\n    # Iterate over the input string with enumerate to access both index and value\n    for index, char in enumerate(input_str):\n        # Check if the index is even (using the modulus operator)\n        if index % 2 == 0:\n            # If the index is even, append the character to the result string\n            result_str += char\n\n    # Return the resulting string\n    return result_str", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Returns a string containing characters from the input string that are at even index positions.\n    \n    :param input_str: The input string from which characters at odd indexes are to be removed.\n    :return: A new string with characters only from even index positions.\n    \"\"\"\n    return ''.join([char for idx, char in enumerate(input_str) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Returns a new string containing only characters at even index positions from the input string.\n    \n    Parameters:\n    input_str (str): The input string from which characters at odd indices will be removed.\n    \n    Returns:\n    str: A new string with characters only from even indices of the input string.\n    \"\"\"\n    return input_str[::2]  # Python's slice notation to select characters at even indices (start:stop:step)", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string: str) -> str:\n    \"\"\"\n    Returns a new string containing only characters at even index positions from the input string.\n\n    :param input_string: The source string to filter.\n    :return: A string with characters from even index positions.\n    \"\"\"\n    # Use list comprehension to iterate over the input string with enumerate (index, value) pairs\n    # Select characters where the index is even (i.e., index % 2 == 0)\n    # Then, join the selected characters back into a string\n    return ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Returns a new string containing characters at even index values of `input_str`.\n\n    :param input_str: The original input string.\n    :return: A string with characters from even index positions.\n    \"\"\"\n    return ''.join([char for idx, char in enumerate(input_str) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Returns a new string containing characters at even index positions from the input string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters from even index positions.\n    \"\"\"\n    return ''.join([char for idx, char in enumerate(s) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Returns a new string with characters at even index positions from the input string.\n    \n    Parameters:\n    - input_str (str): The input string from which characters at odd indexes are to be removed.\n    \n    Returns:\n    - str: A new string containing only characters at even index positions.\n    \"\"\"\n    return input_str[::2]  # Python's slice notation to get every character at even index (0-based indexing)", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Removes characters at odd index positions from the input string.\n    \n    Parameters:\n    input_str (str): The input string from which characters at odd indexes are removed.\n    \n    Returns:\n    str: A new string containing only characters from even index positions of the input string.\n    \"\"\"\n    return input_str[::2]  # Python slice notation to get every character at an even index (0-based indexing)", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Returns a new string containing characters at even index values from the input string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: A new string with characters from the input string that have even index values.\n    \"\"\"\n    return ''.join([char for idx, char in enumerate(s) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Removes characters at odd index values from a given string.\n    \n    Parameters:\n    input_str (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indexes removed.\n    \"\"\"\n    return input_str[::2]  # Python's slice notation to get chars at even indexes (0-based, step 2)", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Removes characters at odd index values from a given string.\n    \n    Parameters:\n    input_str (str): The input string.\n    \n    Returns:\n    str: A new string with characters from even index positions of input_str.\n    \"\"\"\n    # Use list slicing to get characters at even indexes (0::2 means start at 0, go to end, step by 2)\n    # Then join these characters back into a string\n    return ''.join([char for idx, char in enumerate(input_str) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s: str) -> str:\n    \"\"\"\n    Removes characters at odd index positions from a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd index positions removed.\n    \"\"\"\n    # Use list comprehension to filter out characters at odd indexes (0-based indexing)\n    # Python's slicing with a step can also achieve this but for clarity, we explicitly check indexes\n    return ''.join([char for idx, char in enumerate(s) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Returns a new string containing only characters from the input string \n    that are at even index positions (0-based indexing).\n\n    :param input_str: The input string from which characters at odd indices will be removed.\n    :return: A new string with characters only from even index positions of the input string.\n    \"\"\"\n    return ''.join([char for idx, char in enumerate(input_str) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Returns a new string containing characters at even index positions from the input string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: A string with characters from even index positions of the input string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Returns a new string containing characters at even index values from the input string.\n\n    Parameters:\n    - input_string (str): The input string from which characters at odd indexes are to be removed.\n\n    Returns:\n    - str: A new string with characters only from even index positions.\n    \"\"\"\n    return input_string[::2]  # Python's slice notation to select every other character starting from index 0", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Returns a new string with characters from the input string at even index positions.\n    \n    :param input_str: The input string to process.\n    :return: A new string with characters at even index positions from the input string.\n    \"\"\"\n    return input_str[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string: str) -> str:\n    \"\"\"\n    This function takes an input string and returns a new string containing only the characters\n    at even index positions from the original string.\n\n    :param input_string: The input string to process.\n    :return: A new string with characters from even index positions.\n    \"\"\"\n    # Use list comprehension to filter characters at even index positions (0-based indexing)\n    # and then join them into a single string.\n    return ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    Returns a new string containing characters from the input string\n    that are at even index positions (0-based indexing).\n\n    :param input_str: The input string from which characters at odd indexes are to be removed.\n    :return: A new string with characters only from even indexes.\n    \"\"\"\n    return ''.join([char for idx, char in enumerate(input_str) if idx % 2 == 0])", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 59.04761904761905, "dps_norm": 92.5, "pass@1": 86.0, "profiled": [{"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with a specified replacement character.\n\n    Args:\n        input_string (str): The original string that may contain blank spaces.\n        replacement_char (str): A single character to replace each blank space with.\n\n    Returns:\n        str: The input string with all blank spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified replacement character.\n\n    Args:\n    - input_string (str): The original string that may contain blank spaces.\n    - replacement_char (str): A single character to replace each blank space with.\n\n    Returns:\n    - str: The input string with all blank spaces replaced by the replacement character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified replacement character.\n\n    Args:\n        - input_string (str): The original string to modify.\n        - replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n        - str: The modified string with blank spaces replaced.\n    \"\"\"\n    if not isinstance(input_string, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"Both input_string and replacement_char must be strings.\")\n    if len(replacement_char) != 1:\n        raise ValueError(\"replacement_char must be a single character.\")\n\n    # Use the replace method of the string class to substitute all occurrences of a space with the replacement_char\n    modified_string = input_string.replace(' ', replacement_char)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified replacement character.\n\n    Args:\n        input_string (str): The original string that may contain blank spaces.\n        replacement_char (str): A single character to replace each blank space with.\n\n    Returns:\n        str: The input string with all blank spaces replaced by the replacement character.\n    \"\"\"\n    if not isinstance(input_string, str) or not isinstance(replacement_char, str) or len(replacement_char) != 1:\n        raise ValueError(\"Invalid input types. Both inputs must be strings and the replacement must be a single character.\")\n    \n    # Use the built-in str.replace() method to replace all occurrences of a space (' ') with the replacement character\n    modified_string = input_string.replace(' ', replacement_char)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified replacement character.\n\n    Args:\n        input_string (str): The original string.\n        replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in input_str with replacement_char.\n    \n    Args:\n        input_str (str): Original string to modify.\n        replacement_char (str): Character to replace blank spaces with.\n    \n    Returns:\n        str: Modified string with blank spaces replaced.\n    \"\"\"\n    # Check if inputs are of correct type\n    if not isinstance(input_str, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"Both input_str and replacement_char must be strings.\")\n    \n    # Validate replacement_char is a single character\n    if len(replacement_char) != 1:\n        raise ValueError(\"replacement_char must be a single character.\")\n    \n    # Replace all blank spaces with the replacement character\n    modified_str = input_str.replace(\" \", replacement_char)\n    \n    return modified_str", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input_string with replacement_char.\n    \n    Args:\n        input_string (str): Original string to modify.\n        replacement_char (str): Character to replace blank spaces with.\n    \n    Returns:\n        str: Modified string with blank spaces replaced.\n    \"\"\"\n    # Check if input is of correct type\n    if not isinstance(input_string, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"Both input_string and replacement_char must be strings.\")\n    \n    # Ensure replacement_char is a single character\n    if len(replacement_char) != 1:\n        raise ValueError(\"replacement_char must be a single character.\")\n    \n    # Replace all blank spaces with the replacement character\n    modified_string = input_string.replace(\" \", replacement_char)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_str, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in input_str with replacement_char.\n    \n    Args:\n        input_str (str): Original string to modify.\n        replacement_char (str): Character to replace blank spaces with.\n    \n    Returns:\n        str: Modified string with blank spaces replaced.\n    \"\"\"\n    if not isinstance(input_str, str):\n        raise TypeError(\"input_str must be a string.\")\n    if not isinstance(replacement_char, str) or len(replacement_char) != 1:\n        raise ValueError(\"replacement_char must be a single character.\")\n    \n    return input_str.replace(' ', replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in `input_string` with `replacement_char`.\n\n    Args:\n        input_string (str): The original string that may contain blank spaces.\n        replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input_string with replacement_char.\n\n    Args:\n        input_string (str): The original string that may contain blank spaces.\n        replacement_char (str): A single character to replace blank spaces with.\n\n    Returns:\n        str: The input_string with all blank spaces replaced.\n    \"\"\"\n    # Check if input_string is indeed a string and replacement_char is a single character\n    if not isinstance(input_string, str) or not isinstance(replacement_char, str) or len(replacement_char) != 1:\n        raise ValueError(\"Invalid input types. input_string must be a string and replacement_char must be a single character.\")\n\n    # Use the replace() method of the string class to replace all occurrences of ' ' (space) with replacement_char\n    modified_string = input_string.replace(' ', replacement_char)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in `input_string` with `replacement_char`.\n    \n    Args:\n        input_string (str): The original string.\n        replacement_char (str): Character to replace blank spaces with.\n    \n    Returns:\n        str: Modified string with blank spaces replaced.\n    \"\"\"\n    # Check if input_string is indeed a string\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    # Check if replacement_char is a single character\n    if not isinstance(replacement_char, str) or len(replacement_char) != 1:\n        raise ValueError(\"Replacement must be a single character.\")\n    \n    # Use the replace method to substitute all spaces with the replacement character\n    modified_string = input_string.replace(\" \", replacement_char)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string with the replacement character.\n\n    Args:\n    - input_string (str): The original string that may contain blank spaces.\n    - replacement_char (str): A single character to replace blank spaces with.\n\n    Returns:\n    - str: The modified string with all blank spaces replaced.\n    \"\"\"\n    # Check if the input is a string and the replacement is a single character\n    if not isinstance(input_string, str) or not isinstance(replacement_char, str) or len(replacement_char) != 1:\n        raise TypeError(\"Input must be a string and replacement must be a single character.\")\n    \n    # Use the replace method of the string class to substitute all occurrences of a space with the replacement character\n    modified_string = input_string.replace(' ', replacement_char)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in `input_string` with `replacement_char`.\n    \n    Args:\n    - input_string (str): The original string to modify.\n    - replacement_char (str): A single character to replace blank spaces with.\n    \n    Returns:\n    - str: The modified string with blank spaces replaced.\n    \"\"\"\n    # Check if the input is a string and replacement_char is a single character\n    if not isinstance(input_string, str) or not isinstance(replacement_char, str) or len(replacement_char) != 1:\n        raise ValueError(\"Invalid input type. Input must be a string and replacement must be a single character.\")\n    \n    # Use the replace() method to swap all occurrences of a space with the replacement character\n    modified_string = input_string.replace(' ', replacement_char)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in a string with a specified character.\n\n    Args:\n        input_string (str): Original string, potentially with blank spaces.\n        replacement_char (str): Character to use for replacement.\n\n    Returns:\n        str: Modified string with all blank spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified replacement character.\n\n    Args:\n        input_string (str): The original string that may contain blank spaces.\n        replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input_string with the specified replacement_char.\n\n    Args:\n        input_string (str): The original string that may contain blank spaces.\n        replacement_char (str): A single character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with all blank spaces replaced.\n    \"\"\"\n    # Check if input_string is indeed a string and replacement_char is a single character\n    if not isinstance(input_string, str) or not isinstance(replacement_char, str) or len(replacement_char) != 1:\n        raise ValueError(\"Invalid input type. input_string must be a string and replacement_char must be a single character.\")\n    \n    # Use the replace method of the string class to substitute all occurrences of a space with the replacement_char\n    modified_string = input_string.replace(' ', replacement_char)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in a given string with a specified character.\n\n    Args:\n        input_string (str): The original string that may contain blank spaces.\n        replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with all blank spaces replaced.\n    \"\"\"\n    return input_string.replace(\" \", replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_str, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in `input_str` with `replacement_char`.\n    \n    Args:\n        input_str (str): The original string.\n        replacement_char (str): Character to replace spaces with.\n    \n    Returns:\n        str: Modified string with spaces replaced.\n    \"\"\"\n    return input_str.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in `input_string` with `replacement_char`.\n\n    Args:\n        - `input_string` (str): The original string to modify.\n        - `replacement_char` (str): A single character to replace blank spaces with.\n\n    Returns:\n        - `str`: The modified string with blank spaces replaced.\n    \"\"\"\n    if not isinstance(input_string, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"Both input_string and replacement_char must be strings.\")\n    if len(replacement_char) != 1:\n        raise ValueError(\"replacement_char must be a single character.\")\n\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input_string with the replacement_char.\n\n    Args:\n        input_string (str): The original string that may contain blank spaces.\n        replacement_char (str): A single character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with all blank spaces replaced.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"input_string must be of type 'str'\")\n    if not isinstance(replacement_char, str) or len(replacement_char) != 1:\n        raise TypeError(\"replacement_char must be a single character of type 'str'\")\n\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 6}]}, "Mbpp/239": {"dps": 61.55172413793103, "dps_norm": 68.5, "pass@1": 32.0, "profiled": [{"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculates the number of sequences of length n, where each element is >= 2 * previous element and <= m.\n\n    :param m: Upper limit for sequence elements\n    :param n: Length of the sequences\n    :return: Number of possible sequences\n    \"\"\"\n    def helper(last_elem: int, remaining_length: int, memo: dict) -> int:\n        # Base case: if the remaining length is 0, it means we've formed a valid sequence\n        if remaining_length == 0:\n            return 1\n        \n        # Memoization key\n        key = (last_elem, remaining_length)\n        if key in memo:\n            return memo[key]\n        \n        total = 0\n        # The next element must be at least twice the last element but not more than m\n        for next_elem in range(max(1, last_elem * 2), m + 1):\n            total += helper(next_elem, remaining_length - 1, memo)\n        \n        # Store the result for this subproblem\n        memo[key] = total\n        return total\n    \n    # Initialize memoization dictionary and start with any possible first element (from 1 to m)\n    memo = {}\n    total_sequences = 0\n    for first_elem in range(1, m + 1):\n        total_sequences += helper(first_elem, n - 1, memo)\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculates the number of possible sequences of length n, where each element is a positive integer\n    greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n        m (int): The upper limit for each element in the sequence.\n        n (int): The length of the sequence.\n\n    Returns:\n        int: The total number of possible sequences under the given conditions.\n    \"\"\"\n    # Initialize a list to store the count of sequences for each possible last element\n    # We start with m+1 spaces because list indices start at 0, and we need to cover all numbers up to m\n    sequences_count = [0] * (m + 1)\n    \n    # For a sequence of length 1, the number of possible sequences ending with each number i is 1\n    # (since the sequence is just [i] itself), but only if i is at least 1 and at most m\n    for i in range(1, m + 1):\n        sequences_count[i] = 1\n    \n    # For each subsequent length up to n\n    for _ in range(2, n + 1):\n        # Initialize a new list to store the updated counts for this length\n        new_sequences_count = [0] * (m + 1)\n        \n        # For each possible last element in the sequence\n        for j in range(1, m + 1):\n            # The number of sequences ending with j is the sum of sequences ending with any number i\n            # that is at most j//2 (since j must be >= 2*i), because j can follow any of those\n            new_sequences_count[j] = sum(sequences_count[i] for i in range(1, (j // 2) + 1))\n        \n        # Update the counts for the next iteration\n        sequences_count = new_sequences_count\n    \n    # The total number of sequences of length n is the sum of counts for all possible last elements\n    return sum(sequences_count)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is \n    a positive integer >= twice the previous element and <= m.\n\n    Args:\n        m (int): The upper limit for each element in the sequence.\n        n (int): The length of the sequence.\n\n    Returns:\n        int: The total number of possible sequences.\n\n    Example:\n        >>> get_total_number_of_sequences(10, 4)\n        4\n    \"\"\"\n    def backtrack(current_num, current_sequence, m, n):\n        # Base case: sequence length is achieved\n        if len(current_sequence) == n:\n            return 1\n        \n        # Initialize count for this recursive call\n        count = 0\n        \n        # Determine the range for the next number in the sequence\n        next_min = current_num * 2 if current_num else 1\n        next_max = min(m, current_num * 2 + (m // (n - len(current_sequence)))) if len(current_sequence) < n - 1 else m\n        \n        # Iterate over possible next numbers and recurse\n        for next_num in range(next_min, next_max + 1):\n            count += backtrack(next_num, current_sequence + [next_num], m, n)\n        \n        return count\n\n    # Start with an empty sequence and any initial number from 1 to m\n    total_count = sum(backtrack(i, [i], m, n) for i in range(1, m + 1))\n    \n    return total_count", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculate the number of possible sequences of length n, \n    where each element is a positive integer >= twice the previous element and <= m.\n\n    Args:\n    m (int): The upper limit for each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n\n    # Base case for dynamic programming: if n is 1, \n    # the number of sequences is the number of options for the single element\n    if n == 1:\n        return m\n\n    # Initialize count for sequences of length n\n    total_count = 0\n\n    # For each possible last element in the sequence (from 1 to m)\n    for last_element in range(1, m + 1):\n        # The maximum first element can be last_element // 2\n        max_first_element = last_element // 2\n        \n        # If n is 2, directly count; otherwise, recurse with n-1 and max_first_element\n        if n == 2:\n            total_count += max_first_element\n        else:\n            # Recurse with reduced problem size (n-1) and accumulate results\n            total_count += get_total_number_of_sequences(max_first_element, n - 1)\n\n    return total_count", "matching_cluster_idx": 4}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculates the number of possible sequences of length n, \n    where each element is a positive integer >= twice the previous element and <= m.\n\n    Args:\n    m (int): The upper limit for each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n\n    # Initialize a list to store the count of sequences for each possible last element\n    # We start with m+1 because list indices should match the element value for simplicity\n    seq_counts = [0] * (m + 1)\n    \n    # For a sequence of length 1, the number of sequences ending with each number is 1\n    for i in range(1, m + 1):\n        seq_counts[i] = 1\n\n    # For each subsequent length up to n\n    for _ in range(2, n + 1):\n        # Initialize a new list to store the updated counts for this length\n        new_seq_counts = [0] * (m + 1)\n        \n        # For each possible last element in the sequence\n        for j in range(1, m + 1):\n            # The count of sequences ending with j is the sum of counts of sequences \n            # ending with a number k where k <= j/2 (since j >= 2*k)\n            for k in range(1, j // 2 + 1):\n                new_seq_counts[j] += seq_counts[k]\n        \n        # Update the counts for the next iteration\n        seq_counts = new_seq_counts\n\n    # The total number of sequences of length n is the sum of counts for all possible last elements\n    return sum(seq_counts[1:])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculate the number of possible sequences of length n, \n    where each element is a positive integer, \n    greater than or equal to twice the previous element, and less than or equal to m.\n\n    Args:\n        m (int): The upper limit for each element in the sequence.\n        n (int): The length of the sequence.\n\n    Returns:\n        int: The total number of possible sequences.\n    \"\"\"\n\n    # Initialize a list to store the number of sequences for each possible last element\n    # The length is m+1 to accommodate all possible values from 1 to m\n    sequences = [0] * (m + 1)\n    \n    # For sequences of length 1, the number of sequences for each number i is 1\n    # Since a single number is always a valid sequence\n    for i in range(1, m + 1):\n        sequences[i] = 1\n\n    # For each sequence length from 2 to n\n    for _ in range(2, n + 1):\n        # Initialize a temporary list to store the updated counts for this length\n        temp = [0] * (m + 1)\n        \n        # For each possible last element in the sequence\n        for j in range(1, m + 1):\n            # The number of sequences ending with j is the sum of sequences of the previous length\n            # where the last element is less than or equal to j/2 (since j must be >= 2*prev)\n            temp[j] = sum(sequences[k] for k in range(1, (j // 2) + 1))\n        \n        # Update the sequences list for the next iteration\n        sequences = temp\n\n    # The total number of sequences of length n is the sum of sequences for all possible last elements\n    return sum(sequences)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is a \n    positive integer >= twice the previous element and <= m.\n\n    Args:\n    m (int): The upper limit for sequence elements.\n    n (int): The length of the sequences.\n\n    Returns:\n    int: The total number of possible sequences under the given constraints.\n    \"\"\"\n    # Initialize a list to store the count of sequences for each possible last element\n    # We start with m+1 because list indices will represent values from 1 to m\n    sequences_count = [0] * (m + 1)\n    \n    # Base case for sequences of length 1: all numbers from 1 to m are valid sequences\n    for i in range(1, m + 1):\n        sequences_count[i] = 1\n    \n    # For sequences of length 2 to n\n    for _ in range(2, n + 1):\n        # Initialize a temporary list to hold counts for the current length\n        temp_count = [0] * (m + 1)\n        \n        # For each possible last element in the sequence\n        for j in range(1, m + 1):\n            # The first element of the sequence can be at least 1 and at most j//2\n            for k in range(1, j // 2 + 1):\n                # Accumulate counts from all valid previous elements\n                temp_count[j] += sequences_count[k]\n        \n        # Update counts for the next sequence length\n        sequences_count = temp_count[:]\n    \n    # The total count is the sum of counts for all possible last elements\n    return sum(sequences_count)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of possible sequences of length n, where each element is a \n    positive integer greater than or equal to twice the previous element but less than \n    or equal to m.\n\n    Args:\n    m (int): The upper limit for each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n    def recursive_count(current, prev_element, length):\n        # Base case: if the desired length is reached, count this sequence\n        if length == 0:\n            return 1\n        \n        count = 0\n        # For each possible next element (from twice the previous to m)\n        for next_element in range(max(2 * prev_element, 1), m + 1):\n            # Recursively add the counts for sequences with this next element\n            count += recursive_count(current + [next_element], next_element, length - 1)\n        \n        return count\n\n    # Initialize with a dummy previous element (0) and the full length\n    return recursive_count([], 0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculates the number of possible sequences of length n, where each element is a positive \n    integer greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n    m (int): The upper limit for each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n\n    def recursive_sequence_count(last_num: int, remaining_length: int) -> int:\n        # Base case: if the remaining length is 0, we've successfully formed a sequence\n        if remaining_length == 0:\n            return 1\n        \n        # Initialize count for current branch\n        count = 0\n        \n        # Determine the range for the next number in the sequence\n        for next_num in range(max(1, last_num * 2), m + 1):\n            # Recursively add counts for all valid next numbers\n            count += recursive_sequence_count(next_num, remaining_length - 1)\n        \n        return count\n\n    # Special handling for n=1 since the initial logic starts from 1 but our sequence can start from any number up to m\n    if n == 1:\n        return m\n    \n    # Start recursion with the first element being any number from 1 to m, and the remaining length being n-1\n    total_count = 0\n    for start_num in range(1, m + 1):\n        total_count += recursive_sequence_count(start_num, n - 1)\n    \n    return total_count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculate the number of possible sequences of length n where each element is a positive integer >= twice the previous element and <= m.\n\n    Args:\n    m (int): The upper limit for each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n    # Initialize a list to store the number of sequences for each possible last element from 1 to m\n    dp = [0] * (m + 1)\n    \n    # For sequences of length 1, all numbers from 1 to m are valid\n    for i in range(1, m + 1):\n        dp[i] = 1\n    \n    # Compute for each possible length from 2 to n\n    for _ in range(2, n + 1):\n        # Temp variable to store the new dp state for this length\n        new_dp = [0] * (m + 1)\n        \n        # For each possible last element in the sequence\n        for j in range(1, m + 1):\n            # The first element of the sequence can be at most j // 2\n            for k in range(1, (j // 2) + 1):\n                new_dp[j] += dp[k]\n        \n        # Update dp for the next iteration\n        dp = new_dp[:]\n    \n    # The answer is the sum of all sequences that end with any number from 1 to m for the given length n\n    return sum(dp)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the total number of sequences of length `n` under given constraints.\n\n    Parameters:\n    - `m` (int): The upper limit for each element in the sequence.\n    - `n` (int): The length of the sequence.\n\n    Returns:\n    - int: Total number of possible sequences.\n    \"\"\"\n    def recurse(length_left, last_num):\n        # Base case: if length is filled up, count this sequence\n        if length_left == 0:\n            return 1\n        \n        count = 0\n        # Start from twice the last number, up to `m`\n        for num in range(max(1, 2 * last_num), m + 1):\n            # Recurse with one less length and new last number\n            count += recurse(length_left - 1, num)\n        \n        return count\n    \n    # Start with the full length and a 'last number' of 0 (since first number can be any)\n    total_sequences = recurse(n, 0)\n    return total_sequences", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    This function calculates the number of possible sequences of length n,\n    where each element is a positive integer, greater than or equal to twice the previous element, and less than or equal to m.\n\n    Args:\n        m (int): The upper bound for the sequence elements.\n        n (int): The length of the sequence.\n\n    Returns:\n        int: The total number of possible sequences.\n    \"\"\"\n\n    # Initialize a list to store the count of sequences ending at each number up to m\n    seq_count = [0] * (m + 1)\n    \n    # There's only one way to make a sequence of length 1 for each number up to m\n    for i in range(1, m + 1):\n        seq_count[i] = 1\n    \n    # For sequences of length 2 to n\n    for _ in range(2, n + 1):\n        new_seq_count = [0] * (m + 1)\n        \n        # For each possible last element in the sequence\n        for last in range(1, m + 1):\n            # The second last element can be any number from 1 to last // 2\n            for second_last in range(1, (last // 2) + 1):\n                new_seq_count[last] += seq_count[second_last]\n        \n        seq_count = new_seq_count\n    \n    # The total number of sequences is the sum of sequences ending at each number\n    return sum(seq_count)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculates the number of sequences of length `n` where each element is \n    a positive integer >= twice the previous element but <= `m`.\n    \n    :param m: The upper limit for each sequence element\n    :param n: The length of the sequences\n    :return: The total number of possible sequences\n    \"\"\"\n    # Base case: if n is 1, all numbers from 1 to m are valid sequences\n    if n == 1:\n        return m\n    \n    # Initialize count for sequences\n    total_count = 0\n    \n    # For each possible first element in the sequence (from 1 to m)\n    for i in range(1, m + 1):\n        # Recursively calculate the number of sequences starting with 'i'\n        # considering the next element must be at least twice 'i'\n        total_count += count_sequences_from(m, n - 1, i * 2)\n    \n    return total_count\ndef count_sequences_from(m: int, remaining_length: int, min_value: int) -> int:\n    \"\"\"\n    Recursive helper function to calculate the number of sequences of \n    `remaining_length` where each element is <= `m` and >= `min_value`.\n    \n    :param m: Upper limit for sequence elements\n    :param remaining_length: Length of the remaining sequence to fill\n    :param min_value: Minimum value for the next sequence element\n    :return: Number of possible sequences under given constraints\n    \"\"\"\n    if remaining_length == 1:\n        # Base case: count how many numbers from min_value to m (inclusive) for the last element\n        return max(0, m - min_value + 1)  # Ensure count is not negative if min_value > m\n    \n    count = 0\n    # Explore all possible next elements, ensuring they are <= m and >= min_value\n    for next_value in range(min_value, m + 1):\n        # Recursively count sequences with the new remaining length and updated min_value\n        count += count_sequences_from(m, remaining_length - 1, next_value * 2)\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of possible sequences of length `n` where each element is \n    a positive integer >= twice the previous element and <= `m`.\n    \n    Args:\n    - m (int): The upper limit for elements in the sequence.\n    - n (int): The length of the sequence.\n    \n    Returns:\n    - int: The total number of possible sequences under the given constraints.\n    \"\"\"\n    \n    # Initialize a list to store the number of sequences for each possible last element\n    # from 1 to `m`, for a sequence of length 1. This serves as our base case.\n    # For length 1, each number from 1 to `m` can be a sequence on its own.\n    sequences = [1] * m\n    \n    # For each additional position in the sequence (from length 2 to `n`)\n    for _ in range(1, n):\n        # Initialize a new list to store the updated counts for this new length\n        new_sequences = [0] * m\n        \n        # For each possible last element in the new sequences\n        for j in range(1, m + 1):\n            # The number of new sequences ending with `j` is the sum of sequences \n            # ending with any number `i` where `i * 2 <= j` (since `j` must be \n            # at least twice `i`), considering sequences one position shorter.\n            new_sequences[j - 1] = sum(sequences[i - 1] for i in range(1, j // 2 + 1))\n        \n        # Update our counts for the next iteration\n        sequences = new_sequences\n    \n    # The total number of sequences of length `n` is the sum of sequences ending with any number\n    return sum(sequences)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is a \n    positive integer, greater than or equal to twice the previous element, and less \n    than or equal to m.\n\n    Args:\n    m (int): The upper limit for sequence elements.\n    n (int): The length of the sequences.\n\n    Returns:\n    int: The total number of possible sequences under the given constraints.\n    \"\"\"\n    def backtrack(current_sequence, last_element, remaining_length):\n        # Base case: if the sequence is complete\n        if remaining_length == 0:\n            return 1\n        # Initialize count for this branch\n        count = 0\n        # Determine the range for the next element\n        next_min = last_element * 2\n        next_max = m\n        # Iterate over possible next elements\n        for next_element in range(max(1, next_min), next_max + 1):\n            # Recursively build the rest of the sequence\n            count += backtrack(current_sequence + [next_element], next_element, remaining_length - 1)\n        return count\n\n    # Handle edge case where n is 0\n    if n == 0:\n        return 1\n    # Start the backtracking with the first element ranging from 1 to m\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += backtrack([first_element], first_element, n - 1)\n    return total_count", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculates the number of possible sequences of length n, where each element is \n    a positive integer, greater than or equal to twice the previous element, \n    and less than or equal to m.\n\n    Args:\n        m (int): The upper bound for each element in the sequence.\n        n (int): The length of the sequence.\n\n    Returns:\n        int: The total number of possible sequences.\n    \"\"\"\n\n    # Initialize a list to store the count of sequences for each possible last element\n    # We start with m+1 elements, all initialized to 0, to account for all possible last elements in the range [1, m]\n    sequences_count = [0] * (m + 1)\n    \n    # Base case for sequences of length 1: every number from 1 to m can be a sequence\n    for i in range(1, m + 1):\n        sequences_count[i] = 1\n\n    # For each sequence length from 2 to n\n    for _ in range(2, n + 1):\n        # Initialize a temporary list to store the updated counts\n        temp_count = [0] * (m + 1)\n        \n        # For each possible last element in the sequence\n        for j in range(1, m + 1):\n            # Count the number of sequences ending with j\n            # by summing the counts of all elements that are at most j//2 (integer division),\n            # because the previous element must be at least half of j\n            temp_count[j] = sum(sequences_count[k] for k in range(1, (j // 2) + 1))\n        \n        # Update the counts for the next iteration\n        sequences_count = temp_count\n\n    # The total number of sequences is the sum of counts for all possible last elements\n    return sum(sequences_count)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is \n    a positive integer greater than or equal to twice the previous element but \n    less than or equal to m.\n\n    Parameters:\n    - m (int): The upper limit for each element in the sequence.\n    - n (int): The length of the sequence.\n\n    Returns:\n    - int: The total number of possible sequences.\n    \"\"\"\n\n    # Initialize a list to store the number of sequences for each possible last element\n    # considering the constraints. The length is m+1 to account for all possible\n    # values from 1 to m.\n    sequences = [0] * (m + 1)\n    \n    # For a sequence of length 1, the number of sequences ending at each i is 1,\n    # because you can start (and end) a sequence at any number from 1 to m.\n    for i in range(1, m + 1):\n        sequences[i] = 1\n\n    # For sequences of length greater than 1, calculate the number of sequences\n    # ending at each possible number from the smallest possible second element (2)\n    # up to m.\n    for _ in range(1, n):\n        new_sequences = [0] * (m + 1)\n        \n        # For each possible last element in the new sequence length\n        for j in range(1, m + 1):\n            # The first element of the sequence can be at most j//2 (integer division)\n            # because each element must be >= twice the previous one.\n            for k in range(j // 2, 0, -1):\n                new_sequences[j] += sequences[k]\n        \n        # Update the sequences list for the next iteration (next sequence length)\n        sequences = new_sequences\n\n    # The total number of sequences of length n is the sum of sequences ending at\n    # any possible last element.\n    return sum(sequences[1:])  # Ignore the 0th index since we start counting from 1", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element is \n    a positive integer >= twice the previous element but <= m.\n    \n    Args:\n    m (int): Upper limit for each element in the sequence.\n    n (int): Length of the sequence.\n    \n    Returns:\n    int: Total number of possible sequences.\n    \"\"\"\n    def recursive_count(current, last_element, remaining_length, memo):\n        # Memoization key\n        key = (remaining_length, last_element)\n        if key in memo:\n            return memo[key]\n        \n        # Base case: if remaining length is 0, we've formed a valid sequence\n        if remaining_length == 0:\n            return 1\n        \n        count = 0\n        # Explore all possible next elements that are at least double the last and <= m\n        for next_element in range(max(last_element * 2, 1), m + 1):\n            count += recursive_count(current + [next_element], next_element, remaining_length - 1, memo)\n        \n        # Store the result for this subproblem\n        memo[key] = count\n        return count\n    \n    # Initialize and start the recursion with appropriate initial conditions\n    memo = {}\n    return recursive_count([], 0, n, memo)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length `n` where each element is >= 2 * previous element and <= `m`.\n\n    :param m: Upper bound for sequence elements\n    :type m: int\n    :param n: Length of the sequence\n    :type n: int\n    :return: Number of possible sequences\n    :rtype: int\n    \"\"\"\n    def recursive_sequence_count(last_element, remaining_length, memo):\n        # Base case: if remaining length is 0, we've successfully formed a sequence\n        if remaining_length == 0:\n            return 1\n        \n        # Memoization key\n        key = (last_element, remaining_length)\n        if key in memo:\n            return memo[key]\n        \n        count = 0\n        # For each possible next element, recursively count sequences\n        for next_element in range(max(2 * last_element, 1), m + 1):\n            count += recursive_sequence_count(next_element, remaining_length - 1, memo)\n        \n        # Store in memo and return\n        memo[key] = count\n        return count\n\n    # Initialize memoization table\n    memo = {}\n\n    # Start with all possible first elements (1 to m) and count sequences\n    total_count = 0\n    for first_element in range(1, m + 1):\n        total_count += recursive_sequence_count(first_element, n - 1, memo)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, \n    where each element is a positive integer >= twice the previous element and <= m.\n\n    Args:\n        m (int): The upper limit for sequence elements.\n        n (int): The length of the sequences.\n\n    Returns:\n        int: The total number of possible sequences.\n    \"\"\"\n    def backtrack(index, prev_element):\n        # Base case: if the sequence length is reached, count it\n        if index == n:\n            return 1\n        \n        count = 0\n        # Starting from the minimum possible value (twice the previous or 1 if first element)\n        start = max(2 * prev_element, 1)\n        \n        # Iterate over all possible values for the current element\n        for i in range(start, m + 1):\n            # Recursively add counts for all possible subsequent sequences\n            count += backtrack(index + 1, i)\n        \n        return count\n\n    # Start the backtracking process with no previous element (effectively starting from 1)\n    return backtrack(0, 0)", "matching_cluster_idx": 3}]}, "Mbpp/240": {"dps": 56.21951219512195, "dps_norm": 71.11111111111111, "pass@1": 30.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n    \n    Args:\n        list1 (list): The original list to modify.\n        list2 (list): The list of elements to append after replacing the last element in list1.\n    \n    Returns:\n        list: The modified list.\n    \"\"\"\n    if not list1:  # Edge case: if list1 is empty\n        return list2\n    if not list2:  # Edge case: if list2 is empty, return list1 as is (since last element of list1 isn't actually replaced with anything new)\n        return list1[:-1]  # Return all but the last element of list1\n    \n    # Replace the last element of list1 with all elements from list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n        list1 (list): The original list to be modified.\n        list2 (list): The list of elements to replace the last element of list1.\n    \n    Returns:\n        list: The modified list.\n    \"\"\"\n    # Check if list1 is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with the elements of list2\n        # by slicing list1 up to the second last element and appending list2\n        return list1[:-1] + list2\n    else:\n        # If list1 is empty, simply return list2 (as per the problem's implicit expectation)\n        # or raise an exception depending on your application's requirements\n        return list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Args:\n        list1 (list): The list to be modified.\n        list2 (list): The list whose elements will replace the last element of list1.\n    \n    Returns:\n        list: The modified list.\n    \"\"\"\n    # Check if list1 is not empty to avoid indexing errors\n    if list1:\n        # Create a copy of list1 (up to the second last element) to avoid modifying the original list\n        modified_list = list1[:-1]\n        # Extend the modified list with elements from list2\n        modified_list.extend(list2)\n        return modified_list\n    else:\n        # If list1 is empty, simply return list2 (as per the problem's implication)\n        return list2", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n        list1 (list): The original list to be modified.\n        list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n        list: The modified list after replacement.\n    \"\"\"\n    # Check if list1 is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with the elements of list2\n        # by slicing list1 up to the second last element and extending it with list2\n        return list1[:-1] + list2\n    else:\n        # If list1 is empty, simply return list2 (as per the problem's implicit handling of empty lists)\n        return list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of `list1` with the elements of `list2`.\n    \n    Args:\n        list1 (list): The list from which to remove the last element.\n        list2 (list): The list with which to replace the last element of `list1`.\n    \n    Returns:\n        list: A new list with the last element of `list1` replaced by all elements of `list2`.\n    \"\"\"\n    # Check if list1 is not empty to avoid indexing errors\n    if list1:\n        # Slice list1 up to the second last element and extend with list2\n        return list1[:-1] + list2\n    else:\n        # If list1 is empty, simply return list2 (as there's no last element to replace)\n        return list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n        list1 (list): The list from which the last element will be replaced.\n        list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n        list: A new list with the last element of list1 replaced by all elements of list2.\n    \"\"\"\n    # Check if both inputs are lists\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Both inputs must be lists\")\n\n    # Handle the edge case where list1 is empty\n    if len(list1) == 0:\n        return list2[:]  # Return a copy of list2\n\n    # Create a copy of list1 to avoid modifying the original list\n    new_list = list1[:-1]  # Exclude the last element of list1\n    new_list.extend(list2)  # Append all elements of list2\n\n    return new_list", "matching_cluster_idx": 6}, {"solution": "import unittest\ndef replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Parameters:\n    - list1 (list): The original list to be modified.\n    - list2 (list): The list whose elements will replace the last element of list1.\n    \n    Returns:\n    - list: The modified list.\n    \"\"\"\n    if not list1:  # Check if list1 is empty\n        return list2  # If list1 is empty, return list2 as there's nothing to replace\n    if not list2:  # Check if list2 is empty\n        return list1[:-1]  # If list2 is empty, return list1 without its last element\n    \n    # Replace the last element of list1 with the elements of list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Args:\n    - list1 (list): The list from which to remove the last element.\n    - list2 (list): The list whose elements will replace the last element in list1.\n    \n    Returns:\n    - list: A new list where the last element of list1 is replaced by all elements of list2.\n    \"\"\"\n    # Check if list1 is not empty to avoid indexing errors\n    if list1:\n        # Slice list1 up to the second last element and extend with list2\n        return list1[:-1] + list2\n    else:\n        # If list1 is empty, simply return list2 (as per the problem's implicit logic)\n        return list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n        list1 (list): The original list to modify.\n        list2 (list): The list with elements to replace the last element of list1.\n    \n    Returns:\n        list: A new list where the last element of list1 is replaced by all elements of list2.\n    \"\"\"\n    # Check if list1 is not empty to avoid indexing errors\n    if len(list1) > 0:\n        # Return a new list that includes all elements of list1 except the last one, followed by all elements of list2\n        return list1[:-1] + list2\n    else:\n        # If list1 is empty, simply return list2 (since there's nothing to replace)\n        return list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(main_list, replace_with_list):\n    \"\"\"\n    Replaces the last element of the main_list with elements from replace_with_list.\n    \n    Args:\n        main_list (list): The original list to be modified.\n        replace_with_list (list): The list of elements to replace the last element of main_list.\n    \n    Returns:\n        list: The modified list.\n    \"\"\"\n    # Check if main_list is not empty to avoid indexing errors\n    if main_list:\n        # Create a copy of the main_list (up to the second last element)\n        modified_list = main_list[:-1]\n        # Extend the modified list with the replace_with_list\n        modified_list.extend(replace_with_list)\n        return modified_list\n    else:\n        # If main_list is empty, simply return replace_with_list\n        return replace_with_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n        list1 (list): The list from which the last element will be replaced.\n        list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n        list: A new list where the last element of list1 is replaced with all elements of list2.\n    \"\"\"\n    # Check if list1 is not empty to avoid index errors\n    if list1:\n        # Create a copy of list1 up to the second last element\n        new_list = list1[:-1]\n        # Extend the new list with elements from list2\n        new_list.extend(list2)\n        return new_list\n    else:\n        # If list1 is empty, simply return list2 (as per the problem's implied behavior)\n        return list2", "matching_cluster_idx": 6}, {"solution": "def replace_list(main_list, replacement_list):\n    \"\"\"\n    Replaces the last element of `main_list` with elements from `replacement_list`.\n\n    Args:\n        main_list (list): The list to modify.\n        replacement_list (list): The list of elements to insert.\n\n    Returns:\n        list: The modified list.\n    \"\"\"\n    # Check if main_list is not empty to avoid index errors\n    if main_list:\n        # Remove the last element from the main list\n        main_list = main_list[:-1]\n    # Extend the main list with the replacement list\n    main_list.extend(replacement_list)\n    return main_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Args:\n        list1 (list): The original list to modify.\n        list2 (list): The list whose elements will replace the last element in list1.\n\n    Returns:\n        list: The modified list with list1's last element replaced by all elements of list2.\n    \"\"\"\n    # Check if list1 is not empty to avoid index errors\n    if list1:\n        # Create a copy of list1 up to the second last element\n        modified_list = list1[:-1]\n        # Extend the modified list with elements from list2\n        modified_list.extend(list2)\n        return modified_list\n    else:\n        # If list1 is empty, simply return list2 (following the problem's implied logic)\n        return list2", "matching_cluster_idx": 6}, {"solution": "def replace_list(main_list, replacement_list):\n    \"\"\"\n    Replaces the last element of the main_list with all elements from replacement_list.\n\n    Args:\n        main_list (list): The original list to be modified.\n        replacement_list (list): The list whose elements will replace the last element in main_list.\n\n    Returns:\n        list: The modified list.\n    \"\"\"\n    # Check if main_list is not empty to avoid index errors\n    if main_list:\n        # Slice the main_list up to the second last element\n        modified_list = main_list[:-1]\n        # Extend the sliced list with the replacement_list\n        modified_list.extend(replacement_list)\n        return modified_list\n    else:\n        # If main_list is empty, simply return the replacement_list\n        return replacement_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Parameters:\n    list1 (list): The list from which to remove the last element.\n    list2 (list): The list whose elements will replace the last element in list1.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by all elements of list2.\n    \"\"\"\n    # Check if list1 is not empty to avoid indexing errors\n    if len(list1) > 0:\n        # Slice list1 up to the second last element (to exclude the last element)\n        # and extend it with all elements from list2\n        return list1[:-1] + list2\n    else:\n        # If list1 is empty, simply return a copy of list2 (or list2 itself, since it's not modified)\n        return list2.copy()", "matching_cluster_idx": 5}, {"solution": "def replace_list(main_list, replacement_list):\n    \"\"\"\n    Replaces the last element of the main_list with the elements of the replacement_list.\n    \n    Args:\n        main_list (list): The original list to be modified.\n        replacement_list (list): The list whose elements will replace the last element of main_list.\n    \n    Returns:\n        list: The modified list.\n    \"\"\"\n    if not main_list:  # Check if main_list is empty\n        return replacement_list[:]  # Return a copy of replacement_list if main_list is empty\n    elif not replacement_list:  # Check if replacement_list is empty\n        return main_list[:-1]  # Return main_list with the last element removed if replacement_list is empty\n    else:\n        return main_list[:-1] + replacement_list  # Replace last element of main_list with replacement_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n        list1 (list): The original list to be modified.\n        list2 (list): The list whose elements will replace the last element of list1.\n    \n    Returns:\n        list: The modified list.\n    \"\"\"\n    # Check if list1 is not empty to avoid indexing errors\n    if list1:\n        # Remove the last element from list1\n        list1 = list1[:-1]\n    # Extend list1 with elements from list2\n    list1.extend(list2)\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n        list1 (list): The list from which the last element will be replaced.\n        list2 (list): The list whose elements will replace the last element in list1.\n    \n    Returns:\n        list: A new list where the last element of list1 is replaced by all elements of list2.\n    \"\"\"\n    # Check if list1 is not empty to avoid index errors\n    if list1:\n        # Create a copy of list1 to avoid modifying the original list\n        new_list = list1.copy()\n        # Remove the last element from the new list\n        new_list.pop()\n        # Extend the new list with the elements of list2\n        new_list.extend(list2)\n        return new_list\n    else:\n        # If list1 is empty, simply return list2 (following the problem's implicit behavior)\n        return list2.copy()  # Return a copy to maintain the function's non-mutating behavior", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Parameters:\n    - list1 (list): The list from which the last element will be replaced.\n    - list2 (list): The list whose elements will replace the last element of list1.\n    \n    Returns:\n    - list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Check if list1 is not empty to avoid indexing errors\n    if list1:\n        # Slice list1 up to the second last element and extend with list2\n        return list1[:-1] + list2\n    else:\n        # If list1 is empty, simply return list2 (assuming this is the desired behavior)\n        return list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n    \n    Args:\n        list1 (list): The original list to modify.\n        list2 (list): The list with elements to replace the last element of list1.\n    \n    Returns:\n        list: The modified list.\n    \"\"\"\n    if not list1:  # Check if list1 is empty\n        return list2[:]  # Return a copy of list2 if list1 is empty\n    if not list2:  # Check if list2 is empty\n        return list1[:-1]  # Return list1 without the last element if list2 is empty\n    \n    # Replace the last element of list1 with all elements of list2\n    return list1[:-1] + list2[:]", "matching_cluster_idx": 4}]}, "Mbpp/251": {"dps": 79.9712643678161, "dps_norm": 74.44444444444444, "pass@1": 39.0, "profiled": [{"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n    \n    Args:\n        input_list (list): The original list to modify.\n        element: The element to insert before each item in the list.\n    \n    Returns:\n        list: The resulting list with the element inserted before each item.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in input_list:\n        # Insert the given element before each item\n        result.extend([element, item])\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts an element before each element in the input list.\n\n    Args:\n        input_list (list): The original list to modify.\n        element: The element to be inserted before each item in the list.\n\n    Returns:\n        list: A new list with the element inserted before each item of the input list.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in input_list:\n        # Insert the given element\n        result.append(element)\n        # Append the current item from the input list\n        result.append(item)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n    \n    Args:\n        input_list (list): The original list to be modified.\n        element: The element to be inserted before each item in the input list.\n    \n    Returns:\n        list: A new list with the element inserted before each item of the input list.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result_list = []\n    \n    # For each element in the input list\n    for item in input_list:\n        # Append the given element to the result list\n        result_list.append(element)\n        # Then append the current item from the input list\n        result_list.append(item)\n    \n    # Return the resulting list\n    return result_list\ninput_list = ['Red', 'Green', 'Black']", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n    \n    Args:\n    - input_list (list): The list into which the element will be inserted.\n    - element: The element to be inserted before each item in the input list.\n    \n    Returns:\n    - list: The resulting list with the element inserted before each original item.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result_list = []\n    \n    # Iterate over each item in the input list\n    for item in input_list:\n        # Insert the given element\n        result_list.append(element)\n        # Then append the current item from the input list\n        result_list.append(item)\n    \n    # Return the resulting list\n    return result_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n    \n    Args:\n        input_list (list): The original list into which the element will be inserted.\n        element: The element to be inserted before each element in the input list.\n    \n    Returns:\n        list: The resulting list with the element inserted before each original element.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result_list = []\n    \n    # For each element in the input list\n    for input_element in input_list:\n        # First, append the given element to the result list\n        result_list.append(element)\n        # Then, append the current element from the input list\n        result_list.append(input_element)\n    \n    # Return the resulting list\n    return result_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts an element before each element in the input list.\n    \n    Args:\n    - input_list (list): The original list to modify.\n    - element: The element to insert before each item in the list.\n    \n    Returns:\n    - list: The modified list with the element inserted before each item.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # For each element in the input list\n    for item in input_list:\n        # First, append the element to be inserted\n        result.append(element)\n        # Then, append the current item from the input list\n        result.append(item)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n\n    Args:\n        input_list (list): The original list to be modified.\n        element: The element to be inserted before each item in the list.\n\n    Returns:\n        list: The modified list with the element inserted before each original item.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # For each element in the input list\n    for item in input_list:\n        # First, append the element to be inserted\n        result.append(element)\n        # Then, append the original list item\n        result.append(item)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(original_list, element):\n    \"\"\"\n    Inserts an element before each element in the original list.\n\n    Args:\n        original_list (list): The list into which the element is to be inserted.\n        element: The element to be inserted before each element in the list.\n\n    Returns:\n        list: The resulting list with the element inserted before each original element.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # For each element in the original list\n    for orig_elem in original_list:\n        # Append the given element to the result list\n        result.append(element)\n        # Then append the original element to the result list\n        result.append(orig_elem)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts an element before each element in the input list.\n\n    Args:\n        input_list (list): The original list to be modified.\n        element: The element to be inserted before each item in the input list.\n\n    Returns:\n        list: A new list with the element inserted before each item from the input list.\n    \"\"\"\n    # Use list comprehension to create a new list where each element from the input list\n    # is preceded by the given element\n    result = [item for pair in [(element, x) for x in input_list] for item in pair]\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n\n    Args:\n        input_list (list): The original list to be modified.\n        element: The element to be inserted before each item in the input_list.\n\n    Returns:\n        list: A new list with the element inserted before each item from the input_list.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in input_list:\n        # Insert the given element\n        result.append(element)\n        # Then append the current item from the input list\n        result.append(item)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n    \n    Args:\n        input_list (list): The original list to modify.\n        element: The element to insert before each item in the list.\n    \n    Returns:\n        list: A new list with the element inserted before each item of the input list.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each element in the input list\n    for item in input_list:\n        # Insert the given element before the current item from the input list\n        result.extend([element, item])\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n\n    Args:\n    - input_list (list): The original list to be modified.\n    - element: The element to be inserted before each item in the list.\n\n    Returns:\n    - list: A new list with the element inserted before each item from the input list.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in input_list:\n        # First, append the element to the result list\n        result.append(element)\n        # Then, append the current item from the input list\n        result.append(item)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts an element before each element in the input list.\n\n    Args:\n        input_list (list): The original list to be modified.\n        element: The element to be inserted before each item in the input list.\n\n    Returns:\n        list: A new list with the element inserted before each item from the input list.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # For each element in the input list\n    for item in input_list:\n        # First, append the element to be inserted\n        result.append(element)\n        # Then, append the current item from the input list\n        result.append(item)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n    \n    Args:\n    - input_list (list): The list into which the element will be inserted.\n    - element: The element to be inserted before each element in the input list.\n    \n    Returns:\n    - list: A new list with the element inserted before each element of the input list.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # For each element in the input list\n    for item in input_list:\n        # First, append the given element to the result list\n        result.append(element)\n        # Then, append the current item from the input list\n        result.append(item)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n\n    Args:\n        input_list (list): The original list to be modified.\n        element: The element to be inserted before each element in the input list.\n\n    Returns:\n        list: A new list with the element inserted before each element of the input list.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each element in the input list\n    for item in input_list:\n        # Insert the given element before each item from the input list\n        result.extend([element, item])\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n    \n    Args:\n        input_list (list): The original list to modify.\n        element: The element to insert before each item in the list.\n    \n    Returns:\n        list: A new list with the element inserted before each item of the input list.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each element in the input list\n    for item in input_list:\n        # Insert the given element\n        result.append(element)\n        # Then append the current item from the input list\n        result.append(item)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n\n    Args:\n        input_list (list): The original list to be modified.\n        element: The element to be inserted before each element in the list.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    # Use list comprehension to create a new list with the element inserted before each original element\n    # The expression `[element, x] for x in input_list` generates pairs of [element, original_element]\n    # The outer list comprehension then flattens these pairs into a single list\n    return [item for pair in ([element, x] for x in input_list) for item in pair]", "matching_cluster_idx": 4}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n\n    Args:\n        input_list (list): The original list to modify.\n        element: The element to insert before each item in the list.\n\n    Returns:\n        list: A new list with the element inserted before each item.\n    \"\"\"\n    return [item for pair in [(element, x) for x in input_list] for item in pair]\ninput_list = ['Red', 'Green', 'Black']", "matching_cluster_idx": 4}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n    \n    Args:\n    - input_list (list): The original list to be modified.\n    - element: The element to be inserted before each item in the list.\n    \n    Returns:\n    - list: The modified list with the element inserted before each original item.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each element in the input list\n    for item in input_list:\n        # Insert the given element before each item from the input list\n        result.extend([element, item])\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    Inserts a given element before each element in the input list.\n\n    Args:\n        input_list (list): The original list to be modified.\n        element: The element to be inserted before each item in the list.\n\n    Returns:\n        list: The resulting list with the element inserted before each item.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each element in the input list\n    for item in input_list:\n        # Insert the given element\n        result.append(element)\n        # Append the current item from the input list\n        result.append(item)\n    \n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 83.09360730593608, "dps_norm": 76.17647058823529, "pass@1": 58.0, "profiled": [{"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number `n`.\n    \n    Args:\n    - n (int): A non-negative integer.\n    \n    Returns:\n    - int: The count of prime numbers less than `n`.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative number.\")\n    elif n < 2:\n        return 0  # Numbers less than 2 are not prime\n    \n    # Sieve of Eratosthenes algorithm for efficiency\n    sieve = [True] * n\n    sieve[0:2] = [False, False]  # 0 and 1 are not prime numbers\n    \n    # Iterate from 2 to the square root of n\n    for current_prime in range(2, int(n**0.5) + 1):\n        if sieve[current_prime]:\n            # Mark multiples of current_prime as not prime\n            for multiple in range(current_prime*current_prime, n, current_prime):\n                sieve[multiple] = False\n    \n    # Count all primes less than n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Returns the count of prime numbers less than the given non-negative number `n`.\n\n    :param n: A non-negative integer.\n    :return: The number of prime numbers less than `n`.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Handle edge cases\n    if n < 2:\n        return 0\n\n    # Initialize a boolean array, prime, of size `n`\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n\n    # Count all prime numbers in the list\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(N: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number N.\n    \n    Args:\n    N (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than N.\n    \"\"\"\n    if N < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Initialize count of primes\n    count = 0\n    \n    # Iterate through all numbers less than N\n    for num in range(2, N):  # Start from 2, the first prime number\n        # Check if num is prime\n        is_prime = True\n        # Only need to check divisibility up to the square root of num\n        for divisor in range(2, int(num ** 0.5) + 1):\n            if num % divisor == 0:\n                is_prime = False\n                break\n        # If num is prime, increment count\n        if is_prime:\n            count += 1\n    \n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number N.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of prime numbers less than N.\n\n    Raises:\n    ValueError: If n is a negative integer.\n    TypeError: If n is not an integer.\n    \"\"\"\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Handle edge cases where n is less than 2 (since prime numbers start at 2)\n    if n < 2:\n        return 0\n\n    # Initialize a boolean array, prime, of size n\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Iterate from 2 to sqrt(n) to mark as composite (not prime) the multiples of each prime\n    for p in range(2, int(n ** 0.5) + 1):\n        if prime[p]:\n            for i in range(p*p, n, p):\n                prime[i] = False\n\n    # Count all prime numbers in the boolean array\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The number of prime numbers less than n.\n\n    Raises:\n    ValueError: If n is a negative integer.\n    TypeError: If n is not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Initialize count of primes\n    count = 0\n    \n    # Iterate from 2 to n-1 (since we're looking for primes LESS THAN n)\n    for possiblePrime in range(2, n):\n        # Assume number is prime until shown it is not. \n        isPrime = True\n        \n        # Iterate from 2 to sqrt(possiblePrime) to check for factors\n        for num in range(2, int(possiblePrime ** 0.5) + 1):\n            if possiblePrime % num == 0:\n                isPrime = False\n                break\n        \n        # If we found a prime, increment the count\n        if isPrime:\n            count += 1\n    \n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number `n`.\n    \n    Args:\n        n (int): A non-negative integer.\n    \n    Returns:\n        int: The count of prime numbers less than `n`.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Handle edge cases where n is less than 2 (since prime numbers start from 2)\n    if n < 2:\n        return 0\n    \n    # Initialize a boolean array, prime, of size `n` and set all entries true.\n    # A value in prime[i] will finally be false if i is Not a prime, else true.\n    prime = [True for _ in range(n)]\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Update all multiples of p\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, update all multiples of p\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n    \n    # Count all prime numbers in the list\n    count = sum(prime)\n    \n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n    - `n (int)`: A non-negative integer.\n\n    Returns:\n    - `int`: The number of prime numbers less than `n`.\n\n    Raises:\n    - `ValueError`: If `n` is a negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Handle edge cases where n is less than 2 (since prime numbers start at 2)\n    if n < 2:\n        return 0\n\n    # Initialize a boolean array, prime, of size n\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Iterate up to the square root of n\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n\n    # Count all prime numbers in the list\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(N: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number N.\n\n    Args:\n        N (int): A non-negative integer.\n\n    Returns:\n        int: The number of prime numbers less than N.\n    \"\"\"\n    if N < 2:  # Edge case: 0, 1, and negatives have 0 primes less than them\n        return 0\n\n    # Initialize a boolean array, prime, of size N\n    prime = [True] * N\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Iterate from 2 to sqrt(N)\n    for p in range(2, int(N ** 0.5) + 1):\n        if prime[p]:\n            # Mark as composite all the multiples of p\n            for i in range(p * p, N, p):\n                prime[i] = False\n\n    # Count all prime numbers in the list\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number n.\n\n    Args:\n    - n (int): A non-negative integer.\n\n    Returns:\n    - int: The number of prime numbers less than n.\n\n    Raises:\n    - ValueError: If n is a negative integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Edge case: 0 and 1 are not prime numbers\n    if n <= 2:\n        return 0\n\n    # Initialize a boolean array, prime, of size n\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n\n    # Return the count of all prime numbers in the list\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number n.\n\n    Args:\n    - n (int): A non-negative integer.\n\n    Returns:\n    - int: The number of prime numbers less than n.\n\n    Raises:\n    - ValueError: If n is a negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Initialize count of primes\n    count = 0\n\n    # Iterate over all numbers less than n\n    for possiblePrime in range(2, n):  # Start from 2, the first prime number\n\n        # Assume number is prime until shown it is not. \n        isPrime = True\n\n        # Iterate from 2 to sqrt(possiblePrime) to check for factors\n        for num in range(2, int(possiblePrime ** 0.5) + 1):\n            if possiblePrime % num == 0:\n                isPrime = False\n                break\n\n        # If prime, increment count\n        if isPrime:\n            count += 1\n\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number n.\n    \n    Args:\n        n (int): A non-negative integer.\n    \n    Returns:\n        int: The number of prime numbers less than n.\n    \n    Raises:\n        ValueError: If n is a negative integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    def is_prime(num):\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Count primes less than n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    \n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number `n`.\n\n    Args:\n    - n (int): A non-negative integer.\n\n    Returns:\n    - int: The number of prime numbers less than `n`.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Edge case: Numbers less than 2 have no prime numbers\n    if n < 2:\n        return 0\n    \n    # Initialize a boolean array, prime, of size n\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n    \n    # Return the count of all prime numbers in the boolean array\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number n.\n    \n    Args:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The number of prime numbers less than n.\n    \n    Raises:\n    ValueError: If n is a negative integer.\n    TypeError: If n is not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    def is_prime(num: int) -> bool:\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Count prime numbers less than n\n    count = 0\n    for possiblePrime in range(2, n):  # Start from 2, the first prime number\n        if is_prime(possiblePrime):\n            count += 1\n    \n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number `n`.\n\n    Args:\n    - `n` (int): A non-negative integer.\n\n    Returns:\n    - `int`: The count of prime numbers less than `n`.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    elif n < 2:\n        return 0  # Edge case: Numbers less than 2 have no prime numbers before them.\n\n    # Initialize a boolean array, prime, of size n+1\n    prime = [True] * (n + 1)\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n\n    # Count all prime numbers in the list\n    count = sum(1 for is_prime in prime if is_prime)\n\n    return count - (1 if prime[n] else 0)  # Subtract 1 if n itself is prime", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number `n`.\n    \n    :param n: A non-negative integer.\n    :return: The number of prime numbers less than `n`.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    def is_prime(num: int) -> bool:\n        \"\"\"Checks if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Count primes less than n\n    return sum(1 for i in range(2, n) if is_prime(i))", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number `n`.\n    \n    Args:\n    - `n` (int): A non-negative integer.\n    \n    Returns:\n    - `int`: The count of prime numbers less than `n`.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    elif n < 2:\n        return 0  # No prime numbers less than 2\n    \n    # Initialize a boolean array, prime, of size `n`\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n    \n    # Return the count of all prime numbers in the boolean array\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number n.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The number of prime numbers less than n.\n\n    Raises:\n    ValueError: If n is a negative integer.\n    TypeError: If n is not an integer.\n    \"\"\"\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Handle edge cases\n    if n <= 2:\n        return 0\n\n    # Initialize a boolean array, prime, of size n\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n\n    # Count all prime numbers in the array\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number n.\n\n    Args:\n    - n (int): A non-negative integer.\n\n    Returns:\n    - int: The count of prime numbers less than n.\n\n    Raises:\n    - ValueError: If n is a negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Handle edge cases\n    if n <= 2:\n        return 0\n\n    # Initialize count (2 is the first prime, so start with 1 if n > 2)\n    count = 1 if n > 2 else 0\n\n    # Iterate from 3 to n-1 (since we're looking for primes LESS THAN n)\n    for num in range(3, n, 2):  # Increment by 2 to check only odd numbers\n        # Assume number is prime until shown it is not\n        is_prime = True\n\n        # Check divisibility up to the square root of the number\n        for div in range(3, int(num ** 0.5) + 1, 2):\n            if num % div == 0:\n                is_prime = False\n                break\n\n        # If the number is prime, increment the count\n        if is_prime:\n            count += 1\n\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Returns the count of prime numbers less than the given non-negative number n.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The number of prime numbers less than n.\n\n    Raises:\n    ValueError: If n is a negative integer.\n    TypeError: If n is not an integer.\n    \"\"\"\n    # Input Validation\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Handle edge cases where n is less than 2 (since there are no primes < 2)\n    if n < 2:\n        return 0\n\n    # Initialize a boolean array, prime, of size n\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n\n    # Return the count of all prime numbers in the list\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Returns the count of prime numbers less than the given non-negative number n.\n    \n    :param n: A non-negative integer.\n    :return: The number of prime numbers less than n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    elif n < 2:\n        return 0  # No prime numbers less than 2\n    \n    # Initialize a boolean array, prime, of size n\n    prime = [True] * n\n    prime[0] = prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Iterate from 2 to sqrt(n)\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime, mark as composite all the multiples of p\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n    \n    # Count all prime numbers in the boolean array\n    return sum(prime)", "matching_cluster_idx": 14}]}, "Mbpp/265": {"dps": 57.73255813953489, "dps_norm": 74.16666666666666, "pass@1": 72.0, "profiled": [{"solution": "def list_split(original_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    The function rearranges the elements of the original list into sublists where\n    the i-th sublist contains every i-th element from the original list, starting\n    from the i-th element.\n\n    Args:\n        original_list (list): The input list to be split.\n        n (int): The interval at which to split the list.\n\n    Returns:\n        list: A list of lists, where each sublist contains every nth element.\n    \"\"\"\n    # Initialize empty list to store the result\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the original list with enumerate to get both index and value\n    for index, value in enumerate(original_list):\n        # Append each value to the corresponding sublist based on the index % n\n        result[index % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    The function rearranges the input list such that the 1st, (n+1)th, (2n+1)th, etc., \n    elements are in the first sublist, the 2nd, (n+2)th, (2n+2)th, etc., elements \n    are in the second sublist, and so on, until all elements are allocated.\n\n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which to split the list.\n\n    Returns:\n        list: A list of lists, where each sublist contains elements split by the nth interval.\n    \"\"\"\n    # Initialize an empty list to hold the result sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with enumerate to get both index and value\n    for idx, value in enumerate(input_list):\n        # Calculate the index of the result list where the current element should be appended\n        # This is done by finding the remainder of the index divided by n\n        result_idx = idx % n\n        # Append the value to the corresponding sublist in the result\n        result[result_idx].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list every nth element, returning a list of the resulting lists.\n\n    Args:\n    - input_list (list): The list to be split.\n    - n (int): The interval at which to split the list.\n\n    Returns:\n    - list: A list of lists, where each sublist contains elements from the original list, \n            taken every nth element starting from their respective index.\n    \"\"\"\n    # Initialize empty list to store the resulting sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with both index and value\n    for idx, value in enumerate(input_list):\n        # Append the value to the sublist corresponding to its index modulo n\n        result[idx % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists, each containing elements from the input list\n    that occur at every nth position, starting from the beginning of the list.\n\n    Args:\n        - input_list (list): The list to be split.\n        - n (int): The interval at which to split the list.\n\n    Returns:\n        - list of lists: A list of sublists, each containing elements from the\n            input list that are spaced by n positions.\n    \"\"\"\n    return [[input_list[j] for j in range(i, len(input_list), n)] for i in range(n)]", "matching_cluster_idx": 1}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list every nth element, transposing the segments.\n    \n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which the list is split.\n    \n    Returns:\n        list: A list of lists where each sublist contains every nth element from the input list.\n    \"\"\"\n    # Calculate the number of sublists (equal to n)\n    num_sublists = n\n    \n    # Initialize empty sublists\n    split_lists = [[] for _ in range(num_sublists)]\n    \n    # Iterate over the input list with enumerate to access both index and value\n    for idx, value in enumerate(input_list):\n        # Append each element to its corresponding sublist based on the index modulo n\n        split_lists[idx % num_sublists].append(value)\n    \n    return split_lists", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    The function rearranges the input list into sublists where the ith sublist \n    contains every nth element from the original list starting from the ith element.\n\n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which to split the list.\n\n    Returns:\n        list: A list of lists, where each sublist contains every nth element.\n    \"\"\"\n    # Initialize an empty list to hold the result sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with both index and value\n    for idx, value in enumerate(input_list):\n        # Append each element to the corresponding sublist based on its index modulo n\n        result[idx % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list every nth element, returning a list of the resulting lists.\n    \n    The function rearranges the input list such that the first element of each nth \n    group ends up in the first sublist, the second element of each nth group in \n    the second sublist, and so on, until all elements are redistributed.\n    \n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists where each sublist contains elements from the input list, \n          split at every nth position.\n    \"\"\"\n    # Initialize empty list to store the result\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with both index and value\n    for idx, val in enumerate(input_list):\n        # Calculate the position in the result list using the modulus operator\n        # This ensures the list wraps around after 'n' sublists\n        position = idx % n\n        # Append the value to the appropriate sublist in the result\n        result[position].append(val)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists, where each sublist contains every nth element from the original list.\n\n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which elements are selected for each sublist.\n\n    Returns:\n        list: A list of sublists, each containing every nth element.\n    \"\"\"\n    # Initialize empty list to hold the result sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with enumerate to access both index and value\n    for idx, value in enumerate(input_list):\n        # Calculate the sublist index by finding the remainder of the division of the current index by n\n        sublist_idx = idx % n\n        # Append the current value to the corresponding sublist\n        result[sublist_idx].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists, each containing every nth element from the original list.\n\n    Args:\n        input_list (list): The original list to be split.\n        n (int): The interval at which elements are selected for each sublist.\n\n    Returns:\n        list: A list of sublists, where each sublist contains every nth element.\n    \"\"\"\n    # Initialize an empty list to store the result sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with both index and value\n    for i, value in enumerate(input_list):\n        # Calculate the index of the sublist where the current element should be appended\n        # The index is determined by the modulus of the current index with n\n        sublist_index = i % n\n        # Append the value to the corresponding sublist\n        result[sublist_index].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists, each containing every nth element.\n\n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which elements are selected for each sublist.\n\n    Returns:\n        list: A list of sublists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [[input_list[j] for j in range(i, len(input_list), n)] for i in range(n)]", "matching_cluster_idx": 2}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists, each containing elements from the original list \n    but shifted by one position, repeating the pattern every nth element.\n\n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which to split and rearrange the list.\n\n    Returns:\n        list: A list of lists, where each sublist contains elements from the input list\n              but selected at every nth position.\n    \"\"\"\n    # Initialize empty sublists to hold the split elements\n    split_lists = [[] for _ in range(n)]\n    \n    # Iterate over the input list with both index and value\n    for idx, value in enumerate(input_list):\n        # Calculate which sublist to append the current element to, based on the index and n\n        split_lists[idx % n].append(value)\n    \n    return split_lists", "matching_cluster_idx": 1}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    The function reorganizes the input list by grouping elements based on their index modulo n.\n    This essentially means that every nth element (starting from the first, which is 0th in Python) \n    is grouped together in separate sublists.\n    \n    Parameters:\n    - input_list (list): The list to be split.\n    - n (int): The interval at which to split the list.\n    \n    Returns:\n    - list of lists: A list containing sublists, each of which consists of elements spaced by n indices in the original list.\n    \"\"\"\n    # Initialize an empty list to hold the result sublists, with n empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with both index and value\n    for idx, value in enumerate(input_list):\n        # Append each value to the sublist corresponding to its index modulo n\n        result[idx % n].append(value)\n    \n    return result\ninput_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Parameters:\n    - input_list (list): The list to be split.\n    - n (int): The interval at which the list is split.\n\n    Returns:\n    - list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    # Initialize empty lists to store the result\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with enumerate to get both index and value\n    for idx, value in enumerate(input_list):\n        # Append each value to the sublist corresponding to its index modulo n\n        result[idx % n].append(value)\n    \n    return result\ninput_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists, each containing every nth element from the original list.\n\n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which elements are selected for each sublist.\n\n    Returns:\n        list: A list of sublists, each containing every nth element from the input list.\n    \"\"\"\n    # Initialize an empty list to hold the sublists\n    split_lists = [[] for _ in range(n)]\n    \n    # Iterate over the input list with both index and value\n    for idx, val in enumerate(input_list):\n        # Append the value to the corresponding sublist based on the index modulo n\n        split_lists[idx % n].append(val)\n    \n    return split_lists", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list every nth element, returning a list of the resulting lists.\n    \n    The function rearranges the input list such that elements at positions \n    (0, n, 2n, ...), (1, n+1, 2n+1, ...), etc., are grouped together.\n    \n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which to split the list.\n        \n    Returns:\n        list: A list of lists, each containing elements spaced by `n` from the input list.\n    \"\"\"\n    # Initialize empty lists to store the split results\n    split_lists = [[] for _ in range(n)]\n    \n    # Iterate over the input list with both index and value\n    for i, element in enumerate(input_list):\n        # Calculate the index of the split list where the element should be appended\n        # This is done by finding the remainder of the index divided by n\n        split_index = i % n\n        # Append the element to the corresponding split list\n        split_lists[split_index].append(element)\n    \n    return split_lists\ninput_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    The function rearranges the input list by grouping every nth element together.\n    \n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The interval at which elements are grouped together.\n    \n    Returns:\n    list: A list of lists where each sublist contains elements at the same position in each nth group.\n    \"\"\"\n    # Calculate the number of sublists needed (ceiling division to handle remainder elements)\n    num_sublists = -(-len(input_list) // n)  # Equivalent to math.ceil(len(input_list) / n)\n    \n    # Initialize empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with enumerate to have both index and value\n    for i, element in enumerate(input_list):\n        # Append each element to its corresponding sublist based on the index modulo n\n        result[i % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list every nth element, returning a list of the resulting lists.\n    \n    The function rearranges the input list such that the first element of each \n    subgroup (formed by splitting every nth element) is grouped together, \n    followed by the second element of each subgroup, and so on.\n    \n    Args:\n        input_list (list): The input list to be split.\n        n (int): The interval at which to split the list.\n        \n    Returns:\n        list: A list of lists, where each sublist contains elements split every nth position.\n    \"\"\"\n    # Initialize an empty list to hold the result sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with enumerate to access both index and value\n    for idx, value in enumerate(input_list):\n        # Calculate the subgroup index by finding the remainder of the index divided by n\n        subgroup_idx = idx % n\n        # Append the value to the corresponding subgroup in the result list\n        result[subgroup_idx].append(value)\n    \n    return result\ninput_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    This function takes in a list and an integer n, splitting the list \n    for every nth element and returning a list of the resulting lists.\n    \n    The split is column-wise, meaning it groups every nth element together.\n\n    Args:\n        input_list (list): The input list to be split.\n        n (int): The interval at which to split the list.\n\n    Returns:\n        list: A list of lists, where each sublist contains every nth element.\n    \"\"\"\n    # Initialize an empty list to store the resulting sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with enumerate to get both index and value\n    for idx, value in enumerate(input_list):\n        # Calculate the subgroup index by using the modulus of the index with n\n        subgroup_idx = idx % n\n        # Append the value to the corresponding subgroup in the result list\n        result[subgroup_idx].append(value)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists, each containing every nth element from the original list.\n    \n    Args:\n    - input_list (list): The original list to be split.\n    - n (int): The interval at which elements are selected for each sublist.\n    \n    Returns:\n    - list: A list of sublists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [[input_list[j] for j in range(i, len(input_list), n)] for i in range(n)]", "matching_cluster_idx": 1}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists, grouping every nth element from the original list.\n    \n    Args:\n        input_list (list): The list to be split.\n        n (int): The interval at which elements are grouped.\n    \n    Returns:\n        list: A list of lists where each sublist contains elements from the input list, \n              selected at every nth position.\n    \"\"\"\n    # Initialize empty lists to store the grouped elements\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list with enumerate to get both index and value\n    for idx, value in enumerate(input_list):\n        # Calculate the position in the result list using the modulus operator\n        # This ensures the elements are distributed across the sublists in order\n        result[idx % n].append(value)\n    \n    return result", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 62.0, "profiled": [{"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        input_list (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a given list are unique.\n\n    Args:\n        input_list (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in the given list are unique.\n\n    Args:\n    - input_list (list): The list to check for uniqueness.\n\n    Returns:\n    - bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in the provided list are unique.\n\n    Args:\n    - `input_list` (list): The list to check for unique elements.\n\n    Returns:\n    - `bool`: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in the input list are unique.\n    \n    Args:\n        input_list (list): The list to check for uniqueness.\n    \n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If lengths are equal, all elements were unique\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in the input list are unique.\n    \n    Args:\n        input_list (list): The list to be checked.\n    \n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in the input list are unique.\n    \n    Args:\n        input_list (list): The list to check.\n    \n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Returns True if all elements in the input list are unique, False otherwise.\n    \n    Parameters:\n    input_list (list): The list to check for unique elements.\n    \n    Returns:\n    bool: True if all elements are unique, False if duplicates are found.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a given list are unique.\n    \n    Args:\n        lst (list): The input list to check.\n    \n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a given list are unique.\n\n    Args:\n        input_list (list): The list to check for unique elements.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in the input list are unique.\n    \n    Args:\n        input_list (list): The list to check for unique elements.\n    \n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in the input list are unique.\n\n    Args:\n        input_list (list): The list to be checked for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If lengths before and after conversion are the same, all elements were unique\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a given list are unique.\n\n    Args:\n        input_list (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a given list are unique.\n    \n    Args:\n        input_list (list): The list to check for uniqueness.\n    \n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in the given list are unique.\n    \n    Args:\n    input_list (list): The list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a given list are unique.\n\n    Args:\n        input_list (list): The list to check for unique elements.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a given list are unique.\n    \n    Parameters:\n    input_list (list): The list to be checked for unique elements.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If lengths are equal after conversion, all elements were unique\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in the provided list are unique.\n\n    Args:\n    - input_list (list): The list to check for unique elements.\n\n    Returns:\n    - bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Returns True if all elements in the input list are unique, False otherwise.\n\n    :param input_list: The list to check for uniqueness\n    :return: bool\n    \"\"\"\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    \"\"\"\n    Checks if all elements in a given list are unique.\n    \n    Parameters:\n    input_list (list): The list to check for unique elements.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which automatically removes duplicates\n    # If lengths are equal, then all elements were unique\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 20.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the input array.\n\n    Args:\n    - arr (list): The input list of integers.\n\n    Returns:\n    - int: The total number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has 1 or fewer elements, it's already sorted and has no inversions.\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Divide the array into two halves.\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n        \n        # Recursively count inversions in both halves.\n        left_sorted, left_inv = merge_sort(left_half)\n        right_sorted, right_inv = merge_sort(right_half)\n        \n        # Merge the sorted halves and count inversions between them.\n        merged, merged_inv = merge(left_sorted, right_sorted)\n        \n        # Return the merged array and the total inversion count.\n        return merged, left_inv + right_inv + merged_inv\n\n    def merge(left, right):\n        # Initialize variables to store the merged array and inversion count.\n        merged = []\n        inv_count = 0\n        \n        # Initialize indices for both arrays.\n        left_index = right_index = 0\n        \n        # Merge smaller elements first and count inversions.\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                inv_count += len(left) - left_index  # Count inversions.\n                right_index += 1\n        \n        # Append any remaining elements.\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        \n        return merged, inv_count\n\n    # Call merge_sort to get the inversion count.\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in the given array.\n\n    :param arr: Input array of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def mergeSort(arr):\n        # Base case: If array has 1 or fewer elements, it's already sorted, and there are no inversions.\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Divide the array into two halves\n        mid = len(arr) // 2\n        left, left_inv = mergeSort(arr[:mid])\n        right, right_inv = mergeSort(arr[mid:])\n        \n        # Merge the two halves and count inversions between them\n        merged, merge_inv = merge(left, right)\n        \n        # Return the merged array and total inversions\n        return merged, left_inv + right_inv + merge_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        \n        # Merge smaller elements first and count inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        \n        # Append the remaining elements, if any\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n\n    _, inversions = mergeSort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in a given array.\n\n    An inversion is a pair of elements in the array that are out of their \n    natural order, i.e., a larger element appears before a smaller element.\n\n    :param arr: Input list of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_and_count(left, right):\n        # Merge two sorted lists and count inversions\n        result = []\n        i, j = 0, 0\n        inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                inv_count += len(left) - i  # Increment by the remaining in left\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n\n    def merge_sort_and_count(arr):\n        # Recursive merge sort with inversion counting\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        return merged, (inv_left + inv_right + inv_merge)\n\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n\n    Args:\n    - arr (list): The input list of integers.\n\n    Returns:\n    - int: The total number of inversions in the array.\n\n    Example:\n    >>> get_Inv_Count([1,20,6,4,5])\n    5\n    \"\"\"\n    def merge_and_count(left, right):\n        \"\"\"Merge two sorted lists and count inversions.\"\"\"\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Increment for each inversion\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    def merge_sort_and_count(arr):\n        \"\"\"Sort the array using merge sort and count inversions.\"\"\"\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv = merge_sort_and_count(arr[:mid])\n        right, right_inv = merge_sort_and_count(arr[mid:])\n        merged, merged_inv = merge_and_count(left, right)\n        return merged, left_inv + right_inv + merged_inv\n\n    _, inversions = merge_sort_and_count(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in a given array.\n    \n    An inversion is a pair of elements in the array that are out of order, \n    i.e., a larger element appears before a smaller element.\n\n    :param arr: The input array to count inversions in.\n    :type arr: list\n    :return: The total number of inversions in the array.\n    :rtype: int\n    \"\"\"\n    def merge_and_count(left, right):\n        # Initialize variables to store merged array and inversion count\n        merged = []\n        inv_count = 0\n        \n        # Initialize indices for left and right subarrays\n        left_index = right_index = 0\n        \n        # Merge smaller elements first, counting inversions\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                inv_count += len(left) - left_index  # Increment by the remaining in left\n                right_index += 1\n        \n        # Append any remaining elements\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        \n        return merged, inv_count\n    \n    def merge_sort(arr):\n        # Base case: If array has 1 or fewer elements, it's already sorted\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Split array into two halves\n        mid = len(arr) // 2\n        left, left_inv = merge_sort(arr[:mid])\n        right, right_inv = merge_sort(arr[mid:])\n        \n        # Merge the halves, counting inversions\n        merged, merge_inv = merge_and_count(left, right)\n        \n        # Return merged array and total inversion count\n        return merged, left_inv + right_inv + merge_inv\n    \n    # Call the merge sort variant to get the inversion count\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n    \n    An inversion is a pair of elements in the array that are in the wrong order, \n    i.e., a larger element appears before a smaller element.\n    \n    Args:\n        arr (list): The input list of integers.\n    \n    Returns:\n        int: The total number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has 1 or fewer elements, it's already sorted\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Divide the array into two halves\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        \n        # Merge the two sorted halves and count inversions\n        merged, inv_merge = merge(left, right)\n        \n        # Total inversions = left subtree inversions + right subtree inversions + merge inversions\n        return merged, inv_left + inv_right + inv_merge\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        \n        # Merge smaller elements first\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                # If an element from the right is smaller, all remaining left elements are inversions\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        \n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n\n    Args:\n    - arr (list): The input list of integers.\n\n    Returns:\n    - int: The number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has 1 or 0 elements, it is already sorted and has no inversions.\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Split the array into two halves.\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        \n        # Merge the halves and count inversions.\n        merged, inv_merge = merge(left, right)\n        \n        # Return the merged array and the total inversion count.\n        return merged, inv_left + inv_right + inv_merge\n\n    def merge(left, right):\n        merged = []\n        i, j = 0, 0\n        inv_count = 0\n        \n        # Merge smaller elements first, counting inversions.\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        \n        # Append the remaining elements, if any.\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n\n    Args:\n    - arr (list): The input list of integers.\n\n    Returns:\n    - int: The number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has one or zero elements, it's already sorted\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Split the array into two halves\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        \n        # Merge the halves and count inversions\n        merged, inv_merge = merge(left, right)\n        \n        # Return the merged array and total inversions\n        return merged, inv_left + inv_right + inv_merge\n\n    def merge(left, right):\n        result = []\n        i, j = 0, 0\n        inv_count = 0\n        \n        # Merge smaller elements first, counting inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                inv_count += len(left) - i  # Increment inversion count\n                j += 1\n        \n        # Append the remaining elements, if any\n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n    \n    An inversion is a pair of elements in the array that are out of their natural order, \n    i.e., a larger element appears before a smaller element.\n\n    Args:\n        arr (list): The input array to count inversions in.\n\n    Returns:\n        int: The total number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has 1 or fewer elements, it's already sorted\n        if len(arr) <= 1:\n            return arr, 0\n\n        # Divide the array into two halves\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n\n        # Merge the halves and count inversions\n        merged, inv_merge = merge(left, right)\n\n        return merged, inv_left + inv_right + inv_merge\n\n    def merge(left, right):\n        merged = []\n        inv_count = 0\n        left_index = right_index = 0\n\n        # Merge smaller elements first\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                inv_count += len(left) - left_index  # Inversion count\n                right_index += 1\n\n        # If there are remaining elements in either the left or the right\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n\n        return merged, inv_count\n\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in a given array.\n    \n    An inversion is a pair of elements in the array that are out of their natural order, \n    i.e., a larger element appears before a smaller element.\n\n    Args:\n        arr (list): The input list of integers.\n\n    Returns:\n        int: The total number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has one or zero elements, it's already sorted.\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Split the array into two halves.\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n        \n        # Recursively count inversions in both halves.\n        left, inv_left = merge_sort(left_half)\n        right, inv_right = merge_sort(right_half)\n        \n        # Merge the sorted halves and count inversions between them.\n        merged, inv_merge = merge(left, right)\n        \n        # Return the merged array and the total inversion count.\n        return merged, inv_left + inv_right + inv_merge\n\n    def merge(left, right):\n        merged = []\n        inv_count = 0\n        i = j = 0\n        \n        # Merge smaller elements first, counting inversions.\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Inversion found\n                j += 1\n        \n        # Append the remaining elements, if any.\n        merged += left[i:]\n        merged += right[j:]\n        \n        return merged, inv_count\n\n    # Call the merge sort function to get the inversion count.\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n\n    An inversion is a pair of elements in the array that are in the wrong order,\n    i.e., a larger element appears before a smaller element.\n\n    :param arr: The input list of integers.\n    :return: The number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has 1 or fewer elements, it is already sorted\n        if len(arr) <= 1:\n            return arr, 0\n\n        # Divide the array into two halves\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n\n        # Merge the two halves and count inversions\n        merged, inv_merge = merge(left, right)\n\n        return merged, inv_left + inv_right + inv_merge\n\n    def merge(left, right):\n        result = []\n        inv_count = 0\n        i, j = 0, 0\n\n        # Merge smaller elements first, counting inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                inv_count += len(left) - i  # Inversion detected\n                j += 1\n\n        # Append the remaining elements, if any\n        result.extend(left[i:])\n        result.extend(right[j:])\n\n        return result, inv_count\n\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n    \n    Args:\n        arr (list): Input list of integers.\n    \n    Returns:\n        int: Number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has 1 or fewer elements, it's already sorted, and there are no inversions.\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Divide the array into two halves.\n        mid = len(arr) // 2\n        left, left_inv = merge_sort(arr[:mid])\n        right, right_inv = merge_sort(arr[mid:])\n        \n        # Merge the halves and count inversions.\n        merged, merged_inv = merge(left, right)\n        \n        # Total inversions = Left subarray inversions + Right subarray inversions + Merged inversions.\n        return merged, left_inv + right_inv + merged_inv\n    \n    def merge(left, right):\n        merged = []\n        inv_count = 0\n        i = j = 0\n        \n        # Merge smaller elements first and count inversions.\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Inversion: all remaining in left are greater.\n                j += 1\n        \n        # Append any remaining elements.\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n    \n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in a given array.\n\n    An inversion is a pair of elements in the array that are out of their natural order,\n    i.e., a larger element appears before a smaller element.\n\n    :param arr: The input list of integers.\n    :return: The total count of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has 1 or 0 elements, it is already sorted\n        if len(arr) <= 1:\n            return arr, 0\n\n        # Divide the array into two halves\n        mid = len(arr) // 2\n        left_half, left_inv = merge_sort(arr[:mid])\n        right_half, right_inv = merge_sort(arr[mid:])\n\n        # Merge the two halves and count inversions\n        merged, merged_inv = merge(left_half, right_half)\n\n        return merged, left_inv + right_inv + merged_inv\n\n    def merge(left, right):\n        merged = []\n        inv_count = 0\n        left_index = right_index = 0\n\n        # Merge smaller elements first, count inversions\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                inv_count += len(left) - left_index  # Inversion detected\n                right_index += 1\n\n        # Append the remaining elements, if any\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n\n        return merged, inv_count\n\n    # Perform merge sort and count inversions\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in a given array.\n    \n    An inversion is a pair of elements in the array that are out of their natural order, \n    i.e., a larger element appears before a smaller element.\n    \n    :param arr: Input array to count inversions in.\n    :return: Number of inversions in the array.\n    \"\"\"\n    def merge_and_count(arr, left, mid, right):\n        # Merge subarrays and count inversions\n        left_arr, right_arr = arr[left:mid+1], arr[mid+1:right+1]\n        i = j = inv_count = 0\n        k = left\n        \n        while i < len(left_arr) and j < len(right_arr):\n            if left_arr[i] <= right_arr[j]:\n                arr[k] = left_arr[i]\n                i += 1\n            else:\n                arr[k] = right_arr[j]\n                inv_count += len(left_arr) - i  # Count inversions\n                j += 1\n            k += 1\n        \n        # Copy remaining elements, if any\n        while i < len(left_arr):\n            arr[k] = left_arr[i]\n            i += 1\n            k += 1\n        while j < len(right_arr):\n            arr[k] = right_arr[j]\n            j += 1\n            k += 1\n        \n        return inv_count\n\n    def merge_sort_and_count(arr, left, right):\n        # Base case: If array has 1 or 0 elements, it's already sorted, so no inversions.\n        if left >= right:\n            return 0\n        \n        mid = (left + right) // 2\n        inv_left = merge_sort_and_count(arr, left, mid)\n        inv_right = merge_sort_and_count(arr, mid + 1, right)\n        \n        # Merge and count inversions across the two sorted halves\n        inv_merge = merge_and_count(arr, left, mid, right)\n        \n        return inv_left + inv_right + inv_merge\n\n    # Entry point for the inversion count\n    return merge_sort_and_count(arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n\n    :param arr: List of integers\n    :return: Number of inversions\n    \"\"\"\n    def merge_and_count(left, right):\n        \"\"\"Merges two sorted lists and counts inversions.\"\"\"\n        merged = []\n        inv_count = 0\n        i = j = 0\n\n        # Merge smaller elements first, count inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Increment by remaining in left\n                j += 1\n\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged, inv_count\n\n    def sort_and_count(arr):\n        \"\"\"Sorts array and counts inversions using merge sort.\"\"\"\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = sort_and_count(arr[:mid])\n        right, inv_right = sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        return merged, inv_left + inv_right + inv_merge\n\n    _, inversions = sort_and_count(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n\n    Args:\n    - arr (list): The input list of integers.\n\n    Returns:\n    - int: The total number of inversions in the array.\n    \"\"\"\n    def merge_and_count(left, right):\n        result = []\n        count = 0\n        i, j = 0, 0\n        left_len, right_len = len(left), len(right)\n        \n        while i < left_len and j < right_len:\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                count += left_len - i  # Increment for each inversion\n                j += 1\n                \n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, count\n\n    def sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_count = sort_and_count(arr[:mid])\n        right, right_count = sort_and_count(arr[mid:])\n        merged, merged_count = merge_and_count(left, right)\n        return merged, left_count + right_count + merged_count\n\n    _, inv_count = sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n    \n    Args:\n        arr (list): A list of integers.\n    \n    Returns:\n        int: The number of inversions in the array.\n    \"\"\"\n    def merge_and_count(left, right):\n        # Initialize variables to store merged array and inversion count\n        merged = []\n        inv_count = 0\n        \n        # Initialize indices for left and right subarrays\n        left_index = 0\n        right_index = 0\n        \n        # Merge smaller elements first, counting inversions\n        while left_index < len(left) and right_index < len(right):\n            if left[left_index] <= right[right_index]:\n                merged.append(left[left_index])\n                left_index += 1\n            else:\n                merged.append(right[right_index])\n                inv_count += len(left) - left_index  # Increment for each inversion\n                right_index += 1\n        \n        # Append any remaining elements\n        merged.extend(left[left_index:])\n        merged.extend(right[right_index:])\n        \n        return merged, inv_count\n    \n    def merge_sort_and_count(arr):\n        # Base case: If array has 1 or fewer elements, it's already sorted\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Split array into two halves\n        mid = len(arr) // 2\n        left, left_inv = merge_sort_and_count(arr[:mid])\n        right, right_inv = merge_sort_and_count(arr[mid:])\n        \n        # Merge and count inversions\n        merged, merged_inv = merge_and_count(left, right)\n        \n        # Return merged array and total inversion count\n        return merged, left_inv + right_inv + merged_inv\n    \n    # Call the recursive merge sort and inversion counter\n    _, inversions = merge_sort_and_count(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n\n    Args:\n        arr (list): The input list of integers.\n\n    Returns:\n        int: The total count of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the array has 1 or fewer elements, it's already sorted, and there are no inversions.\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Divide the array into two halves.\n        mid = len(arr) // 2\n        left, left_inv = merge_sort(arr[:mid])\n        right, right_inv = merge_sort(arr[mid:])\n        \n        # Merge the two halves and count inversions.\n        merged, merged_inv = merge(left, right)\n        \n        # Return the merged array and the total inversion count.\n        return merged, left_inv + right_inv + merged_inv\n\n    def merge(left, right):\n        result = []\n        inv_count = 0\n        i, j = 0, 0\n        \n        # Merge smaller elements first and count inversions.\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        \n        # Append the remaining elements of left and right, if any.\n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n\n    # Call the merge sort function to sort and count inversions.\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in a given array.\n    \n    An inversion is a pair of elements in the array that are out of their natural order, \n    i.e., a larger element appears before a smaller element.\n    \n    Args:\n        arr (list): The input list of integers.\n    \n    Returns:\n        int: The total number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        return merged, inv_left + inv_right + inv_merge\n\n    def merge(left, right):\n        result = []\n        i, j = 0, 0\n        inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                inv_count += len(left) - i  # Increment inversion count\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv_count\n\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the given array.\n    \n    An inversion is a pair of elements in the array such that \n    the first element is greater than the second element.\n\n    :param arr: Input list of integers\n    :return: Number of inversions in the array\n    \"\"\"\n    def merge_sort(arr):\n        # Base case: If the length of the array is 1 or less, return the array (since it's already sorted)\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Divide the array into two halves\n        mid = len(arr) // 2\n        left, left_inv = merge_sort(arr[:mid])\n        right, right_inv = merge_sort(arr[mid:])\n        \n        # Merge the two halves and count inversions\n        merged, merge_inv = merge(left, right)\n        \n        # Return the merged array and total inversions\n        return merged, (left_inv + right_inv + merge_inv)\n\n    def merge(left, right):\n        result = []\n        inv_count = 0\n        i, j = 0, 0\n        \n        # Merge smaller elements first and count inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                inv_count += len(left) - i  # Inversion count for each element in right that goes before elements in left\n                j += 1\n        \n        # Append any remaining elements\n        result.extend(left[i:])\n        result.extend(right[j:])\n        \n        return result, inv_count\n\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 87.75862068965517, "dps_norm": 65.0, "pass@1": 65.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the n largest products from all possible products of one element from list1 and one from list2.\n\n    Args:\n        list1 (list): The first list of numbers.\n        list2 (list): The second list of numbers.\n        n (int): The number of largest products to return.\n\n    Returns:\n        list: A list of the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    all_products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the n largest\n    largest_n_products = sorted(all_products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Parameters:\n    - `list1` (list): The first list of numbers.\n    - `list2` (list): The second list of numbers.\n    - `n` (int): The number of largest products to return.\n\n    Returns:\n    - `list`: A list of the `n` largest products, in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the n largest\n    largest_n_products = sorted(products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists, selecting one factor from each.\n\n    :param list1: The first list of numbers.\n    :param list2: The second list of numbers.\n    :param n: The number of largest products to find.\n    :return: A list of the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the n largest\n    largest_n_products = sorted(products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists.\n\n    Parameters:\n    - list1 (list): The first list of numbers.\n    - list2 (list): The second list of numbers.\n    - n (int): The number of largest products to return.\n\n    Returns:\n    - list: A list of the n largest products, in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x*y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the n largest\n    largest_n_products = sorted(products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Returns the n largest products from all possible products of one element \n    from list1 and one element from list2, in descending order.\n\n    :param list1: The first list of numbers.\n    :param list2: The second list of numbers.\n    :param n: The number of largest products to return.\n    :return: A list of the n largest products.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the n largest\n    largest_n_products = sorted(products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "import heapq\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists.\n\n    Args:\n    - list1 (List[int]): The first list of numbers.\n    - list2 (List[int]): The second list of numbers.\n    - n (int): The number of largest products to find.\n\n    Returns:\n    - List[int]: A list of the n largest products, in descending order.\n    \"\"\"\n    \n    # Use heapq.nlargest to find the n largest products\n    # The key function calculates the product for each pair of numbers\n    # We iterate over all pairs of numbers from list1 and list2\n    largest_products = heapq.nlargest(n, \n                                      (x * y for x in list1 for y in list2), \n                                      key=lambda x: x)\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "import heapq\nfrom itertools import product\ndef large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Parameters:\n    - list1 (list): The first list of numbers.\n    - list2 (list): The second list of numbers.\n    - n (int): The number of largest products to find.\n\n    Returns:\n    - list: A list of the 'n' largest products.\n    \"\"\"\n    # Generate all possible products\n    all_products = [x * y for x, y in product(list1, list2)]\n    \n    # Use a heap to find the n largest products efficiently\n    return heapq.nlargest(n, all_products)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the 'n' largest products from two lists by selecting one factor from each list.\n\n    Parameters:\n    - list1 (list): First list of numbers.\n    - list2 (list): Second list of numbers.\n    - n (int): Number of largest products to find.\n\n    Returns:\n    - list: A list of the 'n' largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x*y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the 'n' largest\n    largest_n_products = sorted(products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Compute the specified number of largest products from two given lists.\n    \n    Parameters:\n    list1 (list): The first list of numbers.\n    list2 (list): The second list of numbers.\n    n (int): The number of largest products to find.\n    \n    Returns:\n    list: A list of the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the n largest\n    largest_n_products = sorted(products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "import heapq\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n    - list1 (List[int]): The first list of integers.\n    - list2 (List[int]): The second list of integers.\n    - n (int): The number of largest products to return.\n\n    Returns:\n    - List[int]: A list of the n largest products, in descending order.\n    \"\"\"\n    # Use a list comprehension to generate all possible products\n    all_products = [x * y for x in list1 for y in list2]\n    \n    # Use heapq.nlargest to find the n largest products\n    largest_n_products = heapq.nlargest(n, all_products)\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Returns the n largest products by selecting one factor from each list.\n\n    :param list1: First list of numbers.\n    :param list2: Second list of numbers.\n    :param n: Number of largest products to find.\n    :return: List of the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort products in descending order and select the n largest\n    largest_n_products = sorted(products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "import heapq\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the n largest products from two lists.\n\n    Args:\n    - list1 (List[int]): The first list of numbers.\n    - list2 (List[int]): The second list of numbers.\n    - n (int): The number of largest products to return.\n\n    Returns:\n    - List[int]: A list of the n largest products.\n    \"\"\"\n    # Use a min heap to keep track of the n largest products seen so far\n    min_heap = []\n    seen = set()  # To avoid duplicate products due to duplicate numbers in lists\n\n    # Generate all possible products and push them onto the heap\n    for num1 in list1:\n        for num2 in list2:\n            product = num1 * num2\n            # Check to avoid duplicates\n            if (num1, num2) not in seen:\n                seen.add((num1, num2))\n                # Push the product onto the heap. If heap size exceeds n, \n                # the smallest product will be automatically removed\n                if len(min_heap) < n:\n                    heapq.heappush(min_heap, product)\n                else:\n                    heapq.heappushpop(min_heap, product)\n\n    # The heap now contains the n largest products, but in ascending order. \n    # We want them in descending order, so we pop and reverse\n    return sorted(min_heap, reverse=True)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Returns the n largest products from all possible products of one element from list1 and one from list2.\n\n    Args:\n    - list1 (list): The first list of numbers.\n    - list2 (list): The second list of numbers.\n    - n (int): The number of largest products to return.\n\n    Returns:\n    - list: A list of the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the n largest\n    largest_n_products = sorted(products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the 'n' largest products by selecting one factor from each list.\n\n    Parameters:\n    - list1 (list): The first list of numbers.\n    - list2 (list): The second list of numbers.\n    - n (int): The number of largest products to find.\n\n    Returns:\n    - list: A list of the 'n' largest products in descending order.\n    \"\"\"\n    # Generate all possible products and store them in a list of tuples along with their values\n    products = [(x*y, x, y) for x in list1 for y in list2]\n    \n    # Sort the products in descending order based on their values\n    products.sort(reverse=True)\n    \n    # Return the 'n' largest unique products (in case of duplicates, this ensures uniqueness by factor pair)\n    seen = set()\n    result = []\n    for product, _, _ in products:\n        if len(result) < n:\n            if product not in seen:\n                seen.add(product)\n                result.append(product)\n        else:\n            break\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "import heapq\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n    - list1 (List[int]): The first list of numbers.\n    - list2 (List[int]): The second list of numbers.\n    - n (int): The number of largest products to return.\n\n    Returns:\n    - List[int]: A list of the n largest products in descending order.\n    \"\"\"\n    # Use heapq.nlargest to find the n largest products efficiently\n    # The key function calculates the product of each pair of numbers\n    # We iterate over all pairs of numbers from list1 and list2\n    largest_products = heapq.nlargest(n, \n                                      (x*y for x in list1 for y in list2), \n                                      key=None)\n    \n    return largest_products", "matching_cluster_idx": 4}, {"solution": "import heapq\nimport itertools\ndef large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products from two lists, selecting one factor from each.\n\n    :param list1: First list of numbers\n    :param list2: Second list of numbers\n    :param n: Number of largest products to find\n    :return: List of the n largest products in descending order\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x, y in itertools.product(list1, list2)]\n    \n    # Use a heap to efficiently find the n largest elements\n    return heapq.nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the n largest products by selecting one factor from each of the input lists.\n\n    Args:\n        list1 (list): The first list of numbers.\n        list2 (list): The second list of numbers.\n        n (int): The number of largest products to find.\n\n    Returns:\n        list: A list of the n largest products, in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the n largest\n    largest_n_products = sorted(products, reverse=True)[:n]\n    \n    return largest_n_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n\n    Args:\n        list1 (list): The first list of numbers.\n        list2 (list): The second list of numbers.\n        n (int): The number of largest products to find.\n\n    Returns:\n        list: A list of the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products and store them in a list along with their factors for tracking (if needed)\n    products = [(x*y, x, y) for x in list1 for y in list2]\n    \n    # Sort the products in descending order based on the product value\n    products.sort(key=lambda x: x[0], reverse=True)\n    \n    # Return the n largest products (product values only, as per the unit test's expectation)\n    return [product[0] for product in products[:n]]", "matching_cluster_idx": 2}, {"solution": "import heapq\nfrom typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    \"\"\"\n    Finds the specified number of largest products from two given lists, \n    selecting one factor from each list.\n\n    Args:\n    list1 (List[int]): The first list of numbers.\n    list2 (List[int]): The second list of numbers.\n    n (int): The number of largest products to find.\n\n    Returns:\n    List[int]: A list of the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products and store them in a list of tuples (product, num_from_list1, num_from_list2)\n    products = [(x*y, x, y) for x in list1 for y in list2]\n    \n    # Use a heap to find the n largest products efficiently\n    largest_n_products = heapq.nlargest(n, products)\n    \n    # Return only the products (first element of each tuple) in descending order\n    return [product[0] for product in largest_n_products]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number (n) of largest products from two given lists.\n    \n    Parameters:\n    - list1 (list): The first list of numbers.\n    - list2 (list): The second list of numbers.\n    - n (int): The number of largest products to find.\n    \n    Returns:\n    - list: A list of the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products from the two lists\n    all_products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and select the n largest\n    n_largest_products = sorted(all_products, reverse=True)[:n]\n    \n    return n_largest_products", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 98.05164319248826, "dps_norm": 99.61538461538461, "pass@1": 48.0, "profiled": [{"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Find the maximum sum possible by using the given equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n\n    Args:\n        n (int): The input number for the equation\n        memo (dict, optional): Memoization dictionary to store intermediate results. Defaults to {}.\n\n    Returns:\n        int: The maximum sum possible\n    \"\"\"\n    # Base case: If n is 0 or less, return 0 since we can't divide further\n    if n <= 0:\n        return 0\n    \n    # If n is already in memo, return the stored result to avoid recalculating\n    if n in memo:\n        return memo[n]\n    \n    # Calculate the sum for n/2, n/3, n/4, and n/5, considering only integer divisions\n    sum_half   = get_max_sum(n // 2, memo)\n    sum_third  = get_max_sum(n // 3, memo)\n    sum_fourth = get_max_sum(n // 4, memo)\n    sum_fifth  = get_max_sum(n // 5, memo)\n    \n    # Store the maximum sum in memo for n\n    memo[n] = max(n, sum_half + sum_third + sum_fourth + sum_fifth)\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculates the maximum sum possible using the equation f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n)\n\n    Args:\n    - `n`: Positive integer for which to calculate the maximum sum.\n    - `memo` (optional): Dictionary for memoization. Defaults to an empty dictionary.\n\n    Returns:\n    - The maximum sum possible for the given `n`.\n    \"\"\"\n    # Base case: if n is in memo, return the memoized value\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is 0 or less, the maximum sum is 0\n    if n <= 0:\n        return 0\n    \n    # Base case: if n is 1, the maximum sum is 1 (since f(1) = 1 in this context)\n    if n == 1:\n        return 1\n    \n    # Calculate sums for all divisions\n    sum_div_2 = n // 2 > 0 and get_max_sum(n // 2, memo) or 0\n    sum_div_3 = n // 3 > 0 and get_max_sum(n // 3, memo) or 0\n    sum_div_4 = n // 4 > 0 and get_max_sum(n // 4, memo) or 0\n    sum_div_5 = n // 5 > 0 and get_max_sum(n // 5, memo) or 0\n    \n    # The maximum sum is the maximum of the sum of the divisions and n itself\n    max_sum = max(n, sum_div_2 + sum_div_3 + sum_div_4 + sum_div_5)\n    \n    # Memoize the result\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Recursive function with memoization to optimize performance.\n\n    Parameters:\n    - `n` (int): Input number.\n    - `memo` (dict, optional): Memoization dictionary. Defaults to {}.\n\n    Returns:\n    - `int`: Maximum sum possible.\n    \"\"\"\n    # Base case: If n is 0 or already in memo, return the stored result\n    if n == 0 or n in memo:\n        return memo.get(n, 0)  # Return 0 if n is 0, otherwise return the memoized value\n\n    # Calculate divisions (integer division to match the problem's implicit intention)\n    div_2, div_3, div_4, div_5 = n // 2, n // 3, n // 4, n // 5\n\n    # Recursively calculate the maximum sum for each division and choose the maximum between the sum of those and `n`\n    max_sum = max(\n        n,  # Choose `n` as is\n        get_max_sum(div_2, memo) + get_max_sum(div_3, memo) + get_max_sum(div_4, memo) + get_max_sum(div_5, memo)\n    )\n\n    # Store the result in memo to avoid repeated calculations\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculates the maximum sum possible by applying the function f(n) recursively.\n\n    :param n: Input number for the function f(n)\n    :type n: int\n    :param memo: Dictionary for memoization to optimize recursive calls\n    :type memo: dict\n    :return: Maximum sum for the given input number\n    :rtype: int\n    \"\"\"\n    # Base case: If n is already in memo, return the stored result\n    if n in memo:\n        return memo[n]\n    \n    # Base case: If n is 0 or negative, return 0 since no more divisions are possible\n    if n <= 0:\n        return 0\n    \n    # Calculate the maximum sum by recursively applying f(n) to divisions of n\n    # and store it in memo to avoid redundant calculations\n    memo[n] = max(\n        n,  # Choose n itself as an option\n        get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo)\n    )\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    ### Parameters:\n    - `n`: Input number\n    - `memo`: Dictionary to store results for memoization (default is an empty dictionary)\n    \n    ### Returns:\n    - Maximum sum possible using the given equation\n    \"\"\"\n    # Base case: If n is 0 or less, return 0\n    if n <= 0:\n        return 0\n    \n    # Check if result is already memoized\n    if n in memo:\n        return memo[n]\n    \n    # Recursive case: Calculate f(n) by considering the maximum of n and the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    # Note: We use integer division (//) to ensure n/2, n/3, n/4, and n/5 are integers since the function definition implies integer inputs\n    result = max(\n        n, \n        get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo)\n    )\n    \n    # Memoize the result\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculate the maximum sum possible using the function f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Args:\n    - n (int): Input number\n    - memo (dict): Memoization dictionary to optimize recursive calls (default is an empty dictionary)\n    \n    Returns:\n    - int: Maximum sum possible\n    \"\"\"\n    # Base case: If n is 0 or already computed, return the stored result\n    if n < 1:\n        return 0\n    if n in memo:\n        return memo[n]\n    \n    # Recursive case: Compute f(n) by trying all possible divisions and storing the maximum result\n    divisions = [n//2, n//3, n//4, n//5]\n    results = [get_max_sum(div, memo) for div in divisions if div > 0]\n    max_div_sum = sum(results) if results else 0  # Handle case where n is not divisible by 2, 3, 4, or 5\n    \n    # Store and return the maximum of the current number and the sum of divisions\n    memo[n] = max(n, max_div_sum)\n    return memo[n]", "matching_cluster_idx": 11}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculate the maximum sum using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Args:\n    n (int): The input number for the equation.\n    memo (dict): Memoization dictionary to store previously computed values. Defaults to {}.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    # Base case: If n is 0 or less, return 0 since we cannot divide further\n    if n <= 0:\n        return 0\n    \n    # If the result is already in the memo, return it to avoid redundant computation\n    if n in memo:\n        return memo[n]\n    \n    # Calculate the sums for dividing n by 2, 3, 4, and 5, considering only integer divisions\n    sum_half   = n // 2 > 0 and get_max_sum(n // 2, memo) or 0\n    sum_third  = n // 3 > 0 and get_max_sum(n // 3, memo) or 0\n    sum_fourth = n // 4 > 0 and get_max_sum(n // 4, memo) or 0\n    sum_fifth  = n // 5 > 0 and get_max_sum(n // 5, memo) or 0\n    \n    # Store the maximum sum in the memo before returning it\n    memo[n] = max(n, sum_half + sum_third + sum_fourth + sum_fifth)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Calculates the maximum sum possible for a given number n,\n    using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Args:\n    n (int): The input number.\n    memo (dict, optional): Memoization dictionary. Defaults to {}.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    # Base case: Numbers less than or equal to 1 can't be divided further\n    if n <= 1:\n        return n\n    \n    # Check if result is already memoized\n    if n in memo:\n        return memo[n]\n    \n    # Calculate divisions while ignoring remainder (integer division)\n    div_2, div_3, div_4, div_5 = n//2, n//3, n//4, n//5\n    \n    # Recursively calculate sums for divisions and compare with n\n    max_sum = max(n, \n                  get_max_sum(div_2, memo) + get_max_sum(div_3, memo) + \n                  get_max_sum(div_4, memo) + get_max_sum(div_5, memo))\n    \n    # Memoize the result\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculate the maximum sum using the recursive equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Args:\n    - n (int): Input number for the equation\n    - memo (dict, optional): Dictionary for memoization to optimize performance. Defaults to {}.\n    \n    Returns:\n    - int: The maximum sum possible for the given input number\n    \"\"\"\n    # Base case: If n is 0 or less, return 0 since we can't divide further\n    if n <= 0:\n        return 0\n    \n    # Check if result is already memoized\n    if n in memo:\n        return memo[n]\n    \n    # Calculate sums for all divisions\n    sum_div_2 = n // 2 > 0 and get_max_sum(n // 2, memo) or 0\n    sum_div_3 = n // 3 > 0 and get_max_sum(n // 3, memo) or 0\n    sum_div_4 = n // 4 > 0 and get_max_sum(n // 4, memo) or 0\n    sum_div_5 = n // 5 > 0 and get_max_sum(n // 5, memo) or 0\n    \n    # Store the maximum sum in memo before returning it\n    memo[n] = max(n, sum_div_2 + sum_div_3 + sum_div_4 + sum_div_5)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    This function calculates the maximum sum possible using the given equation.\n    \n    Parameters:\n    n (int): Input number\n    memo (dict): Memoization dictionary to store results for subproblems (default is an empty dictionary)\n    \n    Returns:\n    int: Maximum sum\n    \"\"\"\n    # Base case: If n is 0 or already in memo, return the stored result\n    if n in memo or n == 0:\n        return memo.get(n, 0)\n    \n    # Calculate the maximum sum by recursively applying the given equation\n    # and store the result in the memo dictionary\n    else:\n        result = max(n, \n                     get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo))\n        memo[n] = result  # Store the result in memo\n        return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Computes the maximum sum possible for a given number `n` \n    using the equation `f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)`\n    \n    Args:\n        n (int): Input number\n        memo (dict, optional): Memoization dictionary. Defaults to {}.\n\n    Returns:\n        int: Maximum sum possible\n    \"\"\"\n    # Base case: If n is already in the memo dictionary, return its value\n    if n in memo:\n        return memo[n]\n    \n    # Base case: If n is 0 or less, the maximum sum is 0\n    if n <= 0:\n        return 0\n    \n    # Base case: If n is 1, the maximum sum is 1 (since we can't divide 1 further)\n    if n == 1:\n        return 1\n    \n    # Compute the maximum sum by considering all possible divisions\n    # and store it in the memo dictionary to avoid repeated computations\n    memo[n] = max(\n        n,  # Consider n itself as an option\n        get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + \n        get_max_sum(n//4, memo) + get_max_sum(n//5, memo)\n    )\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    This function calculates the maximum sum possible using the given equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Args:\n    n (int): The input number.\n    memo (dict, optional): Dictionary for memoization. Defaults to {}.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    # Base case: If n is 0 or less, return 0\n    if n <= 0:\n        return 0\n    \n    # If the result is already in memo, return it\n    if n in memo:\n        return memo[n]\n    \n    # Calculate the maximum sum by considering two options: either use the current number 'n' as is, \n    # or recursively calculate the sum for n/2, n/3, n/4, and n/5 and sum them up\n    max_sum = n  # Default option is to use 'n' as is\n    max_sum = max(max_sum, \n                  get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo)\n                 )\n    \n    # Store the result in memo\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n: int) -> int:\n    \"\"\"\n    Calculates the maximum sum possible using the given equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The maximum sum.\n    \"\"\"\n    @lru_cache(maxsize=None)  # Memoization for optimization\n    def f(n):\n        if n < 2:  # Base case: when n is less than 2, return n\n            return n\n        # Calculate f(n/2), f(n/3), f(n/4), f(n/5) and sum them up, \n        # then compare with n to find the maximum\n        sum_divisions = sum(\n            f(n // divisor) for divisor in [2, 3, 4, 5] if n // divisor > 0\n        )\n        return max(sum_divisions, n)\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculate the maximum sum possible using the given recursive equation.\n    \n    Args:\n    - n (int): The input number.\n    - memo (dict, optional): Memoization dictionary for optimization. Defaults to {}.\n    \n    Returns:\n    - int: The maximum sum possible.\n    \"\"\"\n    # Base case: If n is 0 or less, return 0\n    if n <= 0:\n        return 0\n    \n    # If result is already in memo, return it\n    if n in memo:\n        return memo[n]\n    \n    # Calculate the sum of divisions and compare with n\n    divisions_sum = 0\n    for divisor in [2, 3, 4, 5]:\n        if n >= divisor:\n            divisions_sum += get_max_sum(n // divisor, memo)\n    \n    # Store the maximum of the current number and the divisions sum in memo\n    memo[n] = max(n, divisions_sum)\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Computes the maximum sum possible using the given recursive equation.\n\n    :param n: Input number\n    :param memo: Dictionary for memoization (default is an empty dictionary)\n    :return: Maximum sum\n    \"\"\"\n    # Base case: if n is 0 or less, return 0\n    if n <= 0:\n        return 0\n    \n    # If result is already computed, return from memo\n    if n in memo:\n        return memo[n]\n    \n    # Compute f(n/2), f(n/3), f(n/4), f(n/5) and sum them up\n    # Use integer division (//) to ensure divisions result in whole numbers\n    sum_of_fractions = (\n        get_max_sum(n // 2, memo) + \n        get_max_sum(n // 3, memo) + \n        get_max_sum(n // 4, memo) + \n        get_max_sum(n // 5, memo)\n    )\n    \n    # Store the max of the sum of fractions and n in memo and return\n    memo[n] = max(sum_of_fractions, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculates the maximum sum possible using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Args:\n        n (int): The input number.\n        memo (dict, optional): Dictionary for memoization. Defaults to {}.\n    \n    Returns:\n        int: The maximum sum.\n    \"\"\"\n    # Base case: If n is 0 or less, return 0\n    if n <= 0:\n        return 0\n    \n    # If n is already in memo, return the stored result\n    if n in memo:\n        return memo[n]\n    \n    # Calculate sums for n/2, n/3, n/4, n/5, and n itself\n    sum_half   = get_max_sum(n // 2, memo) if n >= 2 else 0\n    sum_third  = get_max_sum(n // 3, memo) if n >= 3 else 0\n    sum_fourth = get_max_sum(n // 4, memo) if n >= 4 else 0\n    sum_fifth  = get_max_sum(n // 5, memo) if n >= 5 else 0\n    sum_n      = n\n    \n    # Store the maximum sum in memo and return it\n    memo[n] = max(sum_half + sum_third + sum_fourth + sum_fifth, sum_n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculate the maximum sum possible using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Args:\n    - n (int): The input number\n    - memo (dict, optional): Memoization dictionary. Defaults to {}.\n    \n    Returns:\n    - int: The maximum sum\n    \"\"\"\n    # Base case: If n is 0 or less, return 0\n    if n <= 0:\n        return 0\n    \n    # If result is already memoized, return it\n    if n in memo:\n        return memo[n]\n    \n    # Calculate the sums for each division\n    sum_div_2 = n // 2 and get_max_sum(n // 2, memo)\n    sum_div_3 = n // 3 and get_max_sum(n // 3, memo)\n    sum_div_4 = n // 4 and get_max_sum(n // 4, memo)\n    sum_div_5 = n // 5 and get_max_sum(n // 5, memo)\n    \n    # Store and return the maximum sum in memo\n    memo[n] = max(n, sum_div_2 + sum_div_3 + sum_div_4 + sum_div_5)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculates the maximum sum possible for a given number n\n    using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Parameters:\n    n (int): The input number\n    memo (dict): Memoization dictionary (used for optimization, default is an empty dictionary)\n    \n    Returns:\n    int: The maximum sum possible\n    \"\"\"\n    # Base case: If n is already in the memo dictionary, return its value\n    if n in memo:\n        return memo[n]\n    \n    # Base case: If n is 0 or less, the maximum sum is 0\n    if n <= 0:\n        return 0\n    \n    # Calculate sums for n/2, n/3, n/4, n/5 (integer division to ensure whole numbers)\n    sums = (\n        get_max_sum(n//2, memo) + \n        get_max_sum(n//3, memo) + \n        get_max_sum(n//4, memo) + \n        get_max_sum(n//5, memo)\n    )\n    \n    # Store the maximum of the calculated sums and n in the memo dictionary\n    memo[n] = max(sums, n)\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n: int) -> int:\n    \"\"\"\n    Calculates the maximum sum using the recursive equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Args:\n        n (int): Input number for which the maximum sum is to be calculated.\n    \n    Returns:\n        int: Maximum sum possible for the given number `n`.\n    \"\"\"\n    @lru_cache(maxsize=None)  # Memoization for optimization\n    def f(n):\n        if n < 2:  # Base case: When n is less than 2, return n\n            return n\n        # Calculate sums for divisions by 2, 3, 4, and 5, and compare with n\n        sums = [f(n//i) for i in [2, 3, 4, 5] if n >= i]\n        return max(n, sum(sums) if sums else n)\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo = {}):\n    \"\"\"\n    Calculates the maximum sum possible using the recursive equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Args:\n    n (int): Input number for the equation\n    memo (dict): Dictionary for memoization (default is an empty dictionary)\n    \n    Returns:\n    int: Maximum sum possible for the given number n\n    \"\"\"\n    # Base case: If n is 0 or less, return 0 since no more divisions can yield a positive sum\n    if n <= 0:\n        return 0\n    \n    # Check if the result for n is already computed (memoization)\n    if n in memo:\n        return memo[n]\n    \n    # Recursive case: Calculate the maximum sum by considering the current number 'n' and the sums of its divisions by 2, 3, 4, and 5\n    divisions_sum = 0\n    for divisor in [2, 3, 4, 5]:\n        if n >= divisor:\n            divisions_sum += get_max_sum(n // divisor, memo)  # Using integer division (//) to ensure whole numbers for recursive calls\n    \n    # Store the maximum between the current number 'n' and the sum of its divisions for future reference\n    memo[n] = max(n, divisions_sum)\n    \n    return memo[n]", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 90.0, "profiled": [{"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Returns the first non-repeating character in a string, or None if all characters repeat.\n\n    Parameters:\n    s (str): The input string to search in.\n\n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists.\n    \"\"\"\n    # Count occurrences of each character\n    char_counts = Counter(s)\n\n    # Iterate over the original string to maintain the original order\n    for char in s:\n        # If a character's count is 1, it's the first non-repeating character, so return it\n        if char_counts[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n    - `s (str)`: The input string.\n\n    Returns:\n    - `str or None`: The first non-repeated character if found, `None` otherwise.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n\n    # Count the frequency of each character\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n\n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n\n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Identifies the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string to search in.\n\n    Returns:\n        str or None: The first non-repeated character, or None if all characters repeat.\n    \"\"\"\n\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n\n    # Count the frequency of each character\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n\n    # Iterate through the string again to find the first non-repeated character\n    for char in s:\n        if char_frequency[char] == 1:\n            return char  # Return the first character with a frequency of 1\n\n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n    - `s (str)`: The input string to search in.\n\n    Returns:\n    - `str or None`: The first non-repeating character if found, otherwise `None`.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # Iterate through the string again to find the first character with frequency 1\n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n    \n    Args:\n    - input_string (str): The input string to search in.\n    \n    Returns:\n    - The first non-repeating character if found, otherwise None.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n    \n    # Count the frequency of each character\n    for char in input_string:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in input_string:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        char_frequency[char] = char_frequency.get(char, 0) + 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Args:\n        s (str): Input string.\n    \n    Returns:\n        str or None: First non-repeated character, or None if all characters repeat.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    # Count the occurrence of each character in the string\n    char_counts = Counter(s)\n    \n    # Iterate over the string to maintain the original order\n    for char in s:\n        # If a character appears only once, return it immediately\n        if char_counts[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        input_string (str): The input string to search for the first non-repeated character.\n\n    Returns:\n        str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    # Count the occurrences of each character in the string\n    char_counts = Counter(input_string)\n    \n    # Iterate over the original string to maintain the character order\n    for char in input_string:\n        # If a character's count is 1, it's the first non-repeating character\n        if char_counts[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        input_string (str): The input string to search in.\n\n    Returns:\n        str or None: The first non-repeated character, or None if all characters repeat.\n    \"\"\"\n    # Count occurrences of each character\n    char_counts = Counter(input_string)\n    \n    # Iterate over the original string to maintain the original order\n    for char in input_string:\n        # If a character appears only once, return it\n        if char_counts[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str or None: The first non-repeated character if exists, otherwise None.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str or None: The first non-repeating character if found, None otherwise.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string to search in.\n    \n    Returns:\n    str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    char_frequency = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        char_frequency[char] = char_frequency.get(char, 0) + 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Identifies the first non-repeated character in a string.\n    \n    Args:\n    - `s (str)`: The input string to search in.\n    \n    Returns:\n    - `str or None`: The first character that does not repeat, or `None` if all characters repeat.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # Iterate through the string again to find the first non-repeated character\n    for char in s:\n        if char_frequency[char] == 1:\n            return char  # Return the first occurrence of a non-repeated character\n    \n    # If the loop completes without finding a non-repeated character, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Identifies the first non-repeating character in a given string.\n\n    Args:\n        s (str): Input string.\n\n    Returns:\n        str or None: First non-repeating character, or None if all characters repeat.\n    \"\"\"\n    # Count occurrences of each character in the string\n    char_count = Counter(s)\n    \n    # Iterate over the original string to maintain the original character order\n    for char in s:\n        # Check if the character count is 1\n        if char_count[char] == 1:\n            # If count is 1, return the character as it's the first non-repeating one\n            return char\n    \n    # If loop completes without finding a non-repeating character, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        input_string (str): The string to search in.\n\n    Returns:\n        str or None: The first non-repeating character, or None if all characters repeat.\n    \"\"\"\n    # Create a dictionary to store characters as keys and their counts as values\n    char_count = {}\n    \n    # Count the occurrence of each character\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate over the original string to maintain the original order\n    for char in input_string:\n        # Return the first character that has a count of 1\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(input_string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Args:\n        input_string (str): The string to search in.\n    \n    Returns:\n        str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    # Count occurrences of each character\n    char_counts = Counter(input_string)\n    \n    # Iterate over the original string to maintain the original character order\n    for char in input_string:\n        # Check if the character count is 1 (non-repeated)\n        if char_counts[char] == 1:\n            # Return the first non-repeated character found\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n        s (str): Input string.\n\n    Returns:\n        str or None: The first non-repeating character if exists, otherwise None.\n    \"\"\"\n    # Count occurrences of each character\n    char_counts = Counter(s)\n    \n    # Iterate over the original string to maintain character order\n    for char in s:\n        # Check if the character count is 1\n        if char_counts[char] == 1:\n            # Return the first non-repeating character found\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n    - s (str): The input string to search in.\n\n    Returns:\n    - str or None: The first non-repeated character, or None if all characters repeat.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_frequency = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        char_frequency[char] = char_frequency.get(char, 0) + 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str or None:\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string to search in.\n\n    Returns:\n        str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    # Create a dictionary to store characters as keys and their counts as values\n    char_count = {}\n    \n    # First pass: Count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass: Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 45.0, "profiled": [{"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n        input_tuple (tuple): The tuple to search in.\n        target_element: The element to search for.\n\n    Returns:\n        bool: True if the target element exists, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tup (tuple): The input tuple to search in.\n        elem: The element to search for.\n\n    Returns:\n        bool: True if elem is found in tup, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n    - input_tuple (tuple): The tuple to search within.\n    - target_element: The element to search for.\n\n    Returns:\n    - bool: True if the target element exists in the tuple, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Checks if an element exists within a given tuple.\n\n    Args:\n        tup (tuple): The tuple to search in.\n        elem: The element to search for.\n\n    Returns:\n        bool: True if elem exists in tup, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        elem: The element to search for.\n\n    Returns:\n        bool: True if elem exists in tup, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n        input_tuple (tuple): The tuple to search in.\n        target_element: The element to search for.\n\n    Returns:\n        bool: True if the target element exists in the tuple, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, target):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The input tuple to search in.\n        target (any): The element to search for.\n\n    Returns:\n        bool: True if target exists in tuplex, False otherwise.\n    \"\"\"\n    return target in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Checks if an element exists within a given tuple.\n    \n    Args:\n        tup (tuple): The tuple to search in.\n        elem: The element to search for.\n    \n    Returns:\n        bool: True if elem exists in tup, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Checks if an element exists within a given tuple.\n    \n    Args:\n        tup (tuple): The tuple to search in.\n        elem: The element to search for.\n    \n    Returns:\n        bool: True if elem is found in tup, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n    - input_tuple (tuple): The tuple to search in.\n    - target_element: The element to search for.\n\n    Returns:\n    - bool: True if the target element exists in the tuple, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n    - `input_tuple` (tuple): The tuple to be searched.\n    - `target_element`: The element to be searched for.\n\n    Returns:\n    - `bool`: True if the target element exists in the tuple, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n        - input_tuple (tuple): The tuple to search in.\n        - target_element: The element to search for.\n\n    Returns:\n        - bool: True if the target element exists in the tuple, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Checks if an element exists within a given tuple.\n\n    Parameters:\n    - tup (tuple): The tuple to search in.\n    - elem: The element to search for.\n\n    Returns:\n    bool: True if elem exists in tup, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n    - `input_tuple` (tuple): The tuple to search within.\n    - `target_element`: The element to search for. Can be of any hashable type.\n\n    Returns:\n    - `bool`: True if `target_element` exists in `input_tuple`, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Checks for the existence of an element within a tuple.\n\n    Args:\n        tup (tuple): The tuple to search in.\n        elem: The element to search for.\n\n    Returns:\n        bool: True if elem is found, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n    - input_tuple (tuple): The tuple to search within.\n    - target_element: The element to search for.\n\n    Returns:\n    - bool: True if the target element is found, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Checks for the existence of an element within a tuple.\n    \n    Args:\n        tup (tuple): The input tuple.\n        elem: The element to search for.\n    \n    Returns:\n        bool: True if elem is in tup, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n        - input_tuple (tuple): The tuple to search in.\n        - target_element: The element to search for.\n\n    Returns:\n        - bool: True if the target element exists, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target_element):\n    \"\"\"\n    Checks if a target element exists within a given tuple.\n\n    Args:\n        - input_tuple (tuple): The tuple to search in.\n        - target_element: The element to search for.\n\n    Returns:\n        - bool: True if the target_element exists in the input_tuple, False otherwise.\n    \"\"\"\n    return target_element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, target):\n    \"\"\"\n    Checks if an element exists within a tuple.\n    \n    Args:\n        tuplex (tuple): Input tuple to search in.\n        target (any): Element to search for.\n    \n    Returns:\n        bool: True if target found, False otherwise.\n    \"\"\"\n    return target in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 66.70807453416148, "dps_norm": 81.11111111111111, "pass@1": 65.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks for overlap between two sequences.\n    \n    Args:\n        seq1 (list or tuple): The first sequence.\n        seq2 (list or tuple): The second sequence.\n    \n    Returns:\n        bool: True if seq1 and seq2 have any elements in common, False otherwise.\n    \"\"\"\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in seq1 exists in seq2.\n    \n    Args:\n        seq1 (list): First sequence to check.\n        seq2 (list): Second sequence to check against.\n    \n    Returns:\n        bool: True if overlap found, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if there are any overlapping values between two sequences.\n\n    Args:\n        - seq1 (list): The first sequence to check.\n        - seq2 (list): The second sequence to check against.\n\n    Returns:\n        - bool: True if there's at least one common element, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks for overlapping values between two sequences.\n    \n    Args:\n        seq1 (list): The first sequence to check.\n        seq2 (list): The second sequence to check against.\n    \n    Returns:\n        bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks for overlap between two sequences.\n\n    Args:\n        - seq1 (list): The first sequence to check.\n        - seq2 (list): The second sequence to check against.\n\n    Returns:\n        - bool: True if any element in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks for overlapping elements between two sequences.\n    \n    Args:\n        seq1 (list): The first sequence to check from.\n        seq2 (list): The second sequence to check against.\n    \n    Returns:\n        bool: True if any element of seq1 is found in seq2, False otherwise.\n    \"\"\"\n    # Convert sequences to sets for efficient lookups\n    set2 = set(seq2)\n    \n    # Iterate over each element in seq1 and check existence in set2\n    for element in seq1:\n        if element in set2:\n            # If an element is found, immediately return True\n            return True\n    \n    # If the loop completes without finding a match, return False\n    return False", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks for overlap between two sequences.\n    \n    Args:\n        seq1 (sequence): First sequence to check.\n        seq2 (sequence): Second sequence to check against.\n    \n    Returns:\n        bool: True if overlap found, False otherwise.\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Use set intersection to find common elements\n    overlap = set1.intersection(set2)\n    \n    # If intersection is not empty, there's an overlap\n    return len(overlap) > 0", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element of seq1 exists in seq2.\n\n    Args:\n        seq1 (sequence): The first sequence to check from.\n        seq2 (sequence): The second sequence to check against.\n\n    Returns:\n        bool: True if overlap found, False otherwise.\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set2 = set(seq2)\n    \n    # Use any() with a generator expression to check for overlap\n    return any(item in set2 for item in seq1)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element in seq1 exists in seq2.\n    \n    Args:\n        seq1 (sequence): First sequence to compare.\n        seq2 (sequence): Second sequence to compare against.\n    \n    Returns:\n        bool: True if a common element is found, False otherwise.\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set2 = set(seq2)\n    \n    # Iterate over each element in seq1 and check existence in set2\n    for element in seq1:\n        if element in set2:\n            # If any element is found, immediately return True\n            return True\n    \n    # If loop completes without finding a match, return False\n    return False", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks for overlap between two sequences.\n\n    Args:\n        seq1 (sequence): The first sequence.\n        seq2 (sequence): The sequence to check against.\n\n    Returns:\n        bool: Whether any element of seq1 exists in seq2.\n    \"\"\"\n    # Convert sequences to sets for efficient lookups\n    set2 = set(seq2)\n    \n    # Iterate over each element in the first sequence\n    for element in seq1:\n        # If any element from seq1 is found in set2, return True\n        if element in set2:\n            return True\n    \n    # If the loop completes without finding a match, return False\n    return False", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks for overlap between two sequences.\n    \n    Args:\n        seq1 (list): First sequence.\n        seq2 (list): Second sequence.\n    \n    Returns:\n        bool: Whether seq1 and seq2 have any elements in common.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element from seq1 exists in seq2.\n\n    Args:\n        seq1 (list): The first sequence to check from.\n        seq2 (list): The second sequence to check against.\n\n    Returns:\n        bool: True if any element from seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if there are overlapping values between two sequences.\n\n    Args:\n    - seq1 (sequence): The first sequence (list, tuple, set, etc.)\n    - seq2 (sequence): The second sequence (list, tuple, set, etc.)\n\n    Returns:\n    - bool: True if an overlap is found, False otherwise\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Use set intersection to find overlapping elements\n    overlapping_elements = set1.intersection(set2)\n    \n    # Return True if overlaps are found, False otherwise\n    return len(overlapping_elements) > 0", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Returns True if any element in seq1 exists in seq2, False otherwise.\n    \n    Parameters:\n    - seq1 (sequence): The first sequence to check from.\n    - seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    - bool: Whether overlap exists.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element of seq1 exists in seq2.\n\n    Args:\n        - seq1 (sequence): The first sequence to check.\n        - seq2 (sequence): The second sequence to check against.\n\n    Returns:\n        - bool: True if an overlap is found, False otherwise.\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Use set intersection to find overlapping elements\n    overlapping_elements = set1 & set2\n    \n    # Return True if overlaps exist, False otherwise\n    return len(overlapping_elements) > 0", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element from seq1 exists in seq2.\n\n    Args:\n        seq1 (list): The first sequence to check.\n        seq2 (list): The second sequence to check against.\n\n    Returns:\n        bool: True if any element from seq1 is found in seq2, False otherwise.\n    \"\"\"\n    # Convert sequences to sets for efficient lookup\n    set2 = set(seq2)\n    \n    # Use any() with a generator expression to check for overlap\n    return any(\n        element in set2 \n        for element in seq1\n    )", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if there are any overlapping elements between two sequences.\n\n    Args:\n        - seq1 (list): The first sequence to compare.\n        - seq2 (list): The second sequence to compare.\n\n    Returns:\n        - bool: `True` if any element in `seq1` exists in `seq2`, `False` otherwise.\n    \"\"\"\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any element of seq1 exists in seq2.\n    \n    Args:\n        seq1 (sequence): The first sequence to check from.\n        seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n        bool: True if any element of seq1 is found in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks for overlapping elements between two sequences.\n\n    Args:\n        seq1 (list or tuple): First sequence to check.\n        seq2 (list or tuple): Second sequence to check against.\n\n    Returns:\n        bool: True if overlap exists, False otherwise.\n    \"\"\"\n    # Convert both sequences to sets for efficient lookups\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Use set intersection to find common elements\n    overlapping_elements = set1.intersection(set2)\n    \n    # If there are any overlapping elements, return True; otherwise, return False\n    return bool(overlapping_elements)", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks for overlapping elements between two sequences.\n\n    Args:\n        seq1 (sequence): First sequence to check.\n        seq2 (sequence): Second sequence to check against.\n\n    Returns:\n        bool: True if overlap found, False otherwise.\n    \"\"\"\n    # Convert sequences to sets for efficient lookups\n    set2 = set(seq2)\n    \n    # Use any() with a generator expression to check for overlaps\n    return any(\n        element in set2  # Check if element from seq1 is in set2\n        for element in seq1  # Iterate over each element in seq1\n    )", "matching_cluster_idx": 6}]}, "Mbpp/421": {"dps": 59.547325102880656, "dps_norm": 85.71428571428571, "pass@1": 75.0, "profiled": [{"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates all elements of a tuple into a single string, \n    separated by a specified delimiter.\n\n    Args:\n    - input_tuple (tuple): The input tuple to concatenate.\n    - delimiter (str, optional): The delimiter to use. Defaults to \"-\".\n\n    Returns:\n    - str: A string with all elements from the tuple concatenated by the delimiter.\n    \"\"\"\n    # Ensure all elements are converted to strings for safe concatenation\n    stringified_tuple = (str(element) for element in input_tuple)\n    \n    # Use the join function to concatenate the elements with the delimiter\n    concatenated_string = delimiter.join(stringified_tuple)\n    \n    return concatenated_string", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a string with a specified delimiter.\n    \n    Parameters:\n    - input_tuple (tuple): The tuple to concatenate. Elements will be converted to strings.\n    - delimiter (str): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    - str: A string where each element from `input_tuple` is concatenated with `delimiter`.\n    \"\"\"\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tuple_input, delimiter='-'):\n    \"\"\"\n    Concatenates all elements in a tuple into a single string, separated by a specified delimiter.\n    \n    Parameters:\n    - tuple_input (tuple): The input tuple to be concatenated. Elements can be of any type that can be converted to a string.\n    - delimiter (str): The delimiter to separate the elements. Defaults to '-'.\n    \n    Returns:\n    - str: A concatenated string of all elements in `tuple_input` separated by `delimiter`.\n    \"\"\"\n    # Convert all elements to strings (to ensure concatenation works across types) and join them with the delimiter\n    return delimiter.join(map(str, tuple_input))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates all elements in a tuple into a single string, separated by a delimiter.\n    \n    Parameters:\n    - input_tuple (tuple): The tuple to concatenate.\n    - delimiter (str): The delimiter to separate the elements. Defaults to '-'.\n    \n    Returns:\n    - str: A string with all elements from the tuple concatenated by the delimiter.\n    \"\"\"\n    # Ensure all elements are converted to string for safe concatenation\n    stringified_tuple = (str(element) for element in input_tuple)\n    # Join the stringified elements with the specified delimiter\n    concatenated_string = delimiter.join(stringified_tuple)\n    return concatenated_string", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string using a delimiter.\n\n    Args:\n        - `input_tuple` (tuple): Tuple containing elements of any type.\n        - `delimiter` (str, optional): Delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        - `str`: A string with all tuple elements concatenated by the delimiter.\n    \"\"\"\n    # Convert each element of the tuple to a string and join them with the delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tuple_to_concat, delimiter='-'):\n    \"\"\"\n    Concatenates all elements of a tuple into a single string using a specified delimiter.\n    \n    Parameters:\n    - tuple_to_concat (tuple): Tuple to be concatenated. Elements can be of any type that can be converted to string.\n    - delimiter (str): String used to separate elements in the output string. Default is '-'.\n    \n    Returns:\n    - str: A concatenated string of all elements in the input tuple.\n    \"\"\"\n    # Convert each element to string (to handle non-string types) and join with the delimiter\n    return delimiter.join(map(str, tuple_to_concat))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates all elements in a tuple into a single string\n    using a specified delimiter.\n\n    Args:\n        - `tup`: The input tuple. Elements will be converted to str.\n        - `delimiter`: The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        A string with all tuple elements concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple into a string separated by a specified delimiter.\n\n    Args:\n        input_tuple (tuple): The input tuple containing elements to be concatenated.\n        delimiter (str, optional): The delimiter to separate the elements. Defaults to \"-\".\n\n    Returns:\n        str: A string where all elements from the tuple are concatenated with the delimiter.\n    \"\"\"\n    # Ensure all elements are converted to string before joining\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string using a specified delimiter.\n\n    Args:\n        input_tuple (tuple): A tuple containing elements to be concatenated.\n        delimiter (str, optional): The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        str: A string with all elements from the tuple concatenated by the delimiter.\n    \"\"\"\n    # Ensure all elements are converted to string for concatenation\n    str_elements = [str(element) for element in input_tuple]\n    \n    # Join the string elements with the specified delimiter\n    concatenated_str = delimiter.join(str_elements)\n    \n    return concatenated_str", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tuple_to_concat, delimiter='-'):\n    \"\"\"\n    Concatenates all elements in a tuple into a single string, \n    separated by a specified delimiter.\n\n    Args:\n    - tuple_to_concat (tuple): The input tuple to be concatenated.\n    - delimiter (str): The delimiter to separate the elements. Default is '-'.\n\n    Returns:\n    - str: A string with all elements from the tuple concatenated by the delimiter.\n    \"\"\"\n    # Ensure all elements are converted to string for concatenation\n    str_elements = (str(element) for element in tuple_to_concat)\n    # Join the string elements with the specified delimiter\n    concatenated_str = delimiter.join(str_elements)\n    return concatenated_str", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tuple_to_concat, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a string with a specified delimiter.\n\n    Parameters:\n    - `tuple_to_concat` (tuple): The input tuple to be concatenated.\n    - `delimiter` (str): The delimiter to use for concatenation (default is '-').\n\n    Returns:\n    - str: A string with all elements from the tuple concatenated by the delimiter.\n    \"\"\"\n    # Ensure all elements in the tuple can be converted to strings\n    stringified_tuple = (str(element) for element in tuple_to_concat)\n    \n    # Use the join function to concatenate the stringified elements with the delimiter\n    concatenated_string = delimiter.join(stringified_tuple)\n    \n    return concatenated_string", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a string separated by a delimiter.\n    \n    Args:\n        t (tuple): Tuple with elements of any type that can be converted to string.\n        delimiter (str, optional): Delimiter to separate elements. Defaults to '-'.\n    \n    Returns:\n        str: A string where all elements of the tuple are concatenated by the delimiter.\n    \"\"\"\n    # Convert each tuple element to a string and join them with the delimiter\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string using a specified delimiter.\n\n    Args:\n        input_tuple (tuple): The input tuple to be concatenated.\n        delimiter (str, optional): The delimiter for concatenation. Defaults to '-'.\n\n    Returns:\n        str: Concatenated string.\n    \"\"\"\n    # Ensure all elements are converted to strings before joining\n    str_tuple = (str(element) for element in input_tuple)\n    # Join the stringified elements with the specified delimiter\n    concatenated_str = delimiter.join(str_tuple)\n    return concatenated_str", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates all elements of a tuple into a single string separated by a delimiter.\n    \n    Args:\n    - `input_tuple`: The tuple to be concatenated.\n    - `delimiter` (str): The delimiter used for concatenation. Defaults to '-'.\n    \n    Returns:\n    - str: A string where all elements of `input_tuple` are concatenated by `delimiter`.\n    \"\"\"\n    # Convert all elements to strings to ensure concatenation works across data types\n    str_tuple = (str(element) for element in input_tuple)\n    # Use join() to concatenate the stringified tuple elements with the delimiter\n    concatenated_str = delimiter.join(str_tuple)\n    return concatenated_str", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates all elements in the input tuple into a single string\n    separated by the specified delimiter.\n\n    Args:\n        input_tuple (tuple): The input tuple containing elements to concatenate.\n        delimiter (str): The delimiter to separate elements. Defaults to '-'.\n\n    Returns:\n        str: A string with all elements from the tuple concatenated by the delimiter.\n    \"\"\"\n    # Ensure all elements are converted to string before joining\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the input tuple into a string using the specified delimiter.\n\n    Args:\n        - input_tuple (tuple): The tuple to concatenate. Elements can be of any type that can be converted to string.\n        - delimiter (str): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        - str: A concatenated string of all elements in the input tuple, separated by the delimiter.\n    \"\"\"\n    # Ensure all elements are converted to strings to allow concatenation\n    str_elements = (str(element) for element in input_tuple)\n    \n    # Use the join method to concatenate the string elements with the delimiter\n    concatenated_str = delimiter.join(str_elements)\n    \n    return concatenated_str", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates all elements in a tuple into a single string separated by a delimiter.\n\n    Args:\n        - input_tuple (tuple): The tuple containing elements to be concatenated.\n        - delimiter (str): The separator used between elements. Defaults to \"-\".\n\n    Returns:\n        str: A string with all tuple elements concatenated by the delimiter.\n    \"\"\"\n    # Ensure all elements are converted to string for concatenation\n    str_elements = (str(element) for element in input_tuple)\n    # Use join() to concatenate the string elements with the delimiter\n    concatenated_str = delimiter.join(str_elements)\n    return concatenated_str", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    Concatenates all elements of a tuple into a single string separated by a specified delimiter.\n    \n    Args:\n    - input_tuple (tuple): The tuple containing elements to be concatenated.\n    - delimiter (str, optional): The delimiter to separate elements. Defaults to \"-\".\n\n    Returns:\n    - str: A string with all tuple elements concatenated by the delimiter.\n    \"\"\"\n    # Ensure all elements are converted to string for concatenation\n    str_elements = (str(element) for element in input_tuple)\n    # Join the string elements with the specified delimiter\n    concatenated_str = delimiter.join(str_elements)\n    return concatenated_str", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a string using a specified delimiter.\n\n    Args:\n        input_tuple (tuple): Tuple with elements to be concatenated.\n        delimiter (str, optional): Delimiter to separate elements. Defaults to '-'.\n\n    Returns:\n        str: Concatenated string of tuple elements.\n    \"\"\"\n    # Convert each element to string and join them with the delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a string separated by a delimiter.\n\n    Args:\n        input_tuple (tuple): The input tuple to concatenate. Elements can be of any type that can be converted to string.\n        delimiter (str, optional): The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        str: A string where all elements from the input tuple are concatenated by the delimiter.\n    \"\"\"\n    # Ensure all elements can be converted to strings and then join them with the delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}]}, "Mbpp/424": {"dps": 30.505415162454874, "dps_norm": 70.0, "pass@1": 72.0, "profiled": [{"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Args:\n        strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of the last characters, one from each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the input tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    # Use list comprehension to iterate over each string in the tuple\n    # and extract the last character (-1 index) from each string\n    return [string[-1] for string in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Args:\n    - tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    - list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    # Check if input is indeed a tuple\n    if not isinstance(tuple_of_strings, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    \n    # Validate all elements in the tuple are strings\n    if not all(isinstance(s, str) for s in tuple_of_strings):\n        raise ValueError(\"All elements in the tuple must be strings.\")\n    \n    # Use list comprehension to extract the last character of each string\n    # The '-1' index in Python refers to the last element of a sequence\n    return [s[-1] for s in tuple_of_strings if s]  # Ignore empty strings", "matching_cluster_idx": 2}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the input tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of strings where each string is the last character of the corresponding input string.\n    \"\"\"\n    return [string[-1] for string in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the input tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    # Check if input is indeed a tuple\n    if not isinstance(tuple_of_strings, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    \n    # Use list comprehension to extract the last character from each string\n    # The [-1] index refers to the last element in a string (or list)\n    rear_elements = [string[-1] for string in tuple_of_strings if isinstance(string, str)]\n    \n    # Optionally, raise an error if not all elements were strings (if desired)\n    if len(rear_elements) != len(tuple_of_strings):\n        raise ValueError(\"All elements in the tuple must be strings.\")\n    \n    return rear_elements", "matching_cluster_idx": 2}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the rear index element from each string in the given tuple.\n\n    Args:\n        strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of rear index elements, one from each string in the input tuple.\n    \"\"\"\n    return [string[-1] for string in strings_tuple if isinstance(string, str)]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the provided tuple.\n\n    Args:\n        strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of last characters, one from each string in the input tuple.\n\n    Raises:\n        ValueError: If the input is not a tuple or if the tuple contains non-string elements.\n    \"\"\"\n    if not isinstance(strings_tuple, tuple) or not all(isinstance(s, str) for s in strings_tuple):\n        raise ValueError(\"Input must be a tuple containing only strings.\")\n\n    return [s[-1] for s in strings_tuple if s]  # Handles empty strings by skipping them", "matching_cluster_idx": 2}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Args:\n        strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    return [string[-1] for string in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup_of_strings):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Args:\n        tup_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of rear index elements (last characters) from each string.\n    \"\"\"\n    return [string[-1] for string in tup_of_strings if isinstance(string, str)]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extract the rear (last) index element of each string in the given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of characters, where each character is the last element of the corresponding string in the input tuple.\n    \"\"\"\n    # Use list comprehension to iterate over each string in the tuple\n    # and extract the last character of each string using slicing (-1 index)\n    return [string[-1] for string in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extract the last character from each string in the input tuple.\n\n    Parameters:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    # Check if input is indeed a tuple\n    if not isinstance(tuple_of_strings, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    \n    # Ensure all elements in the tuple are strings\n    if not all(isinstance(s, str) for s in tuple_of_strings):\n        raise ValueError(\"All elements in the tuple must be strings.\")\n    \n    # Extract the last character from each string using list comprehension\n    # and return the result as a list\n    return [s[-1] for s in tuple_of_strings if s]  # Check for non-empty strings", "matching_cluster_idx": 2}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    return [string[-1] for string in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    return [string[-1] for string in tuple_of_strings if isinstance(string, str)]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Parameters:\n    - `strings_tuple`: A tuple containing strings.\n\n    Returns:\n    - A list of strings where each string is the last character of the corresponding input string.\n    \"\"\"\n    return [string[-1] for string in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the input tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of strings where each string is the last character of the corresponding input string.\n    \"\"\"\n    return [string[-1] for string in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in the input tuple.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    return [string[-1] for string in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character from each string in a tuple of strings.\n\n    Args:\n        tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    # Initialize an empty list to store the rear index elements\n    rear_elements = []\n    \n    # Iterate over each string in the input tuple\n    for string in tuple_of_strings:\n        # Check if the string is not empty to avoid index errors\n        if string:\n            # Extract the last character of the string and append it to the list\n            rear_elements.append(string[-1])\n        else:\n            # If the string is empty, append None or any appropriate placeholder\n            rear_elements.append(None)  # or rear_elements.append('') if you prefer an empty string\n    \n    # Return the list of rear index elements\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extract the last character from each string in the input tuple.\n\n    Parameters:\n    - `tuple_of_strings`: A tuple containing strings.\n\n    Returns:\n    - A list of strings where each string is the last character of the corresponding input string.\n    \"\"\"\n    return [string[-1] for string in tuple_of_strings if isinstance(string, str)]", "matching_cluster_idx": 2}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    Args:\n        strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of last characters, one from each string in the input tuple.\n    \"\"\"\n    # Check if input is a tuple\n    if not isinstance(strings_tuple, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    \n    # Use list comprehension to extract the last character of each string\n    # The [-1] indexing is used to get the last character of each string\n    rear_index_elements = [string[-1] for string in strings_tuple if isinstance(string, str)]\n    \n    # If no strings were found in the tuple, or if all strings were empty, return an empty list\n    if not rear_index_elements or (len(rear_index_elements) != len(strings_tuple) and not all(rear_index_elements)):\n        return []\n    \n    return rear_index_elements", "matching_cluster_idx": 2}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extract the rear index element of each string in the given tuple.\n\n    Args:\n        strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n        list: A list of rear index characters from each string in the tuple.\n    \"\"\"\n    return [string[-1] for string in strings_tuple if isinstance(string, str)]", "matching_cluster_idx": 2}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 71.0, "profiled": [{"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists in main_list that contain target_element.\n\n    Args:\n        main_list (list): A list of lists.\n        target_element: The element to search for in sublists.\n\n    Returns:\n        int: The number of sublists containing target_element.\n    \"\"\"\n    # Initialize a counter for sublists containing the target element\n    count = 0\n    \n    # Iterate over each sublist in the main list\n    for sublist in main_list:\n        # Check if the target element is in the current sublist\n        if target_element in sublist:\n            # If found, increment the counter\n            count += 1\n    \n    # Return the total count of sublists containing the target element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists within `main_list` that contain `target_element`.\n    \n    Args:\n        - main_list (list of lists): The list containing sublists to search through.\n        - target_element: The element to search for within the sublists.\n    \n    Returns:\n        - count (int): The number of sublists containing `target_element`.\n    \"\"\"\n    # Initialize a counter for sublists containing the target element\n    count = 0\n    \n    # Iterate over each sublist in the main list\n    for sublist in main_list:\n        # Check if the target element is in the current sublist\n        if target_element in sublist:\n            # If found, increment the counter\n            count += 1\n    \n    # Return the total count of sublists with the target element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists in `main_list` that contain `target_element`.\n\n    Args:\n        main_list (list): A list of lists.\n        target_element: The element to search for in sublists.\n\n    Returns:\n        int: The count of sublists containing `target_element`.\n    \"\"\"\n    return sum(1 for sublist in main_list if target_element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the occurrence of a target element across all sublists in a main list.\n    \n    Args:\n        main_list (list): A list containing sublists.\n        target_element: The element to be searched for in the sublists.\n    \n    Returns:\n        int: The number of sublists containing the target_element.\n    \"\"\"\n    # Use list comprehension to iterate over each sublist in main_list\n    # and check if target_element exists in the sublist, counting the True occurrences\n    count = sum(1 for sublist in main_list if target_element in sublist)\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists in `main_list` that contain `target_element`.\n\n    Args:\n        - `main_list` (list of lists): The list of lists to search in.\n        - `target_element`: The element to search for.\n\n    Returns:\n        - `int`: The number of sublists containing `target_element`.\n    \"\"\"\n    # Initialize a counter for sublists containing the target element\n    count = 0\n    \n    # Iterate over each sublist in the main list\n    for sublist in main_list:\n        # Check if the target element is in the current sublist\n        if target_element in sublist:\n            # If found, increment the counter\n            count += 1\n    \n    # Return the total count of sublists containing the target element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, target_element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists (list): A list containing sublists.\n        target_element: The element to search for in the sublists.\n\n    Returns:\n        int: The number of sublists containing the target_element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if target_element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the occurrence of a target element across all sublists in a given list.\n    \n    Args:\n        main_list (list): A list of lists.\n        target_element: The element to be searched within sublists.\n    \n    Returns:\n        int: Number of sublists containing the target element.\n    \"\"\"\n    # Initialize a counter variable to track the number of sublists with the target element\n    count = 0\n    \n    # Iterate over each sublist in the main list\n    for sublist in main_list:\n        # Check if the target element is present in the current sublist\n        if target_element in sublist:\n            # If the element is found, increment the counter\n            count += 1\n    \n    # Return the total count of sublists containing the target element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists within `main_list` that contain `target_element`.\n\n    Args:\n        main_list (list of lists): The list containing sublists to search through.\n        target_element: The element to search for within the sublists.\n\n    Returns:\n        int: The number of sublists containing `target_element`.\n    \"\"\"\n    return sum(1 for sublist in main_list if target_element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the occurrence of sublists containing a target element.\n\n    Args:\n        main_list (list): A list of lists.\n        target_element: The element to be searched within sublists.\n\n    Returns:\n        int: Number of sublists containing the target_element.\n    \"\"\"\n    # Initialize a counter for sublists with the target element\n    count = 0\n    \n    # Iterate over each sublist in the main list\n    for sublist in main_list:\n        # Check if the target element is in the current sublist\n        if target_element in sublist:\n            # If found, increment the counter\n            count += 1\n    \n    # Return the total count of sublists with the target element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, target_element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n    - `list_of_lists` (list): A list containing sublists.\n    - `target_element`: The element to search for in the sublists.\n\n    Returns:\n    - `int`: The number of sublists containing the target element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if target_element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, target_element):\n    \"\"\"\n    Counts the number of sublists in a nested list that contain a particular element.\n\n    Args:\n        nested_list (list): A list potentially containing sublists.\n        target_element: The element to search for within the sublists.\n\n    Returns:\n        int: The number of sublists containing the target element.\n    \"\"\"\n    # Initialize counter for sublists with the target element\n    count = 0\n    \n    # Iterate over each sublist in the nested list\n    for sublist in nested_list:\n        # Check if the target element is in the current sublist\n        if target_element in sublist:\n            # If found, increment the counter\n            count += 1\n    \n    # Return the total count of sublists with the target element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, target_element):\n    \"\"\"\n    Counts the number of sublists in `list_of_lists` that contain `target_element`.\n\n    Args:\n        list_of_lists (list): A list of lists to search in.\n        target_element: The element to search for in the sublists.\n\n    Returns:\n        int: The number of sublists containing `target_element`.\n    \"\"\"\n    # Initialize a counter variable to store the count of sublists with the target element\n    count = 0\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Check if the target element is in the current sublist\n        if target_element in sublist:\n            # If found, increment the counter\n            count += 1\n    \n    # Return the total count of sublists containing the target element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists in `main_list` that contain `target_element`.\n\n    Args:\n        - main_list (list of lists): The list containing sublists to search through.\n        - target_element: The element to search for in the sublists.\n\n    Returns:\n        - int: The number of sublists containing `target_element`.\n    \"\"\"\n    return sum(1 for sublist in main_list if target_element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, target_element):\n    \"\"\"\n    Counts the number of sublists in a list of lists that contain a specified element.\n\n    Args:\n        - list_of_lists (list): A list containing sublists.\n        - target_element: The element to search for within the sublists.\n\n    Returns:\n        - int: The number of sublists containing the target element.\n    \"\"\"\n    # Initialize a counter variable to keep track of sublists with the target element\n    count = 0\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Check if the target element is in the current sublist\n        if target_element in sublist:\n            # If found, increment the counter\n            count += 1\n    \n    # Return the total count of sublists containing the target element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists in `main_list` that contain `target_element`.\n    \n    Parameters:\n    - `main_list` (list of lists): The list containing sublists to search through.\n    - `target_element`: The element to search for within the sublists.\n    \n    Returns:\n    - `count` (int): The number of sublists containing `target_element`.\n    \"\"\"\n    count = sum(1 for sublist in main_list if target_element in sublist)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, target_element):\n    \"\"\"\n    Counts the number of sublists in a nested list that contain a particular element.\n\n    Args:\n        - `nested_list` (list of lists): The list containing sublists to search through.\n        - `target_element`: The element to look for in the sublists.\n\n    Returns:\n        - `int`: The count of sublists containing the `target_element`.\n    \"\"\"\n    # Initialize a counter variable to keep track of the number of sublists with the target element\n    count = 0\n    \n    # Iterate over each sublist in the nested list\n    for sublist in nested_list:\n        # Check if the target element is present in the current sublist\n        if target_element in sublist:\n            # If the element is found, increment the counter\n            count += 1\n    \n    # Return the total count after checking all sublists\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists in `main_list` that contain `target_element`.\n\n    Args:\n        main_list (list): A list containing sublists.\n        target_element: The element to search for within the sublists.\n\n    Returns:\n        int: The number of sublists containing `target_element`.\n    \"\"\"\n    # Initialize a counter variable to keep track of sublists with the target element\n    count = 0\n    \n    # Iterate over each sublist in the main list\n    for sublist in main_list:\n        # Check if the target element is in the current sublist\n        if target_element in sublist:\n            # If found, increment the counter\n            count += 1\n    \n    # Return the total count after checking all sublists\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, target_element):\n    \"\"\"\n    Counts the number of sublists in `list_of_lists` that contain `target_element`.\n\n    Args:\n        - list_of_lists (list): A list containing sublists.\n        - target_element: The element to search for in the sublists.\n\n    Returns:\n        - int: The number of sublists containing `target_element`.\n    \"\"\"\n    # Initialize a counter for sublists containing the target element\n    count = 0\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Check if the target element is in the current sublist\n        if target_element in sublist:\n            # If it is, increment the counter\n            count += 1\n    \n    # Return the total count of sublists with the target element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists in main_list that contain target_element.\n    \n    Parameters:\n    main_list (list): A list of lists.\n    target_element: The element to search for in sublists.\n    \n    Returns:\n    int: Count of sublists containing target_element.\n    \"\"\"\n    return sum(1 for sublist in main_list if target_element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(main_list, target_element):\n    \"\"\"\n    Counts the number of sublists within a list that contain a specific element.\n\n    Args:\n        main_list (list): The list containing sublists to search through.\n        target_element: The element to search for within the sublists.\n\n    Returns:\n        int: The number of sublists containing the target element.\n    \"\"\"\n    return sum(1 for sublist in main_list if target_element in sublist)", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 46.15702479338843, "dps_norm": 48.333333333333336, "pass@1": 74.0, "profiled": [{"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The list of integers to be sorted\n    :return: A new list with the elements sorted in ascending order\n    \"\"\"\n    # Create a copy to avoid modifying the original array\n    arr = arr[:]\n    n = len(arr)\n    gap = n // 2\n\n    # Iterate over gaps from n/2 to 1\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements to the right if they are greater than the current element\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array in ascending order using the Shell Sort algorithm.\n\n    :param arr: List of integers to be sorted\n    :return: Sorted list in ascending order\n    \"\"\"\n    # Initialize the gap size\n    gap = len(arr) // 2\n\n    # Continue the process until the gap size is greater than zero\n    while gap > 0:\n        # Iterate over the array with the current gap\n        for i in range(gap, len(arr)):\n            # Store the current element\n            temp = arr[i]\n            j = i\n\n            # Shift the elements that are greater than the current element to the right\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place the current element in its correct position\n            arr[j] = temp\n\n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array in ascending order using the Shell Sort algorithm.\n\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    # Initialize the gap size\n    gap = len(arr) // 2\n    \n    # Continue the process until the gap size becomes zero\n    while gap > 0:\n        # Iterate over the array with the current gap size\n        for i in range(gap, len(arr)):\n            # Store the current element\n            temp = arr[i]\n            # Initialize the variable for comparison\n            j = i\n            \n            # Shift elements greater than the current element to the right\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place the current element at its correct position\n            arr[j] = temp\n        \n        # Reduce the gap size for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr (list): The list of integers to be sorted.\n\n    Returns:\n        list: A new list containing the elements of `arr` in ascending order.\n    \"\"\"\n    # Create a copy to avoid modifying the original array\n    arr_copy = arr.copy()\n    \n    # Initialize the gap size\n    gap = len(arr_copy) // 2\n    \n    # Loop until the gap size becomes 0\n    while gap > 0:\n        # Perform a gapped insertion sort for the current gap size\n        for i in range(gap, len(arr_copy)):\n            temp = arr_copy[i]\n            j = i\n            # Shift elements that are greater than the current element to the right\n            while j >= gap and arr_copy[j - gap] > temp:\n                arr_copy[j] = arr_copy[j - gap]\n                j -= gap\n            # Place the current element at its correct position\n            arr_copy[j] = temp\n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n    \n    return arr_copy", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array by using shell sort.\n\n    :param arr: The list of integers to be sorted.\n    :return: The sorted list in ascending order.\n    \"\"\"\n    # Initialize the gap size. We start with half of the array size and iteratively reduce it.\n    gap = len(arr) // 2\n    \n    # Continue the process until the gap size becomes zero.\n    while gap > 0:\n        # Iterate over the array with the current gap size.\n        for i in range(gap, len(arr)):\n            # Store the current element for comparison.\n            temp = arr[i]\n            # Initialize the variable that tracks the position for the temp element.\n            j = i\n            \n            # Shift the previous elements to the right until a smaller element is found.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place the temp element at its correct position.\n            arr[j] = temp\n        \n        # Reduce the gap size for the next iteration.\n        gap //= 2\n    \n    # Return the sorted array.\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using Shell Sort algorithm.\n\n    :param arr: The input array to be sorted\n    :return: The sorted array\n    \"\"\"\n    # Initialize the gap size. You can use different sequences but here we're using a simple one\n    gap = len(arr) // 2\n    \n    while gap > 0:\n        # Perform insertion sort for this gap size\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            # Shift the previous elements to the right if they are larger than the current element\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place the element at its correct position\n            arr[j] = temp\n        # Reduce the gap size for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The input list of integers to be sorted.\n    :return: A new sorted list in ascending order.\n    \"\"\"\n    # Create a copy to avoid modifying the original array\n    arr_copy = arr[:]\n    \n    # Initialize the gap size\n    gap = len(arr_copy) // 2\n    \n    # Loop until the gap is not zero\n    while gap > 0:\n        # Perform a gapped insertion sort\n        for i in range(gap, len(arr_copy)):\n            temp = arr_copy[i]\n            j = i\n            # Shift elements greater than temp to the right\n            while j >= gap and arr_copy[j - gap] > temp:\n                arr_copy[j] = arr_copy[j - gap]\n                j -= gap\n            arr_copy[j] = temp  # Place temp at the correct position\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr_copy", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    # Initialize the gap size\n    gap = len(arr) // 2\n    \n    # Continue the process until the gap size is greater than zero\n    while gap > 0:\n        # Iterate over the array with the current gap size\n        for i in range(gap, len(arr)):\n            # Store the current element\n            temp = arr[i]\n            j = i\n            \n            # Shift elements greater than the current element to the right\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place the current element at its correct position\n            arr[j] = temp\n        \n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    # Initialize the gap size. Start with half of the array size and reduce it by half in each iteration.\n    gap = len(arr) // 2\n\n    # Continue the process until the gap size becomes zero.\n    while gap > 0:\n        # Iterate over the array starting from the gap size to the end.\n        for i in range(gap, len(arr)):\n            # Store the current element to be compared with the elements before the gap.\n            temp = arr[i]\n            # Initialize the index to compare elements before the gap.\n            j = i\n            \n            # Shift the elements to the right if they are greater than the current element (temp).\n            while j >= gap and arr[j - gap] > temp:\n                # Shift the element.\n                arr[j] = arr[j - gap]\n                # Move to the previous gap position.\n                j -= gap\n            \n            # Place the temp element at its correct position after shifting.\n            arr[j] = temp\n        \n        # Reduce the gap size by half for the next iteration.\n        gap //= 2\n    \n    # Return the sorted array.\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The input list of integers to be sorted.\n    :return: A new list containing the elements of `arr` in ascending order.\n    \"\"\"\n    # Initialize the gap size. We start with half of the array size and progressively reduce it.\n    gap = len(arr) // 2\n    \n    # Continue the process until the gap size becomes zero.\n    while gap > 0:\n        # Iterate over the array with the current gap size.\n        for i in range(gap, len(arr)):\n            # Store the current element to be compared with the previous elements with the gap size.\n            temp = arr[i]\n            j = i\n            \n            # Shift the previous elements to the right if they are greater than the current element.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Insert the current element at its correct position.\n            arr[j] = temp\n        \n        # Reduce the gap size by half for the next iteration.\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The input list of integers to be sorted.\n    :return: A new list containing the sorted elements.\n    \"\"\"\n    # Create a copy to avoid modifying the original array\n    arr = arr.copy()\n    \n    # Initialize the gap size\n    gap = len(arr) // 2\n    \n    # Continue the process until the gap size is greater than zero\n    while gap > 0:\n        # Perform insertion sort for this gap size\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            # Shift elements of arr[0..i] that are greater than temp, to one position ahead of their current position\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The input list of integers to be sorted.\n    :return: A new sorted list in ascending order.\n    \"\"\"\n    # Create a copy to ensure the function does not modify the original array\n    arr_copy = arr[:]\n    \n    # Initialize the gap size\n    gap = len(arr_copy) // 2\n    \n    # Loop until the gap is not zero\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, len(arr_copy)):\n            temp = arr_copy[i]\n            j = i\n            # Shift elements that are greater than the current element to the right\n            while j >= gap and arr_copy[j - gap] > temp:\n                arr_copy[j] = arr_copy[j - gap]\n                j -= gap\n            # Place the current element at its correct position\n            arr_copy[j] = temp\n        # Reduce the gap size for the next iteration\n        gap //= 2\n    \n    return arr_copy", "matching_cluster_idx": 3}, {"solution": "def shell_sort(array):\n    \"\"\"\n    Sorts the given array using Shell Sort algorithm.\n\n    Args:\n        array (list): The list of integers to be sorted.\n\n    Returns:\n        list: A new sorted list in ascending order.\n    \"\"\"\n    # Initialize the gap size\n    gap = len(array) // 2\n\n    # Continue the process until the gap size becomes zero\n    while gap > 0:\n        # Iterate over the array starting from the gap to the end\n        for i in range(gap, len(array)):\n            # Store the current element to be compared\n            temp = array[i]\n            # Initialize j for the inner loop, starting from the current index and subtracting the gap\n            j = i\n            # Continue shifting elements to the right until a smaller element is found or the beginning is reached\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            # Place the temp element at its correct position\n            array[j] = temp\n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n\n    return array", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The input array to be sorted\n    :return: The sorted array\n    \"\"\"\n    # Initialize the gap size. The initial gap size is half of the array length.\n    gap = len(arr) // 2\n\n    # Continue the process until the gap size becomes zero.\n    while gap > 0:\n        # Iterate over the array with the current gap size.\n        for i in range(gap, len(arr)):\n            # Store the current element to be compared with elements at previous gaps.\n            temp = arr[i]\n            j = i\n\n            # Compare and shift elements until a smaller element is found at the previous gap.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place the stored element at its correct position.\n            arr[j] = temp\n\n        # Reduce the gap size by half for the next iteration.\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The list of integers to be sorted\n    :return: A new list containing the elements of `arr` in ascending order\n    \"\"\"\n    # Initialize the gap size. We start with half the array size and reduce it by half in each iteration.\n    gap = len(arr) // 2\n\n    # Continue the process until the gap size becomes zero.\n    while gap > 0:\n        # Iterate over the array starting from the gap size to the end.\n        for i in range(gap, len(arr)):\n            # Store the current element to be compared with the previous elements.\n            temp = arr[i]\n            # Initialize the variable to keep track of the previous gap-sized index.\n            j = i\n\n            # Continue shifting the elements to the right until we find the correct position for `temp`.\n            while j >= gap and arr[j - gap] > temp:\n                # Shift the element to the right.\n                arr[j] = arr[j - gap]\n                # Move to the previous gap-sized index.\n                j -= gap\n\n            # Place `temp` at its correct position.\n            arr[j] = temp\n\n        # Reduce the gap size by half for the next iteration.\n        gap //= 2\n\n    # Return the sorted array.\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: List of integers to be sorted\n    :return: Sorted list of integers\n    \"\"\"\n    # Initialize the gap size\n    gap = len(arr) // 2\n\n    # Continue the process until the gap size is greater than zero\n    while gap > 0:\n        # Iterate over the array with the current gap size\n        for i in range(gap, len(arr)):\n            # Store the current element for comparison\n            temp = arr[i]\n            j = i\n\n            # Shift elements greater than the current element to the right\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Insert the current element at its correct position\n            arr[j] = temp\n\n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The input list of integers to be sorted.\n    :return: A new list containing the sorted elements of the input array.\n    \"\"\"\n    # Create a copy to keep the original array unchanged\n    arr_copy = arr[:]\n    \n    # Initialize the gap size\n    gap = len(arr_copy) // 2\n    \n    # Continue the process until the gap size becomes zero\n    while gap > 0:\n        # Iterate over the array starting from the gap\n        for i in range(gap, len(arr_copy)):\n            # Store the current element\n            temp = arr_copy[i]\n            # Initialize j for the previous gap-sized element\n            j = i\n            \n            # Continue shifting elements to the right until the correct position for the temp is found\n            while j >= gap and arr_copy[j - gap] > temp:\n                arr_copy[j] = arr_copy[j - gap]\n                j -= gap\n            \n            # Place the temp at its correct position\n            arr_copy[j] = temp\n        \n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n    \n    return arr_copy", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The input list of integers to be sorted.\n    :return: The sorted list of integers.\n    \"\"\"\n    # Initialize the gap size\n    gap = len(arr) // 2\n    \n    # Continue the process until the gap size becomes zero\n    while gap > 0:\n        # Iterate over the array with the current gap\n        for i in range(gap, len(arr)):\n            # Store the current element\n            temp = arr[i]\n            # Initialize the variable for comparison\n            j = i\n            \n            # Shift the previous elements to the right if they are greater than the current element\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place the current element at its correct position\n            arr[j] = temp\n        \n        # Reduce the gap size by half for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The input list of integers to be sorted.\n    :return: A new sorted list in ascending order.\n    \"\"\"\n    # Initialize the gap size. We start with half the size of the array.\n    gap = len(arr) // 2\n\n    # Continue the process until the gap is not zero.\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, len(arr)):\n            temp = arr[i]  # This is the element to be compared.\n            j = i\n            \n            # Shift the previous gapped elements of arr[0..i-1], that are greater than temp,\n            # to one position ahead of their current position.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the element to be compared) in its correct location in the gapped array.\n            arr[j] = temp\n        \n        # Reduce the gap size by half for the next iteration.\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    :param arr: The input list of integers to be sorted\n    :return: A new sorted list in ascending order\n    \"\"\"\n    # Initialize the gap size\n    gap = len(arr) // 2\n    \n    # Continue the process until the gap size becomes zero\n    while gap > 0:\n        # Iterate over the array with the current gap\n        for i in range(gap, len(arr)):\n            # Store the current element for comparison\n            temp = arr[i]\n            j = i\n            \n            # Shift elements greater than temp to the right\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Place the temp element at its correct position\n            arr[j] = temp\n        \n        # Reduce the gap size for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 41.54255319148936, "dps_norm": 40.0, "pass@1": 86.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in a given array.\n\n    Args:\n        arr (list): A list of numbers.\n        num (int or float): The number to compare.\n\n    Returns:\n        bool: True if num is greater than all elements, False otherwise.\n    \"\"\"\n    # Use the built-in all() function with a generator expression\n    # to check if num is greater than every element in arr\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks if the entered number is greater than all elements in the given array.\n\n    Args:\n        array (list): A list of numbers.\n        number (int or float): The number to compare against the array elements.\n\n    Returns:\n        bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    # Check if input array is indeed a list\n    if not isinstance(array, list):\n        raise TypeError(\"Input 'array' must be a list.\")\n    \n    # Check if all elements in the array are numbers and the input number is a number\n    if not all(isinstance(x, (int, float)) for x in array) or not isinstance(number, (int, float)):\n        raise TypeError(\"All elements in 'array' and 'number' must be numbers.\")\n    \n    # Use the built-in all() function with a generator expression to check the condition\n    # all() returns True if all elements of the iterable (here, the generator expression) are true\n    return all(number > elem for elem in array)", "matching_cluster_idx": -1}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n\n    Args:\n        - array (list): A list of numbers.\n        - num (int or float): The number to compare against the array elements.\n\n    Returns:\n        - bool: True if `num` is greater than all elements in `array`, False otherwise.\n    \"\"\"\n    # Iterate over each element in the array\n    for element in array:\n        # If the number is not greater than any element, immediately return False\n        if num <= element:\n            return False\n    # If the loop completes without finding any element greater than or equal to num, \n    # it means num is greater than all elements, so return True\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Checks if a given number is greater than all elements in the provided array.\n\n    Args:\n        array (list): A list of numbers.\n        num (int or float): The number to compare against the array's elements.\n\n    Returns:\n        bool: True if `num` is greater than all elements in `array`, False otherwise.\n    \"\"\"\n    return all(num > element for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n\n    Args:\n        array (list): A list of numbers.\n        num (int or float): The number to compare with array elements.\n\n    Returns:\n        bool: True if num is greater than all elements in array, False otherwise.\n    \"\"\"\n    return all(num > element for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Checks if the given number is greater than all elements in the array.\n\n    Args:\n        array (list): A list of numbers.\n        num (int or float): The number to compare with the array elements.\n\n    Returns:\n        bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > element for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n    \n    Args:\n        array (list): A list of numbers.\n        number (int or float): The number to compare against the array elements.\n    \n    Returns:\n        bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    # Use the built-in all() function in combination with a generator expression\n    # to check if the number is greater than all elements in the array\n    return all(number > element for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n\n    Args:\n    - array (list): A list of numbers.\n    - num (int or float): The number to compare with array elements.\n\n    Returns:\n    - bool: True if `num` is greater than all elements in `array`, False otherwise.\n    \"\"\"\n    # Check if all elements in the array are less than the given number\n    return all(element < num for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n\n    Args:\n        - array (list): A list of numbers.\n        - num (int or float): The number to compare against the array's elements.\n\n    Returns:\n        - bool: True if `num` is greater than all elements in `array`; False otherwise.\n    \"\"\"\n    return all(num > element for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n    \n    Args:\n        arr (list): A list of numbers.\n        num (int or float): The number to compare.\n    \n    Returns:\n        bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    # Check if all elements in the array are less than the given number\n    return all(element < num for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, target_number):\n    \"\"\"\n    Checks if a target number is greater than all elements in a given array.\n    \n    Args:\n        array (list): List of numbers to compare against.\n        target_number (int or float): Number to check for superiority.\n    \n    Returns:\n        bool: True if target_number is greater than all elements in array; False otherwise.\n    \"\"\"\n    # Check if the input array is indeed a list\n    if not isinstance(array, list):\n        raise TypeError(\"Input array must be a list.\")\n    \n    # Ensure all elements in the array are numbers and target_number is a number\n    if not all(isinstance(x, (int, float)) for x in array) or not isinstance(target_number, (int, float)):\n        raise TypeError(\"Array elements and target_number must be numbers.\")\n    \n    # Use the built-in all() function with a generator expression to check the condition\n    # all() returns True if all elements of the iterable (here, the generator expression) are true\n    return all(target_number > num for num in array)", "matching_cluster_idx": -1}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Returns True if `num` is greater than all elements in `array`, False otherwise.\n\n    :param array: A list of numbers.\n    :param num: The number to compare against all elements in `array`.\n    :return: bool\n    \"\"\"\n    return all(num > element for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks if the given number is greater than all elements in the provided array.\n    \n    Args:\n        array (list): A list of numbers\n        number (int or float): The number to compare against the array elements\n    \n    Returns:\n        bool: True if the number is greater than all elements, False otherwise\n    \"\"\"\n    # Check if all elements in the array are less than the given number\n    return all(element < number for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n\n    Args:\n    - `array (list)`: A list of numbers.\n    - `number (int or float)`: The number to compare against the array elements.\n\n    Returns:\n    - `bool`: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    # Check if input array is indeed a list\n    if not isinstance(array, list):\n        raise TypeError(\"Input 'array' must be a list.\")\n    \n    # Check if all elements in the array and the number are either int or float\n    if not all(isinstance(x, (int, float)) for x in array) or not isinstance(number, (int, float)):\n        raise TypeError(\"All elements in the array and the 'number' must be integers or floats.\")\n    \n    # Use the built-in all() function with a generator expression to check the condition\n    # The all() function returns True if all elements of the iterable (here, the generator expression) are true.\n    return all(number > elem for elem in array)", "matching_cluster_idx": -1}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n\n    Args:\n        arr (list): A list of integers.\n        num (int): The number to compare with the array elements.\n\n    Returns:\n        bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > elem for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if num is greater than all elements in arr.\n\n    Args:\n        arr (list): A list of numbers.\n        num (int or float): The number to compare against the array elements.\n\n    Returns:\n        bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    # Check if input is of correct type\n    if not isinstance(arr, list) or not all(isinstance(x, (int, float)) for x in arr):\n        raise TypeError(\"Array must contain only numbers.\")\n    if not isinstance(num, (int, float)):\n        raise TypeError(\"Number to compare must be an integer or float.\")\n\n    # Use the built-in all() function with a generator expression to check the condition\n    return all(num > element for element in arr)", "matching_cluster_idx": -1}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n\n    Args:\n        array (list): List of numbers.\n        number (int or float): The number to compare with the array elements.\n\n    Returns:\n        bool: True if the number is greater than all elements, False otherwise.\n    \"\"\"\n    # Check if input array is actually a list\n    if not isinstance(array, list):\n        raise TypeError(\"Input 'array' must be a list.\")\n    \n    # Check if all elements in the array and the number are either int or float\n    if not all(isinstance(x, (int, float)) for x in array) or not isinstance(number, (int, float)):\n        raise TypeError(\"All elements in the array and the number must be either int or float.\")\n    \n    # Use the built-in all() function with a generator expression to check the condition\n    return all(number > element for element in array)", "matching_cluster_idx": -1}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks whether the entered number is greater than all elements in the given array.\n    \n    Parameters:\n    array (list): The input list of numbers.\n    number (int or float): The number to compare against the array's elements.\n    \n    Returns:\n    bool: True if the number is greater than all elements in array, False otherwise.\n    \"\"\"\n    # Ensure input array is indeed a list\n    if not isinstance(array, list):\n        raise TypeError(\"Input 'array' must be a list.\")\n    \n    # Check if all elements in the array are comparable (numbers)\n    if not all(isinstance(x, (int, float)) for x in array):\n        raise TypeError(\"All elements in the array must be numbers.\")\n    \n    # Check if the input number is a number\n    if not isinstance(number, (int, float)):\n        raise TypeError(\"Input 'number' must be a number.\")\n    \n    # Use the built-in all() function with a generator expression to check the condition\n    # all() returns True if all elements of the iterable are true\n    return all(number > elem for elem in array)", "matching_cluster_idx": -1}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a number is greater than all elements in a given array.\n\n    Args:\n        arr (list): A list of numbers.\n        num (int or float): The number to compare.\n\n    Returns:\n        bool: True if num is greater than all elements, False otherwise.\n    \"\"\"\n    # Use the built-in all() function with a generator expression\n    # to check if num is greater than every element in arr\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Checks if a given number is greater than all elements in an array.\n\n    Args:\n        array (list): A list of numbers.\n        num (int or float): The number to compare with array elements.\n\n    Returns:\n        bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    # Check if input is a list and number is an integer or float\n    if not isinstance(array, list) or not all(isinstance(x, (int, float)) for x in array):\n        raise TypeError(\"Array must be a list of numbers.\")\n    if not isinstance(num, (int, float)):\n        raise TypeError(\"Number must be an integer or float.\")\n\n    # Use the built-in all() function with a generator expression to check the condition\n    return all(num > elem for elem in array)", "matching_cluster_idx": -1}]}, "Mbpp/437": {"dps": 96.32352941176471, "dps_norm": 95.0, "pass@1": 39.0, "profiled": [{"solution": "def remove_odd(input_string):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Parameters:\n    input_string (str): The input string from which to remove odd characters.\n\n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return input_string[1::2]  # Slice from index 1 to the end, stepping by 2", "matching_cluster_idx": 3}, {"solution": "def remove_odd(input_string):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n    \n    Parameters:\n    input_string (str): The input string from which to remove odd characters.\n    \n    Returns:\n    str: A new string containing only characters from even indices.\n    \"\"\"\n    return input_string[1::2]  # Slice from the second character (index 1) to the end, stepping by 2", "matching_cluster_idx": 4}, {"solution": "import unittest\ndef remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indexes from the input string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indexes removed.\n    \"\"\"\n    return s[1::2]  # Start from index 1, step by 2 to keep only even-indexed characters", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indexes from a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indexes removed.\n    \"\"\"\n    return s[1::2]  # Python uses 0-based indexing, so start from 1 to skip odds", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    This function removes characters at odd indices from the input string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: A new string with characters from even indices of the input string.\n    \"\"\"\n    return s[1::2]  # Python uses 0-based indexing, so [1::2] skips odd indices (1, 3, 5, ...)", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from the input string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return s[1::2]  # Start from the second character (index 1) and step by 2", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from the input string.\n    \n    Parameters:\n    s (str): The input string from which to remove odd characters.\n    \n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return s[1::2]  # Slice string starting from index 1, stepping by 2", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from the input string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return s[1::2]  # Start from the second character (index 1) and step by 2", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indexes from the input string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indexes removed.\n    \"\"\"\n    return s[1::2]  # Python uses 0-based indexing, so starting from 1 skips the first (odd-indexed) character", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Returns a new string containing only characters at even indices from the input string.\n    \n    :param s: Input string\n    :return: String with characters at odd indices removed\n    \"\"\"\n    return s[1::2]  # Python uses 0-based indexing, so start from 1 to skip 'odd' indices", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indexes from a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indexes removed.\n    \"\"\"\n    return s[1::2]  # Start from index 1 (first odd index), step by 2 to skip odd indexes", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return s[1::2]  # Python uses 0-based indexing, so [1::2] skips odd indices", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from the input string.\n    \n    :param s: Input string\n    :return: String with characters at odd indices removed\n    \"\"\"\n    return s[1::2]  # Slice from index 1 to the end, stepping by 2", "matching_cluster_idx": 4}, {"solution": "import unittest\ndef remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Parameters:\n    - `s` (str): The input string.\n\n    Returns:\n    - (str): The string with characters at odd indices removed.\n    \"\"\"\n    return s[1::2]  # Start from the second character (index 1) and step by 2", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indexes from a given string.\n    \n    Parameters:\n    s (str): The input string from which to remove odd-indexed characters.\n    \n    Returns:\n    str: A new string with characters from the even indexes of the original string.\n    \"\"\"\n    return s[1::2]  # Python uses 0-based indexing, so start from 1 to skip odd indexes", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indices removed.\n    \"\"\"\n    return s[1::2]  # Slice from the second character (index 1) to the end, stepping by 2", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Returns a string with only characters at even indices.\n    \n    :param s: The input string.\n    :return: A new string containing characters from even indices of `s`.\n    \"\"\"\n    return s[1::2]  # Slice the string starting from index 1, stepping by 2", "matching_cluster_idx": 4}, {"solution": "def remove_odd(input_string):\n    \"\"\"\n    Removes characters at odd indexes from the input string.\n    \n    Parameters:\n    - input_string (str): The string from which to remove odd-indexed characters.\n    \n    Returns:\n    - str: A new string containing only the characters at even indexes.\n    \"\"\"\n    return input_string[1::2]  # Slice from index 1 to the end, stepping by 2", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indexes from a string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with characters at odd indexes removed.\n    \"\"\"\n    return s[1::2]  # Slice from index 1 to the end, stepping by 2 (thus, removing odd-indexed characters)", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes odd-indexed characters from a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with odd-indexed characters removed (0-based indexing).\n    \"\"\"\n    return s[1::2]  # Start from index 1, step by 2 to skip odd indices", "matching_cluster_idx": 4}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 24.0, "profiled": [{"solution": "def count_Occurrence(tuple_elements, list_to_check):\n    \"\"\"\n    Counts the occurrences of all elements from `list_to_check` in `tuple_elements`.\n    \n    Parameters:\n    - `tuple_elements` (tuple): The tuple to search in.\n    - `list_to_check` (list): The list of elements to search for.\n    \n    Returns:\n    - `occurrence_count` (int): Total count of occurrences of all elements from the list in the tuple.\n    \"\"\"\n    occurrence_count = 0\n    for element in list_to_check:\n        occurrence_count += tuple_elements.count(element)\n    return occurrence_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_to_search, elements_to_count):\n    \"\"\"\n    Counts the occurrences of all elements from `elements_to_count` list in `tuple_to_search`.\n\n    Args:\n    - tuple_to_search (tuple): The tuple in which to count occurrences.\n    - elements_to_count (list): List of elements to count occurrences for.\n\n    Returns:\n    - int: Total count of occurrences of all elements from the list in the tuple.\n    \"\"\"\n    # Initialize count variable to store total occurrences\n    total_count = 0\n    \n    # Iterate over each element that we need to count\n    for element in elements_to_count:\n        # For each element, count its occurrences in the tuple and add to total_count\n        total_count += tuple_to_search.count(element)\n    \n    # Return the total count of all elements' occurrences\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrences of all elements from a list within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search in.\n    lst (list): The list of elements to count occurrences for.\n    \n    Returns:\n    int: Total occurrences of all elements from `lst` in `tup`.\n    \"\"\"\n    # Initialize a counter variable\n    total_occurrences = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Count the occurrences of the current element in the tuple and add to the total\n        total_occurrences += tup.count(element)\n    \n    # Return the total occurrences found\n    return total_occurrences", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_to_check):\n    \"\"\"\n    Counts the total occurrences of all elements from `list_to_check` within `tuple_input`.\n\n    Args:\n        tuple_input (tuple): The tuple to search in.\n        list_to_check (list): The list containing elements to search for.\n\n    Returns:\n        int: Total count of occurrences of all elements from `list_to_check` in `tuple_input`.\n    \"\"\"\n    # Initialize a counter variable to store the total occurrences\n    total_count = 0\n    \n    # Iterate over each element in the list that we need to check\n    for element in list_to_check:\n        # For each element, count its occurrences in the tuple and add to the total count\n        total_count += tuple_input.count(element)\n    \n    # Return the total count after checking all elements\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_to_search, elements_to_find):\n    \"\"\"\n    Counts the occurrence of all elements from `elements_to_find` list within `tuple_to_search`.\n    \n    Args:\n        tuple_to_search (tuple): The tuple to search in.\n        elements_to_find (list): List of elements to find the occurrences of.\n    \n    Returns:\n        int: Total count of occurrences of all elements from the list in the tuple.\n    \"\"\"\n    # Initialize a counter variable to store the total occurrences\n    total_count = 0\n    \n    # Iterate over each element that we need to find\n    for element in elements_to_find:\n        # For each element, count its occurrences in the tuple and add to the total count\n        total_count += tuple_to_search.count(element)\n    \n    # Return the total count of occurrences\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_to_count):\n    \"\"\"\n    Counts the occurrences of all elements from `list_to_count` in `tuple_input`.\n    \n    Args:\n        tuple_input (tuple): The tuple to search in.\n        list_to_count (list): The list of elements to count occurrences for.\n    \n    Returns:\n        int: Total count of occurrences.\n    \"\"\"\n    # Initialize count to 0\n    total_count = 0\n    \n    # For each element in the list that we want to count\n    for element in list_to_count:\n        # Add the count of this element in the tuple to the total count\n        total_count += tuple_input.count(element)\n    \n    # Return the total count\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_to_check):\n    \"\"\"\n    Counts the total occurrences of all elements from `list_to_check` in `tuple_input`.\n\n    Args:\n    - tuple_input (tuple): The tuple to search in.\n    - list_to_check (list): The list of elements to search for.\n\n    Returns:\n    - int: Total occurrence count of all elements from `list_to_check` in `tuple_input`.\n    \"\"\"\n    # Initialize a counter variable to store the total occurrences\n    total_count = 0\n    \n    # Iterate over each element in the list to check\n    for element in list_to_check:\n        # For each element, count its occurrences in the tuple and add to the total count\n        total_count += tuple_input.count(element)\n    \n    # Return the total count\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of all elements from lst in tup.\n\n    Args:\n        tup (tuple): The tuple to search within.\n        lst (list): The list of elements to count occurrences for.\n\n    Returns:\n        int: Total count of occurrences.\n    \"\"\"\n    # Initialize a counter variable to store the total occurrences\n    total_count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # For each element, count its occurrences in the tuple and add to the total count\n        total_count += tup.count(element)\n    \n    # Return the total count of occurrences\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_to_search, elements_to_count):\n    \"\"\"\n    Counts the occurrences of all elements from a list in a tuple.\n\n    Args:\n        tuple_to_search (tuple): The tuple to search in.\n        elements_to_count (list): List of elements to count.\n\n    Returns:\n        int: Total count of elements from the list found in the tuple.\n    \"\"\"\n    # Initialize a counter variable to store the total count\n    total_count = 0\n    \n    # Iterate over each element in the list of elements to count\n    for element in elements_to_count:\n        # Use the tuple's count method to count occurrences of the current element\n        # and add this to the total count\n        total_count += tuple_to_search.count(element)\n    \n    # Return the total count after checking all elements\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_to_search, elements_to_count):\n    \"\"\"\n    Counts the total occurrences of all elements from `elements_to_count` list within `tuple_to_search`.\n\n    Args:\n    - tuple_to_search (tuple): The tuple to search within.\n    - elements_to_count (list): List of elements to count occurrences for.\n\n    Returns:\n    - int: Total count of occurrences of all elements in the list within the tuple.\n    \"\"\"\n    return sum(tuple_to_search.count(element) for element in elements_to_count)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Counts the total occurrences of all elements from `list_input` in `tuple_input`.\n\n    Args:\n    - tuple_input (tuple): The tuple to search in.\n    - list_input (list): The list of elements to search for.\n\n    Returns:\n    - int: The total count of occurrences of all elements from `list_input` in `tuple_input`.\n    \"\"\"\n    return sum(tuple_input.count(element) for element in list_input)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_targets):\n    \"\"\"\n    Counts the occurrence of all elements from list_targets within tuple_data.\n\n    Args:\n        tuple_data (tuple): The tuple to search in.\n        list_targets (list): The list of elements to count occurrences for.\n\n    Returns:\n        int: The total count of occurrences of all elements from list_targets in tuple_data.\n    \"\"\"\n    # Initialize count to 0\n    total_count = 0\n    \n    # Iterate over each target element\n    for target in list_targets:\n        # Increment total_count by the number of occurrences of the target in the tuple\n        total_count += tuple_data.count(target)\n    \n    # Return the total count\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_elements, list_elements):\n    \"\"\"\n    Counts the occurrence of all elements from the list in the tuple.\n\n    Args:\n        tuple_elements (tuple): The tuple to search in.\n        list_elements (list): The list of elements to search for.\n\n    Returns:\n        int: The total count of occurrences of all elements from the list in the tuple.\n    \"\"\"\n    # Initialize a counter variable to store the total occurrences\n    total_occurrences = 0\n    \n    # Iterate over each element in the list that we're searching for\n    for element in list_elements:\n        # For each element, count its occurrences in the tuple and add to the total\n        total_occurrences += tuple_elements.count(element)\n    \n    # Return the total occurrences found\n    return total_occurrences", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_to_search, elements_to_find):\n    \"\"\"\n    Counts the total occurrences of all elements from `elements_to_find` list in `tuple_to_search`.\n\n    Args:\n    - tuple_to_search (tuple): The tuple to search in.\n    - elements_to_find (list): The list of elements to find and count.\n\n    Returns:\n    - int: Total count of occurrences of all elements from the list in the tuple.\n    \"\"\"\n    # Initialize count variable to 0\n    total_count = 0\n    \n    # Iterate over each element that we need to find\n    for element in elements_to_find:\n        # Count the occurrences of the current element in the tuple and add to total_count\n        total_count += tuple_to_search.count(element)\n    \n    # Return the total count\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_to_search, elements_to_find):\n    \"\"\"\n    Counts the occurrences of all elements from a list within a tuple.\n\n    Args:\n    - `tuple_to_search` (tuple): The tuple to search in.\n    - `elements_to_find` (list): List of elements to find in the tuple.\n\n    Returns:\n    - `int`: Total count of occurrences of all elements from the list in the tuple.\n    \"\"\"\n    # Initialize a counter variable to store the total occurrences\n    total_count = 0\n    \n    # Iterate over each element that we need to find\n    for element in elements_to_find:\n        # For each element, count its occurrences in the tuple and add to the total count\n        total_count += tuple_to_search.count(element)\n    \n    # Return the total count of all elements' occurrences\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_to_find):\n    \"\"\"\n    Counts the occurrence of all elements from list_to_find in tuple_input.\n    \n    Args:\n        tuple_input (tuple): The tuple to search in.\n        list_to_find (list): The list of elements to search for.\n    \n    Returns:\n        int: Total count of occurrences of all elements from list_to_find in tuple_input.\n    \"\"\"\n    # Initialize a counter variable to store the total occurrences\n    total_count = 0\n    \n    # Iterate over each element in the list that we are looking for\n    for element in list_to_find:\n        # For each element, count its occurrences in the tuple and add to the total count\n        total_count += tuple_input.count(element)\n    \n    # Return the total count\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_data, list_elements):\n    \"\"\"\n    Counts the total occurrences of all elements from list_elements in tuple_data.\n    \n    Parameters:\n    tuple_data (tuple): The tuple to search in.\n    list_elements (list): The list of elements to search for.\n    \n    Returns:\n    int: Total occurrences of all list elements in the tuple.\n    \"\"\"\n    # Initialize a counter variable to store the total occurrences\n    total_occurrences = 0\n    \n    # Iterate over each element in the list that we are searching for\n    for element in list_elements:\n        # For each element, count its occurrences in the tuple and add to the total\n        total_occurrences += tuple_data.count(element)\n    \n    # Return the total occurrences found\n    return total_occurrences", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of all elements from a list within a tuple.\n    \n    Parameters:\n    - tup (tuple): Input tuple to search within.\n    - lst (list): List of elements to count occurrences for.\n    \n    Returns:\n    - int: Total count of occurrences of all elements from lst in tup.\n    \"\"\"\n    # Initialize a counter variable\n    total_count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Count the occurrences of the current element in the tuple and add to total_count\n        total_count += tup.count(element)\n    \n    # Return the total count\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total occurrences of all elements from a list within a tuple.\n    \n    Args:\n        tup (tuple): The tuple to search within.\n        lst (list): The list of elements to count occurrences for.\n    \n    Returns:\n        int: The total count of occurrences.\n    \"\"\"\n    # Initialize a counter variable to store the total count\n    total_count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Count the occurrences of the current element in the tuple and add to the total count\n        total_count += tup.count(element)\n    \n    # Return the total count\n    return total_count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_to_search, list_of_elements):\n    \"\"\"\n    Counts the total occurrences of all elements from list_of_elements in tuple_to_search.\n    \n    Args:\n        tuple_to_search (tuple): The tuple to search in.\n        list_of_elements (list): The list of elements to count.\n    \n    Returns:\n        int: Total count of all elements from list_of_elements in tuple_to_search.\n    \"\"\"\n    # Initialize a counter variable to store the total count\n    total_count = 0\n    \n    # Iterate over each element in the list_of_elements\n    for element in list_of_elements:\n        # For each element, count its occurrences in the tuple and add to total_count\n        total_count += tuple_to_search.count(element)\n    \n    # Return the total count\n    return total_count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 77.0, "profiled": [{"solution": "def remove_whitespaces(input_str):\n    \"\"\"\n    Removes all whitespace characters from a given string.\n    \n    :param input_str: The string from which to remove all whitespaces.\n    :return: The input string with all whitespaces removed.\n    \"\"\"\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n    - input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n    - str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: The input string without any whitespace characters.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: Input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: The input string without any whitespace characters.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the given string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: The input string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    Args:\n        input_string (str): The string to remove whitespaces from.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the given string.\n    \n    Args:\n    input_string (str): The input string to be processed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the given string.\n\n    Args:\n        input_string (str): The input string to remove whitespaces from.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespaces from the given input string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n    - input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n    - str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the input string.\n    \n    Args:\n    - input_string (str): The string to remove whitespaces from.\n    \n    Returns:\n    - str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: The input string without any whitespace characters.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the input string.\n    \n    Args:\n        input_string (str): The string from which to remove whitespaces.\n    \n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The string to remove whitespaces from.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    This function takes an input string, removes all whitespaces, and returns the result.\n    \n    :param input_string: The string from which to remove whitespaces.\n    :return: The input string without whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    This function removes all whitespaces from the input string.\n\n    Args:\n        input_string (str): The input string to remove whitespaces from.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: Input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    This function removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The input string from which whitespaces are to be removed.\n\n    Returns:\n        str: The input string without any whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 85.58333333333333, "dps_norm": 97.0, "pass@1": 59.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list (list): A list containing string values.\n\n    Returns:\n        list: A list with each original string reversed.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(string_list, list):\n        raise ValueError(\"Input must be a list\")\n    \n    # Use list comprehension to reverse each string in the list\n    # The condition checks if each element in the list is indeed a string\n    reversed_list = [s[::-1] for s in string_list if isinstance(s, str)]\n    \n    # If not all elements were processed (i.e., some were not strings), warn and return\n    if len(reversed_list) != len(string_list):\n        print(\"Warning: Non-string elements encountered and excluded from reversal.\")\n    \n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of strings.\n\n    Args:\n        string_list (list): A list containing string values.\n\n    Returns:\n        list: A list with each original string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n        strings (list[str]): List of string values.\n    \n    Returns:\n        list[str]: List with each string reversed.\n    \"\"\"\n    # Using list comprehension to iterate over each string in the input list\n    # and the slicing technique to reverse each string\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list.\n    \n    Args:\n    - string_list (list): A list containing string values.\n    \n    Returns:\n    - list: A list with each original string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        string_list (list): A list of strings.\n\n    Returns:\n        list: A list with each string reversed.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(string_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Ensure all elements in the list are strings\n    if not all(isinstance(s, str) for s in string_list):\n        raise ValueError(\"All elements in the list must be strings.\")\n    \n    # Use list comprehension with slicing to reverse each string\n    reversed_list = [s[::-1] for s in string_list]\n    \n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n        strings (list[str]): A list of string values.\n    \n    Returns:\n        list[str]: A new list with each string from the input list reversed.\n    \"\"\"\n    # Use list comprehension to create a new list with reversed strings\n    # The reversed() function returns a reverse iterator, and join() concatenates the characters back into a string\n    return [''.join(reversed(s)) for s in strings]", "matching_cluster_idx": 3}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Parameters:\n    - `string_list` (list): A list containing string values.\n    \n    Returns:\n    - `list`: A new list with each string from the input list reversed.\n    \"\"\"\n    # Use list comprehension to create a new list with reversed strings\n    # The `reversed` function returns a reverse iterator, and `join` concatenates the characters back into a string\n    return [''.join(reversed(s)) for s in string_list]", "matching_cluster_idx": 3}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list (list): A list containing string values.\n\n    Returns:\n        list: A list with each string from the input list reversed.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(string_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Ensure all elements in the list are strings\n    if not all(isinstance(s, str) for s in string_list):\n        raise TypeError(\"All elements in the list must be strings.\")\n    \n    # Use list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in string_list]\n    \n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    :param input_list: List of string values\n    :return: List of strings with each element reversed\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Validate all elements in the list are strings\n    if not all(isinstance(item, str) for item in input_list):\n        raise ValueError(\"All elements in the list must be strings.\")\n    \n    # Use list comprehension with slicing to reverse each string\n    reversed_list = [item[::-1] for item in input_list]\n    \n    return reversed_list\ninput_list = ['Red', 'Green', 'Blue', 'White', 'Black']", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n        string_list (list): A list of string values.\n    \n    Returns:\n        list: A new list with each string from the input list reversed.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(string_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Ensure all elements in the list are strings\n    if not all(isinstance(s, str) for s in string_list):\n        raise TypeError(\"All elements in the list must be strings.\")\n    \n    # Use list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in string_list]\n    \n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n        string_list (list): A list of string values.\n    \n    Returns:\n        list: A new list with each string from the input list reversed.\n    \"\"\"\n    # Use list comprehension to create a new list with each string reversed\n    # The expression `s[::-1]` slices the string `s` in reverse order\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n        input_list (list): A list of string values.\n    \n    Returns:\n        list: A new list with each string from the input list reversed.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Ensure all elements in the list are strings\n    if not all(isinstance(item, str) for item in input_list):\n        raise ValueError(\"All elements in the list must be strings.\")\n    \n    # Use list comprehension to reverse each string in the input list\n    reversed_list = [item[::-1] for item in input_list]\n    \n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n    - **strings** (list[str]): A list of string values to be reversed.\n\n    Returns:\n    - list[str]: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    strings (list): A list of string values.\n    \n    Returns:\n    list: A list with each string from the input list reversed.\n    \"\"\"\n    # Use list comprehension for concise and efficient iteration over the input list\n    # The slicing operation [::-1] is used to reverse each string\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    - `string_list` (list): A list of strings.\n    \n    Returns:\n    - `list`: A list of strings where each original string is reversed.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(string_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Ensure all elements in the list are strings\n    if not all(isinstance(s, str) for s in string_list):\n        raise TypeError(\"All elements in the list must be strings.\")\n    \n    # Use list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in string_list]\n    \n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n        string_list (list): A list containing string values.\n    \n    Returns:\n        list: A list with each string from the input list reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list (list[str]): A list of strings.\n\n    Returns:\n        list[str]: A new list with each string from the input list reversed.\n    \"\"\"\n    # Use list comprehension to create a new list with reversed strings\n    # The expression `string[::-1]` reverses each string in the input list\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the input list.\n\n    Args:\n    - strings (list of str): A list of string values.\n\n    Returns:\n    - list of str: The input list with each string reversed.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(strings, list):\n        raise TypeError(\"Input must be a list of strings.\")\n\n    # Use list comprehension to reverse each string in the list\n    # The `[::-1]` slice reverses a string in Python\n    # Also check each element is a string before attempting to reverse\n    reversed_list = [s[::-1] for s in strings if isinstance(s, str)]\n\n    # If the original list length doesn't match the processed list, \n    # it means non-string elements were found and removed\n    if len(strings) != len(reversed_list):\n        print(\"Warning: Non-string elements were found and excluded from the result.\")\n\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    **Parameters:**\n    - `string_list` (list): A list containing string values.\n\n    **Returns:**\n    - `list`: The input list with each string reversed.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(string_list, list):\n        raise TypeError(\"Input must be a list.\")\n\n    # Ensure all elements in the list are strings\n    if not all(isinstance(item, str) for item in string_list):\n        raise ValueError(\"All elements in the list must be strings.\")\n\n    # Use list comprehension to reverse each string in the list\n    reversed_list = [item[::-1] for item in string_list]\n    \n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n    \n    Args:\n    - strings (list): A list of string values.\n    \n    Returns:\n    - list: A new list with each original string reversed.\n    \"\"\"\n    # Use list comprehension to create a new list with reversed strings\n    # The `reversed` function returns a reversed iterator of the string, \n    # and `join` concatenates the characters back into a string\n    return [''.join(reversed(s)) for s in strings]", "matching_cluster_idx": 3}]}, "Mbpp/460": {"dps": 43.67408906882591, "dps_norm": 73.6842105263158, "pass@1": 19.0, "profiled": [{"solution": "def Extract(sublists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n    \n    Parameters:\n    - sublists (list of lists): A list containing sublists.\n    \n    Returns:\n    - list: A list of the first elements of the input sublists.\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Check for non-empty sublists", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n\n    Args:\n        sublists (list of lists): A list containing sublists.\n\n    Returns:\n        list: A list with the first element from each sublist.\n\n    Example:\n        >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n        [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Handle empty sublists safely", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n\n    :param list_of_lists: A list containing sublists\n    :return: List of first elements\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists if sublist]  # Handling empty sublists", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist in the provided list.\n\n    Args:\n        sublists (list): A list containing sublists.\n\n    Returns:\n        list: A list of the first elements from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Check if sublist is not empty", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist in a given list of lists.\n\n    Args:\n        sublists (list): A list containing sublists.\n\n    Returns:\n        list: A list of first elements, one from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Handling potential empty sublists", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a new list containing the first element from each sublist.\n\n    :param list_of_lists: A list containing sublists.\n    :return: A list of the first elements from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists if sublist]  # Safeguard against empty sublists", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n\n    :param sublists: A list of lists\n    :return: List of first elements\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Handling empty sublists", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element of each sublist from a given list of lists.\n\n    Args:\n    - list_of_lists (list): A list containing sublists.\n\n    Returns:\n    - list: A list containing the first element of each sublist.\n    \"\"\"\n    # Check if input is a list to ensure the function works as expected\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    # Use list comprehension to iterate over each sublist and extract the first element\n    # Assuming all sublists are non-empty and are indeed lists\n    return [sublist[0] for sublist in list_of_lists if isinstance(sublist, list) and sublist]", "matching_cluster_idx": 2}, {"solution": "import unittest\ndef Extract(sublists):\n    \"\"\"\n    Returns a list containing the first element from each sublist.\n\n    Args:\n        sublists (list): A list of lists.\n\n    Returns:\n        list: A list of first elements from the input sublists.\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Handle potential empty sublists", "matching_cluster_idx": 3}, {"solution": "import unittest\ndef Extract(sublists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n\n    Args:\n        sublists (list of lists): A list of lists from which to extract first elements.\n\n    Returns:\n        list: A list of the first elements.\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Check for non-empty sublists", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist in a given list of lists.\n\n    Args:\n        sublists (list): A list containing sublists.\n\n    Returns:\n        list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Ensure sublist is not empty", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n\n    Args:\n    - `sublists` (list of lists): Input list containing sublists.\n\n    Returns:\n    - `list`: A list of the first elements of the input sublists.\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Using list comprehension to handle empty sublists safely", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n\n    :param sublists: A list of lists\n    :return: A list of first elements\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Handles empty sublists", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n    \n    :param list_of_lists: A list containing sublists.\n    :return: A list of first elements.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist in the given list of sublists.\n    \n    Args:\n        sublists (list of lists): A list containing sublists.\n    \n    Returns:\n        list: A list containing the first element from each sublist.\n    \n    Raises:\n        TypeError: If input is not a list of lists.\n        ValueError: If any sublist is empty.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(sublists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    # Initialize an empty list to store the first elements\n    first_elements = []\n    \n    # Iterate over each sublist in the main list\n    for sublist in sublists:\n        # Check if sublist is indeed a list\n        if not isinstance(sublist, list):\n            raise TypeError(\"Input must be a list of lists.\")\n        \n        # Check if sublist is not empty\n        if len(sublist) == 0:\n            raise ValueError(\"Sublists cannot be empty.\")\n        \n        # Append the first element of the current sublist to the result list\n        first_elements.append(sublist[0])\n    \n    return first_elements", "matching_cluster_idx": -1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n    \n    Args:\n    - list_of_lists (list): A list containing sublists.\n    \n    Returns:\n    - list: A list of the first elements from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists if sublist]  # Handle empty sublists", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist in the provided list of lists.\n\n    Args:\n        sublists (list of lists): A list containing sublists.\n\n    Returns:\n        list: A list of first elements from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in sublists if sublist]  # Handle potential empty sublists", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element from each sublist in the provided list of sublists.\n\n    Args:\n        sublists (list of lists): A list containing sublists.\n\n    Returns:\n        list: A list of the first elements from each sublist.\n\n    Raises:\n        TypeError: If input is not a list of lists.\n        ValueError: If any sublist is empty.\n    \"\"\"\n    # Validate input type\n    if not all(isinstance(sublist, list) for sublist in sublists):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    # Extract first element from each sublist\n    first_elements = [sublist[0] for sublist in sublists if sublist]\n    \n    # Check if any sublist was empty (since we filtered them out)\n    if len(first_elements) != len(sublists):\n        raise ValueError(\"All sublists must be non-empty.\")\n    \n    return first_elements", "matching_cluster_idx": 1}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n\n    Args:\n        list_of_lists (list): A list of lists\n\n    Returns:\n        list: A list of first elements from each sublist\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists if sublist]  # Handles empty sublists", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 79.17073170731707, "dps_norm": 95.0, "pass@1": 81.0, "profiled": [{"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `input_string`.\n    \n    Args:\n        - input_string (str): The original string.\n        - char_to_replace (str): Character to be replaced. Must be a single character.\n        - replacement_char (str): Character to replace with. Must be a single character.\n    \n    Returns:\n        - str: The modified string after replacement.\n    \"\"\"\n    if not isinstance(input_string, str) or not isinstance(char_to_replace, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"All inputs must be strings.\")\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"char_to_replace and replacement_char must be single characters.\")\n    \n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 5}, {"solution": "def replace_char(original_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a specified character in a string with another character.\n\n    Args:\n        original_string (str): The string in which characters will be replaced.\n        char_to_replace (str): A single character to be replaced.\n        replacement_char (str): A single character to replace with.\n\n    Returns:\n        str: The modified string after replacement.\n    \"\"\"\n    return original_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `input_string`.\n\n    Args:\n        - input_string (str): The original string.\n        - char_to_replace (str): Character to be replaced. Must be a single character.\n        - replacement_char (str): Character to replace with. Must be a single character.\n\n    Returns:\n        - str: The modified string after replacement.\n    \"\"\"\n    if not isinstance(input_string, str) or not isinstance(char_to_replace, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"All inputs must be strings.\")\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"char_to_replace and replacement_char must be single characters.\")\n\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `input_str`.\n\n    Args:\n        - input_str (str): The original string.\n        - char_to_replace (str): Character to be replaced.\n        - replacement_char (str): Character to replace with.\n\n    Returns:\n        - str: The modified string after replacement.\n    \"\"\"\n    return input_str.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of char_to_replace with replacement_char in input_str.\n    \n    Args:\n        input_str (str): The original string.\n        char_to_replace (str): Character to be replaced. Must be of length 1.\n        replacement_char (str): Character to replace with. Must be of length 1.\n    \n    Returns:\n        str: The modified string with replacements made.\n    \"\"\"\n    if not isinstance(input_str, str) or not isinstance(char_to_replace, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"All inputs must be strings.\")\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"char_to_replace and replacement_char must be single characters.\")\n    \n    return input_str.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 5}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of `old` with `new` in string `s`.\n    \n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n    \n    Returns:\n        str: The modified string with all `old` characters replaced by `new`.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(original_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `original_string`.\n    \n    Parameters:\n    - `original_string` (str): The input string.\n    - `char_to_replace` (str): A single character to be replaced.\n    - `replacement_char` (str): A single character to replace with.\n    \n    Returns:\n    - str: The modified string after replacement.\n    \"\"\"\n    if not isinstance(original_string, str) or not isinstance(char_to_replace, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"All inputs must be strings.\")\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"char_to_replace and replacement_char must be single characters.\")\n    \n    # Using built-in string method `replace` for simplicity and efficiency\n    return original_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 5}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of `old_char` with `new_char` in `string`.\n\n    Args:\n        - `string (str)`: The original string.\n        - `old_char (str)`: The character to be replaced.\n        - `new_char (str)`: The character to replace with.\n\n    Returns:\n        - `str`: The modified string with `old_char` replaced by `new_char`.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a specified character in a string with another character.\n\n    Args:\n        input_str (str): The original string.\n        char_to_replace (str): The character to be replaced.\n        replacement_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string.\n    \"\"\"\n    return input_str.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `input_str`.\n    \n    Parameters:\n    - input_str (str): The original string.\n    - char_to_replace (str): Character to be replaced. Must be a single character.\n    - replacement_char (str): Character to replace with. Must be a single character.\n    \n    Returns:\n    - str: The modified string with replacements made.\n    \"\"\"\n    if not isinstance(input_str, str) or not isinstance(char_to_replace, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"All inputs must be strings.\")\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"char_to_replace and replacement_char must be single characters.\")\n    \n    return input_str.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 5}, {"solution": "def replace_char(original_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `original_string`.\n\n    Args:\n        - **original_string** (str): The input string.\n        - **char_to_replace** (str): Character to be replaced.\n        - **replacement_char** (str): Character to replace with.\n\n    Returns:\n        - **str**: Modified string after replacement.\n    \"\"\"\n    return original_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(original_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `original_string`.\n\n    Args:\n        - `original_string` (str): The string in which characters will be replaced.\n        - `char_to_replace` (str): A single character to be replaced.\n        - `replacement_char` (str): The character that will replace `char_to_replace`.\n\n    Returns:\n        - `str`: The modified string after replacement.\n    \"\"\"\n    if not isinstance(original_string, str) or not isinstance(char_to_replace, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"All inputs must be strings.\")\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"char_to_replace and replacement_char must be single characters.\")\n\n    return original_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 5}, {"solution": "def replace_char(input_str, target_char, replacement_char):\n    \"\"\"\n    Replaces all occurrences of target_char with replacement_char in input_str.\n    \n    Args:\n        input_str (str): The original string.\n        target_char (str): Character to be replaced.\n        replacement_char (str): Character to replace with.\n    \n    Returns:\n        str: The modified string.\n    \"\"\"\n    return input_str.replace(target_char, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(original_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `original_string`.\n    \n    Args:\n    - original_string (str): The input string to modify.\n    - char_to_replace (str): A single character to be replaced.\n    - replacement_char (str): A single character to replace with.\n    \n    Returns:\n    - str: The modified string with all occurrences of `char_to_replace` changed to `replacement_char`.\n    \"\"\"\n    if not isinstance(original_string, str) or not isinstance(char_to_replace, str) or not isinstance(replacement_char, str):\n        raise TypeError(\"All inputs must be strings.\")\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"char_to_replace and replacement_char must be single characters.\")\n    \n    return original_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 5}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `input_string`.\n\n    Args:\n        - input_string (str): The original string.\n        - char_to_replace (str): Character to be replaced. Must be of length 1.\n        - replacement_char (str): Character to replace with. Must be of length 1.\n\n    Returns:\n        - str: The modified string after replacement.\n\n    Raises:\n        - ValueError: If `char_to_replace` or `replacement_char` is not a single character.\n    \"\"\"\n    if not (isinstance(char_to_replace, str) and isinstance(replacement_char, str) and \n            len(char_to_replace) == 1 and len(replacement_char) == 1):\n        raise ValueError(\"Both 'char_to_replace' and 'replacement_char' must be single characters.\")\n\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, original, replacement):\n    \"\"\"\n    Replaces all occurrences of a character with another in a given string.\n\n    Args:\n        input_str (str): The original string.\n        original (str): The character to be replaced.\n        replacement (str): The character to replace with.\n\n    Returns:\n        str: The modified string with replacements made.\n    \"\"\"\n    return input_str.replace(original, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `input_str`.\n    \n    Parameters:\n    - input_str (str): The original string.\n    - char_to_replace (str): A single character to be replaced.\n    - replacement_char (str): A single character to replace with.\n    \n    Returns:\n    - str: The modified string after replacement.\n    \"\"\"\n    # Check if inputs are strings\n    if not all(isinstance(s, str) for s in [input_str, char_to_replace, replacement_char]):\n        raise TypeError(\"All inputs must be strings.\")\n    # Check if char_to_replace and replacement_char are single characters\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"char_to_replace and replacement_char must be single characters.\")\n    \n    # Use Python's built-in string method replace to achieve the substitution\n    return input_str.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 5}, {"solution": "def replace_char(original_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n\n    Args:\n        - original_string (str): The original string to modify.\n        - char_to_replace (str): The character to replace (length must be 1).\n        - replacement_char (str): The character to replace with (length must be 1).\n\n    Returns:\n        - str: The modified string with all occurrences of `char_to_replace` replaced by `replacement_char`.\n\n    Raises:\n        - ValueError: If `char_to_replace` or `replacement_char` is not a single character.\n    \"\"\"\n    if not (isinstance(char_to_replace, str) and isinstance(replacement_char, str) and \n            len(char_to_replace) == 1 and len(replacement_char) == 1):\n        raise ValueError(\"Both char_to_replace and replacement_char must be single characters.\")\n\n    return original_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another.\n\n    Args:\n        input_str (str): The original string.\n        char_to_replace (str): Character to be replaced. Must be a single character.\n        replacement_char (str): Character to replace with. Must be a single character.\n\n    Returns:\n        str: The modified string with replacements made.\n\n    Raises:\n        ValueError: If either `char_to_replace` or `replacement_char` is not a single character.\n    \"\"\"\n    if len(char_to_replace) != 1 or len(replacement_char) != 1:\n        raise ValueError(\"Both char_to_replace and replacement_char must be single characters.\")\n\n    return input_str.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of `char_to_replace` with `replacement_char` in `input_string`.\n\n    Args:\n        input_string (str): The original string.\n        char_to_replace (str): Character to be replaced. Must be a single character.\n        replacement_char (str): Character to replace with. Must be a single character.\n\n    Returns:\n        str: The modified string after replacement.\n\n    Raises:\n        ValueError: If `char_to_replace` or `replacement_char` is not a single character.\n    \"\"\"\n    if not (isinstance(char_to_replace, str) and isinstance(replacement_char, str) and \n            len(char_to_replace) == len(replacement_char) == 1):\n        raise ValueError(\"Both characters to replace and replacement character must be single characters.\")\n\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 95.0503355704698, "dps_norm": 96.66666666666667, "pass@1": 73.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"\n    Calculates the sum of the smallest and largest numbers in a given array.\n\n    :param arr: A list of numbers\n    :return: The sum of the smallest and largest numbers\n    \"\"\"\n    if not arr:  # Check if array is empty\n        return 0  # or raise an exception, depending on your requirements\n    \n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    This function calculates the sum of the smallest and largest numbers in a given array.\n\n    Parameters:\n    - array (list): A list of numbers.\n\n    Returns:\n    - int/float: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n    - ValueError: If the input array is empty.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Array cannot be empty\")\n\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    This function calculates the sum of the smallest and largest values in a given array.\n\n    Args:\n        array (list): A list of numbers.\n\n    Returns:\n        int or float: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n        ValueError: If the input array is empty.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Input array cannot be empty\")\n\n    # Find the smallest and largest numbers in the array\n    smallest = min(array)\n    largest = max(array)\n\n    # Calculate and return the sum of the smallest and largest numbers\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    Returns the sum of the smallest and largest elements in the given array.\n\n    :param array: A list of numbers.\n    :return: The sum of the smallest and largest numbers in the array.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Array cannot be empty\")\n    \n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the input array.\n\n    :param array: A list of numbers\n    :return: Sum of the largest and smallest numbers\n    :rtype: int or float\n    \"\"\"\n    if not array:  # Check if array is empty\n        raise ValueError(\"Input array is empty\")\n    return max(array) + min(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    This function calculates the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    array (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the largest and smallest numbers in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n\n    # Check if the array is empty\n    if not array:\n        raise ValueError(\"Input array is empty\")\n\n    # Identify the smallest and largest numbers in the array\n    smallest = min(array)\n    largest = max(array)\n\n    # Calculate and return the sum of the smallest and largest numbers\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function calculates the sum of the smallest and largest numbers in a given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int or float: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array is empty\")\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest values in a given array.\n\n    Args:\n        arr (list): A list of numbers.\n\n    Returns:\n        int or float: The sum of the maximum and minimum values in the array.\n    \"\"\"\n    if not arr:  # Check if the array is empty\n        raise ValueError(\"Array cannot be empty\")\n\n    # Find the smallest and largest numbers in the array\n    smallest = min(arr)\n    largest = max(arr)\n\n    # Return the sum of the smallest and largest numbers\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculates the sum of the smallest and largest numbers in an array.\n\n    Args:\n        arr (list): A list of numbers.\n\n    Returns:\n        int: The sum of the smallest and largest numbers.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    Returns the sum of the smallest and largest values in the input array.\n\n    :param array: A list of numbers\n    :return: The sum of the smallest and largest numbers in the array\n    \"\"\"\n    if not array:\n        raise ValueError(\"Array cannot be empty\")\n    \n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    Calculates the sum of the smallest and largest values in a given array.\n\n    Args:\n        array (list): A list of numbers.\n\n    Returns:\n        int or float: Sum of the smallest and largest numbers in the array.\n\n    Raises:\n        ValueError: If input array is empty.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Input array cannot be empty\")\n\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    Returns the sum of the smallest and largest numbers in the given array.\n\n    Args:\n    - array (list): A list of numbers.\n\n    Returns:\n    - int or float: The sum of the smallest and largest numbers in the array.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Array cannot be empty\")\n\n    # Ensure all elements in the array are numbers\n    if not all(isinstance(x, (int, float)) for x in array):\n        raise ValueError(\"All elements in the array must be numbers\")\n\n    # Find the smallest and largest numbers in the array\n    smallest = min(array)\n    largest = max(array)\n\n    # Return the sum of the smallest and largest numbers\n    return smallest + largest", "matching_cluster_idx": 1}, {"solution": "def big_sum(array):\n    \"\"\"\n    This function calculates the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    - array (list): A list of numbers.\n\n    Returns:\n    - int or float: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n    - ValueError: If the input array is empty.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Input array cannot be empty\")\n\n    # Find the smallest and largest values in the array\n    smallest = min(array)\n    largest = max(array)\n\n    # Return the sum of the smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    This function calculates the sum of the smallest and largest numbers in a given array.\n    \n    Parameters:\n    - `array` (list): A list of numbers.\n    \n    Returns:\n    - `int`: The sum of the smallest and largest numbers in the array.\n    \"\"\"\n    if not array:  # Check if the array is empty\n        raise ValueError(\"Array cannot be empty\")\n    \n    # Find the smallest and largest numbers in the array\n    smallest = min(array)\n    largest = max(array)\n    \n    # Return the sum of the smallest and largest numbers\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    This function finds the sum of the largest and smallest values in a given array.\n\n    Args:\n        array (list): A list of numbers.\n\n    Returns:\n        int: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n        ValueError: If the input array is empty.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Input array is empty\")\n\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "import unittest\ndef big_sum(array):\n    \"\"\"\n    Returns the sum of the smallest and largest elements in the given array.\n\n    Args:\n        array (list): A list of numbers.\n\n    Returns:\n        int or float: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n        ValueError: If the input array is empty.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Input array is empty\")\n    \n    # Find the smallest and largest numbers in the array\n    smallest = min(array)\n    largest = max(array)\n    \n    # Return the sum of the smallest and largest numbers\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    This function calculates the sum of the smallest and largest numbers in a given array.\n\n    Args:\n        array (list): A list of numbers.\n\n    Returns:\n        int or float: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n        ValueError: If the input array is empty.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Input array cannot be empty\")\n\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function calculates the sum of the smallest and largest numbers in a given array.\n\n    Args:\n        arr (list): A list of numbers.\n\n    Returns:\n        int: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n        ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array is empty\")\n\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    This function calculates the sum of the smallest and largest numbers in a given array.\n\n    Args:\n        array (list): A list of numbers.\n\n    Returns:\n        int: The sum of the smallest and largest numbers in the array.\n\n    Raises:\n        ValueError: If the input array is empty.\n    \"\"\"\n    if not array:\n        raise ValueError(\"Input array cannot be empty\")\n\n    return min(array) + max(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function calculates the sum of the largest and smallest values in a given array.\n    \n    Parameters:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: The sum of the largest and smallest numbers in the array.\n    \"\"\"\n    if not arr:  # Check if the array is empty\n        return None  # or you can raise an exception based on your requirement\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 58.0, "profiled": [{"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_string (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the input string to lower case.\n\n    Parameters:\n    - input_string (str): The string to be converted.\n\n    Returns:\n    - str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n    input_string (str): The string to be converted.\n\n    Returns:\n    str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the input string to lower case.\n\n    Args:\n        input_string (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_string (str): The string to convert.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def to_lower(input_str):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_str (str): The input string to convert.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    if not isinstance(input_str, str):\n        raise TypeError(\"Input must be a string.\")\n    return input_str.lower()\ndef is_lower(input_str):\n    return to_lower(input_str)", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the input string to lower case.\n\n    Args:\n        input_string (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the input string to lower case.\n\n    Args:\n    - input_string (str): The string to be converted.\n\n    Returns:\n    - str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_string (str): The input string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given input string to lower case.\n\n    Args:\n        input_string (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the input string to lower case.\n\n    Args:\n        input_string (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_string (str): The input string to convert.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the input string to lower case.\n\n    Args:\n        input_string (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the input string to lower case.\n\n    Args:\n    - input_string (str): The string to be converted.\n\n    Returns:\n    - str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_str (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the input string to lower case.\n\n    Args:\n        input_string (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_string (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n\n    Example:\n        >>> is_lower(\"InValid\")\n        'invalid'\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n    \n    Args:\n        input_string (str): The string to convert.\n    \n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given input string to lower case.\n\n    Args:\n        input_string (str): The input string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n\n    Raises:\n        TypeError: If input is not a string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the input string to lower case.\n\n    Args:\n        input_string (str): The string to be converted.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 80.3825136612022, "dps_norm": 80.9090909090909, "pass@1": 56.0, "profiled": [{"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a string.\n\n    Args:\n        input_string (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (.*?) enclosed in double quotes\n    pattern = r'\"(.*?)\"'\n    \n    # Find all matches of the pattern in the input string\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a given string.\n    \n    Parameters:\n    s (str): Input string containing quoted values.\n    \n    Returns:\n    list: A list of values extracted from the input string.\n    \"\"\"\n    # Regular expression pattern to match any characters (except newline) \n    # enclosed in double quotes\n    pattern = r'\"([^\"\\n]*)\"'\n    \n    # Find all matches of the pattern in the input string\n    matches = re.findall(pattern, s)\n    \n    return matches", "matching_cluster_idx": 7}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a given string.\n    \n    Args:\n        s (str): The input string containing quoted values.\n    \n    Returns:\n        list: A list of strings, each representing a value that was enclosed in double quotes in the input string.\n    \"\"\"\n    # Regular expression pattern to match any characters (including none) between double quotes\n    pattern = r'\"([^\"]*)\"'\n    \n    # Find all matches in the string\n    matches = re.findall(pattern, s)\n    \n    # Return the matches, which are the values between the double quotes\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extract values enclosed within quotation marks from a given string.\n    \n    Args:\n    input_string (str): The string to extract quoted values from.\n    \n    Returns:\n    list: A list of strings representing the values between the quotation marks.\n    \"\"\"\n    # Regular expression pattern to match values enclosed in double quotes\n    pattern = r'\"([^\"]*)\"'\n    \n    # Use findall to get all matches of the pattern in the input string\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a string.\n\n    Args:\n        s (str): Input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (.*?) enclosed in quotes (\"\")\n    pattern = r'\"(.*?)\"'\n    # re.findall returns all non-overlapping matches of pattern in string, as a list of strings\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a string.\n\n    Args:\n        input_string (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    # Regular expression pattern to match any character (except newline) \n    # enclosed in double quotes, allowing for capturing the content\n    pattern = r'\"(.*?)\"'\n    \n    # Find all occurrences of the pattern in the input string\n    matches = re.findall(pattern, input_string, flags=re.DOTALL)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed within double quotation marks from a string.\n\n    Args:\n    - input_string (str): The input string containing quoted values.\n\n    Returns:\n    - list: A list of values extracted from the input string.\n    \"\"\"\n    # Regular expression pattern to match values within double quotes\n    pattern = r'\"(.*?)\"'\n    \n    # Find all matches in the input string, capturing the group within the quotes\n    matches = re.findall(pattern, input_string)\n    \n    # Return the list of matches\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a given string.\n\n    Args:\n    s (str): Input string containing values enclosed in quotation marks.\n\n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Using regular expression to find all substrings enclosed in double quotes\n    pattern = r'\"([^\"]*)\"'  \n    # re.findall returns all non-overlapping matches of pattern in string, as a list of strings\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    \"\"\"\n    Extract values enclosed within quotation marks from a given string.\n\n    :param s: Input string containing quoted values.\n    :return: List of strings representing values extracted from within quotes.\n    \"\"\"\n    import re\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed within double quotation marks from a given string.\n\n    Args:\n        input_string (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the enclosing quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (including none) \n    # enclosed within double quotes\n    pattern = r'\"(.*?)\"'\n    \n    # Find all matches in the input string\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a given string.\n\n    Args:\n        input_string (str): The input string containing values enclosed in double quotes.\n\n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    # Regular expression pattern to match any characters (including spaces) \n    # enclosed in double quotes. The matched group (values within quotes) \n    # is captured for retrieval.\n    pattern = r'\"([^\"]*)\"'\n    \n    # Use findall to get all non-overlapping matches of the pattern in the string \n    # as a list of strings. The string is scanned left-to-right, and matches \n    # are returned in the order found.\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a given string.\n\n    Parameters:\n    - input_string (str): The string to extract quoted values from.\n\n    Returns:\n    - list: A list of strings representing the values extracted from within quotes.\n    \"\"\"\n    pattern = r'\"(.*?)\"'  # Regular expression pattern to match any characters (.*?) between quotes (\"\")\n    matches = re.findall(pattern, input_string)  # Find all matches of the pattern in the string\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a string.\n    \n    Args:\n        input_string (str): The input string to extract quoted values from.\n    \n    Returns:\n        list[str]: A list of values that were enclosed in double quotation marks.\n    \"\"\"\n    # Regular expression pattern to match values enclosed in double quotes\n    pattern = r'\"(.*?)\"'\n    \n    # Find all occurrences of the pattern in the input string\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a given string.\n\n    Args:\n    - s (str): Input string containing quoted values.\n\n    Returns:\n    - list: A list of extracted values.\n    \"\"\"\n    # Regular expression pattern to match any character (except newline) \n    # enclosed within double quotes\n    pattern = r'\"([^\"\\n]*)\"'\n    \n    # Find all occurrences matching the pattern in the input string\n    matches = re.findall(pattern, s)\n    \n    return matches", "matching_cluster_idx": 7}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a string.\n    \n    Parameters:\n    - `s` (str): The input string containing quoted values.\n    \n    Returns:\n    - list: A list of strings, each being a value extracted from between quotation marks.\n    \"\"\"\n    # Regular expression pattern to match strings enclosed in double quotes\n    pattern = r'\"(.*?)\"'\n    # Find all matches of the pattern in the string, capturing the group within the quotes\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from a given string.\n\n    Parameters:\n    - `s` (str): Input string containing values enclosed in double quotes.\n\n    Returns:\n    - `list[str]`: A list of values extracted from the input string.\n    \"\"\"\n    # Regular expression pattern to match any characters (including none) between double quotes\n    pattern = r'\"([^\"]*)\"'\n    \n    # re.findall returns all non-overlapping matches of pattern in string, as a list of strings\n    # The parentheses in the pattern create a capture group, which allows findall to return only the part of the match inside the quotes\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed within double quotation marks from a given string.\n\n    Args:\n        input_string (str): The string from which to extract quoted values.\n\n    Returns:\n        list: A list of strings, each representing a value that was enclosed in double quotes in the input string.\n    \"\"\"\n    # Regular expression pattern to match any character (.) any number of times (*?) \n    # enclosed within double quotes (\"\") but in a non-greedy way to avoid matching too much\n    pattern = r'\"(.*?)\"'\n    \n    # Use re.findall to find all occurrences of the pattern in the input string\n    # The parentheses in the pattern create a capture group, so re.findall returns the captured groups (i.e., the text within the quotes)\n    return re.findall(pattern, input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a given string.\n    \n    Parameters:\n    s (str): Input string containing values enclosed in quotation marks.\n    \n    Returns:\n    list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (including none) \n    # that are enclosed within double quotes\n    pattern = r'\"([^\"]*)\"'\n    \n    # Use findall to get all matches of the pattern in the string\n    # The parentheses in the pattern create a group, so findall returns \n    # the groups (i.e., the text within the quotes) rather than the full match (quote-inclusive)\n    matches = re.findall(pattern, s)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a given string.\n\n    Args:\n        s (str): Input string containing quoted values.\n\n    Returns:\n        list: A list of strings, each representing a value that was enclosed in quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (non-greedy) within double quotes\n    pattern = r'\"(.*?)\"'\n    \n    # Find all matches of the pattern in the string\n    matches = re.findall(pattern, s)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a given input string.\n\n    Args:\n        input_string (str): The string from which to extract quoted values.\n\n    Returns:\n        list: A list of strings, each representing a value that was enclosed in quotation marks in the input string.\n    \"\"\"\n    # Regular expression pattern to match any characters (including none) that are within double quotes\n    pattern = r'\"([^\"]*)\"'\n    # Find all occurrences in the input string based on the pattern\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.30864197530865, "dps_norm": 86.42857142857142, "pass@1": 80.0, "profiled": [{"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Returns a list of numbers that appear only once in the input list.\n    \n    :param nums: List of integers\n    :return: List of unique integers\n    \"\"\"\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    return [num for num, count in count_dict.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    This function removes numbers that appear more than once in the input list.\n    \n    :param numbers: A list of integers\n    :return: A list of integers with only numbers that appear once in the original list\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    num_count = {}\n    \n    # Count occurrences of each number\n    for num in numbers:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in num_count.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(num_list):\n    \"\"\"\n    Removes duplicate numbers from a given list, returning only numbers that appear once.\n\n    :param num_list: List of integers\n    :return: List of integers with duplicates removed\n    \"\"\"\n    # Count occurrences of each number\n    num_counts = {}\n    for num in num_list:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(num_list):\n    \"\"\"\n    Removes duplicate numbers from a given list, returning a new list containing only numbers that appear once.\n\n    :param num_list: A list of integers\n    :return: A list of unique integers appearing only once in the input list\n    \"\"\"\n    # Count occurrences of each number\n    num_counts = {}\n    for num in num_list:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Filter out duplicates, keeping only numbers that appear once\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(input_list):\n    \"\"\"\n    Returns a list of numbers that appear only once in the input list.\n    \n    :param input_list: List of integers\n    :return: List of integers (unique numbers from input_list)\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    num_count = {}\n    \n    # Count the occurrence of each number\n    for num in input_list:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in num_count.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Removes numbers that appear more than once in the given list.\n\n    :param numbers: A list of integers\n    :return: List of integers that appear only once\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    num_count = {}\n    \n    # Count occurrences of each number\n    for num in numbers:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Return a list of numbers that appear exactly once\n    return [num for num, count in num_count.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(num_list):\n    \"\"\"\n    This function takes a list of numbers as input and returns a new list containing numbers \n    that appear only once in the original list.\n\n    Args:\n        num_list (list): A list of integers.\n\n    Returns:\n        list: A list of integers that appear only once in `num_list`.\n    \"\"\"\n    # Create a dictionary to store the frequency of each number\n    freq_dict = {}\n    \n    # Iterate over the list to count the occurrence of each number\n    for num in num_list:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    # Use list comprehension to create a new list with numbers that appear only once\n    unique_nums = [num for num, freq in freq_dict.items() if freq == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(num_list):\n    \"\"\"\n    Returns a list of numbers that appear only once in the input list.\n\n    :param num_list: Input list of integers\n    :return: List of unique integers (appearing only once in `num_list`)\n    \"\"\"\n    # Create a dictionary to store counts of each number\n    num_counts = {}\n    \n    # Count occurrences of each number\n    for num in num_list:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Filter numbers that appear only once\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Removes numbers that appear more than once from the input list.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        list: A list of integers that appear only once in the input list.\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    num_count = {}\n    \n    # Count occurrences of each number\n    for num in numbers:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num, count in num_count.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(input_list):\n    \"\"\"\n    Removes duplicate numbers from a given list, preserving numbers that appear only once.\n\n    Args:\n        input_list (list): A list of integers.\n\n    Returns:\n        list: A list of integers that appear only once in the input list.\n    \"\"\"\n    # Count occurrences of each number in the list\n    count_dict = {}\n    for num in input_list:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(input_list):\n    \"\"\"\n    Removes duplicate numbers from a given list, returning a new list.\n    \n    :param input_list: List of integers\n    :return: List of integers with duplicates removed\n    \"\"\"\n    # Count occurrences of each number\n    num_count = {}\n    for num in input_list:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num, count in num_count.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(input_list):\n    \"\"\"\n    Returns a list of numbers that appear exactly once in the input list.\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    \n    # Iterate over the input list to count occurrences of each number\n    for num in input_list:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter the input list for numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    This function takes a list of numbers as input, identifies numbers that appear more than once, \n    and returns a new list containing only the numbers that appear exactly twice, along with numbers that appear once.\n\n    However, based on the provided unit test, it seems the intention might be slightly different:\n    - Remove all numbers that appear more than once, returning only numbers that appear exactly once.\n    \n    The solution below follows the interpretation from the unit test for consistency.\n\n    :param nums: A list of integers\n    :return: A list of integers that appear only once in the input list\n    \"\"\"\n    count_dict = {}  # Dictionary to store count of each number\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filtering numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Returns a list of numbers that appear only once in the input list.\n\n    :param nums: A list of integers\n    :return: A list of unique integers\n    \"\"\"\n    # Count occurrences of each number\n    num_counts = {}\n    for num in nums:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Returns a list of numbers that appear only once in the input list.\n    \n    :param nums: List of integers\n    :return: List of unique integers\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter numbers that appear only once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(num_list):\n    \"\"\"\n    Returns a list of numbers that appear exactly once in the input list.\n    \n    :param num_list: List of integers\n    :return: List of unique integers (appearing only once in the input)\n    \"\"\"\n    # Count occurrences of each number\n    count_map = Counter(num_list)\n    \n    # Filter numbers that appear exactly once\n    unique_nums = [num for num, count in count_map.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(num_list):\n    \"\"\"\n    Removes numbers that appear more than once from a given list of numbers.\n\n    Args:\n    - num_list (list): A list of integers.\n\n    Returns:\n    - list: A new list with unique numbers that appeared only once in the original list.\n    \"\"\"\n    # Count occurrences of each number\n    num_counts = {}\n    for num in num_list:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Filter numbers that appear only once\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(input_list):\n    \"\"\"\n    Returns a list of numbers that appear only once in the input list.\n    \n    :param input_list: List of integers\n    :return: List of unique integers (appearing only once in input_list)\n    \"\"\"\n    # Count occurrences of each number\n    num_counts = {}\n    for num in input_list:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n    \n    # Filter numbers that appear only once\n    unique_nums = [num for num, count in num_counts.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(input_list):\n    \"\"\"\n    This function takes a list of numbers as input, and returns a new list containing only the numbers \n    that appear exactly twice in the original list, preserving their original order.\n\n    :param input_list: A list of integers\n    :return: A list of integers that appear exactly once in the input list\n    \"\"\"\n    # Create a dictionary to store the count of each number in the list\n    count_dict = {}\n    \n    # Iterate over the input list to count occurrences of each number\n    for num in input_list:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Use a list comprehension to filter numbers that appear exactly once\n    unique_nums = [num for num in input_list if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(num_list):\n    \"\"\"\n    Returns a list of numbers that appear only once in the input list.\n\n    :param num_list: A list of integers\n    :return: List of integers that are unique\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    num_count = {}\n    \n    # Count occurrences of each number\n    for num in num_list:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in num_count.items() if count == 1]", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 88.44444444444444, "dps_norm": 70.90909090909092, "pass@1": 55.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A new flat list with elements interleaved from input lists.\n    \n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length\")\n    \n    # Using zip to iterate over the lists in parallel and a list comprehension to flatten\n    return [item for tup in zip(list1, list2, list3) for item in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from input lists.\n\n    Raises:\n        ValueError: If input lists are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n\n    # Use zip to pair elements from each list, then flatten the result\n    interleaved = [item for tup in zip(list1, list2, list3) for item in tup]\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A flat list with elements from list1, list2, and list3 interleaved.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n\n    return [item for triplet in zip(list1, list2, list3) for item in triplet]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A new flat list with elements from list1, list2, and list3 interleaved.\n    \n    Raises:\n        ValueError: If list1, list2, and list3 are not of the same length.\n    \"\"\"\n    # Check if all lists are of the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length\")\n    \n    # Use zip to transpose the lists and then flatten the result\n    return [element for tup in zip(list1, list2, list3) for element in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list to interleave.\n        list2 (list): The second list to interleave.\n        list3 (list): The third list to interleave.\n    \n    Returns:\n        list: A flat list with elements interleaved from input lists.\n    \n    Raises:\n        ValueError: If input lists are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    # Use zip to pair elements from each list, then flatten the result\n    interleaved = [item for triplet in zip(list1, list2, list3) for item in triplet]\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n    - list1 (list): The first list to interleave.\n    - list2 (list): The second list to interleave.\n    - list3 (list): The third list to interleave.\n    \n    Returns:\n    - list: A single, flat list with elements interleaved from the input lists.\n    \n    Raises:\n    - ValueError: If the input lists are not all of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    # Use zip to pair elements from each list, then flatten the result\n    interleaved_list = [item for triplet in zip(list1, list2, list3) for item in triplet]\n    \n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A new list containing all elements from the input lists in interleaved order.\n    \n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length\")\n    \n    # Use zip to iterate over the lists in parallel and chain the results\n    from itertools import chain, zip_longest\n    # Ensure we handle cases where lists might not all be filled to the same length with zip_longest\n    # Since the problem states they should be the same length, this is more for future-proofing/robustness\n    interleaved = chain(*zip_longest(list1, list2, list3))\n    \n    # Filter out any filler values (None) that zip_longest might have inserted\n    # Not strictly necessary given the problem's constraints but good practice\n    interleaved = (item for item in interleaved if item is not None)\n    \n    # Convert the iterator back into a list and return\n    return list(interleaved)", "matching_cluster_idx": 5}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Parameters:\n    - list1 (list): The first list\n    - list2 (list): The second list\n    - list3 (list): The third list\n    \n    Returns:\n    - list: A single flat list with elements interleaved from input lists\n    \"\"\"\n    # Check if all lists are of the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length\")\n    \n    # Use zip to pair elements from each list, then flatten the result\n    interleaved = [item for tup in zip(list1, list2, list3) for item in tup]\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): First list\n        list2 (list): Second list\n        list3 (list): Third list\n\n    Returns:\n        list: A new list with elements interleaved from the input lists.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n\n    # Use zip to iterate over the lists in parallel and flatten the result\n    interleaved = [item for tup in zip(list1, list2, list3) for item in tup]\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): First list\n        list2 (list): Second list\n        list3 (list): Third list\n        \n    Returns:\n        list: A flat list with elements interleaved from the input lists.\n        \n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists are of the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    # Use zip to iterate over the lists in parallel and flatten the result\n    interleaved = [element for tup in zip(list1, list2, list3) for element in tup]\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list to interleave.\n        list2 (list): The second list to interleave.\n        list3 (list): The third list to interleave.\n    \n    Returns:\n        list: A single flat list with elements interleaved from the input lists.\n    \n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    # Use zip to iterate over the lists in parallel, \n    # then chain the results into a single flat list\n    from itertools import chain\n    return list(chain(*zip(list1, list2, list3)))", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A flat list with elements from list1, list2, and list3 interleaved.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists are of the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n\n    # Use zip to pair elements from each list, then flatten the result\n    return [item for tup in zip(list1, list2, list3) for item in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A single flat list with elements interleaved from input lists.\n    \n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length\")\n    \n    return [item for triplet in zip(list1, list2, list3) for item in triplet]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list to interleave.\n        list2 (list): The second list to interleave.\n        list3 (list): The third list to interleave.\n\n    Returns:\n        list: A single, flat list with elements interleaved from list1, list2, and list3.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n\n    # Use zip to transpose the lists, then flatten the result\n    interleaved_list = [item for tup in zip(list1, list2, list3) for item in tup]\n    \n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): First input list.\n        list2 (list): Second input list.\n        list3 (list): Third input list.\n        \n    Returns:\n        list: A flat list with elements from list1, list2, and list3 interleaved.\n        \n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists are of the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    # Use zip to iterate over the lists in parallel and flatten the result\n    interleaved_list = [item for triplet in zip(list1, list2, list3) for item in triplet]\n    \n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A flat list containing elements from the input lists in an interleaved manner.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n\n    # Use zip to pair elements from each list, then flatten the result\n    interleaved = [item for triplet in zip(list1, list2, list3) for item in triplet]\n    \n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): First list to interleave\n        list2 (list): Second list to interleave\n        list3 (list): Third list to interleave\n    \n    Returns:\n        list: A single flat list with elements interleaved from the input lists\n    \n    Raises:\n        ValueError: If the input lists are not of the same length\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length\")\n    \n    # Use zip to iterate over the lists in parallel and chain the results into a single list\n    from itertools import chain, zip_longest\n    return list(chain(*zip_longest(list1, list2, list3)))", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list\n        list2 (list): The second list\n        list3 (list): The third list\n\n    Returns:\n        list: A new list with elements interleaved from list1, list2, and list3\n\n    Raises:\n        ValueError: If the input lists are not of the same length\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length\")\n\n    # Use zip to iterate over the lists in parallel and flatten the result\n    interleaved_list = [element for tup in zip(list1, list2, list3) for element in tup]\n    \n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single, flat list with elements interleaved from the input lists.\n\n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n\n    # Use zip to transpose the lists, then flatten the result\n    return [element for tup in zip(list1, list2, list3) for element in tup]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A single flat list with elements interleaved from the input lists.\n    \n    Raises:\n        ValueError: If the input lists are not of the same length.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All input lists must be of the same length.\")\n    \n    # Use zip to transpose the lists and then flatten the result\n    interleaved_list = [item for tup in zip(list1, list2, list3) for item in tup]\n    \n    return interleaved_list", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 19.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end.\n\n    Args:\n    - arr (list): The input list to be split.\n    - n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n    - list: The modified list with the first part appended to the end after splitting at the nth index.\n    \"\"\"\n    # Check if n is within the bounds of the list to avoid index errors\n    if n < len(arr):\n        # Split the list into two parts at the nth index\n        first_part = arr[:n]\n        second_part = arr[n:]\n        \n        # Combine the two parts in reverse order\n        result = second_part + first_part\n    else:\n        # If n is out of bounds, return the original list (or handle as per your requirement)\n        result = arr\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end.\n\n    Args:\n        input_list (list): The input list to be manipulated.\n        n (int): The index at which to split the list.\n\n    Returns:\n        list: A new list with the elements after the nth index followed by the elements up to the nth index.\n    \"\"\"\n    # Check if n is within the bounds of the list to avoid indexing errors\n    if n < len(input_list):\n        # Split the list into two parts at the nth index\n        first_part = input_list[:n]  # Elements before the nth index\n        second_part = input_list[n:]  # Elements at and after the nth index\n        # Combine the two parts in reverse order\n        result = second_part + first_part\n        return result\n    else:\n        # If n is out of bounds, return the original list (or handle as per requirement)\n        return input_list", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end.\n\n    Args:\n        - input_list (list): The list to be manipulated.\n        - n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        - list: The modified list with the first part appended to the end after splitting at the nth element.\n    \"\"\"\n    if not input_list or n < 0 or n >= len(input_list):\n        # Handling edge cases: empty list, negative n, or n out of range\n        return input_list\n    \n    # Split the list into two parts at the nth element\n    first_part = input_list[:n]  # Elements before the nth index\n    second_part = input_list[n:]  # Elements at and after the nth index\n    \n    # Combine the two parts in reverse order\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end.\n\n    Args:\n        - input_list (list): The list to be manipulated.\n        - n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        - list: The modified list with the first part appended to the end after splitting at the nth element.\n    \"\"\"\n    if not input_list or n < 0 or n >= len(input_list):\n        return input_list  # Edge case: Return original list if empty, n is negative, or n is out of range\n    \n    # Split the list into two parts at the nth element\n    first_part = input_list[:n]  \n    second_part = input_list[n:]\n    \n    # Combine the two parts in reverse order\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end.\n    \n    Args:\n    - input_list (list): The list to be split and rotated.\n    - n (int): The index at which to split the list (0-indexed).\n    \n    Returns:\n    - list: The modified list with the first part appended to the end after splitting at the nth element.\n    \"\"\"\n    # Validate if n is within bounds to avoid indexing errors\n    if n < len(input_list):\n        # Split the list into two parts at the nth element\n        first_part = input_list[:n]\n        second_part = input_list[n:]\n        \n        # Combine the two parts in reverse order\n        result = second_part + first_part\n        return result\n    else:\n        # Handle case when n is out of bounds by returning the original list\n        # or you could choose to raise an exception depending on your requirements\n        return input_list", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and \n    appends the first part to the end of the second part.\n\n    Args:\n        - input_list (list): The list to be split.\n        - n (int): The index at which to split the list.\n\n    Returns:\n        - list: The modified list with the first part appended to the end.\n    \"\"\"\n    if not input_list or n >= len(input_list):\n        return input_list  # Return original list if empty or n is out of range\n    \n    # Split the list into two parts at the nth index\n    first_part = input_list[:n]\n    second_part = input_list[n:]\n    \n    # Combine the two parts in reverse order\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n        arr (list): Input list to split.\n        n (int): Index at which to split (0-indexed).\n    \n    Returns:\n        list: Modified list with the first part appended to the end.\n    \"\"\"\n    # Check if n is within bounds to prevent index errors\n    if n < len(arr):\n        # Split the array into two parts at the nth index\n        first_part = arr[:n]\n        second_part = arr[n:]\n        \n        # Combine the second part with the first part appended to the end\n        result = second_part + first_part\n        return result\n    else:\n        # If n is out of range, return the original array (or handle as per requirement)\n        return arr", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element and appends the first part to the end.\n\n    Args:\n        - `input_list` (list): The list to be split and rearranged.\n        - `n` (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        - `list`: The modified list with the first part appended to the end after splitting at the nth element.\n    \"\"\"\n    if not input_list or n >= len(input_list) or n < 0:\n        return input_list  # Edge case handling: return original list for invalid inputs\n    \n    # Split the list into two parts at the nth element\n    first_part = input_list[:n]\n    second_part = input_list[n:]\n    \n    # Append the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits a list at the nth element and appends the first part to the end.\n    \n    Args:\n    - input_list (list): The list to manipulate.\n    - n (int): The index at which to split the list (0-indexed).\n    \n    Returns:\n    - list: The modified list with the first part appended to the end after splitting at nth element.\n    \"\"\"\n    if not input_list or n < 0 or n >= len(input_list):\n        return input_list  # Edge case: Return original list if it's empty, n is negative, or n exceeds list length\n    \n    # Split the list into two parts at the nth element\n    first_part = input_list[:n]  \n    second_part = input_list[n:]\n    \n    # Append the first part to the end of the second part and return\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and \n    appends the first part to the end of the second part.\n\n    Args:\n        input_list (list): The input list to be manipulated.\n        n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        list: The modified list with the first part appended to the end.\n    \"\"\"\n    if not input_list or n >= len(input_list):\n        return input_list  # Handle edge cases where list is empty or n is out of range\n    \n    # Split the list into two parts at the nth index\n    first_part = input_list[:n]\n    second_part = input_list[n:]\n    \n    # Combine the two parts in reverse order\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth index (0-indexed) and appends the first part to the end.\n\n    Args:\n        input_list (list): The list to be split and rearranged.\n        n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        list: The rearranged list.\n    \"\"\"\n    if not input_list or n >= len(input_list):\n        return input_list  # Return original list if it's empty or n is out of range\n    \n    # Split the list into two parts at the nth index\n    first_part = input_list[:n]\n    second_part = input_list[n:]\n    \n    # Append the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end.\n\n    Args:\n        - input_list (list): The list to be split.\n        - n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        - list: The modified list with the first part appended to the end after splitting at the nth element.\n    \"\"\"\n    if not input_list or n >= len(input_list) or n < 0:\n        # Edge case handling: Return original list if it's empty, n is out of range, or negative.\n        return input_list\n    \n    # Split the list into two parts at the nth index\n    first_part = input_list[:n]\n    second_part = input_list[n:]\n    \n    # Append the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and \n    appends the first part to the end of the second part.\n    \n    Args:\n        input_list (list): The list to be split and rearranged.\n        n (int): The index at which to split the list.\n    \n    Returns:\n        list: The modified list.\n    \"\"\"\n    if not input_list or n >= len(input_list):\n        return input_list  # Return original list if empty or n is out of range\n    \n    # Split the list into two parts at the nth index\n    first_part = input_list[:n]\n    second_part = input_list[n:]\n    \n    # Append the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end of the second part.\n\n    Args:\n        input_list (list): The list to be manipulated.\n        n (int): The index at which to split the list.\n\n    Returns:\n        list: The manipulated list with the first part appended to the end of the second part.\n    \"\"\"\n    if not input_list or n >= len(input_list):\n        return input_list  # Edge case: If list is empty or n is out of range, return original list\n    \n    # Split the list into two parts at the nth index\n    first_part = input_list[:n]\n    second_part = input_list[n:]\n    \n    # Append the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end of the second part.\n\n    Args:\n        input_list (list): The list to be split.\n        n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        list: The modified list with the first part appended to the end of the second part.\n    \"\"\"\n    if not input_list or n >= len(input_list):\n        return input_list  # Edge case: return original list if empty or n is out of range\n    \n    # Split the list into two parts at the nth element\n    first_part = input_list[:n]\n    second_part = input_list[n:]\n    \n    # Append the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits the input list at the nth element and appends the first part to the end.\n\n    Args:\n        input_list (list): The list to be split and rotated.\n        n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        list: The modified list with the first part appended to the end after splitting at the nth element.\n    \"\"\"\n    if not input_list or n >= len(input_list):\n        return input_list  # Handle edge cases: empty list or n out of range\n    \n    # Split the list into two parts at the nth element (n+1 because list slicing is exclusive of end index)\n    first_part = input_list[:n]\n    second_part = input_list[n:]\n    \n    # Combine the two parts in reverse order to achieve the desired output\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits a list at the nth element (0-indexed) and appends the first part to the end of the second part.\n\n    Args:\n        input_list (list): The list to be split and reordered.\n        n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        list: The reordered list.\n    \"\"\"\n    # Check if n is within bounds to avoid indexing errors\n    if n < len(input_list):\n        # Split the list into two parts at the nth index\n        first_part = input_list[:n]\n        second_part = input_list[n:]\n        \n        # Combine the two parts in the desired order and return\n        return second_part + first_part\n    else:\n        # If n is out of bounds, return the original list (or handle as per requirement)\n        return input_list", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end.\n    \n    Parameters:\n    - arr (list): The input list to be split.\n    - n (int): The index at which to split the list (0-indexed).\n    \n    Returns:\n    - list: The modified list with the first part appended to the end after splitting at the nth element.\n    \"\"\"\n    # Check if n is within the bounds of the array\n    if n < len(arr):\n        # Split the array into two parts at the nth element\n        first_part = arr[:n]\n        second_part = arr[n:]\n        \n        # Append the first part to the end of the second part\n        result = second_part + first_part\n        return result\n    else:\n        # Handle out-of-bounds n by returning the original array (or raise an exception, depending on your needs)\n        return arr  # Alternatively, you could: raise ValueError(\"n is out of range\")", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the input list at the nth element (0-indexed) and appends the first part to the end.\n\n    Args:\n        - arr (list): The input list to be split.\n        - n (int): The index at which to split the list (0-indexed).\n\n    Returns:\n        - list: The modified list with the first part appended to the end after splitting at the nth element.\n    \"\"\"\n    if not arr or n >= len(arr) or n < 0:\n        # If the array is empty, n is out of range, or n is negative, return the original array\n        return arr\n    \n    # Split the array into two parts at the nth index\n    first_part = arr[:n]  \n    second_part = arr[n:]\n    \n    # Combine the two parts in reverse order\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 26.8018018018018, "dps_norm": 79.16666666666667, "pass@1": 18.0, "profiled": [{"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple version of the input list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n    \n    Args:\n        input_list (list): The list to be converted.\n    \n    Returns:\n        tuple: A tuple version of the input list.\n    \"\"\"\n    # Directly use the built-in tuple() function to convert the list\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple version of the input list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts an input list into a tuple.\n\n    Args:\n    - input_list (list): The list to be converted.\n\n    Returns:\n    - tuple: A tuple containing all elements from the input list.\n\n    Raises:\n    - TypeError: If input is not a list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a provided list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple version of the input list.\n\n    Raises:\n        TypeError: If input is not a list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts input list to a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple containing all elements from the input list.\n\n    Raises:\n        TypeError: If input is not a list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts an input list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple containing all elements from the input list.\n    \"\"\"\n    # Check if input is indeed a list\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n\n    # Use built-in tuple() function for conversion\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple containing all elements from the input list.\n\n    Raises:\n        TypeError: If input is not a list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts an input list into a tuple.\n\n    Args:\n    - input_list (list): The list to be converted.\n\n    Returns:\n    - tuple: A tuple containing all elements from the input list.\n\n    Raises:\n    - TypeError: If the input is not a list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Utilize Python's built-in tuple() function to convert the list\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list into a tuple.\n    \n    Args:\n        input_list (list): The list to be converted.\n    \n    Returns:\n        tuple: A tuple containing all elements from the input list.\n    \"\"\"\n    # Directly use Python's built-in tuple() function to convert the list\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple version of the input list.\n\n    Raises:\n        TypeError: If input is not a list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple version of the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple containing all elements from the input list.\n\n    Raises:\n        TypeError: If the input is not a list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n\n    Args:\n    - input_list (list): The list to be converted.\n\n    Returns:\n    - tuple: The tuple version of the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts an input list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple representation of the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple version of the input list.\n    \"\"\"\n    # Check if input is indeed a list\n    if not isinstance(input_list, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    # Directly convert the list to a tuple using the tuple() function\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts input list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple version of the input list.\n\n    Raises:\n        TypeError: If input is not a list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a given list into a tuple.\n\n    Args:\n        input_list (list): The list to be converted.\n\n    Returns:\n        tuple: A tuple containing all elements from the input list.\n    \"\"\"\n    # Directly use the built-in tuple() function to convert the list\n    return tuple(input_list)", "matching_cluster_idx": 2}]}, "Mbpp/588": {"dps": 83.94495412844037, "dps_norm": 90.0, "pass@1": 79.0, "profiled": [{"solution": "def big_diff(num_list):\n    \"\"\"\n    This function calculates the difference between the largest and smallest values in a given list.\n\n    Args:\n        num_list (list): A list of numbers.\n\n    Returns:\n        int: The difference between the maximum and minimum values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not num_list:\n        raise ValueError(\"Input list is empty. Cannot find difference.\")\n\n    return max(num_list) - min(num_list)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest numbers in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The difference between the maximum and minimum values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a list of numbers.\n    \n    Parameters:\n    numbers (list): A list containing numeric values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values in the list.\n    \"\"\"\n    if not isinstance(numbers, list) or not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"Input must be a list of numbers.\")\n    if len(numbers) < 1:\n        raise ValueError(\"List must not be empty.\")\n    \n    return max(numbers) - min(numbers)", "matching_cluster_idx": 2}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest numbers in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The difference between the max and min values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Compute the difference between the largest and smallest numbers in a list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The difference between the maximum and minimum values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list is empty\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest numbers in a list.\n\n    Args:\n    - numbers (list): A list of numeric values.\n\n    Returns:\n    - int or float: The difference between the max and min values in the list.\n\n    Raises:\n    - ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    # Ensure all elements are numeric (either int or float)\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise TypeError(\"All elements in the list must be numeric\")\n    \n    return max(numbers) - min(numbers)", "matching_cluster_idx": 2}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The difference between the largest and smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest numbers in a list.\n\n    Args:\n        - nums (list): A list of numbers.\n\n    Returns:\n        - int or float: The difference between the max and min values in the list.\n\n    Raises:\n        - ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest numbers in a list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The difference between the maximum and minimum values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest numbers in a list.\n\n    Args:\n    - numbers (list): A list of numbers.\n\n    Returns:\n    - int: The difference between the max and min values in the list.\n\n    Raises:\n    - ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    This function calculates the difference between the largest and smallest values in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numeric values.\n\n    Returns:\n        int: The difference between the maximum and minimum values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"Input list is empty\")\n\n    # Ensure all elements in the list are numeric\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise TypeError(\"All elements in the list must be numeric\")\n\n    # Find the smallest and largest numbers in the list\n    smallest = min(numbers)\n    largest = max(numbers)\n\n    # Calculate and return the difference\n    return largest - smallest", "matching_cluster_idx": 2}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a given list.\n\n    Args:\n        - nums (list): A list of numbers.\n\n    Returns:\n        - int: The difference between the maximum and minimum values in the list.\n\n    Raises:\n        - ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a list of numbers.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The difference between the maximum and minimum values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculates the difference between the largest and smallest numbers in a list.\n\n    Args:\n    - nums (list): A list of numbers.\n\n    Returns:\n    - int: The difference between the maximum and minimum numbers in the list.\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        raise ValueError(\"Input list is empty\")\n    \n    # Ensure all elements in the list are numbers (either int or float)\n    if not all(isinstance(num, (int, float)) for num in nums):\n        raise TypeError(\"All elements in the list must be numbers\")\n    \n    # Calculate and return the difference between the max and min values\n    return max(nums) - min(nums)", "matching_cluster_idx": 2}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Calculates the difference between the largest and smallest values in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The difference between the maximum and minimum values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Compute the difference between the largest and smallest values in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int or float: The difference between the max and min values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The difference between the max and min values in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest value in a list.\n    \n    Args:\n        nums (list): A list of numbers.\n    \n    Returns:\n        int: The difference between the max and min values in the list.\n    \n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "import unittest\ndef big_diff(nums):\n    \"\"\"\n    Calculate the difference between the largest and smallest numbers in a list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The difference between the largest and smallest numbers.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a list of numbers.\n\n    Args:\n    - numbers (list): A list of numeric values.\n\n    Returns:\n    - int or float: The difference between the maximum and minimum values in the list.\n\n    Raises:\n    - ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty.\")\n    \n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 66.13333333333334, "dps_norm": 56.666666666666664, "pass@1": 15.0, "profiled": [{"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Parameters:\n    n (int): The input number for which binomial coefficients are generated.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    # Initialize sum variable\n    total_sum = 0\n    \n    # Generate binomial coefficients for each k from 0 to n\n    for k in range(n):\n        # Calculate the product of current and next binomial coefficients\n        product = math.comb(n, k) * math.comb(n, k+1)\n        \n        # Add the product to the total sum\n        total_sum += product\n    \n    # Return the final sum\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    :param n: Input number\n    :return: Sum of the product of consecutive binomial coefficients\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        # Calculate binomial coefficients using math.comb (Python 3.8+)\n        # For Python < 3.8, use math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n        product = math.comb(n, k) * math.comb(n, k + 1)\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Computes the sum of the product of consecutive binomial coefficients.\n    \n    The formula for the sum of the product of consecutive binomial coefficients\n    from 0 to n is the (n+1)th Fibonacci number, where each term is the sum of \n    the two preceding ones, usually starting with 0 and 1.\n    \n    However, for educational purposes, this function directly calculates binomial\n    coefficients and sums their products as per the problem's apparent intention.\n    \n    :param n: The input number up to which the sum is calculated.\n    :return: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        # Calculate binomial coefficients using comb (Python >= 3.8)\n        # For older Python versions, use math.comb is not available, \n        # you can define your own comb function (example provided below)\n        product = math.comb(n, i) * math.comb(n, i+1) if i < n else math.comb(n, i)\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients\n    for a given n (number of terms in the binomial expansion).\n\n    Args:\n        n (int): The number of terms in the binomial expansion.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    # Initialize sum variable\n    total_sum = 0\n    \n    # Generate binomial coefficients and calculate sum of product of consecutive ones\n    for i in range(n):\n        # Calculate binomial coefficient for the current term\n        current_coef = math.comb(n, i)\n        \n        # Calculate binomial coefficient for the next term\n        if i < n:  # Safety check to avoid index out of range\n            next_coef = math.comb(n, i+1)\n            # Add product of current and next coefficients to total sum\n            total_sum += current_coef * next_coef\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients\n    for a given n. The binomial coefficients are from (n, 0) to (n, n).\n\n    Args:\n        n (int): The input number for which to calculate the sum.\n\n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        # Calculate binomial coefficients using math.comb (Python 3.8+)\n        # For Python < 3.8, use math.factorial(n) // (math.factorial(i) * math.factorial(n-i))\n        coeff_i = math.comb(n, i)\n        coeff_next = math.comb(n, i+1) if (i+1) <= n else 0\n        total_sum += coeff_i * coeff_next\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    \n    The sum involves calculating binomial coefficients of the form C(n, k) and \n    then summing the products of consecutive coefficients: \n    C(n, 0)*C(n, 1) + C(n, 1)*C(n, 2) + ... + C(n, n-1)*C(n, n).\n    \n    Parameters:\n    n (int): The input number for binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        # Calculate binomial coefficients using math.comb (Python 3.8+)\n        # For Python < 3.8, use math.factorial(n) / (math.factorial(k) * math.factorial(n-k))\n        coeff1 = math.comb(n, k)\n        coeff2 = math.comb(n, k + 1) if k < n else 0  # Avoid index out of range\n        total_sum += coeff1 * coeff2\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given `n`.\n\n    :param n: The input number\n    :return: Sum of the product of consecutive binomial coefficients\n    \"\"\"\n    # Initialize sum variable\n    total_sum = 0\n    \n    # Loop through each pair of consecutive binomial coefficients\n    for k in range(n):\n        # Calculate the product of the current and next binomial coefficients\n        product = math.comb(n, k) * math.comb(n, k+1)\n        \n        # Add the product to the total sum\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    This function calculates the sum of the product of consecutive binomial coefficients.\n    \n    The binomial coefficients are generated for the power of n. For each pair of consecutive \n    coefficients, their product is calculated and summed up.\n    \n    Parameters:\n    n (int): The power for generating binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    # Initialize sum variable\n    total_sum = 0\n    \n    # Generate binomial coefficients for (1 + x)^n\n    for k in range(n):\n        # Calculate the current and next binomial coefficients\n        curr_coef = math.comb(n, k)\n        next_coef = math.comb(n, k + 1)\n        \n        # Calculate the product of the current and next coefficients and add to the total sum\n        total_sum += curr_coef * next_coef\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients from n choose 0 to n choose n.\n    \n    :param n: The upper limit for calculating binomial coefficients.\n    :return: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        # Calculate the product of current and next binomial coefficients\n        product = math.comb(n, i) * math.comb(n, i + 1) if i < n else math.comb(n, i)\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n    - n (int): The input number for which binomial coefficients are calculated.\n\n    Returns:\n    - int: Sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    # Initialize sum variable\n    total_sum = 0\n    \n    # Generate binomial coefficients for 'n'\n    for k in range(n + 1):\n        # Calculate the binomial coefficient for 'n choose k'\n        coeff_k = math.comb(n, k)\n        \n        # For the last coefficient, there's no next coefficient to multiply with, so skip\n        if k < n:\n            # Calculate the next binomial coefficient for 'n choose (k+1)'\n            coeff_next_k = math.comb(n, k + 1)\n            \n            # Add the product of these coefficients to the total sum\n            total_sum += coeff_k * coeff_next_k\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    This function calculates the sum of the products of consecutive binomial coefficients.\n    \n    The binomial coefficients are generated for the power (n), and then products of consecutive \n    coefficients are summed up.\n    \n    Parameters:\n    n (int): The power for generating binomial coefficients.\n    \n    Returns:\n    int: Sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    # Initialize sum variable to 0\n    total_sum = 0\n    \n    # Generate binomial coefficients for the given power (n)\n    for k in range(n + 1):\n        # Calculate binomial coefficient using math.comb (Python 3.8+)\n        # For Python < 3.8, use math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n        coeff = math.comb(n, k)\n        \n        # If not the first coefficient, multiply with the previous one and add to the sum\n        if k > 0:\n            prev_coeff = math.comb(n, k - 1)\n            total_sum += coeff * prev_coeff\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients\n    for a given n, where the sum involves products from C(n,0) to C(n,n-1).\n\n    Args:\n    - n (int): The input number for binomial coefficients.\n\n    Returns:\n    - int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        # Calculate binomial coefficients using math.comb (Python 3.8+)\n        # For earlier Python versions, use math.factorial(n) // (math.factorial(k) * math.factorial(n-k))\n        total_sum += math.comb(n, k) * math.comb(n, k+1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients\n    for a given n, where each product involves coefficients from (n, k) and (n, k+1)\n    for k from 0 to n-1.\n\n    Args:\n        n (int): The input number defining the set of binomial coefficients.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):  # Loop through all consecutive pairs\n        # Calculate binomial coefficients for (n, k) and (n, k+1)\n        coeff_k = math.comb(n, k)\n        coeff_k_plus_1 = math.comb(n, k + 1)\n        # Add the product of these coefficients to the total sum\n        total_sum += coeff_k * coeff_k_plus_1\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n    \n    The sum involves calculating the product of each pair of consecutive binomial \n    coefficients from the expansion of (1+x) to the power of `n`, and then summing these products.\n    \n    Parameters:\n    - `n` (int): The power to which (1+x) is raised in the binomial expansion.\n    \n    Returns:\n    - int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):  # Loop through each coefficient up to but not including `n`\n        # Calculate the product of the current coefficient and the next one\n        product = math.comb(n, k) * math.comb(n, k+1)\n        total_sum += product  # Add the product to the total sum\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n        n (int): The power of the binomial expansion (1 + x)^n.\n    \n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    # Generate all binomial coefficients for (1 + x)^n\n    coefficients = [math.comb(n, k) for k in range(n + 1)]\n    \n    # Calculate the sum of the product of consecutive coefficients\n    for i in range(len(coefficients) - 1):\n        total_sum += coefficients[i] * coefficients[i + 1]\n    \n    return total_sum", "matching_cluster_idx": 7}]}, "Mbpp/597": {"dps": 95.22388059701493, "dps_norm": 98.75, "pass@1": 77.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the combined sorted elements of two input arrays.\n\n    :param arr1: The first sorted array.\n    :param arr2: The second sorted array.\n    :param k: The position of the element to find (1-indexed).\n    :return: The kth element in the combined sorted array.\n    \"\"\"\n    # Combine and sort the arrays\n    combined = sorted(arr1 + arr2)\n    \n    # Validate k is within bounds\n    if k < 1 or k > len(combined):\n        raise ValueError(\"k is out of bounds\")\n    \n    # Return the kth element (adjust for 0-indexing)\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element in the combined and sorted array of two input sorted arrays.\n    \n    Parameters:\n    - arr1 (list): First sorted array.\n    - arr2 (list): Second sorted array.\n    - k (int): The position of the element to find (1-indexed).\n\n    Returns:\n    - int: The kth element in the combined sorted array.\n\n    Raises:\n    - ValueError: If k is less than 1 or greater than the total length of both arrays.\n    \"\"\"\n    # Check if k is within valid range\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise ValueError(\"k is out of range\")\n\n    # Combine and sort the arrays\n    combined = sorted(arr1 + arr2)\n    \n    # Since list indices are 0-based, subtract 1 from k\n    return combined[k - 1]", "matching_cluster_idx": 2}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n\n    :param arr1: First sorted array\n    :param arr2: Second sorted array\n    :param k: Position of the element to find (1-indexed)\n    :return: The kth element in the combined sorted array\n    \"\"\"\n    # Combine and sort the arrays\n    combined = sorted(arr1 + arr2)\n    \n    # Since list indices are 0-based, subtract 1 from k\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n    \n    :param arr1: First sorted array\n    :param arr2: Second sorted array\n    :param k: The position of the element to find (1-indexed)\n    :return: The kth element in the combined sorted array\n    \"\"\"\n    # Combine and sort the arrays\n    combined = sorted(arr1 + arr2)\n    \n    # Validate k within bounds\n    if k < 1 or k > len(combined):\n        raise ValueError(\"k is out of bounds\")\n    \n    # Return the kth element (adjust for 0-indexing)\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element in the merged sorted array of two input sorted arrays.\n\n    :param arr1: The first sorted array.\n    :type arr1: list\n    :param arr2: The second sorted array.\n    :type arr2: list\n    :param k: The position of the element to find (1-indexed).\n    :type k: int\n    :return: The kth element in the merged sorted array.\n    :rtype: int\n    \"\"\"\n    # Merge the two sorted arrays into one\n    merged = sorted(arr1 + arr2)\n    \n    # Since array indices are 0-based, subtract 1 from k\n    kth_index = k - 1\n    \n    # Check if k is within the bounds of the merged array\n    if kth_index < len(merged):\n        # Return the kth element\n        return merged[kth_index]\n    else:\n        # Handle the case when k is out of range\n        raise ValueError(\"k is larger than the total number of elements\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element in the merged sorted array of two input sorted arrays.\n\n    Parameters:\n    - arr1 (list): First sorted array.\n    - arr2 (list): Second sorted array.\n    - k (int): The position of the element to find (1-indexed).\n\n    Returns:\n    - The kth element in the merged and sorted array, or None if k is out of range.\n    \"\"\"\n    # Merge and sort the arrays\n    merged = sorted(arr1 + arr2)\n    \n    # Check if k is within the bounds of the merged array\n    if k < 1 or k > len(merged):\n        return None\n    \n    # Return the kth element (adjusting for 0-indexing)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n\n    :param arr1: The first sorted array.\n    :param arr2: The second sorted array.\n    :param k: The position of the element to find (1-indexed).\n    :return: The kth element in the combined sorted array.\n    \"\"\"\n    # Merge and sort the arrays, then return the kth element (adjusting for 0-indexing)\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Merges two sorted arrays and returns the kth element.\n    \n    :param arr1: First sorted array\n    :param arr2: Second sorted array\n    :param k: The position of the element to find (1-indexed)\n    :return: The kth element in the combined and sorted array\n    \"\"\"\n    # Combine the two arrays\n    combined = arr1 + arr2\n    \n    # Sort the combined array in ascending order\n    combined.sort()\n    \n    # Since list indices are 0-based, subtract 1 from k\n    kth_index = k - 1\n    \n    # Check if k is within the bounds of the combined array\n    if k < 1 or k > len(combined):\n        raise ValueError(\"k is out of range\")\n    \n    # Return the kth element\n    return combined[kth_index]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element in the combined sorted sequence of two input arrays.\n\n    Args:\n    - `arr1` (list): The first sorted array.\n    - `arr2` (list): The second sorted array.\n    - `k` (int): The position of the element to find (1-indexed).\n\n    Returns:\n    - The kth element in the combined and sorted sequence of `arr1` and `arr2`.\n    \"\"\"\n    # Combine and sort both arrays\n    combined = sorted(arr1 + arr2)\n    \n    # Since list indices are 0-based, subtract 1 from k\n    kth_index = k - 1\n    \n    # Check if k is within bounds\n    if k < 1 or k > len(combined):\n        raise ValueError(\"k is out of range\")\n    \n    # Return the kth element\n    return combined[kth_index]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n\n    :param arr1: First sorted array\n    :param arr2: Second sorted array\n    :param k: Position of the element to find (1-indexed)\n    :return: The kth element in the combined sorted array\n    \"\"\"\n    # Merge the two sorted arrays into one\n    merged = sorted(arr1 + arr2)\n    \n    # Since list indices are 0-based, subtract 1 from k\n    kth_index = k - 1\n    \n    # Check if k is within bounds\n    if k < 1 or k > len(merged):\n        raise ValueError(\"k is out of bounds\")\n    \n    # Return the kth element\n    return merged[kth_index]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n\n    :param arr1: First sorted array\n    :param arr2: Second sorted array\n    :param k: Index of the desired element (1-indexed)\n    :return: The kth element in the merged and sorted array\n    \"\"\"\n    # Merge and sort the arrays\n    merged = sorted(arr1 + arr2)\n    \n    # Validate k is within bounds\n    if k < 1 or k > len(merged):\n        raise ValueError(\"k is out of bounds\")\n    \n    # Return the kth element (adjust for 0-indexing)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n    \n    The function merges the two sorted arrays into one and then returns the element at index k-1.\n    \n    Parameters:\n    - arr1 (list): The first sorted array.\n    - arr2 (list): The second sorted array.\n    - k (int): The position of the element to find (1-indexed).\n    \n    Returns:\n    - The kth element in the merged sorted array.\n    \"\"\"\n    # Combine the two arrays into one\n    merged = arr1 + arr2\n    \n    # Sort the merged array in ascending order\n    merged.sort()\n    \n    # Since list indices are 0-based, subtract 1 from k to get the correct index\n    kth_index = k - 1\n    \n    # Check if k is within bounds to avoid IndexError\n    if kth_index < len(merged):\n        # Return the element at the kth index\n        return merged[kth_index]\n    else:\n        # Handle the case when k is larger than the total number of elements\n        return \"k is out of range\"", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n\n    :param arr1: First sorted array\n    :param arr2: Second sorted array\n    :param k: Position of the element to find (1-indexed)\n    :return: The kth element in the combined sorted array\n    \"\"\"\n    # Combine and sort the arrays\n    combined = sorted(arr1 + arr2)\n    \n    # Adjust k for 0-indexing\n    k -= 1\n    \n    # Check if k is within bounds\n    if k < len(combined):\n        return combined[k]\n    else:\n        raise ValueError(\"k is larger than the total number of elements\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element from the merged sorted array of `arr1` and `arr2`.\n    \n    Args:\n        - arr1 (list): The first sorted list of integers.\n        - arr2 (list): The second sorted list of integers.\n        - k (int): The position of the element to find (1-indexed).\n\n    Returns:\n        - int: The kth element in the merged sorted array.\n    \"\"\"\n    # Merge and sort the two arrays\n    merged = sorted(arr1 + arr2)\n    \n    # Check if k is within bounds\n    if k < 1 or k > len(merged):\n        raise ValueError(\"k is out of bounds\")\n    \n    # Return the kth element (adjust for 0-indexing)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element in the combined sorted array of arr1 and arr2.\n    \n    :param arr1: First sorted array\n    :param arr2: Second sorted array\n    :param k: Position of the element to find (1-indexed)\n    :return: The kth element, or None if k is out of range\n    \"\"\"\n    # Combine and sort the arrays\n    combined = sorted(arr1 + arr2)\n    \n    # Check if k is within the bounds of the combined array\n    if k < 1 or k > len(combined):\n        return None\n    \n    # Since list indices are 0-based, subtract 1 from k\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element in the combined sorted list of two input sorted arrays.\n\n    Args:\n        arr1 (list): The first sorted list of integers.\n        arr2 (list): The second sorted list of integers.\n        k (int): The position of the element to find (1-indexed).\n\n    Returns:\n        int: The kth element in the combined sorted list.\n\n    Raises:\n        ValueError: If k is less than 1 or greater than the total length of both arrays.\n    \"\"\"\n    # Check if k is within valid range\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise ValueError(\"k is out of range\")\n\n    # Merge and sort the arrays\n    merged = sorted(arr1 + arr2)\n\n    # Since list indices are 0-based, subtract 1 from k\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the Kth element from two sorted arrays.\n\n    Args:\n    - arr1 (list): The first sorted array.\n    - arr2 (list): The second sorted array.\n    - k (int): The index of the desired element (1-indexed).\n\n    Returns:\n    - The Kth element in the combined sorted array.\n\n    Raises:\n    - ValueError: If k is less than 1 or greater than the total length of both arrays.\n    \"\"\"\n    # Check if k is within bounds\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise ValueError(\"k is out of bounds\")\n\n    # Merge and sort the arrays\n    merged = sorted(arr1 + arr2)\n    \n    # Since list indices are 0-based, subtract 1 from k\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element in the combined sorted array of two input sorted arrays.\n    \n    :param arr1: First sorted array\n    :param arr2: Second sorted array\n    :param k: Index of the desired element (1-indexed)\n    :return: The kth element in the combined sorted array\n    \"\"\"\n    # Combine the two arrays into one\n    combined = arr1 + arr2\n    \n    # Sort the combined array in ascending order\n    combined.sort()\n    \n    # Adjust k to be 0-indexed for Python list indexing\n    k -= 1\n    \n    # Check if k is within bounds\n    if k < len(combined):\n        # Return the kth element\n        return combined[k]\n    else:\n        # Handle out-of-bounds k\n        raise ValueError(\"k is out of bounds\")", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element in the combined sorted array of two input sorted arrays.\n    \n    Parameters:\n    arr1 (list): First sorted array.\n    arr2 (list): Second sorted array.\n    k (int): The position of the element to find (1-indexed).\n\n    Returns:\n    int: The kth element in the combined sorted array.\n    \"\"\"\n    # Combine and sort the two arrays\n    combined = sorted(arr1 + arr2)\n    \n    # Check if k is within the bounds of the combined array\n    if k < 1 or k > len(combined):\n        raise ValueError(\"k is out of bounds\")\n    \n    # Since list indices are 0-based, subtract 1 from k\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n    \n    This function merges two sorted lists into one and returns the element at the kth position.\n    The position k is 1-indexed for simplicity, matching the problem statement.\n    \n    :param arr1: First sorted array\n    :param arr2: Second sorted array\n    :param k: Position of the element to find (1-indexed)\n    :return: The kth element in the combined sorted array\n    \"\"\"\n    # Combine both arrays into one\n    combined = arr1 + arr2\n    \n    # Sort the combined array in ascending order\n    combined.sort()\n    \n    # Since list indices are 0-based, subtract 1 from k to find the correct position\n    kth_position = k - 1\n    \n    # Check if k is within the bounds of the combined array\n    if kth_position < len(combined):\n        # Return the kth element\n        return combined[kth_position]\n    else:\n        # Handle the case where k is out of range\n        return None", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 53.0, "profiled": [{"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words separated by spaces in a given string.\n\n    Args:\n        input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the order of words reversed.\n    \"\"\"\n    # Split the input string into a list of words\n    words = input_string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words back into a string separated by spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of words separated by spaces in a given string.\n\n    :param input_string: The input string containing words separated by spaces.\n    :return: A string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list of words back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string, separated by spaces.\n\n    Args:\n        input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words = input_string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n    - input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n    - str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n        input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words = input_string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words back into a string separated by spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n    - input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n    - str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n        input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words using space as the delimiter\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list of words back into a string with spaces in between\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a given string.\n    \n    Args:\n    input_string (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n    - input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n    - str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n    - input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n    - str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words using space as the delimiter\n    words = input_string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words back into a string separated by spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of words separated by spaces in a given string.\n\n    Args:\n        input_string (str): The input string containing space-separated words.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words using space as the delimiter\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list of words back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of space-separated words in a given string.\n\n    Args:\n        input_string (str): The input string containing space-separated words.\n\n    Returns:\n        str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n        input_str (str): The input string with space-separated words.\n\n    Returns:\n        str: The string with words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_str.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_str = ' '.join(reversed_list)\n    \n    return reversed_str", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of space-separated words in a given string.\n\n    Args:\n        input_string (str): The input string containing space-separated words.\n\n    Returns:\n        str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n        input_string (str): The input string with words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words = input_string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n        input_string (str): The string containing space-separated words to be reversed.\n\n    Returns:\n        str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a given string, separated by spaces.\n\n    Args:\n        input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_words_list = words_list[::-1]\n    \n    # Join the reversed list of words back into a string separated by spaces\n    reversed_string = ' '.join(reversed_words_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n    input_string (str): The input string with words separated by spaces.\n\n    Returns:\n    str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words = input_string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n    - input_string (str): The input string containing words separated by spaces.\n\n    Returns:\n    - str: A string with the words in reversed order.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string: str) -> str:\n    \"\"\"\n    Reverses the order of words separated by spaces in a given string.\n\n    Args:\n        input_string (str): The input string to reverse words from.\n\n    Returns:\n        str: A string with the words reversed.\n    \"\"\"\n    # Split the input string into a list of words\n    words_list = input_string.split()\n    \n    # Reverse the list of words\n    reversed_list = words_list[::-1]\n    \n    # Join the reversed list back into a string separated by spaces\n    reversed_string = ' '.join(reversed_list)\n    \n    return reversed_string", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 58.69565217391305, "dps_norm": 57.142857142857146, "pass@1": 72.0, "profiled": [{"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from a given list.\n\n    Args:\n    - input_list (list): The original list.\n    - k (int): The position of the element to be removed (1-indexed).\n\n    Returns:\n    - list: A new list with the k'th element removed.\n\n    Raises:\n    - ValueError: If k is less than 1 or greater than the list length.\n    \"\"\"\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k is out of range\")\n    \n    # Convert k to 0-indexed for Python's list indexing\n    k -= 1\n    \n    # Use list slicing to return a new list with the k'th element removed\n    return input_list[:k] + input_list[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns the modified list.\n    \n    Parameters:\n    - input_list (list): The original list from which an element will be removed.\n    - k (int): The position (1-indexed) of the element to be removed.\n    \n    Returns:\n    - list: A new list with the k'th element removed.\n    \"\"\"\n    # Check if k is within valid range (adjust for 0-indexing)\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k is out of range\")\n    \n    # Use list slicing to create a new list with the k'th element removed\n    # Adjust k for 0-indexing by subtracting 1\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from a given list.\n\n    :param input_list: The list from which an element will be removed.\n    :type input_list: list\n    :param k: The position (1-indexed) of the element to remove.\n    :type k: int\n    :return: A new list with the k'th element removed from `input_list`.\n    :rtype: list\n    :raises ValueError: If `k` is out of range.\n    \"\"\"\n    # Validate k to ensure it's within bounds (1-indexed to 0-indexed adjustment)\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k is out of range. It must be between 1 and the length of the input list.\")\n\n    # Convert k to 0-indexed for Python's list indexing\n    k -= 1\n    \n    # Use list slicing to create a new list with the k'th element removed\n    return input_list[:k] + input_list[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Returns a new list with the k'th element (1-indexed) removed.\n    \n    :param input_list: Original list\n    :param k: Position of the element to remove (1-indexed)\n    :return: New list with the k'th element removed\n    \"\"\"\n    # Check if k is within valid range (adjust for 0-based indexing)\n    if 1 <= k <= len(input_list):\n        # Use list slicing to create a new list excluding the k'th element\n        return input_list[:k-1] + input_list[k:]\n    else:\n        raise ValueError(\"k is out of range\")", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list.\n\n    **Parameters:**\n    - `input_list` (list): The original list from which an element will be removed.\n    - `k` (int): The position (1-indexed) of the element to be removed.\n\n    **Returns:**\n    - `list`: A new list with the k'th element removed from `input_list`.\n\n    **Raises:**\n    - `ValueError`: If `k` is less than 1 or greater than the length of `input_list`.\n    \"\"\"\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k is out of range\")\n\n    # Convert k to 0-indexed for Python list indexing\n    k -= 1\n    \n    # Return a new list that excludes the k'th element\n    return input_list[:k] + input_list[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns the modified list.\n    \n    Args:\n        - input_list (list): The original list from which an element is to be removed.\n        - k (int): The position of the element to be removed (1-indexed for user convenience).\n    \n    Returns:\n        - list: A new list with the k'th element removed from the input list.\n    \"\"\"\n    # Adjust k to match Python's 0-indexing\n    k -= 1\n    \n    # Check if k is within bounds to avoid IndexError\n    if k < 0 or k >= len(input_list):\n        raise IndexError(\"k is out of range\")\n    \n    # Use list slicing to create a new list with the k'th element excluded\n    return input_list[:k] + input_list[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list.\n\n    :param input_list: The original list from which an element will be removed.\n    :param k: The index of the element to be removed (1-indexed for user convenience).\n    :return: A new list with the k'th element removed.\n    \"\"\"\n    # Adjust k for 0-indexing used in Python lists\n    k -= 1\n    \n    # Check if k is within bounds to avoid IndexError\n    if 0 <= k < len(input_list):\n        # Return a new list that excludes the k'th element\n        return input_list[:k] + input_list[k+1:]\n    else:\n        # If k is out of bounds, return the original list\n        return input_list.copy()  # Return a copy to not modify the original", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list.\n    \n    Args:\n        - input_list (list): The original list from which an element is to be removed.\n        - k (int): The position of the element to be removed (1-indexed).\n    \n    Returns:\n        - list: A new list with the k'th element removed.\n    \"\"\"\n    # Check if k is within the bounds of the list (adjust for 0-indexing)\n    if k < 1 or k > len(input_list):\n        raise IndexError(\"k is out of range\")\n    \n    # Use list slicing to return a new list that excludes the k'th element\n    # The expression input_list[:k-1] gets all elements before the k'th,\n    # and input_list[k:] gets all elements after the k'th.\n    # We adjust k to k-1 because list indices are 0-based.\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from a given list.\n\n    Args:\n        - input_list (list): The original list from which an element will be removed.\n        - k (int): The index (1-indexed) of the element to be removed.\n\n    Returns:\n        - list: A new list with the k'th element removed.\n    \"\"\"\n    # Adjust k to match Python's 0-indexing\n    k -= 1\n    \n    # Check if k is within bounds\n    if k < 0 or k >= len(input_list):\n        raise IndexError(\"k is out of range for the given list\")\n    \n    # Return a new list with the k'th element removed\n    return input_list[:k] + input_list[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from a list (considering k as 1-indexed).\n    \n    Args:\n        input_list (list): The list from which an element will be removed.\n        k (int): The position of the element to be removed (1-indexed).\n    \n    Returns:\n        list: A new list with the k'th element removed.\n    \"\"\"\n    # Check if k is within bounds (since Python uses 0-indexing, adjust k)\n    if k < 1 or k > len(input_list):\n        raise IndexError(\"k is out of range\")\n    \n    # Use list slicing to create a new list excluding the k'th element\n    # Adjust k to 0-indexing by subtracting 1\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from a list (k is 1-indexed).\n\n    Args:\n        input_list (list): The original list.\n        k (int): The position of the element to remove (1-indexed).\n\n    Returns:\n        list: A new list with the k'th element removed. If k is out of range, returns the original list.\n    \"\"\"\n    # Check if k is within valid range (considering 1-indexing)\n    if k < 1 or k > len(input_list):\n        return input_list  # Return original list if k is out of range\n    \n    # Use list slicing to create a new list without the k'th element\n    # Subtract 1 from k because list indices are 0-based\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list.\n\n    Args:\n        - input_list (list): The list from which to remove an element.\n        - k (int): The index (1-indexed) of the element to remove.\n\n    Returns:\n        - list: A new list with the k'th element removed.\n    \"\"\"\n    # Convert k to 0-indexed for Python list indexing\n    k -= 1\n    \n    # Check if k is within bounds\n    if k < 0 or k >= len(input_list):\n        raise IndexError(\"k is out of range\")\n    \n    # Use list slicing to create a new list with the k'th element removed\n    return input_list[:k] + input_list[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list.\n\n    Args:\n        input_list (list): The input list from which an element will be removed.\n        k (int): The position of the element to be removed (1-indexed).\n\n    Returns:\n        list: A new list with the k'th element removed from the input list.\n\n    Raises:\n        ValueError: If k is less than 1 or greater than the length of the input list.\n    \"\"\"\n    # Check if k is within valid range\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k is out of range\")\n\n    # Since Python uses 0-based indexing, subtract 1 from k\n    k -= 1\n    \n    # Use list slicing to return a new list with the k'th element removed\n    return input_list[:k] + input_list[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Returns a new list with the k'th element removed.\n    \n    :param input_list: The original list.\n    :param k: The position (1-indexed) of the element to remove.\n    :return: New list with the k'th element removed.\n    \"\"\"\n    # Check if k is within bounds (adjust for 0-indexing)\n    if k < 1 or k > len(input_list):\n        raise IndexError(\"k is out of range\")\n    \n    # Use list slicing to create a new list without the k'th element\n    # Subtract 1 from k to convert from 1-indexed to 0-indexed\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns the resulting list.\n    \n    Args:\n        input_list (list): The original list from which an element will be removed.\n        k (int): The index of the element to be removed (1-indexed for user convenience).\n        \n    Returns:\n        list: A new list with the k'th element removed.\n    \"\"\"\n    # Adjust k to match Python's 0-indexed lists\n    k -= 1\n    \n    # Check if k is within valid range\n    if k < 0 or k >= len(input_list):\n        raise IndexError(\"k is out of range\")\n    \n    # Use list slicing to create a new list without the k'th element\n    return input_list[:k] + input_list[k+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns the new list.\n\n    Args:\n        input_list (list): The original list from which to remove an element.\n        k (int): The index (1-indexed) of the element to remove.\n\n    Returns:\n        list: A new list with the k'th element removed.\n\n    Raises:\n        IndexError: If k is less than 1 or greater than the length of the input list.\n    \"\"\"\n    # Check if k is within valid range (1-indexed to 0-indexed conversion)\n    if k < 1 or k > len(input_list):\n        raise IndexError(\"k is out of range\")\n    \n    # Use list slicing to create a new list without the k'th element (0-indexed, so k-1)\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from a given list (1-based indexing).\n\n    Args:\n        - input_list (list): The original list from which an element will be removed.\n        - k (int): The position of the element to be removed (1-based indexing).\n\n    Returns:\n        - list: A new list with the k'th element removed.\n    \"\"\"\n    # Validate k to ensure it's within the list bounds (considering 1-based indexing)\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k is out of range\")\n\n    # Use list slicing to create a new list that excludes the k'th element\n    # Since Python uses 0-based indexing, subtract 1 from k\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Returns a new list with the k'th element removed from input_list.\n    Note: k is 1-indexed for user convenience, but internally handled as 0-indexed.\n\n    :param input_list: Original list to modify\n    :param k: Index of the element to remove (1-indexed)\n    :return: New list with the k'th element removed\n    \"\"\"\n    # Convert k to 0-indexed for Python list compatibility\n    k_zero_indexed = k - 1\n    \n    # Check if k is within bounds\n    if k_zero_indexed < 0 or k_zero_indexed >= len(input_list):\n        raise IndexError(\"k is out of range\")\n    \n    # Use list slicing to create a new list excluding the k'th element\n    return input_list[:k_zero_indexed] + input_list[k_zero_indexed + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Removes the k'th element from the input list (k is 1-indexed).\n    \n    Args:\n    - input_list (list): The original list.\n    - k (int): The position of the element to be removed (1-indexed).\n    \n    Returns:\n    - list: A new list with the k'th element removed.\n    \"\"\"\n    # Check if k is within bounds (adjust for 0-indexing)\n    if k < 1 or k > len(input_list):\n        raise IndexError(\"k is out of range\")\n    \n    # Use list slicing to create a new list without the k'th element\n    # Adjust k to 0-indexing for Python's list indexing\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    \"\"\"\n    Returns a new list with the same elements as the input list, \n    but with the k'th element removed (1-indexed).\n\n    Args:\n        input_list (list): The original list from which to remove an element.\n        k (int): The position of the element to remove (1-indexed).\n\n    Returns:\n        list: A new list with the k'th element removed.\n\n    Raises:\n        ValueError: If k is less than 1 or greater than the list length.\n    \"\"\"\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k is out of range. Must be between 1 and list length.\")\n    \n    # Convert k to 0-indexed for Python list indexing\n    k -= 1\n    \n    # Use list slicing to create a new list without the k'th element\n    return input_list[:k] + input_list[k+1:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/631": {"dps": 70.76388888888887, "dps_norm": 80.625, "pass@1": 33.0, "profiled": [{"solution": "def replace_spaces(input_str: str) -> str:\n    \"\"\"\n    Replaces whitespaces with underscores if found, otherwise replaces underscores with whitespaces.\n\n    Args:\n        input_str (str): The input string to perform replacements on.\n\n    Returns:\n        str: The modified string with either whitespaces replaced by underscores or vice versa.\n    \"\"\"\n    if ' ' in input_str:  # Check if string contains whitespace\n        # Replace whitespaces with underscores\n        return input_str.replace(' ', '_')\n    elif '_' in input_str:  # Check if string contains underscore\n        # Replace underscores with whitespaces\n        return input_str.replace('_', ' ')\n    else:\n        # If neither condition is met, return the original string\n        return input_str", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n    \n    Args:\n        input_string (str): Input string to swap spaces and underscores.\n    \n    Returns:\n        str: Modified string with spaces and underscores swapped.\n    \"\"\"\n    # Use the `translate` method along with `maketrans` for efficient character replacement\n    # First, create a translation table that swaps space with underscore and vice versa\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    \n    # Apply the translation table to the input string\n    return input_string.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n    \n    Parameters:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Use the translate method with a translation table to swap spaces with underscores\n    # First, create a translation table\n    trans_table = str.maketrans({' ': '_', '_': ' '})\n    \n    # Then, apply the translation table to the input string\n    return input_string.translate(trans_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces all whitespace characters in a string with underscores and vice versa.\n\n    Args:\n        input_string (str): The input string to modify.\n\n    Returns:\n        str: The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    # First, replace all whitespace characters with a temporary placeholder\n    # to avoid replacing the underscores that will replace spaces with something else.\n    # Here, we use '|-|' as our placeholder, assuming it doesn't naturally occur in the input.\n    temp_string = input_string.replace(' ', '|-|')\n    \n    # Then, replace all underscores with spaces\n    temp_string = temp_string.replace('_', ' ')\n    \n    # Finally, replace the placeholder with underscores\n    result_string = temp_string.replace('|-|', '_')\n    \n    return result_string", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string (str): The input string to process.\n\n    Returns:\n        str: The string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    return input_string.replace(' ', '_') if ' ' in input_string else input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string: str, replace_with: str = '_') -> str:\n    \"\"\"\n    Replaces whitespaces in the input string with a specified character (default is underscore) \n    and vice versa (replaces specified character with whitespace).\n\n    Args:\n        input_string (str): The input string to perform replacements on.\n        replace_with (str, optional): Character to replace with. Defaults to '_'.\n\n    Returns:\n        str: The modified string after replacements.\n    \"\"\"\n    # Check if input is a string\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Replace whitespace with the specified character and vice versa\n    return input_string.translate(str.maketrans(' _', f'{replace_with} '))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Toggles between replacing whitespaces with underscores and vice versa.\n    \n    If the input string contains one or more whitespaces, they are replaced with underscores.\n    If the input string contains no whitespaces but has one or more underscores, they are replaced with spaces.\n    \n    Parameters:\n    - input_string (str): The input string to process.\n    \n    Returns:\n    - str: The processed string with toggled separators.\n    \"\"\"\n    if ' ' in input_string:  # Check if whitespace is present\n        # Replace all whitespaces with underscores\n        return input_string.replace(' ', '_')\n    elif '_' in input_string:  # If not, check for underscores\n        # Replace all underscores with spaces\n        return input_string.replace('_', ' ')\n    else:\n        # Return original string if neither condition is met\n        return input_string", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string: str) -> str:\n    \"\"\"\n    Replaces whitespaces with underscores in a given string and vice versa.\n\n    Args:\n        input_string (str): The input string to modify.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    # Check if the input contains more spaces or underscores to decide the replacement\n    if input_string.count(' ') > input_string.count('_'):\n        # More spaces, replace spaces with underscores\n        return input_string.replace(' ', '_')\n    else:\n        # More or equal underscores, replace underscores with spaces\n        return input_string.replace('_', ' ')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    - `input_string` (str): The input string to modify.\n\n    Returns:\n    - `str`: The modified string with spaces and underscores swapped.\n    \"\"\"\n    # Use the `str.translate` method along with `str.maketrans` for efficient character replacement\n    # Create a translation table that swaps space and underscore\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    # Apply the translation to the input string\n    return input_string.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(input_string: str) -> str:\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n    \n    Args:\n        input_string (str): The string to modify.\n    \n    Returns:\n        str: The modified string with whitespaces and underscores swapped.\n    \"\"\"\n    # First, replace all underscores with a temporary placeholder\n    # to avoid conflicts when replacing spaces with underscores\n    temp_placeholder = '__TEMP__'\n    string_without_underscores = input_string.replace('_', temp_placeholder)\n    \n    # Replace all spaces with underscores\n    with_underscores = string_without_underscores.replace(' ', '_')\n    \n    # Finally, replace the temporary placeholder back with spaces\n    result = with_underscores.replace(temp_placeholder, ' ')\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"\n    Replaces whitespaces with underscores in a string if the string contains spaces.\n    If the string contains underscores (and no spaces), it replaces underscores with spaces.\n    \n    :param s: Input string\n    :return: Modified string\n    \"\"\"\n    if ' ' in s:\n        # Replace spaces with underscores if the string contains spaces\n        return s.replace(' ', '_')\n    elif '_' in s:\n        # Replace underscores with spaces if the string contains underscores (but no spaces)\n        return s.replace('_', ' ')\n    else:\n        # If neither space nor underscore is found, return the original string\n        return s", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Toggles between replacing whitespaces with underscores and vice versa.\n    \n    Parameters:\n    - input_string (str): The string to modify.\n    \n    Returns:\n    - str: The modified string.\n    \"\"\"\n    if ' ' in input_string:  # Check if string contains whitespace\n        # Replace all whitespaces with underscores\n        return input_string.replace(' ', '_')\n    elif '_' in input_string:  # Check if string contains underscore\n        # Replace all underscores with whitespaces\n        return input_string.replace('_', ' ')\n    else:\n        # If neither condition is met, return the original string\n        return input_string", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string: str) -> str:\n    \"\"\"\n    Replaces whitespaces with underscores in a given string and vice versa.\n\n    Args:\n        input_string (str): The input string to process.\n\n    Returns:\n        str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # First, we'll create a translation table for swapping spaces and underscores\n    # We use the `str.maketrans()` method for this, which returns a translation table\n    # that can be used with the `translate()` method.\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Now, we apply the translation to the input string using the `translate()` method\n    # This will swap all spaces with underscores and vice versa in one pass.\n    swapped_string = input_string.translate(translation_table)\n    \n    return swapped_string", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string: str) -> str:\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n    - input_string (str): The input string to process.\n\n    Returns:\n    - str: The string with whitespaces replaced with underscores and vice versa.\n    \"\"\"\n    # First, replace all underscores with a temporary placeholder to avoid conflicts\n    temp_string = input_string.replace(\"_\", \"__temp__\")\n    # Then, replace all whitespaces with underscores\n    temp_string = temp_string.replace(\" \", \"_\")\n    # Finally, replace the temporary placeholder back with a whitespace\n    result_string = temp_string.replace(\"__temp__\", \" \")\n    return result_string", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string: str) -> str:\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string (str): The input string to process.\n\n    Returns:\n        str: The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    # Determine the replacement character based on the presence of space or underscore\n    if ' ' in input_string:\n        # Replace spaces with underscores\n        replacement_char = '_'\n        target_char = ' '\n    elif '_' in input_string:\n        # Replace underscores with spaces\n        replacement_char = ' '\n        target_char = '_'\n    else:\n        # If neither space nor underscore is found, return the original string\n        return input_string\n\n    # Perform the replacement\n    return input_string.replace(target_char, replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string: str) -> str:\n    \"\"\"\n    Toggles replacement between whitespaces and underscores in a given string.\n    \n    If the string contains more whitespaces, it replaces them with underscores.\n    Conversely, if it contains more underscores, it replaces them with whitespaces.\n    \n    :param input_string: The input string to process.\n    :return: The modified string with toggled whitespace/underscore replacement.\n    \"\"\"\n    if input_string.count(' ') > input_string.count('_'):\n        # More spaces, replace with underscores\n        return input_string.replace(' ', '_')\n    else:\n        # More or equal underscores (including 0), replace with spaces\n        return input_string.replace('_', ' ')", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores in a given string and vice versa.\n\n    Args:\n        input_string (str): The string to modify.\n\n    Returns:\n        str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    return input_string.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Parameters:\n    - input_string (str): The input string to modify.\n\n    Returns:\n    - str: The modified string.\n    \"\"\"\n    # Check if input is a string\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Use the translate method along with maketrans for efficient replacement\n    # First, create a translation table\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    \n    # Apply the translation table to the input string\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(input_string: str) -> str:\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n        input_string (str): The input string to be modified.\n    \n    Returns:\n        str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # First, replace all underscores with a temporary placeholder to avoid conflict\n    temp_placeholder = '__TEMP__'\n    intermediate_string = input_string.replace('_', temp_placeholder)\n    \n    # Then, replace all whitespaces with underscores\n    intermediate_string = intermediate_string.replace(' ', '_')\n    \n    # Finally, replace the temporary placeholder back with a whitespace\n    result_string = intermediate_string.replace(temp_placeholder, ' ')\n    \n    return result_string", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores if found, otherwise replaces underscores with spaces.\n    \n    Parameters:\n    - input_string (str): The input string to process.\n    \n    Returns:\n    - str: The processed string with replacements made.\n    \"\"\"\n    if ' ' in input_string:  # Check if string contains a whitespace\n        # Replace one or more whitespaces with a single underscore\n        output_string = input_string.replace(' ', '_')\n    elif '_' in input_string:  # Check if string contains an underscore\n        # Replace one or more underscores with a single space\n        output_string = input_string.replace('_', ' ')\n    else:\n        # If neither condition is met, return the original string\n        output_string = input_string\n    \n    return output_string", "matching_cluster_idx": 7}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 64.0, "profiled": [{"solution": "def move_zero(input_list):\n    \"\"\"\n    Moves all zeroes to the end of the given list, preserving the original order of non-zero elements.\n    \n    Parameters:\n    - input_list (list): The list from which to move zeroes to the end.\n    \n    Returns:\n    - list: The modified list with all zeroes at the end.\n    \"\"\"\n    # Separate non-zero elements into one list\n    non_zero_elements = [element for element in input_list if element != 0]\n    \n    # Count the number of zeroes in the original list\n    num_zeroes = len(input_list) - len(non_zero_elements)\n    \n    # Append the counted number of zeroes to the non-zero elements list\n    result = non_zero_elements + [0] * num_zeroes\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list, preserving the order of non-zero elements.\n    \n    Args:\n        lst (list): Input list containing integers.\n    \n    Returns:\n        list: New list with zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements into a new list, preserving their original order\n    non_zeros = [x for x in lst if x != 0]\n    \n    # Calculate the number of zeroes in the original list\n    num_zeros = len(lst) - len(non_zeros)\n    \n    # Create a list of zeroes equal to the number of zeroes found\n    zeros = [0] * num_zeros\n    \n    # Combine the non-zero list with the list of zeroes to get the final result\n    result = non_zeros + zeros\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the given list, preserving the order of non-zero elements.\n\n    Args:\n        lst (list): The input list that may contain zeroes.\n\n    Returns:\n        list: The modified list with all zeroes at the end.\n    \"\"\"\n    # Separate non-zero elements and zeroes into different lists\n    non_zero_elements = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine the two lists to get the final result\n    return non_zero_elements + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \n    Args:\n        input_list (list): The list to modify.\n    \n    Returns:\n        list: The list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements into a new list\n    non_zero_elements = [element for element in input_list if element != 0]\n    \n    # Calculate the number of zeroes in the original list\n    num_zeroes = len(input_list) - len(non_zero_elements)\n    \n    # Extend the non-zero list with zeroes to maintain original length\n    non_zero_elements.extend([0] * num_zeroes)\n    \n    return non_zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    Moves all zeroes to the end of the given list, maintaining the original order of non-zero elements.\n\n    Args:\n        input_list (list): The input list that may contain zeroes.\n\n    Returns:\n        list: The modified list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements from the input list while maintaining their original order\n    non_zero_elements = [element for element in input_list if element != 0]\n    \n    # Calculate the number of zeroes in the input list\n    num_zeroes = len(input_list) - len(non_zero_elements)\n    \n    # Return a new list with non-zero elements first, followed by zeroes\n    return non_zero_elements + [0] * num_zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \n    Args:\n        lst (list): The input list that may contain zeroes.\n    \n    Returns:\n        list: A new list with all non-zero elements first, followed by zeroes.\n    \"\"\"\n    # Separate non-zero elements from zeroes\n    non_zeros = [x for x in lst if x != 0]\n    zeros = [x for x in lst if x == 0]\n    \n    # Combine the two lists to get the desired order\n    result = non_zeros + zeros\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    Args:\n    - lst (list): Input list containing integers.\n\n    Returns:\n    - list: List with all zeroes moved to the end, maintaining the relative order of non-zero elements.\n    \"\"\"\n    # Separate non-zero elements into a new list while preserving their original order\n    non_zero_elements = [element for element in lst if element != 0]\n    \n    # Calculate the number of zeroes in the original list\n    num_zeroes = len(lst) - len(non_zero_elements)\n    \n    # Return a new list with non-zero elements followed by the appropriate number of zeroes\n    return non_zero_elements + [0] * num_zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    Moves all zeroes to the end of the given list, preserving the order of non-zero elements.\n\n    Args:\n        input_list (list): A list containing integers.\n\n    Returns:\n        list: The modified list with all zeroes at the end.\n    \"\"\"\n    # Separate non-zero elements into a new list\n    non_zero_elements = [element for element in input_list if element != 0]\n    \n    # Calculate the number of zeroes in the original list\n    num_zeroes = len(input_list) - len(non_zero_elements)\n    \n    # Return a new list with non-zero elements first, followed by zeroes\n    return non_zero_elements + [0] * num_zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    Moves all zeroes to the end of the given list, maintaining the relative order of non-zero elements.\n\n    Args:\n        input_list (list): The list from which zeroes are to be moved to the end.\n\n    Returns:\n        list: The modified list with zeroes at the end.\n    \"\"\"\n    # Separate non-zero elements from the input list, maintaining their original order\n    non_zero_elements = [element for element in input_list if element != 0]\n    \n    # Calculate the number of zeroes in the original list\n    num_zeroes = len(input_list) - len(non_zero_elements)\n    \n    # Construct the result by appending zeroes to the non-zero elements\n    result = non_zero_elements + [0] * num_zeroes\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    Moves all zeroes to the end of the given list, preserving the original order of non-zero elements.\n\n    Args:\n        input_list (list): The input list that may contain zeroes.\n\n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements and zeroes into two different lists\n    non_zero_elements = [element for element in input_list if element != 0]\n    zeroes = [element for element in input_list if element == 0]\n    \n    # Combine the two lists to get the final result\n    result = non_zero_elements + zeroes\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n        lst (list): Input list containing integers.\n    \n    Returns:\n        list: List with all zeroes moved to the end.\n    \"\"\"\n    # Initialize two pointers, one for tracking non-zero elements and one for iteration\n    non_zero_idx = 0\n    \n    # Iterate over the list\n    for i in range(len(lst)):\n        # If the current element is not zero, swap it with the element at the non_zero_idx\n        if lst[i] != 0:\n            lst[non_zero_idx], lst[i] = lst[i], lst[non_zero_idx]\n            # Increment the non_zero_idx pointer\n            non_zero_idx += 1\n    \n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n        lst (list): The input list that may contain zeroes.\n    \n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements into a new list\n    non_zero_elements = [x for x in lst if x != 0]\n    \n    # Calculate the number of zeroes in the original list\n    num_zeroes = len(lst) - len(non_zero_elements)\n    \n    # Append zeroes to the end of the non-zero elements list\n    result = non_zero_elements + [0] * num_zeroes\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(es):\n    \"\"\"\n    Move all zeroes to the end of the list while preserving the order of non-zero elements.\n\n    Args:\n        es (list): The input list that may contain zeroes.\n\n    Returns:\n        list: The modified list with all zeroes at the end.\n    \"\"\"\n    # Separate non-zero elements from zeroes\n    non_zeros = [e for e in es if e != 0]\n    # Calculate the number of zeroes to append at the end\n    num_zeros = len(es) - len(non_zeros)\n    \n    # Combine non-zero elements with trailing zeroes\n    return non_zeros + [0] * num_zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    lst (list): Input list containing integers.\n    \n    Returns:\n    list: List with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements into a new list\n    non_zero_elements = [element for element in lst if element != 0]\n    \n    # Calculate the number of zeroes in the original list\n    num_zeroes = len(lst) - len(non_zero_elements)\n    \n    # Return a new list with non-zero elements first, followed by zeroes\n    return non_zero_elements + [0] * num_zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    Moves all zeroes to the end of the input list while maintaining the relative order of non-zero elements.\n\n    Args:\n        input_list (list): A list that may contain zeroes and non-zero elements.\n\n    Returns:\n        list: The input list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements from the input list, preserving their original order\n    non_zero_elements = [element for element in input_list if element != 0]\n    \n    # Calculate the number of zeroes in the input list\n    num_zeroes = len(input_list) - len(non_zero_elements)\n    \n    # Append the calculated number of zeroes to the list of non-zero elements\n    result = non_zero_elements + [0] * num_zeroes\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    Moves all zeroes to the end of the given list, maintaining the relative order of non-zero elements.\n\n    Args:\n    - input_list (list): A list containing integers (including zeroes).\n\n    Returns:\n    - list: The input list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements from the input list, preserving their original order\n    non_zero_elements = [element for element in input_list if element != 0]\n    \n    # Calculate the number of zeroes in the input list\n    num_zeroes = len(input_list) - len(non_zero_elements)\n    \n    # Construct the output list by appending zeroes to the non-zero elements\n    output_list = non_zero_elements + [0] * num_zeroes\n    \n    return output_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \n    Args:\n        lst (list): The input list that may contain zeroes.\n    \n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements from zeroes\n    non_zeroes = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine the lists to get the desired output\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \n    Args:\n        input_list (list): The input list that may contain zeroes.\n    \n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements into a new list\n    non_zero_elements = [x for x in input_list if x != 0]\n    \n    # Calculate the number of zeroes in the original list\n    num_zeroes = len(input_list) - len(non_zero_elements)\n    \n    # Return a new list with non-zero elements followed by zeroes\n    return non_zero_elements + [0] * num_zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n        lst (list): The input list that may contain zeroes.\n    \n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements and zeroes into different lists\n    non_zeroes = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    \n    # Combine the two lists to get the final result\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(input_list):\n    \"\"\"\n    Move all zeroes to the end of the given list, maintaining the relative order of non-zero elements.\n\n    Args:\n        input_list (list): The input list that may contain zeroes.\n\n    Returns:\n        list: The list with all zeroes moved to the end.\n    \"\"\"\n    # Initialize two lists: one for non-zero elements and one for zeroes\n    non_zeroes = [x for x in input_list if x != 0]  # List comprehension for non-zero elements\n    zeroes = [x for x in input_list if x == 0]      # List comprehension for zeroes\n\n    # Combine the two lists to get the final result\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 84.8780487804878, "dps_norm": 45.0, "pass@1": 10.0, "profiled": [{"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    This function calculates the sum of XOR of all pairs of numbers in the given list.\n    \n    Parameters:\n    - nums (list): A list of integers.\n    - n (int): The size of the list (for clarity, though not strictly necessary in Python).\n    \n    Returns:\n    - int: The sum of XOR of all pairs of numbers.\n    \"\"\"\n    total_xor_sum = 0\n    # Iterate over all pairs of numbers in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate XOR of the current pair and add it to the total sum\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the list.\n\n    :param numbers: List of integers.\n    :param n: Total number of elements to consider.\n    :return: Sum of XOR of all pairs.\n    \"\"\"\n    # Initialize sum variable to 0\n    total_xor_sum = 0\n    \n    # Iterate over the range of the first 'n' elements in the list\n    for i in range(n):\n        # For each element, iterate over the rest of the list (including itself for full pair coverage)\n        for j in range(n):\n            # If it's the same index, skip to avoid XORing a number with itself\n            if i == j:\n                continue\n            # Calculate XOR of the current pair and add to the total sum\n            total_xor_sum += numbers[i] ^ numbers[j]\n    \n    # Since each pair is counted twice (e.g., (A,B) and (B,A)), divide by 2\n    total_xor_sum //= 2\n    \n    return total_xor_sum", "matching_cluster_idx": -1}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n\n    Args:\n        numbers (list): A list of integers.\n        n (int): The length of the list (included for problem statement compliance).\n\n    Returns:\n        int: The sum of XOR of all pairs of numbers.\n    \"\"\"\n    # Initialize sum variable to 0\n    total_xor_sum = 0\n    \n    # Iterate over the list using indices to form pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate XOR of the current pair and add to total\n            total_xor_sum += numbers[i] ^ numbers[j]\n    \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    This function calculates the sum of XOR of all pairs of numbers in the given list.\n    \n    Parameters:\n    - numbers (list): A list of integers.\n    - n (int): The size of the list (for validation, but not strictly necessary in Python).\n    \n    Returns:\n    - int: The sum of XOR of all pairs of numbers.\n    \"\"\"\n    # Initialize sum variable to 0\n    total_xor_sum = 0\n    \n    # Iterate over all possible pairs in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate XOR of the current pair and add it to the total sum\n            total_xor_sum += numbers[i] ^ numbers[j]\n    \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n        numbers (list): A list of integers.\n        n (int): The total number of elements to consider for pairing (must be <= len(numbers)).\n    \n    Returns:\n        int: The sum of XOR of all pairs.\n    \"\"\"\n    # Validate input\n    if n > len(numbers):\n        raise ValueError(\"n cannot be greater than the length of the numbers list\")\n    \n    # Initialize sum of XOR\n    xor_sum = 0\n    \n    # Generate all possible pairs and calculate XOR sum\n    for i in range(n):\n        for j in range(i + 1, n):  # Ensure distinct pairs without repetition\n            # Calculate XOR of the current pair and add to the sum\n            xor_sum += numbers[i] ^ numbers[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, length=None):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n\n    If length is provided, it optimizes the calculation by considering only the specified number of elements from the list.\n\n    Args:\n        - numbers (list): A list of integers.\n        - length (int, optional): The number of elements to consider from the list. Defaults to None, meaning all elements are considered.\n\n    Returns:\n        int: The sum of XOR of all pairs of numbers.\n    \"\"\"\n    # If length is specified, slice the list; otherwise, use the entire list\n    numbers = numbers[:length] if length is not None else numbers\n    \n    # Initialize sum of XOR\n    xor_sum = 0\n    \n    # Iterate over all pairs of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Calculate XOR of the current pair and add to the total sum\n            xor_sum += numbers[i] ^ numbers[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n=None):\n    \"\"\"\n    Calculates the sum of XOR of all pairs in the list.\n    \n    Args:\n        numbers (list): List of integers.\n        n (int, optional): Length of the list. Automatically calculated if not provided.\n    \n    Returns:\n        int: Sum of XOR of all pairs.\n    \"\"\"\n    # Ensure n is the length of the list for the operation\n    n = len(numbers) if n is None else n\n    \n    # Initialize sum of XOR\n    xor_sum = 0\n    \n    # Iterate over all unique pairs in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate XOR of the current pair and add to the sum\n            xor_sum += numbers[i] ^ numbers[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in the given list.\n\n    :param numbers: List of integers.\n    :param n: Number of elements to consider from the list for pairing.\n    :return: Sum of XOR of all pairs.\n    \"\"\"\n    # Initialize sum variable to 0\n    total_xor_sum = 0\n    \n    # Consider all pairs of numbers up to the nth element\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate XOR of the current pair and add to the total sum\n            total_xor_sum += numbers[i] ^ numbers[j]\n    \n    return total_xor_sum\nnumbers = [5, 9, 7, 6]\nn = 4", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    This function calculates the sum of XOR of all pairs of numbers in the given list.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    n (int): The size of the list (not explicitly necessary but included as per the problem statement).\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers.\n    \"\"\"\n    # Initialize sum of XOR\n    xor_sum = 0\n    \n    # Iterate over all pairs of numbers in the list\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate XOR of the current pair and add it to the sum\n            xor_sum += numbers[i] ^ numbers[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    This function calculates the sum of XOR of all pairs of numbers in the given list.\n    \n    :param numbers: A list of integers.\n    :param n: The size of the input list.\n    :return: The sum of XOR of all pairs of numbers.\n    \"\"\"\n    total_sum = 0  # Initialize variable to hold the total sum of XOR operations.\n    \n    # Iterate over each unique pair of numbers in the list.\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate XOR of the current pair and add it to the total sum.\n            total_sum += numbers[i] ^ numbers[j]\n    \n    return total_sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 73.03191489361701, "dps_norm": 74.33333333333333, "pass@1": 75.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses elements in the input array up to the Kth position.\n\n    Args:\n    - `arr` (list): The input array to be partially reversed.\n    - `k` (int): The position up to which the array should be reversed.\n\n    Returns:\n    - `list`: The modified array with elements reversed up to the Kth position.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"K cannot be larger than the array's length\")\n    \n    # Slice the array into two parts: up to K and the rest\n    up_to_k = arr[:k]\n    the_rest = arr[k:]\n    \n    # Reverse the first part and concatenate with the second part\n    return up_to_k[::-1] + the_rest", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the input array up to the kth position.\n    \n    :param arr: Input list\n    :type arr: list\n    :param k: Position up to which the array is reversed\n    :type k: int\n    :return: Partially reversed list\n    :rtype: list\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n    \n    # Slice the array into two parts at the kth position and reverse the first part\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n\n    :param array: The input list to be partially reversed.\n    :param k: The position up to which the array is reversed (1-indexed for user convenience).\n    :return: A new list with the first `k` elements reversed, and the rest remaining in original order.\n    \"\"\"\n    # Adjust k for 0-indexing\n    k = min(k, len(array))  # Ensure k doesn't exceed array length\n    k -= 1  # Convert to 0-indexed for slicing\n    \n    # Slice the array into two parts: up to k (reversed) and after k (as is)\n    # Then, concatenate these two parts\n    return array[:k+1][::-1] + array[k+1:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n\n    :param arr: The input list to be partially reversed.\n    :type arr: list\n    :param k: The position up to which the array should be reversed.\n    :type k: int\n    :return: The array with elements reversed up to the k-th position.\n    :rtype: list\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n    # Slice the array into two parts at the k-th position\n    # and then reverse the first part, keeping the second part as is\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the input array up to the Kth position.\n\n    Parameters:\n    - `arr` (list): Input array to be reversed up to K.\n    - `k` (int): Position up to which the array is reversed.\n\n    Returns:\n    - `list`: The modified array with elements reversed up to the Kth position.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"K cannot be greater than the length of the array.\")\n    \n    # Slice the array up to K, reverse it, and concatenate with the rest of the array\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    \"\"\"\n    Reverses the input array up to the given position K.\n    \n    Parameters:\n    - arr (list): The input list to be modified.\n    - K (int): The position up to which the array is reversed.\n    \n    Returns:\n    - list: The modified array with elements reversed up to position K.\n    \"\"\"\n    # Check if K is within array bounds\n    if K > len(arr):\n        raise ValueError(\"K exceeds array length\")\n    \n    # Reverse the array up to position K\n    # We use list slicing to achieve this in a Pythonic way\n    # arr[:K] will be reversed and concatenated with the rest of the array (from index K to the end)\n    return arr[:K][::-1] + arr[K:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of `arr` up to the `k`th position.\n    \n    :param arr: Input list of elements.\n    :param k: Position up to which the array should be reversed.\n    :return: The modified list.\n    \"\"\"\n    # Check if k is within bounds\n    if k > len(arr):\n        raise ValueError(\"k exceeds array length\")\n    \n    # Slice the array into two parts at the kth position, \n    # reverse the first part, and concatenate both\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the input array up to the given position (k).\n\n    Args:\n        arr (list): Input list of elements\n        k (int): Position up to which the array should be reversed\n\n    Returns:\n        list: Modified list with elements reversed up to the k-th position\n\n    Raises:\n        ValueError: If k is less than 1 or greater than the length of the array\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k is out of range\")\n\n    # Slice the array into two parts: up to k (inclusive) and the rest\n    # Then, reverse the first part using slicing and concatenate with the second part\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n    \n    :param arr: Input list to be modified.\n    :type arr: list\n    :param k: Position up to which the array is reversed.\n    :type k: int\n    :return: The modified list with elements reversed up to the k-th position.\n    :rtype: list\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k cannot be larger than the length of the array.\")\n    \n    # Reverse the array up to the k-th position\n    # We add 1 to k because list slicing in Python is up to but not including the end index\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(array, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n\n    Args:\n    - array (list): The input list of elements.\n    - k (int): The position up to which the array should be reversed.\n\n    Returns:\n    - list: The modified list with elements reversed up to the k-th position.\n    \"\"\"\n    # Check if k is within bounds\n    if k > len(array):\n        raise ValueError(\"k exceeds array length\")\n\n    # Slice the array into two parts: up to k and the rest\n    # Then, reverse the first part and concatenate with the second\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to the k-th position.\n\n    :param arr: Input list of elements\n    :type arr: list\n    :param k: Position up to which the array is reversed\n    :type k: int\n    :return: Modified list with elements reversed up to the k-th position\n    :rtype: list\n    \"\"\"\n    # Check if k is within bounds\n    if k > len(arr):\n        raise ValueError(\"k cannot be larger than the array length\")\n    \n    # Slice the array into two parts: up to k and from k to the end\n    # Then, reverse the first part and concatenate with the second part\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n\n    Args:\n    - array (list): The input list to be modified.\n    - k (int): The position up to which the array is reversed.\n\n    Returns:\n    - list: The modified array with elements reversed up to the k-th position.\n    \"\"\"\n    if k > len(array):\n        raise ValueError(\"k cannot be larger than the array length\")\n    \n    # Slice the array into two parts: up to k and from k to the end\n    # Then, reverse the first part and concatenate with the second part\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n\n    Args:\n    - `array` (list): Input list to be modified.\n    - `k` (int): Position up to which the array should be reversed.\n\n    Returns:\n    - `list`: Modified array with elements reversed up to the k-th position.\n    \"\"\"\n    if k > len(array):\n        raise ValueError(\"k cannot be larger than the array's length\")\n    \n    # Reverse the array up to the k-th position\n    # We use list slicing to achieve this in a Pythonic way\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the input array up to the given position k.\n    \n    Parameters:\n    - arr (list): The input list of elements to be reversed.\n    - k (int): The position up to which the array is to be reversed.\n    \n    Returns:\n    - list: The modified list with elements reversed up to the k-th position.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k cannot be larger than the length of the array\")\n    \n    # Slice the array into two parts: up to k and the rest\n    # Then, reverse the first part using list slicing and concatenate with the second part\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n\n    Args:\n    - array (list): The input list to be reversed partially.\n    - k (int): The position up to which the array is to be reversed.\n\n    Returns:\n    - list: The modified list with elements reversed up to the k-th position.\n    \"\"\"\n    if k > len(array):\n        raise ValueError(\"k cannot be larger than the array length\")\n    \n    # Slice the array into two parts: up to k and from k to the end\n    # Then, reverse the first part using slicing and concatenate with the second part\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    \"\"\"\n    Reverses the input array up to the Kth position.\n\n    Args:\n    - arr (list): The input list to be modified.\n    - K (int): The position up to which the list is reversed.\n\n    Returns:\n    - list: The modified list with elements reversed up to the Kth position.\n    \"\"\"\n    if K > len(arr):\n        raise ValueError(\"K cannot be greater than the length of the array.\")\n    \n    # Slice the array into two parts: up to K and from K to the end\n    # Then, reverse the first part and concatenate with the second part\n    return arr[:K][::-1] + arr[K:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n    \n    Args:\n        arr (list): Input array to be modified.\n        k (int): Position up to which the array will be reversed.\n        \n    Returns:\n        list: The array with elements reversed up to the k-th position.\n    \"\"\"\n    # Check if k is within bounds to avoid index errors\n    k = min(k, len(arr))  # Ensure k does not exceed array length\n    \n    # Reverse the array up to the k-th position\n    # Using list slicing to create a new list with the first k elements reversed\n    # and then concatenating the rest of the array (from k to the end)\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(array, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n\n    Args:\n        array (list): Input list to be partially reversed.\n        k (int): Position up to which the array is reversed.\n\n    Returns:\n        list: The modified array with elements reversed up to the k-th position.\n    \"\"\"\n    if k > len(array):\n        raise ValueError(\"K cannot be greater than the array length.\")\n    \n    # Slice the array into two parts at the k-th position\n    # Then, reverse the first part and concatenate with the second part\n    return array[:k][::-1] + array[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n\n    Parameters:\n    - arr (list): The input list to be partially reversed.\n    - k (int): The position up to which the array should be reversed.\n\n    Returns:\n    - list: The array with elements reversed up to the k-th position.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k cannot be larger than the array's length\")\n    \n    # Slice the array into two parts at the k-th position\n    # and then reverse the first part\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the input array up to the k-th position.\n\n    :param arr: Input list of elements\n    :param k: Position up to which the array should be reversed\n    :return: The modified array with elements reversed up to the k-th position\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n    \n    # Slice the array into two parts: up to k and from k to the end\n    # Then, reverse the first part and concatenate with the second part\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 53.84615384615385, "dps_norm": 85.0, "pass@1": 68.0, "profiled": [{"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a given tuple and returns the new tuple.\n    \n    Parameters:\n    - input_tuple (tuple): The original tuple to which a dictionary will be added.\n    - input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the original tuple plus the dictionary.\n    \"\"\"\n    # Since tuples are immutable, we need to create a new tuple\n    # We use the '+' operator to concatenate the original tuple with a new tuple containing the dictionary\n    new_tuple = input_tuple + (input_dict,)\n    \n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a tuple and returns the resulting tuple.\n\n    Args:\n        input_tuple (tuple): The original tuple.\n        input_dict (dict): The dictionary to be added.\n\n    Returns:\n        tuple: A new tuple containing all elements from `input_tuple` plus `input_dict`.\n    \"\"\"\n    # Since tuples are immutable, we convert to list, append, then convert back to tuple\n    result_list = list(input_tuple)  # Convert tuple to list for mutability\n    result_list.append(input_dict)    # Append dictionary to list\n    result_tuple = tuple(result_list)  # Convert list back to tuple\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to the end of a given tuple.\n\n    Args:\n        input_tuple (tuple): The original tuple to be extended.\n        input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n        tuple: A new tuple containing all elements from the original tuple and the appended dictionary.\n    \"\"\"\n    # Tuples are immutable, so we convert to list, append, and then convert back to tuple\n    list_version = list(input_tuple)  # Convert tuple to list for mutability\n    list_version.append(input_dict)    # Append dictionary to the list\n    return tuple(list_version)         # Convert back to tuple and return", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a tuple and returns the new tuple.\n\n    Args:\n        input_tuple (tuple): The original tuple to be extended.\n        input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n        tuple: A new tuple containing all elements from the input tuple plus the input dictionary.\n    \"\"\"\n    # Since tuples are immutable, we convert to list, append, and then convert back to tuple\n    list_version = list(input_tuple)  # Convert tuple to list for mutability\n    list_version.append(input_dict)    # Append the dictionary to the list\n    return tuple(list_version)         # Convert list back to tuple and return", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a given tuple.\n    \n    Parameters:\n    - input_tuple (tuple): The original tuple to be extended.\n    - input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    - tuple: A new tuple with the original elements plus the dictionary at the end.\n    \"\"\"\n    # Tuples are immutable; convert to list to append, then convert back to tuple\n    list_version = list(input_tuple)\n    list_version.append(input_dict)\n    return tuple(list_version)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n    \n    Args:\n    - input_tuple (tuple): The original tuple to be extended.\n    - input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    - tuple: A new tuple with the dictionary appended at the end.\n    \"\"\"\n    # Since tuples are immutable in Python, we convert the tuple to a list,\n    # append the dictionary, and then convert it back to a tuple.\n    temp_list = list(input_tuple)  # Convert tuple to a list\n    temp_list.append(input_dict)   # Append the dictionary\n    return tuple(temp_list)        # Convert back to a tuple and return", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a tuple.\n    \n    Args:\n    - input_tuple (tuple): The original tuple.\n    - input_dict (dict): The dictionary to be added.\n    \n    Returns:\n    - tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    # Since tuples are immutable, we convert to list, append, then convert back\n    temp_list = list(input_tuple)  # Convert tuple to list\n    temp_list.append(input_dict)   # Append dictionary to list\n    result_tuple = tuple(temp_list) # Convert list back to tuple\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to the end of a given tuple.\n    \n    Parameters:\n    input_tuple (tuple): The original tuple to be extended.\n    input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple and the input dictionary.\n    \"\"\"\n    # Since tuples are immutable in Python, we cannot directly add to them.\n    # Instead, we convert the tuple to a list, append the dict, and convert back to a tuple.\n    list_version = list(input_tuple)  # Convert tuple to list\n    list_version.append(input_dict)  # Append dictionary to the list\n    return tuple(list_version)  # Convert back to tuple and return", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to the end of a given tuple.\n\n    Args:\n    - input_tuple (tuple): The original tuple to be extended.\n    - input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    - tuple: A new tuple containing all elements from the input tuple plus the input dictionary.\n    \"\"\"\n    # Since tuples are immutable in Python, we can't directly append to them.\n    # Instead, we create a new tuple that includes all elements from the original tuple and the new dictionary.\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to the end of a given tuple.\n\n    Args:\n        input_tuple (tuple): The original tuple to be extended.\n        input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n        tuple: A new tuple with the dictionary appended at the end.\n    \"\"\"\n    # Since tuples are immutable, we convert to list, append, and then convert back\n    list_temp = list(input_tuple)  # Convert tuple to list for mutability\n    list_temp.append(input_dict)    # Append dictionary to the list\n    return tuple(list_temp)         # Convert back to tuple and return\ninput_tuple = (4, 5, 6)\ninput_dict = {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3}", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a tuple, returning a new tuple.\n    \n    Args:\n        input_tuple (tuple): The original tuple to be extended.\n        input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n        tuple: A new tuple containing all elements from `input_tuple` and `input_dict`.\n    \"\"\"\n    # Convert the tuple to a list to enable append operation\n    list_from_tuple = list(input_tuple)\n    \n    # Append the dictionary to the list\n    list_from_tuple.append(input_dict)\n    \n    # Convert the list back to a tuple and return it\n    return tuple(list_from_tuple)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a tuple, returning a new tuple.\n    \n    Parameters:\n    - input_tuple (tuple): The original tuple to be extended.\n    - input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the input tuple and the input dictionary.\n    \"\"\"\n    # Since tuples are immutable, we convert the tuple to a list to append the dictionary\n    list_from_tuple = list(input_tuple)\n    \n    # Append the dictionary to the list\n    list_from_tuple.append(input_dict)\n    \n    # Convert the list back to a tuple for the output\n    output_tuple = tuple(list_from_tuple)\n    \n    return output_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to a given tuple and returns the resulting tuple.\n    \n    Parameters:\n    - input_tuple (tuple): The original tuple to which the dictionary will be added.\n    - input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the input tuple and the input dictionary.\n    \"\"\"\n    # Since tuples are immutable, we convert the tuple to a list to append the dictionary\n    list_from_tuple = list(input_tuple)\n    # Append the dictionary to the list\n    list_from_tuple.append(input_dict)\n    # Convert the list back to a tuple to meet the output requirement\n    resulting_tuple = tuple(list_from_tuple)\n    return resulting_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a given tuple, returning a new tuple.\n    \n    Args:\n    - input_tuple (tuple): The original tuple to be extended.\n    - input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the input tuple and the input dictionary.\n    \"\"\"\n    # Since tuples are immutable, we convert it to a list to append the dictionary\n    list_from_tuple = list(input_tuple)\n    \n    # Append the dictionary to the list\n    list_from_tuple.append(input_dict)\n    \n    # Convert the list back to a tuple for output consistency\n    resulting_tuple = tuple(list_from_tuple)\n    \n    return resulting_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple (tuple): The original tuple to which the dictionary will be added.\n        input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n        tuple: A new tuple containing all elements from `input_tuple` and `input_dict` at the end.\n    \"\"\"\n    # Tuples are immutable, so we convert to list, append, and then convert back to tuple\n    list_version = list(input_tuple)  # Convert tuple to list for mutability\n    list_version.append(input_dict)  # Append the dictionary to the list\n    return tuple(list_version)  # Convert back to tuple and return", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a tuple and returns the resulting tuple.\n    \n    Parameters:\n    - input_tuple (tuple): The original tuple to be extended.\n    - input_dict (dict): The dictionary to be appended to the tuple.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the input tuple and the input dictionary.\n    \"\"\"\n    # Since tuples are immutable, we need to create a new tuple\n    # We use the '+' operator to concatenate the input tuple with a new tuple containing the dictionary\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to the end of a tuple, returning the new tuple.\n    \n    Args:\n        input_tuple (tuple): The original tuple.\n        input_dict (dict): The dictionary to be added.\n    \n    Returns:\n        tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    # Since tuples are immutable, we convert to list, append, then convert back\n    list_from_tuple = list(input_tuple)  # Convert tuple to a list for mutability\n    list_from_tuple.append(input_dict)   # Append the dictionary to the list\n    new_tuple = tuple(list_from_tuple)   # Convert the list back to a tuple\n    return new_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a tuple and returns the resulting tuple.\n    \n    Since tuples are immutable in Python, we create a new tuple \n    combining the original tuple with the dictionary.\n    \n    Parameters:\n    - input_tuple (tuple): The original tuple.\n    - input_dict (dict): The dictionary to be added.\n    \n    Returns:\n    - tuple: A new tuple containing all elements from the input tuple and the input dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to a tuple.\n\n    Args:\n        - input_tuple (tuple): The original tuple to be extended.\n        - input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n        - tuple: A new tuple containing all elements from the original tuple and the added dictionary.\n    \"\"\"\n    # Since tuples are immutable, we convert the tuple to a list to append the dict\n    list_from_tuple = list(input_tuple)\n    \n    # Append the dictionary to the list\n    list_from_tuple.append(input_dict)\n    \n    # Convert the list back to a tuple for the output\n    output_tuple = tuple(list_from_tuple)\n    \n    return output_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n    \n    Args:\n        input_tuple (tuple): The original tuple to be extended.\n        input_dict (dict): The dictionary to be added.\n    \n    Returns:\n        tuple: A new tuple containing all elements from `input_tuple` followed by `input_dict`.\n    \"\"\"\n    # Since tuples are immutable, we cannot directly append to them. \n    # Instead, we create a new tuple using the original tuple's elements plus the new dictionary.\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 54.23497267759562, "dps_norm": 65.0, "pass@1": 24.0, "profiled": [{"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts values enclosed within double quotation marks from a given string.\n\n    Args:\n        input_string (str): The input string to extract quoted values from.\n\n    Returns:\n        list: A list of strings, each representing a value found between quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (including spaces) enclosed in double quotes\n    pattern = r'\"(.*?)\"'\n    \n    # Find all occurrences of the pattern in the input string, capturing the enclosed values\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    \"\"\"\n    Extracts values between double quotation marks from the input string.\n    \n    :param input_string: String to extract quoted values from.\n    :return: List of strings representing quoted values.\n    \"\"\"\n    import re\n    # Regular expression pattern to match any characters (non-greedy) enclosed in double quotes\n    pattern = r'\"(.*?)\"'\n    # Find all matches of the pattern in the input string\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a string.\n    \n    Args:\n        input_string (str): The input string containing quoted values.\n    \n    Returns:\n        list: A list of strings, each representing a value extracted from within quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any text enclosed in double quotes\n    pattern = r'\"([^\"]*)\"'\n    \n    # Find all matches of the pattern in the input string\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string: str) -> list:\n    \"\"\"\n    Extracts all substrings enclosed within quotation marks from the input string.\n    \n    Args:\n        input_string (str): The string to extract quoted values from.\n    \n    Returns:\n        list: A list of substrings that were enclosed within quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (.) any number of times (*?) \n    # enclosed within double quotes (\"...\"), using a non-greedy match to avoid \n    # matching too much in case of multiple quoted substrings\n    pattern = r'\"(.*?)\"'\n    \n    # re.findall returns all non-overlapping matches of pattern in string, as a list of strings\n    # The parentheses in the pattern create a capture group, which allows findall to return \n    # the matched group (i.e., the content within the quotes) rather than the entire match\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string: str) -> list[str]:\n    \"\"\"\n    Extracts all substrings enclosed within double quotation marks from the input string.\n\n    Args:\n    - `input_string` (str): The string from which to extract quoted substrings.\n\n    Returns:\n    - `list[str]`: A list of substrings found between double quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'  # Regular expression pattern to match any character (except \") between \"\n    matches = re.findall(pattern, input_string)  # Find all matches in the input string\n    return matches", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    \"\"\"\n    Extract values enclosed within quotation marks from a string.\n\n    Args:\n    - input_string (str): The string to extract quoted values from.\n\n    Returns:\n    - list[str]: A list of strings found between quotation marks.\n    \"\"\"\n    quoted_values = []\n    quote_flag = False\n    temp_string = \"\"\n\n    for char in input_string:\n        if char == '\"':\n            quote_flag = not quote_flag  # Toggle quote flag on encountering a quote\n            if not quote_flag:  # If closing a quoted section\n                quoted_values.append(temp_string)\n                temp_string = \"\"  # Reset temp string\n        elif quote_flag:\n            temp_string += char  # Accumulate characters within quotes\n\n    return quoted_values", "matching_cluster_idx": 2}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts all substrings enclosed within double quotation marks from the input string.\n\n    Args:\n        input_string (str): The string to extract quoted values from.\n\n    Returns:\n        list: A list of substrings found enclosed in double quotes.\n    \"\"\"\n    pattern = r'\"(.*?)\"'  # Regular expression pattern to match any characters (.*?) between double quotes (\"\")\n    matches = re.findall(pattern, input_string)  # Find all occurrences matching the pattern\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts all substrings enclosed within double quotation marks.\n\n    Args:\n        input_string (str): The input string to extract quoted substrings from.\n\n    Returns:\n        list: A list of substrings that were enclosed within double quotes.\n    \"\"\"\n    # Regular expression pattern to match any characters (including none) between double quotes\n    pattern = r'\"(.*?)\"'\n    \n    # re.findall returns all non-overlapping matches of pattern in string, as a list of strings\n    # The '?' after '*' makes the match non-greedy, so it stops at the first quote it finds\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts all substrings enclosed within double quotation marks from the input string.\n\n    Args:\n        input_string (str): The string from which to extract quoted values.\n\n    Returns:\n        list[str]: A list of substrings found between double quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (including none) between double quotes\n    pattern = r'\"([^\"]*)\"'\n    \n    # re.findall returns all non-overlapping matches of pattern in string, as a list of strings\n    # The parentheses around [^\"]* form a group, which allows findall to return the matched group (i.e., the content between quotes)\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts values between double quotation marks from the input string.\n\n    Args:\n        input_string (str): The string to extract quoted values from.\n\n    Returns:\n        list: A list of strings found between double quotation marks.\n    \"\"\"\n    pattern = r'\"(.*?)\"'  # Regular expression pattern to match quoted strings\n    # Using re.findall to find all occurrences in the string\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extract values enclosed in quotation marks from a given string.\n    \n    Args:\n        input_string (str): Input string to extract quoted values from.\n    \n    Returns:\n        list: List of strings, each being a value that was enclosed in quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (.) between quotes (\"\"),\n    # ensuring the quotes are matched and the content is captured as a group.\n    # The `findall` function returns all non-overlapping matches of pattern in string, as a list of strings.\n    pattern = r'\"(.*?)\"'\n    \n    # Use `re.findall` to find all occurrences matching the pattern in the input string.\n    # The `?` after `.*` makes the match non-greedy, so it stops at the first closing quote.\n    quoted_values = re.findall(pattern, input_string)\n    \n    return quoted_values", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts values between double quotation marks from the input string.\n\n    Args:\n        input_string (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of strings, each representing a value that was enclosed in double quotes.\n    \"\"\"\n    # Regular expression pattern to match any characters (.) between double quotes (\"\"),\n    # the parentheses around .* form a capture group to include the matched content in the result\n    pattern = r'\"(.*?)\"'\n    \n    # re.findall returns all non-overlapping matches of pattern in string, as a list of strings\n    # The '?' after '*' makes the match non-greedy, so it stops at the first '\"' it encounters\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(input_string):\n    \"\"\"\n    Extracts values enclosed between double quotation marks from a given string.\n\n    Args:\n    - input_string (str): The input string from which to extract quoted values.\n\n    Returns:\n    - list: A list of substrings that were found enclosed within double quotation marks.\n    \"\"\"\n    import re\n    # Regular expression pattern to match any characters (non-greedy) enclosed in double quotes\n    pattern = r'\"(.*?)\"'\n    # Find all matches in the input string\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a given string.\n    \n    Args:\n    - input_string (str): The string from which to extract quoted values.\n    \n    Returns:\n    - list: A list of strings found between quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (including none) \n    # between double quotes, capturing the content (not the quotes themselves)\n    pattern = r'\"([^\"]*)\"'\n    \n    # Use findall to get all matches of the pattern in the string\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n    \n    Parameters:\n    input_string (str): The string from which to extract quoted substrings.\n    \n    Returns:\n    list: A list of substrings that were enclosed in double quotes in the input string.\n    \"\"\"\n    # Regular expression pattern to match any characters (.) any number of times (*?) \n    # enclosed in double quotes (\"), using a non-greedy match to avoid matching too much\n    pattern = r'\"(.*?)\"'\n    \n    # Use re.findall to find all occurrences of the pattern in the input string\n    # The parentheses in the pattern create a capture group, so only the matched \n    # content within the quotes is returned, not the quotes themselves\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(input_string):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        input_string (str): The string from which to extract quoted values.\n\n    Returns:\n        list: A list of strings, each representing a value that was enclosed in double quotes.\n    \"\"\"\n    import re\n    # Regular expression pattern to match any characters (including none) enclosed in double quotes\n    pattern = r'\"(.*?)\"'\n    # Find all occurrences in the string, capturing only the content within the quotes\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(input_string):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        input_string (str): The string from which to extract quoted values.\n\n    Returns:\n        list: A list of substrings that were enclosed in double quotes in the input string.\n    \"\"\"\n    import re\n    # Regular expression pattern to match any characters (including none) enclosed in double quotes\n    pattern = r'\"[^\"]*\"'\n    # Find all matches of the pattern in the input string\n    matches = re.findall(pattern, input_string)\n    # Remove the enclosing double quotes from each match\n    extracted_values = [match[1:-1] for match in matches]\n    return extracted_values", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    \"\"\"\n    Extracts all values enclosed within double quotation marks (\" \") from a given string.\n\n    Args:\n    input_string (str): The string from which to extract quoted values.\n\n    Returns:\n    list: A list of strings, each representing a value found between quotation marks.\n    \"\"\"\n    # Regular expression pattern to match any characters (including none) within double quotes\n    pattern = r'\"(.*?)\"'\n    \n    # Use findall to get all non-overlapping matches of the pattern in the string as a list of strings\n    matches = re.findall(pattern, input_string)\n    \n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values enclosed within quotation marks from a given string.\n\n    Args:\n        s (str): Input string potentially containing quoted values.\n\n    Returns:\n        list: A list of strings that were enclosed within quotation marks in the input string.\n    \"\"\"\n    # Regular expression pattern to match any characters (including spaces) enclosed in double quotes\n    pattern = r'\"([^\"]*)\"'\n    \n    # Use re.findall to find all occurrences of the pattern in the string\n    # The parentheses in the pattern create a group, which allows findall to return only the matched group (i.e., the text within the quotes)\n    quoted_values = re.findall(pattern, s)\n    \n    return quoted_values", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    \"\"\"\n    Extracts all substrings enclosed within quotation marks from the input string.\n\n    Args:\n        input_string (str): The string to extract quoted values from.\n\n    Returns:\n        list[str]: A list of substrings that were enclosed in quotation marks.\n    \"\"\"\n    import re\n    # Regular expression pattern to match any characters (non-greedy) within double quotes\n    pattern = r'\"(.*?)\"'\n    # Find all matches of the pattern in the input string\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 4}]}, "Mbpp/732": {"dps": 41.22093023255814, "dps_norm": 80.0, "pass@1": 70.0, "profiled": [{"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with colons.\n\n    Args:\n        input_string (str): The input string to modify.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the characters to replace\n    chars_to_replace = [' ', ',', '.']\n    \n    # Initialize the output string with the input string\n    output_string = input_string\n    \n    # Iterate over each character to replace\n    for char in chars_to_replace:\n        # Replace all occurrences of the current character with a colon\n        output_string = output_string.replace(char, ':')\n    \n    return output_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with a colon (:).\n    \n    Parameters:\n    input_string (str): The input string to modify.\n    \n    Returns:\n    str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = ' .,'\n    \n    # Use a translation table to replace multiple characters at once\n    translation_table = str.maketrans({char: ':' for char in chars_to_replace})\n    \n    # Apply the translation to the input string\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n        input_string (str): The input string to modify.\n    \n    Returns:\n        str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = ' .,'\n    \n    # Use the str.translate method for efficient replacement\n    # First, create a translation table\n    translation_table = str.maketrans(chars_to_replace, ':' * len(chars_to_replace))\n    \n    # Apply the translation table to the input string\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the input string with a colon (:).\n\n    Args:\n        input_string (str): The input string to process.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Use the str.translate method along with str.maketrans for efficient replacement\n    # First, create a translation table\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Apply the translation to the input string\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with a colon.\n    \n    Parameters:\n    input_string (str): The input string to modify.\n    \n    Returns:\n    str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to replace\n    chars_to_replace = ' .,'\n    \n    # Define the replacement character\n    replacement_char = ':'\n    \n    # Initialize the output string\n    output_string = input_string\n    \n    # Replace each character\n    for char in chars_to_replace:\n        output_string = output_string.replace(char, replacement_char)\n    \n    return output_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with colons.\n\n    Args:\n        input_string (str): The input string to process.\n\n    Returns:\n        str: The input string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = ' .,'\n    \n    # Use a translation table to replace characters\n    translation_table = str.maketrans({char: ':' for char in chars_to_replace})\n    \n    # Apply the translation to the input string\n    result_string = input_string.translate(translation_table)\n    \n    return result_string", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with a colon.\n    \n    Parameters:\n    input_string (str): The input string to modify.\n    \n    Returns:\n    str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = ' .,'\n    \n    # Initialize an empty string to store the result\n    result_string = ''\n    \n    # Iterate over each character in the input string\n    for char in input_string:\n        # Check if the character is in the list to be replaced\n        if char in chars_to_replace:\n            # If so, append a colon to the result string\n            result_string += ':'\n        else:\n            # Otherwise, append the original character\n            result_string += char\n    \n    # Return the modified string\n    return result_string", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all spaces, commas, and dots in a given string with colons.\n\n    Args:\n        input_string (str): The string in which to replace characters.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Use the translate method along with str.maketrans for efficient replacement\n    # First, create a translation table\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Apply the translation to the input string\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the input string with colons.\n\n    Args:\n        input_string (str): The input string to modify.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use the translate method for efficient character replacement\n    # First, create a translation table\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Apply the translation table to the input string\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a string with a colon.\n\n    Parameters:\n    - input_string (str): The input string to process.\n\n    Returns:\n    - str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define characters to be replaced\n    chars_to_replace = ' .,'\n    \n    # Use a list comprehension with if-else to replace characters\n    # For each character in the input string, keep it if not in chars_to_replace, else replace with a colon\n    modified_string = ''.join([char if char not in chars_to_replace else ':' for char in input_string])\n    \n    return modified_string", "matching_cluster_idx": 5}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with a colon.\n\n    Args:\n        input_string (str): The input string to modify.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = [' ', ',', '.']\n    \n    # Use a list comprehension with if-else to replace characters, then join the result\n    modified_string = ''.join([char if char not in chars_to_replace else ':' for char in input_string])\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        input_string (str): The input string to modify.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = ' .,'\n    \n    # Initialize an empty string to store the result\n    result_string = ''\n    \n    # Iterate over each character in the input string\n    for char in input_string:\n        # Check if the character needs to be replaced\n        if char in chars_to_replace:\n            # If it does, append a colon to the result string\n            result_string += ':'\n        else:\n            # If not, append the original character\n            result_string += char\n    \n    # Return the modified string\n    return result_string", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a string with colons.\n\n    Args:\n        input_string (str): The input string to modify.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define characters to replace\n    chars_to_replace = [' ', ',', '.']\n    \n    # Initialize output string as the input string\n    output_string = input_string\n    \n    # Replace each character with a colon\n    for char in chars_to_replace:\n        output_string = output_string.replace(char, ':')\n    \n    return output_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with colons.\n\n    Args:\n        input_string (str): The string to modify.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define characters to replace\n    chars_to_replace = [' ', ',', '.']\n    \n    # Use a list comprehension to replace each character in the list with a colon\n    # Then, join the resulting list back into a string\n    modified_string = ''.join([':' if char in chars_to_replace else char for char in input_string])\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a string with colons.\n\n    Args:\n        input_string (str): The string to modify.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use the `replace()` method in combination with chaining for multiple replacements\n    # or utilize regular expressions for a more concise solution. Here, we'll demonstrate both:\n    \n    # **Method 1: Chaining `replace()` (Readable and Straightforward)**\n    # modified_string = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    \n    # **Method 2: Using Regular Expressions (Concise, Powerful)**\n    import re\n    modified_string = re.sub('[ ,.]', ':', input_string)\n    \n    return modified_string", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the input string with colons.\n    \n    :param input_string: The input string to modify.\n    :return: The modified string.\n    \"\"\"\n    # Use the translate method for efficient replacement\n    # First, create a translation table\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Apply the translation to the input string\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with a colon (:).\n\n    Args:\n        input_string (str): The input string to modify.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = ' .,'\n    \n    # Use a translation table to replace specified characters with a colon\n    translation_table = str.maketrans({char: ':' for char in chars_to_replace})\n    \n    # Apply the translation to the input string and return the result\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon in a given string.\n\n    Args:\n        input_string (str): The input string to be processed.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Use the translate method for efficient replacement\n    # First, create a translation table\n    translation_table = str.maketrans({' ': ':', ',': ':', '.': ':'})\n    \n    # Apply the translation table to the input string\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with a colon.\n    \n    Parameters:\n    input_string (str): The string to modify.\n    \n    Returns:\n    str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = ' .,'\n    \n    # Use a list comprehension with a conditional to replace characters\n    # The `in` operator checks if a character is in the `chars_to_replace` string\n    # If it is, it's replaced with a colon; otherwise, the original character is kept\n    modified_string = ''.join([char if char not in chars_to_replace else ':' for char in input_string])\n    \n    return modified_string", "matching_cluster_idx": 5}, {"solution": "def replace_specialchar(input_string):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in a given string with a colon.\n\n    Args:\n    - input_string (str): The string in which to replace special characters.\n\n    Returns:\n    - str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = ' .,'\n    # Use a list comprehension with a conditional to replace characters\n    # The `str.translate()` method is more efficient for multiple replacements\n    # However, for clarity and simplicity in explaining, we'll use `str.replace()` in a loop here\n    for char in chars_to_replace:\n        input_string = input_string.replace(char, ':')\n    return input_string", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 83.47272727272727, "dps_norm": 72.22222222222223, "pass@1": 75.0, "profiled": [{"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary where each key is an element at an odd index (0-based),\n    and its corresponding value is the element at the following even index.\n\n    Args:\n        input_tuple (tuple): The input tuple to be converted. It must have an even number of elements.\n\n    Returns:\n        dict: A dictionary with key-value pairs from the input tuple's adjacent elements.\n\n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary where each key-value pair is created from adjacent elements.\n    \n    :param input_tuple: Input tuple with an even number of elements.\n    :return: Dictionary where each key is followed by its corresponding value in the input tuple.\n    :raises ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n\n    # Use dictionary comprehension with slicing to create key-value pairs from adjacent elements\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary where keys and values are taken as adjacent elements.\n\n    Args:\n        input_tuple (tuple): Input tuple with an even number of elements.\n\n    Returns:\n        dict: Dictionary where keys are the first of each pair, and values are the second in the input tuple.\n\n    Raises:\n        ValueError: If the input tuple does not have an even number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple (tuple): Input tuple with an even number of elements.\n\n    Returns:\n        dict: Dictionary where each key-value pair is created from adjacent elements.\n    \"\"\"\n    # Initialize an empty dictionary to store key-value pairs\n    result_dict = {}\n\n    # Check if the tuple has at least two elements\n    if len(input_tuple) >= 2:\n        # Iterate over the tuple's indices in steps of 2\n        for i in range(0, len(input_tuple), 2):\n            # Ensure we don't exceed the tuple's bounds for the value\n            if i + 1 < len(input_tuple):\n                # Assign the current element as key and the next as value in the dictionary\n                result_dict[input_tuple[i]] = input_tuple[i + 1]\n            else:\n                # If the tuple has an odd number of elements, ignore the last one with a warning\n                print(f\"Warning: Ignoring last element {input_tuple[i]} in the tuple since it doesn't have a pair.\")\n\n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n        input_tuple (tuple): Input tuple with an even number of elements.\n        \n    Returns:\n        dict: Dictionary where each key-value pair is created from adjacent elements in the input tuple.\n        \n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n    \n    # Use dictionary comprehension with slicing to create key-value pairs from adjacent elements\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple (tuple): Input tuple with alternately positioned keys and values.\n\n    Returns:\n        dict: Dictionary with keys and values from the input tuple.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n\n    # Initialize an empty dictionary\n    result_dict = {}\n\n    # Iterate over the input tuple in steps of 2\n    for i in range(0, len(input_tuple), 2):\n        # Use the current element as the key and the next one as the value\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a given tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n        input_tuple (tuple): Input tuple with an even number of elements.\n        \n    Returns:\n        dict: Dictionary where odd-indexed elements (0-based indexing) are keys and \n              the following even-indexed elements are their corresponding values.\n              \n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n    \n    return dict(zip(input_tuple[::2], input_tuple[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple (tuple): The input tuple to be converted.\n\n    Returns:\n        dict: A dictionary where keys and values are adjacent elements from the input tuple.\n\n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n\n    # Use dictionary comprehension with slicing to create the dictionary\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary where keys and values are adjacent elements from the tuple.\n    \n    Args:\n    - input_tuple (tuple): Input tuple with an even number of elements.\n    \n    Returns:\n    - dict: Dictionary where each key-value pair is made from adjacent elements in the input tuple.\n    \n    Raises:\n    - ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n    \n    # Use dictionary comprehension with a step of 2 to iterate over the tuple\n    # For each pair of adjacent elements, the first becomes the key, and the second becomes the value\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a given tuple into a key-value dictionary using adjacent elements.\n    \n    The function assumes that the input tuple has an even number of elements.\n    If the tuple has an odd number of elements, the last element is ignored.\n    \n    Parameters:\n    input_tuple (tuple): The input tuple to be converted.\n    \n    Returns:\n    dict: A dictionary where keys and values are formed from adjacent elements of the input tuple.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        print(\"Warning: Input tuple has an odd number of elements. The last element will be ignored.\")\n        input_tuple = input_tuple[:-1]  # Remove the last element if the count is odd\n    \n    # Initialize an empty dictionary\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 (considering adjacent elements as key-value pairs)\n    for i in range(0, len(input_tuple), 2):\n        # Assign the current element as the key and the next one as the value\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a given tuple into a dictionary where each key-value pair is created from adjacent elements.\n    \n    Parameters:\n    - input_tuple (tuple): The input tuple to be converted. It is expected to have an even number of elements.\n    \n    Returns:\n    - dict: A dictionary where each key is an element from the tuple, paired with the following element as its value.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    # Use dictionary comprehension to create key-value pairs from adjacent elements\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a given tuple into a dictionary where keys and values are adjacent elements.\n    \n    :param input_tuple: Input tuple with an even number of elements.\n    :return: Dictionary where odd-positioned elements (0-indexed) are keys and even-positioned elements are values.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    # Initialize an empty dictionary\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2\n    for i in range(0, len(input_tuple), 2):\n        # Use the current element as the key and the next one as the value\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary where keys and values are adjacent elements.\n\n    Args:\n    - input_tuple (tuple): Input tuple with an even number of elements.\n\n    Returns:\n    - dict: Dictionary with key-value pairs from the input tuple.\n\n    Raises:\n    - ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n\n    # Use dictionary comprehension with step of 2 to pair adjacent elements\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple (tuple): The input tuple to be converted. It must have an even number of elements.\n\n    Returns:\n        dict: A dictionary where keys and values are taken from adjacent elements in the input tuple.\n\n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n\n    # Initialize an empty dictionary\n    result_dict = {}\n\n    # Iterate over the tuple in steps of 2\n    for i in range(0, len(input_tuple), 2):\n        # Use the current element as the key and the next one as the value\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Convert a given tuple into a dictionary where keys and values are \n    created from adjacent elements in the tuple.\n\n    Args:\n        input_tuple (tuple): A tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary where each key-value pair is made from adjacent \n              elements in the input tuple.\n\n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n\n    return dict(zip(input_tuple[::2], input_tuple[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n    \n    Parameters:\n    - `input_tuple` (tuple): Input tuple to be converted. It must have an even number of elements.\n    \n    Returns:\n    - `dict`: Dictionary with key-value pairs formed from adjacent elements in the input tuple.\n    \n    Raises:\n    - `ValueError`: If the input tuple has an odd number of elements.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    # Use dictionary comprehension with slicing to create key-value pairs\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Convert a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple (tuple): The input tuple to be converted.\n\n    Returns:\n        dict: A dictionary where each key is an element at an even index in the input tuple,\n              and its value is the element at the next (odd) index.\n\n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n\n    # Use dictionary comprehension to generate the key-value pairs\n    # zip(*[iter(input_tuple)]*2) pairs up the elements of the tuple\n    return dict(zip(*[iter(input_tuple)]*2))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n    - `input_tuple`: A tuple with an even number of elements.\n    \n    Returns:\n    - A dictionary where every odd-indexed element in the tuple serves as a key for the following even-indexed element.\n    \n    Raises:\n    - `ValueError` if the input tuple does not have an even number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n    \n    # Utilize dictionary comprehension with a step of 2 to iterate over the tuple,\n    # using the current element as the key and the next one as the value.\n    return {input_tuple[i]: input_tuple[i+1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Convert a tuple into a key-value dictionary using adjacent elements.\n    \n    :param input_tuple: Tuple with an even number of elements.\n    :return: Dictionary with tuple elements as keys and their adjacent elements as values.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        print(\"Warning: Input tuple has an odd number of elements. Ignoring the last element.\")\n    \n    # Initialize an empty dictionary\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 (considering key-value pairs)\n    for i in range(0, len(input_tuple) - len(input_tuple) % 2, 2):\n        # Assign the current element as the key and the next one as the value\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple to a dictionary, pairing adjacent elements as key-value pairs.\n    \n    :param t: Input tuple\n    :return: Dictionary with even-indexed elements as keys and odd-indexed elements as values\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements for pairing.\")\n    \n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}]}, "Mbpp/744": {"dps": 45.99315068493151, "dps_norm": 60.833333333333336, "pass@1": 72.0, "profiled": [{"solution": "def check_none(input_tuple):\n    \"\"\"\n    Returns True if the input tuple contains at least one None value, False otherwise.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: Presence of None in the tuple.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if a given tuple contains any None values.\n    \n    Args:\n        tup (tuple): Input tuple to check.\n    \n    Returns:\n        bool: True if the tuple contains None, False otherwise.\n    \"\"\"\n    return any(val is None for val in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None value.\n\n    Args:\n    input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if any element in the input tuple is None.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(val is None for val in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a given tuple contains any None value.\n    \n    Args:\n        input_tuple (tuple): The tuple to check for None values.\n    \n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The input tuple to check.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(val is None for val in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if a given tuple contains any None value.\n    \n    Args:\n        tup (tuple): The input tuple to inspect.\n    \n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(val is None for val in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks for the presence of None in a tuple.\n    \n    Args:\n        tup (tuple): The input tuple to check.\n    \n    Returns:\n        bool: True if None is found, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if the given tuple has any None value.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if any element in the given tuple is None.\n\n    Args:\n        input_tuple (tuple): The tuple to be inspected for None values.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if a tuple contains any None value.\n    \n    Args:\n        tup (tuple): The input tuple to check.\n    \n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(val is None for val in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(val is None for val in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Returns True if the tuple contains at least one None value, False otherwise.\n\n    :param input_tuple: The input tuple to be checked.\n    :return: Boolean indicating the presence of None.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(val is None for val in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if a tuple contains any None values.\n    \n    Args:\n        tup (tuple): The input tuple to check.\n    \n    Returns:\n        bool: True if the tuple contains at least one None, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if any element in the given tuple is None.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}]}, "Mbpp/750": {"dps": 66.12244897959184, "dps_norm": 75.0, "pass@1": 78.0, "profiled": [{"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends elements of the input tuple to the input list.\n    \n    Args:\n        input_list (list): The list to which elements are to be added.\n        input_tuple (tuple): The tuple whose elements are to be added.\n    \n    Returns:\n        list: The modified list with tuple elements appended.\n    \"\"\"\n    # Ensure inputs are of correct type\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input 'input_list' must be a list.\")\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input 'input_tuple' must be a tuple.\")\n    \n    # Use list extend method to add tuple elements\n    input_list.extend(input_tuple)\n    \n    # Return the modified list\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends all elements of the input tuple to the input list.\n\n    Args:\n        input_list (list): The original list to which elements will be added.\n        input_tuple (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n        list: The modified list with tuple elements appended.\n    \"\"\"\n    # Convert the input tuple to a list to utilize list extension method\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the input list with the list converted from the tuple\n    input_list.extend(list_from_tuple)\n    \n    # Return the modified list\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends elements of the input tuple to the input list.\n    \n    Args:\n        input_list (list): The list to which elements will be appended.\n        input_tuple (tuple): The tuple from which elements will be taken.\n    \n    Returns:\n        list: The modified list with tuple elements appended.\n    \"\"\"\n    # Convert the tuple to a list (since tuples are immutable in Python)\n    # and then extend the input list with these elements\n    input_list.extend(list(input_tuple))\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(input_list, tuple_to_add):\n    \"\"\"\n    Appends elements of a tuple to the end of a list.\n\n    Args:\n        input_list (list): The original list to which elements will be added.\n        tuple_to_add (tuple): The tuple whose elements will be appended to the list.\n\n    Returns:\n        list: The modified list with tuple elements appended.\n    \"\"\"\n    # Convert the tuple to a list to utilize list extend method\n    list_from_tuple = list(tuple_to_add)\n    \n    # Use list extend to add all elements from the tuple list to the input list\n    input_list.extend(list_from_tuple)\n    \n    # Return the modified input list\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends elements of a tuple to a list.\n\n    Args:\n        input_list (list): The original list to which elements will be added.\n        input_tuple (tuple): The tuple whose elements will be appended to the list.\n\n    Returns:\n        list: The modified list with tuple elements appended.\n    \"\"\"\n    # Create a copy of the original list to avoid in-place modification\n    modified_list = input_list.copy()\n    \n    # Use list extend method to add all elements from the tuple to the list\n    modified_list.extend(input_tuple)\n    \n    # Return the modified list\n    return modified_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends the elements of the input tuple to the input list.\n    \n    Args:\n        input_list (list): The list to which elements will be added.\n        input_tuple (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n        list: The modified list with the tuple elements appended.\n    \"\"\"\n    # Convert the input tuple to a list to allow extension\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the input list with the list converted from the tuple\n    input_list.extend(list_from_tuple)\n    \n    # Return the modified list\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(input_list, tuple_to_add):\n    \"\"\"\n    Appends elements of a tuple to a list.\n    \n    Args:\n        input_list (list): The original list.\n        tuple_to_add (tuple): The tuple to be added to the list.\n    \n    Returns:\n        list: The list with the tuple's elements appended.\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it in-place\n    modified_list = input_list.copy()\n    # Extend the list with the elements from the tuple\n    modified_list.extend(tuple_to_add)\n    # Return the modified list\n    return modified_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends elements of a tuple to a list.\n    \n    Args:\n    - input_list (list): The original list to which elements will be added.\n    - input_tuple (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    - list: The updated list with tuple elements appended.\n    \"\"\"\n    # Ensure inputs are of correct type\n    if not isinstance(input_list, list) or not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a list and a tuple respectively.\")\n    \n    # Use list extension to add tuple elements to the list\n    input_list.extend(input_tuple)\n    \n    # Return the updated list\n    return input_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the given tuple to the given list.\n    \n    Args:\n        input_list (list): The list to which elements will be added.\n        input_tuple (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n        list: The modified list with tuple elements appended.\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it directly\n    modified_list = input_list.copy()\n    \n    # Use extend method to add all elements from the tuple to the list copy\n    modified_list.extend(input_tuple)\n    \n    # Return the modified list\n    return modified_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds all elements of the given tuple to the end of the given list.\n    \n    Args:\n        input_list (list): The original list to which elements will be added.\n        input_tuple (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n        list: The modified list with the tuple's elements appended.\n    \"\"\"\n    # Ensure inputs are of the correct type\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input 'input_list' must be a list.\")\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input 'input_tuple' must be a tuple.\")\n    \n    # Use list.extend() to add all tuple elements to the list\n    # The * operator unpacks the tuple into positional arguments for extend()\n    # Alternatively, could use input_list += input_tuple for a more concise approach\n    input_list.extend(input_tuple)\n    \n    # Return the modified list\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds all elements from the given tuple to the end of the given list.\n    \n    Args:\n    - input_list (list): The original list to which elements will be added.\n    - input_tuple (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    - list: The modified list with tuple elements appended.\n    \"\"\"\n    # Convert the input tuple to a list to utilize list extend method\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the original list with the new list created from the tuple\n    input_list.extend(list_from_tuple)\n    \n    # Return the modified list\n    return input_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends all elements of the input_tuple to the input_list.\n    \n    Args:\n    - input_list (list): The original list to which elements will be added.\n    - input_tuple (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    - list: The modified list with tuple elements appended.\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it directly\n    result_list = input_list.copy()\n    \n    # Use extend method to add all elements from the tuple to the list copy\n    result_list.extend(input_tuple)\n    \n    # Return the modified list\n    return result_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends all elements of the input tuple to the input list.\n    \n    Args:\n    - input_list (list): The list to which elements will be appended.\n    - input_tuple (tuple): The tuple whose elements will be appended to the list.\n    \n    Returns:\n    - list: The modified list with tuple elements appended.\n    \"\"\"\n    # Convert the tuple to a list to leverage extend functionality\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the input list with the elements from the tuple (now in list form)\n    input_list.extend(list_from_tuple)\n    \n    # Return the modified list\n    return input_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds the elements of the input tuple to the input list.\n\n    Args:\n    - input_list (list): The original list to which elements will be added.\n    - input_tuple (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    - list: The updated list with tuple elements appended.\n    \"\"\"\n    # Ensure inputs are of the correct type\n    if not isinstance(input_list, list) or not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input must be a list and a tuple, respectively.\")\n\n    # Use list extend method to add all elements from the tuple to the list\n    # Since lists are mutable, this operation modifies the original list\n    # To avoid side effects, we return a new list with the extended content\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends elements of a tuple to a list.\n\n    Args:\n        input_list (list): The list to which elements are to be added.\n        input_tuple (tuple): The tuple from which elements are to be taken.\n\n    Returns:\n        list: The modified list with tuple elements appended.\n    \"\"\"\n    # Ensure inputs are of the correct type\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input 'input_list' must be of type list.\")\n    if not isinstance(input_tuple, tuple):\n        raise TypeError(\"Input 'input_tuple' must be of type tuple.\")\n    \n    # Append tuple elements to the list\n    # Using list.extend() to add all elements from the tuple\n    input_list.extend(input_tuple)\n    \n    # Return the modified list\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends the elements of the input_tuple to the end of the input_list.\n    \n    Args:\n        input_list (list): The original list to be extended.\n        input_tuple (tuple): The tuple whose elements are to be added to the list.\n    \n    Returns:\n        list: The extended list containing all elements from the original list and the tuple.\n    \"\"\"\n    # Convert the input tuple to a list to utilize list extend method\n    tuple_as_list = list(input_tuple)\n    \n    # Extend the input list with the elements from the tuple (now in list form)\n    input_list.extend(tuple_as_list)\n    \n    # Return the extended list\n    return input_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends elements of a tuple to the end of a list.\n    \n    Args:\n        input_list (list): Original list to be extended.\n        input_tuple (tuple): Tuple whose elements are to be added.\n    \n    Returns:\n        list: The input list with the tuple's elements appended.\n    \"\"\"\n    # Use list.extend() to add all elements from the tuple to the list\n    input_list.extend(input_tuple)\n    # Return the updated list\n    return input_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements from a given tuple to a given list.\n    \n    Args:\n        lst (list): The original list.\n        tpl (tuple): The tuple to add to the list.\n    \n    Returns:\n        list: The updated list with tuple elements appended.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Args:\n        input_list (list): The original list.\n        input_tuple (tuple): The tuple to be added to the list.\n    \n    Returns:\n        list: The list with the tuple's elements appended.\n    \"\"\"\n    # Convert the tuple to a list to utilize list extension\n    list_from_tuple = list(input_tuple)\n    \n    # Extend the input list with the list created from the tuple\n    input_list.extend(list_from_tuple)\n    \n    # Return the updated list\n    return input_list", "matching_cluster_idx": 4}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"\n    Appends all elements from the input tuple to the end of the input list.\n    \n    Args:\n        input_list (list): The original list to which elements will be added.\n        input_tuple (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n        list: The modified list with tuple elements appended.\n    \"\"\"\n    # Convert the input tuple to a list to utilize list extension method\n    input_list.extend(list(input_tuple))\n    # Return the modified list\n    return input_list", "matching_cluster_idx": 3}]}, "Mbpp/753": {"dps": 92.51677852348993, "dps_norm": 73.75, "pass@1": 63.0, "profiled": [{"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the k minimum records from a list of tuples based on the integer value in each tuple.\n\n    :param records: List of tuples, where each tuple contains a string and an integer.\n    :type records: list[tuple[str, int]]\n    :param k: Number of minimum records to return.\n    :type k: int\n    :return: List of the k tuples with the smallest integer values.\n    :rtype: list[tuple[str, int]]\n    \"\"\"\n    # Check if k is not greater than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the integer value in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the k minimum records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the k tuples with the smallest second element from the input list.\n    \n    :param records: List of tuples (name, value)\n    :type records: list[tuple[str, int]]\n    :param k: Number of minimum records to return\n    :type k: int\n    :return: List of k tuples with the smallest values\n    :rtype: list[tuple[str, int]]\n    \"\"\"\n    # Check if k is not larger than the list length\n    k = min(k, len(records))\n    \n    # Sort the list of tuples based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Returns the k minimum records from a list of tuples based on the tuple's second element.\n\n    :param tuple_list: List of tuples where each tuple's second element is used for comparison.\n    :type tuple_list: list[tuple]\n    :param k: Number of minimum records to return.\n    :type k: int\n    :return: List of k tuples with the smallest second elements.\n    :rtype: list[tuple]\n    \"\"\"\n    # Check if k is not larger than the list length to avoid indexing errors\n    k = min(k, len(tuple_list))\n    \n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n        records (list): A list of tuples, where each tuple contains a string (name) and an integer (value).\n        k (int): The number of minimum records to return.\n\n    Returns:\n        list: A list of the k tuples with the smallest values (second element of the tuple).\n    \"\"\"\n    # First, sort the list of records in ascending order based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Then, return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples.\n\n    :param records: List of tuples (name, value) to search through.\n    :type records: list[tuple[str, int]]\n    :param k: Number of minimum records to find.\n    :type k: int\n    :return: k tuples with the smallest values, sorted by value in ascending order.\n    :rtype: list[tuple[str, int]]\n    \"\"\"\n    # Check if k is not larger than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the second element of each tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from a list of tuples.\n\n    :param records: List of tuples where the second element of each tuple is used for comparison.\n    :type records: list[tuple]\n    :param k: The number of minimum records to return.\n    :type k: int\n    :return: A list of the k tuples with the smallest second elements.\n    :rtype: list[tuple]\n    \"\"\"\n    # Check if k is not more than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from a list of tuples.\n\n    :param records: List of tuples (e.g., [('Name', Value), ...])\n    :type records: list[tuple]\n    :param k: Number of minimum records to return\n    :type k: int\n    :return: k tuples with the smallest values\n    :rtype: list[tuple]\n    \"\"\"\n    # Check if k is not greater than the number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the k tuples with the smallest values from the input list of records.\n\n    :param records: List of tuples containing a name and a value.\n    :type records: list[tuple[str, int]]\n    :param k: Number of records to return with the smallest values.\n    :type k: int\n    :return: k tuples with the smallest values.\n    :rtype: list[tuple[str, int]]\n    \"\"\"\n    # Check if k is not greater than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the value (second element of each tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the k smallest records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n        records (list): A list of tuples where the second element of each tuple is used for comparison.\n        k (int): The number of minimum records to return.\n\n    Returns:\n        list: A list of the k tuples with the smallest second elements.\n    \"\"\"\n    # Check if k is not greater than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the k minimum records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Returns the k minimum records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: A list of tuples where each tuple contains a string and a number.\n    :type tuple_list: list[tuple[str, int]]\n    :param k: The number of minimum records to return.\n    :type k: int\n    :return: A list of the k minimum tuples based on the second element of each tuple.\n    :rtype: list[tuple[str, int]]\n    \"\"\"\n    # Check if k is not larger than the list length to avoid indexing errors\n    k = min(k, len(tuple_list))\n    \n    # Sort the tuple list based on the second element of each tuple (the number)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list, which are the k minimum records\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Retrieves the k smallest records based on the integer value in each tuple.\n\n    Args:\n    - records (list): A list of tuples containing a name (str) and a number (int).\n    - k (int): The number of minimum records to return.\n\n    Returns:\n    - list: A list of the k tuples with the smallest integer values.\n    \"\"\"\n    # Check if k is not greater than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the integer value in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the k smallest records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(record_list, k):\n    \"\"\"\n    Returns the k tuples with the smallest integer values from the given list of records.\n    \n    :param record_list: List of tuples containing a name and an integer value.\n    :type record_list: list[tuple[str, int]]\n    :param k: Number of minimum records to find.\n    :type k: int\n    :return: List of the k tuples with the smallest integer values.\n    :rtype: list[tuple[str, int]]\n    \"\"\"\n    # Check if k is not larger than the list length to avoid indexing errors\n    k = min(k, len(record_list))\n    \n    # Sort the list of tuples based on the second element (integer value) of each tuple\n    sorted_records = sorted(record_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list, which are the minimum k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Retrieves the minimum k records from a list of tuples based on the tuple's integer value.\n\n    Args:\n        tuple_list (list): List of tuples containing string and integer pairs.\n        k (int): Number of minimum records to retrieve.\n\n    Returns:\n        list: A list of k tuples with the smallest integer values.\n    \"\"\"\n    # Check if k is not greater than the list length to avoid indexing errors\n    k = min(k, len(tuple_list))\n    \n    # Sort the tuple list based on the integer value in each tuple (second element, indexed by 1)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements of the sorted list, which are the minimum k records\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Returns the k minimum records from a list of tuples based on the second element of each tuple.\n\n    :param tuple_list: List of tuples where the second element of each tuple is used for comparison.\n    :type tuple_list: list[tuple]\n    :param k: Number of minimum records to return.\n    :type k: int\n    :return: List of k tuples with the smallest second elements.\n    :rtype: list[tuple]\n    \"\"\"\n    # Check if k is not larger than the list length to avoid indexing errors\n    k = min(k, len(tuple_list))\n    \n    # Sort the list based on the second element of each tuple (ascending order)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from a list of tuples.\n\n    :param records: List of tuples where the second element of each tuple is comparable (e.g., integers, floats)\n    :type records: list[tuple]\n    :param k: Number of minimum records to return\n    :type k: int\n    :return: k minimum records\n    :rtype: list[tuple]\n    \"\"\"\n    # Check if k is not more than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the second element of each tuple (ascending order)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Returns the minimum k records from a list of tuples.\n    \n    The tuples are ordered based on the second element of each tuple (assuming it's the value to compare).\n    \n    :param tuple_list: List of tuples (e.g., [('name', value), ...])\n    :param k: Number of minimum records to return\n    :return: List of k tuples with the smallest values\n    \"\"\"\n    # Check if k is not larger than the list length to avoid indexing errors\n    k = min(k, len(tuple_list))\n    \n    # Sort the tuple list based on the second element of each tuple (the value)\n    sorted_tuples = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the k smallest records from a list of tuples.\n    \n    The list of tuples is expected to contain string and integer values.\n    The function sorts the list based on the integer value in each tuple and returns the k smallest records.\n    \n    Parameters:\n    - records (list): A list of tuples containing a string and an integer.\n    - k (int): The number of minimum records to return.\n    \n    Returns:\n    - list: A list of the k smallest tuples based on the integer value.\n    \"\"\"\n    # Check if k is not greater than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the integer value in each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the k smallest records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the k minimum records from a list of tuples based on the second element of each tuple.\n\n    :param records: List of tuples, where each tuple contains a name (str) and a value (int)\n    :param k: Number of minimum records to return\n    :return: List of the k tuples with the smallest second elements\n    \"\"\"\n    # Check if k is not larger than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the second element of each tuple (in ascending order)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the k smallest records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the tuple's second element (value).\n\n    Args:\n        records (list[tuple[str, int]]): List of tuples containing name and value.\n        k (int): Number of minimum records to return.\n\n    Returns:\n        list[tuple[str, int]]: k tuples with the smallest values, sorted by value in ascending order.\n    \"\"\"\n    # Check if k is not greater than the total number of records\n    k = min(k, len(records))\n    \n    # Sort the records based on the value (second element of each tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the k smallest records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Returns the k tuples with the minimum values from a given list of tuples.\n    \n    :param tuple_list: List of tuples, each containing a string and an integer.\n    :type tuple_list: list[tuple[str, int]]\n    :param k: Number of minimum records to return.\n    :type k: int\n    :return: List of k tuples with the smallest integer values.\n    :rtype: list[tuple[str, int]]\n    \"\"\"\n    # Check if k is not greater than the list length to avoid indexing errors\n    k = min(k, len(tuple_list))\n    \n    # Sort the tuple list based on the integer value in each tuple (ascending order)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 85.63218390804599, "dps_norm": 86.11111111111111, "pass@1": 18.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds and returns common elements that appear at the same index in three input lists.\n    \n    Args:\n        l1 (list): The first list for comparison.\n        l2 (list): The second list for comparison.\n        l3 (list): The third list for comparison.\n    \n    Returns:\n        list: A list of elements common to all three input lists at the same index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over the indices up to the shortest list's length\n    # and check if the elements at the current index are the same across all three lists\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds and returns elements that are common across three lists at the same index.\n\n    Args:\n        l1 (list): The first list for comparison.\n        l2 (list): The second list for comparison.\n        l3 (list): The third list for comparison.\n\n    Returns:\n        list: A list of elements common to all three input lists at the same index.\n    \"\"\"\n    # Ensure all lists are of equal length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension with zip to find common elements at the same index\n    common_elements = [element for i, element in enumerate(zip(l1, l2, l3)) if i < min_len and len(set(element)) == 1]\n    \n    # Since zip returns tuples, extract the single (common) element from each tuple\n    common_elements = [tuple_element[0] for tuple_element in common_elements]\n    \n    return common_elements", "matching_cluster_idx": 3}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Returns a list of elements that appear at the same index in all three input lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n    \n    Returns:\n        list: A list of elements common to the same indices in l1, l2, and l3.\n    \"\"\"\n    # Ensure all lists are of the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension with zip to find common elements at the same index\n    common_elements = [element for i in range(min_len) if (element := l1[i]) == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds elements that are common across three lists at the same index.\n    \n    Parameters:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of elements that appear in the same index across all input lists.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index errors\n    max_len = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate over the range of the maximum length found\n    for i in range(max_len):\n        # Check if the element at the current index is the same across all lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they match, append the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extracts common elements from three lists based on their index.\n\n    Args:\n        l1 (list): First list for comparison\n        l2 (list): Second list for comparison\n        l3 (list): Third list for comparison\n\n    Returns:\n        list: A list of elements common to all three input lists at the same index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension with zip to iterate over the lists in parallel\n    # up to the length of the shortest list, and include elements where all\n    # values at the current index are equal.\n    common_elements = [x for x, y, z in zip(l1, l2, l3) if x == y == z]\n    \n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extracts elements that are common across three lists at the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of elements common to all three lists at the same index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over the indices and check for common elements\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of elements common to l1, l2, and l3 at the same index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index out of range errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over the indices up to the shortest list's length\n    # and check if the elements at the current index are the same across all lists\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds common elements from three lists at the same index.\n    \n    Parameters:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of elements that appear in all three input lists under the same index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over the indices up to the shortest list's length\n    # and check if elements at the same index are equal across all three lists\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Returns a list of elements that appear at the same index in all input lists.\n\n    :param l1: First input list.\n    :param l2: Second input list.\n    :param l3: Third input list.\n    :return: List of common elements by index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over the indices up to the shortest list's length\n    # Check if the element at the current index is the same across all lists\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Returns a list of elements that appear at the same index in all three input lists.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of elements common to the same index in all input lists.\n    \"\"\"\n    # Ensure all lists are of the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over indices and check for matching elements\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extracts elements that appear at the same index in all three input lists.\n    \n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n    \n    Returns:\n        list: A list of elements common to all input lists by index.\n    \"\"\"\n    # Ensure all lists are of the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over indices up to the shortest list's length\n    # Check if elements at the same index in all lists are identical\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extracts elements that are common to all three lists at the same index.\n    \n    Args:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of elements that appear at the same index in all three input lists.\n    \"\"\"\n    # Ensure all lists are of the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over the indices up to the shortest list's length\n    # and check if the elements at each index are equal across all three lists\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds elements that are common across three lists at the same index.\n\n    Args:\n        l1 (list): The first list for comparison.\n        l2 (list): The second list for comparison.\n        l3 (list): The third list for comparison.\n\n    Returns:\n        list: A list of elements common across all input lists at the same index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate over the range of the minimum list length\n    for i in range(min_len):\n        # Check if the element at the current index is the same across all lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they match, append to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds elements that are common across three lists at the same index.\n    \n    Parameters:\n    l1 (list): The first list.\n    l2 (list): The second list.\n    l3 (list): The third list.\n    \n    Returns:\n    list: A list of elements common to all input lists at the same index.\n    \"\"\"\n    # Ensure all lists are of the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over the indices up to the shortest list's length\n    # Check if the elements at the current index are the same across all lists\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements at the same index across three lists.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of elements common to all three input lists at the same index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to iterate over the indices up to the minimum length\n    # and check if elements at the same index are equal across all lists\n    common_elements = [l1[i] for i in range(min_len) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds and returns elements that are common across three lists at the same index.\n\n    Parameters:\n    - `l1` (list): The first list for comparison.\n    - `l2` (list): The second list for comparison.\n    - `l3` (list): The third list for comparison.\n\n    Returns:\n    - `list`: A list of elements common to all input lists at the same index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index out of range errors\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate over the range of the shortest list length\n    for i in range(min_len):\n        # Check if the element at the current index is the same across all lists\n        if l1[i] == l2[i] == l3[i]:\n            # If elements match, add to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Parameters:\n    - `l1` (list): The first list for comparison.\n    - `l2` (list): The second list for comparison.\n    - `l3` (list): The third list for comparison.\n    \n    Returns:\n    - `list`: A list of elements common to all input lists at the same index.\n    \"\"\"\n    # Ensure all lists have the same length to avoid index errors\n    max_len = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate over the indices up to the length of the shortest list\n    for i in range(max_len):\n        # Check if the element at the current index is the same in all lists\n        if l1[i] == l2[i] == l3[i]:\n            # If the same, append to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds and returns common elements that appear at the same index in three input lists.\n    \n    Parameters:\n    l1 (list): The first list for comparison.\n    l2 (list): The second list for comparison.\n    l3 (list): The third list for comparison.\n    \n    Returns:\n    list: A list of elements common to all three input lists at the same index.\n    \"\"\"\n    # Ensure all lists are of the same length to avoid index errors\n    max_len = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate over the range of the maximum length\n    for i in range(max_len):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they match, append the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 84.82300884955752, "dps_norm": 92.5, "pass@1": 30.0, "profiled": [{"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list of numbers.\n\n    :param numbers: A list of numbers\n    :return: The second smallest number, or None if list has less than 2 unique numbers\n    \"\"\"\n    # Remove duplicates by converting to set, then sort the set\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if there are at least two unique numbers\n    if len(unique_numbers) < 2:\n        return None  # or raise an exception, depending on your preference\n    \n    # The second element in the sorted list of unique numbers is the second smallest\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Returns the second smallest number in a list.\n\n    If the list contains less than two distinct numbers, returns None.\n\n    :param numbers: A list of numbers.\n    :return: The second smallest number or None.\n    \"\"\"\n    if len(set(numbers)) < 2:\n        # If there are less than two unique numbers, return None\n        return None\n\n    # Remove duplicates by converting to a set and sort the numbers\n    unique_numbers = sorted(set(numbers))\n\n    # The second smallest number is the second element in the sorted list\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a list.\n    \n    If the list has less than two unique elements, returns None.\n    \n    :param numbers: A list of numbers\n    :return: The second smallest number or None if not found\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Check if there are at least two unique elements\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers and return the second element (index 1)\n    return sorted(unique_numbers)[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    This function finds the second smallest number in a list.\n    \n    Parameters:\n    - numbers (list): A list of numbers.\n    \n    Returns:\n    - The second smallest number in the list. If no second smallest exists (e.g., all elements are the same or the list has less than two unique elements), it returns None.\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_nums = set(numbers)\n    \n    # Check if the list has less than two unique elements\n    if len(unique_nums) < 2:\n        return None\n    \n    # Sort the unique numbers in ascending order\n    sorted_nums = sorted(unique_nums)\n    \n    # The second smallest number is the second element in the sorted list (index 1)\n    return sorted_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n    \n    Args:\n        numbers (list): A list of integers.\n    \n    Returns:\n        int or None: The second smallest number if exists, otherwise None.\n    \"\"\"\n    # Check if the list has less than two unique numbers\n    unique_numbers = set(numbers)\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Remove the smallest number and return the smallest of the remaining set\n    smallest = min(unique_numbers)\n    unique_numbers.remove(smallest)\n    return min(unique_numbers)", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest distinct number in a list.\n\n    Args:\n    - numbers (list): A list of numbers.\n\n    Returns:\n    - The second smallest distinct number, or None if it doesn't exist.\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Check if there are less than two unique numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers and return the second one\n    return sorted(unique_numbers)[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest unique number in a list.\n    \n    :param numbers: A list of integers\n    :return: The second smallest unique integer, or None if no second smallest exists\n    \"\"\"\n    # Remove duplicates by converting to set\n    unique_numbers = set(numbers)\n    \n    # Check if there are less than 2 unique numbers\n    if len(unique_numbers) < 2:\n        return None  # No second smallest\n    \n    # Sort the unique numbers\n    sorted_unique_numbers = sorted(unique_numbers)\n    \n    # The second smallest is the second element in the sorted list\n    return sorted_unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n    - numbers (list): A list of numbers.\n\n    Returns:\n    - The second smallest number if found, otherwise None.\n    \"\"\"\n    # Check if the list has less than two unique elements\n    if len(set(numbers)) < 2:\n        return None  # or raise ValueError(\"List must have at least two unique elements\")\n\n    # Remove duplicates by converting to set and sort the numbers\n    sorted_unique_numbers = sorted(set(numbers))\n\n    # The second smallest number is the second element in the sorted list\n    return sorted_unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    This function finds the second smallest number in a given list.\n    \n    Parameters:\n    - numbers (list): A list of numbers.\n    \n    Returns:\n    - The second smallest number in the list, or None if the list has less than two unique numbers.\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Check if the list has less than two unique numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers in ascending order\n    sorted_unique_numbers = sorted(unique_numbers)\n    \n    # The second smallest number is the one at index 1 in the sorted list\n    return sorted_unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n    \n    Args:\n        numbers (list): A list of numbers.\n    \n    Returns:\n        The second smallest number if exists, otherwise None.\n    \"\"\"\n    if len(numbers) < 2:\n        return None  # Not enough elements to find a second smallest\n    \n    # Remove duplicates by converting to set, then sort the set\n    unique_numbers = sorted(set(numbers))\n    \n    # If all numbers were the same (after set conversion the length is 1), \n    # there's no second smallest\n    if len(unique_numbers) < 2:\n        return None\n    \n    # The second element in the sorted list of unique numbers is the second smallest\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n    \n    Args:\n        numbers (list): A list of numbers.\n    \n    Returns:\n        The second smallest number if exists, otherwise None.\n    \"\"\"\n    if len(numbers) < 2:\n        return None  # Not enough elements to find a second smallest\n    \n    # Remove duplicates and sort the list in ascending order\n    unique_sorted_numbers = sorted(set(numbers))\n    \n    # Check if there's a second element after removing duplicates\n    if len(unique_sorted_numbers) > 1:\n        return unique_sorted_numbers[1]  # Return the second smallest\n    else:\n        return None  # Only one unique element or less, no second smallest", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Returns the second smallest unique number in a list.\n\n    :param numbers: A list of integers\n    :return: The second smallest unique integer, or None if no second smallest exists\n    \"\"\"\n    # Remove duplicates by converting to set, then sort the unique numbers\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if there are at least two unique numbers\n    if len(unique_numbers) < 2:\n        return None  # Return None if no second smallest exists\n    \n    # The second smallest number will be the second element in the sorted list (index 1)\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list of numbers.\n    \n    If there is no second smallest (i.e., all numbers are the same), \n    or if the list has less than two unique numbers, returns None.\n    \n    :param numbers: A list of integers\n    :return: The second smallest number, or None if not applicable\n    \"\"\"\n    # Remove duplicates by converting to set, then sort the set\n    unique_sorted_numbers = sorted(set(numbers))\n    \n    # Check if there are at least two unique numbers\n    if len(unique_sorted_numbers) < 2:\n        return None\n    \n    # The second smallest is the second element in the sorted list\n    return unique_sorted_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Find the second smallest number in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        The second smallest number if it exists, otherwise `None`.\n    \"\"\"\n    # Remove duplicates by converting to set\n    unique_nums = set(numbers)\n    \n    # Check if there are at least two distinct numbers\n    if len(unique_nums) < 2:\n        return None\n    \n    # Sort the unique numbers and return the second one\n    return sorted(unique_nums)[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n    \n    If the list has less than two distinct numbers, \n    it returns None (since there's no second smallest).\n    \n    Parameters:\n    - numbers (list): A list of numbers.\n    \n    Returns:\n    - The second smallest number in the list, or None if it doesn't exist.\n    \"\"\"\n    # Remove duplicates by converting to set and then sort the numbers\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if there are at least two unique numbers\n    if len(unique_numbers) < 2:\n        return None  # Return None if less than two unique numbers exist\n    \n    # The second smallest number is the second element in the sorted list\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        The second smallest number if it exists, otherwise None.\n    \"\"\"\n    if len(numbers) < 2:\n        # If the list has less than 2 elements, there's no second smallest.\n        return None\n\n    # Remove duplicates by converting to set, but preserve order seen\n    unique_nums = dict.fromkeys(numbers)\n    \n    # If all numbers are the same (hence only one unique number), \n    # there's no second smallest.\n    if len(unique_nums) < 2:\n        return None\n\n    # Sort the unique numbers and return the second one\n    sorted_unique_nums = sorted(unique_nums)\n    return sorted_unique_nums[1]", "matching_cluster_idx": 2}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n    \n    Args:\n    - numbers (list): A list of numbers.\n    \n    Returns:\n    - The second smallest number if it exists, otherwise None.\n    \"\"\"\n    # Remove duplicates by converting to set, then sort the set\n    unique_nums = sorted(set(numbers))\n    \n    # Check if there are at least two distinct numbers\n    if len(unique_nums) < 2:\n        return None  # Return None if less than two distinct numbers\n    \n    # The second smallest number is the second element in the sorted list of unique numbers\n    return unique_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list, considering duplicates.\n\n    Args:\n    - numbers (list): A list of numbers.\n\n    Returns:\n    - The second smallest number if found, otherwise None.\n    \"\"\"\n    if len(numbers) < 2:\n        return None  # List must have at least two elements\n    \n    # Remove duplicates by converting to set\n    unique_numbers = set(numbers)\n    \n    # Check if all numbers are the same (after removing duplicates)\n    if len(unique_numbers) < 2:\n        return None  # Not enough unique numbers\n    \n    # Sort the unique numbers and return the second one\n    return sorted(unique_numbers)[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n    \n    Args:\n    - numbers (list): A list of numbers.\n    \n    Returns:\n    - The second smallest number in the list, or None if the list has less than two unique elements.\n    \n    Raises:\n    - ValueError: If the input is not a list or if the list contains non-numeric values.\n    \"\"\"\n    # Validate input\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list\")\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"List must only contain numbers\")\n    \n    # Remove duplicates by converting to set\n    unique_numbers = set(numbers)\n    \n    # Handle edge cases\n    if len(unique_numbers) < 2:\n        return None  # Not enough unique elements to find a second smallest\n    \n    # Sort the unique numbers and return the second one\n    return sorted(unique_numbers)[1]", "matching_cluster_idx": 2}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest distinct number in a list.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        The second smallest distinct number, or `None` if not found.\n    \"\"\"\n    # Remove duplicates by converting to set, then sort the unique numbers\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if there are at least two unique numbers\n    if len(unique_numbers) < 2:\n        return None  # Not enough unique numbers to find a second smallest\n    \n    # The second smallest number is the second element in the sorted list of unique numbers\n    return unique_numbers[1]", "matching_cluster_idx": 5}]}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/758": {"dps": 77.51930501930501, "dps_norm": 80.0, "pass@1": 53.0, "profiled": [{"solution": "from typing import List, Dict, Tuple\ndef unique_sublists(list_of_lists: List[List[int]]) -> Dict[Tuple, int]:\n    \"\"\"\n    Counts unique sublists in a list of lists and returns a dictionary \n    with tuples of sublists as keys and their occurrence counts as values.\n\n    :param list_of_lists: A list containing lists of integers\n    :return: A dictionary with tuples of sublists as keys and their counts as values\n    \"\"\"\n    # Convert sublists to tuples for hashability and use a dictionary to count occurrences\n    occurrence_dict = {}\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple to make it hashable for dictionary keys\n        tuple_sublist = tuple(sublist)\n        # Increment the count if the tuple is already a key, otherwise set count to 1\n        occurrence_dict[tuple_sublist] = occurrence_dict.get(tuple_sublist, 0) + 1\n    \n    return occurrence_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(main_list):\n    \"\"\"\n    Counts unique sublists in a given list and returns their occurrences as a dictionary.\n    \n    :param main_list: List of lists to be processed.\n    :return: Dictionary with tuples of unique sublists as keys and their counts as values.\n    \"\"\"\n    # Initialize an empty dictionary to store the counts of unique sublists\n    sublist_counts = {}\n    \n    # Iterate over each sublist in the main list\n    for sublist in main_list:\n        # Convert the sublist to a tuple to make it hashable for dictionary keys\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in sublist_counts:\n            sublist_counts[sublist_tuple] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            sublist_counts[sublist_tuple] = 1\n    \n    # Return the dictionary with the counts of unique sublists\n    return sublist_counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts occurrences of sublists within a list, converting them to tuples for dictionary keys.\n    \n    Args:\n        lst (list): The list containing sublists to be counted.\n    \n    Returns:\n        dict: A dictionary where keys are tuples (representing original sublists) and values are their occurrence counts.\n    \"\"\"\n    # Initialize an empty dictionary to store tuple-count pairs\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (to make it hashable for dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already a key in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    # Return the dictionary containing the counts of all unique sublists\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(nested_list):\n    \"\"\"\n    Counts occurrences of unique sublists in a given list.\n    \n    Args:\n    - nested_list (list): A list containing sublists.\n    \n    Returns:\n    - dict: A dictionary where each key is a unique sublist converted to a tuple, \n            and its corresponding value is the frequency of the sublist in the original list.\n    \"\"\"\n    # Initialize a dictionary to store tuple frequencies, utilizing defaultdict for ease\n    freq_dict = defaultdict(int)\n    \n    # Iterate over each sublist in the nested list\n    for sublist in nested_list:\n        # Convert the sublist to a tuple (since lists are not hashable and thus cannot be dict keys)\n        tuple_sublist = tuple(sublist)\n        \n        # Increment the frequency count for the current tuple (sublist) in the dictionary\n        freq_dict[tuple_sublist] += 1\n    \n    # Convert the defaultdict back to a regular dictionary for return (optional but clearer for API)\n    return dict(freq_dict)", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(nested_list):\n    \"\"\"\n    Counts occurrences of sublists (as tuples) in a given nested list.\n\n    :param nested_list: A list containing sublists.\n    :return: Dictionary where keys are tuples (sublists converted to tuples for hashability) \n             and values are their respective occurrence counts.\n    \"\"\"\n    # Convert sublists to tuples for dictionary key creation (lists are not hashable)\n    tuple_list = [tuple(sublist) for sublist in nested_list]\n    \n    # Use dictionary comprehension with tuple_list to count occurrences\n    occurrence_dict = {t: tuple_list.count(t) for t in set(tuple_list)}\n    \n    return occurrence_dict", "matching_cluster_idx": 3}, {"solution": "def unique_sublists(sublist_container):\n    \"\"\"\n    Converts sublists to tuples (since lists are not hashable) and counts their occurrences.\n    \n    Args:\n        sublist_container (list): A list containing sublists.\n        \n    Returns:\n        dict: A dictionary where keys are unique sublists (converted to tuples) and values are their occurrence counts.\n    \"\"\"\n    # Initialize an empty dictionary to store tuple-count pairs\n    occurrence_dict = {}\n    \n    # Iterate over each sublist in the container\n    for sublist in sublist_container:\n        # Convert the sublist to a tuple for hashing\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in occurrence_dict:\n            occurrence_dict[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            occurrence_dict[tuple_sublist] = 1\n    \n    return occurrence_dict", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts occurrences of sublists within a list, returning a dictionary where each\n    unique sublist (converted to a tuple for hashability) is a key, and its value\n    is the number of occurrences in the original list.\n\n    Args:\n        lst (list): The list containing sublists to count.\n\n    Returns:\n        dict: A dictionary with tuples of sublists as keys and their occurrences as values.\n    \"\"\"\n    # Initialize a dictionary to store the counts, using defaultdict for simplicity\n    counts = defaultdict(int)\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable for dictionary keys\n        sublist_tuple = tuple(sublist)\n        # Increment the count for this tuple in the dictionary\n        counts[sublist_tuple] += 1\n    \n    # Convert the defaultdict back to a regular dict for the return type consistency\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from typing import List, Dict, Tuple\ndef unique_sublists(nested_list: List[List]) -> Dict[Tuple, int]:\n    \"\"\"\n    Counts occurrences of unique sublists in a given list of lists.\n    \n    Args:\n    nested_list (List[List]): A list containing lists as elements.\n    \n    Returns:\n    Dict[Tuple, int]: A dictionary with tuples (representing unique sublists) as keys and their occurrence counts as values.\n    \"\"\"\n    # Initialize an empty dictionary to store the count of each unique sublist\n    sublist_counts = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in nested_list:\n        # Convert the sublist to a tuple to make it hashable (since lists are not hashable and cannot be dictionary keys)\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count; otherwise, add it with a count of 1\n        sublist_counts[sublist_tuple] = sublist_counts.get(sublist_tuple, 0) + 1\n    \n    return sublist_counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lists):\n    \"\"\"\n    Counts occurrences of unique sublists within a list.\n    \n    Args:\n        lists (list): A list containing sublists.\n    \n    Returns:\n        dict: A dictionary where keys are tuples (converted from unique sublists) \n              and values are their respective occurrence counts.\n    \"\"\"\n    # Initialize an empty dictionary to store sublist counts\n    sublist_counts = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple (since lists are not hashable for dict keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already a key in the dictionary, increment its count\n        if tuple_sublist in sublist_counts:\n            sublist_counts[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            sublist_counts[tuple_sublist] = 1\n    \n    return sublist_counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts unique sublists in a given list, converting them to tuples for hashing,\n    and returns their frequencies in a dictionary.\n\n    :param lst: A list containing sublist(s) to be counted.\n    :return: A dictionary with tuples (converted from sublists) as keys and their occurrence counts as values.\n    \"\"\"\n    # Initialize an empty dictionary to store tuple frequencies\n    frequency_dict = {}\n    \n    # Iterate over each sublist in the given list\n    for sublist in lst:\n        # Convert the sublist to a tuple for dictionary key usage\n        tuple_sublist = tuple(sublist)\n        \n        # Check if the tuple is already in the dictionary\n        if tuple_sublist in frequency_dict:\n            # If present, increment its count\n            frequency_dict[tuple_sublist] += 1\n        else:\n            # If not present, add it with a count of 1\n            frequency_dict[tuple_sublist] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts occurrences of sublists within a list, returning a dictionary where each key is a unique sublist\n    (converted to a tuple for hashability) and its corresponding value is the count of its occurrences.\n\n    Args:\n        list_of_lists (list): A list containing lists as its elements.\n\n    Returns:\n        dict: A dictionary where keys are tuples (representing the original sublists) and values are their counts.\n    \"\"\"\n    # Initialize an empty dictionary to store the counts\n    sublist_counts = {}\n\n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple for use as a dictionary key\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple_sublist is already in the dictionary, increment its count\n        if tuple_sublist in sublist_counts:\n            sublist_counts[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            sublist_counts[tuple_sublist] = 1\n\n    # Return the dictionary containing the counts of each unique sublist\n    return sublist_counts", "matching_cluster_idx": 5}, {"solution": "from typing import List, Dict, Tuple\ndef unique_sublists(nested_list: List[List]) -> Dict[Tuple, int]:\n    \"\"\"\n    Counts unique sublists within a list, converting each to a tuple for hashing.\n    \n    Args:\n    - `nested_list`: The input list containing sublists to be counted.\n    \n    Returns:\n    - A dictionary where each key is a unique sublist (converted to a tuple) and its corresponding value is the count of occurrences.\n    \"\"\"\n    # Initialize an empty dictionary to store the count of each unique sublist (as tuples)\n    sublist_counts: Dict[Tuple, int] = {}\n    \n    # Iterate over each sublist in the input nested list\n    for sublist in nested_list:\n        # Convert the sublist to a tuple (to make it hashable for dictionary keys)\n        tuple_sublist: Tuple = tuple(sublist)\n        \n        # If the tuple_sublist is already in the dictionary, increment its count\n        if tuple_sublist in sublist_counts:\n            sublist_counts[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            sublist_counts[tuple_sublist] = 1\n    \n    # Return the dictionary containing counts of all unique sublists\n    return sublist_counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Count unique sublists within a list.\n\n    Args:\n        list_of_lists (list): A list containing lists as elements.\n\n    Returns:\n        dict: Dictionary with tuples (representing unique sublists) as keys and their occurrence counts as values.\n    \"\"\"\n    # Initialize an empty dictionary to store the count of each unique sublist\n    sublist_counts = {}\n\n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple (since lists are not hashable and hence cannot be dict keys)\n        sublist_tuple = tuple(sublist)\n        \n        # Check if the tuple is already in the dictionary\n        if sublist_tuple in sublist_counts:\n            # If it is, increment its count by 1\n            sublist_counts[sublist_tuple] += 1\n        else:\n            # If not, add it to the dictionary with a count of 1\n            sublist_counts[sublist_tuple] = 1\n\n    return sublist_counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(main_list):\n    \"\"\"\n    Counts unique sublists in a given list, converting them to tuples for dictionary keys.\n    \n    Args:\n        main_list (list): A list potentially containing sublists.\n    \n    Returns:\n        dict: A dictionary where keys are tuples (representing unique sublists) and values are their counts.\n    \"\"\"\n    # Initialize an empty dictionary to store the counts of unique sublists (as tuples)\n    sublist_counts = {}\n    \n    # Iterate over each sublist in the main list\n    for sublist in main_list:\n        # Convert the sublist to a tuple to make it hashable for dictionary key usage\n        sublist_tuple = tuple(sublist)\n        \n        # Check if the sublist (now a tuple) is already in the dictionary\n        if sublist_tuple in sublist_counts:\n            # If present, increment its count by 1\n            sublist_counts[sublist_tuple] += 1\n        else:\n            # If not present, add it to the dictionary with a count of 1\n            sublist_counts[sublist_tuple] = 1\n    \n    # Return the dictionary containing the counts of unique sublists\n    return sublist_counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Converts sublists to tuples and counts their occurrences.\n\n    Args:\n    - list_of_lists (list): A list containing sublists.\n\n    Returns:\n    - dict: A dictionary where keys are tuples (converted from unique sublists)\n            and values are their respective occurrence counts.\n    \"\"\"\n    # Initialize an empty dictionary to store tuple-count pairs\n    tuple_counts = {}\n\n    # Iterate over each sublist in the input list\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple (since lists are not hashable for dict keys)\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in tuple_counts:\n            tuple_counts[sublist_tuple] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            tuple_counts[sublist_tuple] = 1\n\n    return tuple_counts", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts occurrences of unique sublists within a list.\n    \n    Args:\n        lst (list): A list containing sublists.\n    \n    Returns:\n        dict: A dictionary where keys are tuples (converted from unique sublists) \n              and values are their occurrence counts in the original list.\n    \"\"\"\n    # Initialize a dictionary to store the counts, using defaultdict for convenience\n    count_dict = defaultdict(int)\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable and thus cannot be dict keys)\n        sublist_tuple = tuple(sublist)\n        \n        # Increment the count for this tuple in the dictionary\n        count_dict[sublist_tuple] += 1\n    \n    # Convert the defaultdict back to a regular dictionary for return\n    return dict(count_dict)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts occurrences of unique sublists within a list.\n    \n    Args:\n    - lst (list): A list potentially containing duplicate sublists.\n    \n    Returns:\n    - dict: A dictionary where keys are unique sublists (converted to tuples) and values are their respective counts.\n    \"\"\"\n    # Initialize an empty dictionary to store tuple-count pairs\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable and thus cannot be dict keys)\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    # Return the dictionary with the counts of unique sublists\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(sublist_list):\n    \"\"\"\n    Counts occurrences of sublists within a list.\n    \n    Args:\n        sublist_list (list): A list containing sublists.\n    \n    Returns:\n        dict: A dictionary where keys are tuples (representing the original sublists)\n              and values are their respective occurrence counts.\n    \"\"\"\n    # Initialize an empty dictionary to store the count of each unique sublist\n    sublist_counts = {}\n    \n    # Iterate over each sublist in the given list\n    for sublist in sublist_list:\n        # Convert the sublist to a tuple to make it hashable (for dictionary key usage)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already a key in the dictionary, increment its count\n        if tuple_sublist in sublist_counts:\n            sublist_counts[tuple_sublist] += 1\n        # Otherwise, add it as a new key with a count of 1\n        else:\n            sublist_counts[tuple_sublist] = 1\n    \n    # Return the dictionary with the counts of each unique sublist\n    return sublist_counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts occurrences of sublists in a list, returning a dictionary with tuples as keys.\n    \n    :param lst: The list containing sublists to count.\n    :return: A dictionary with tuples (converted from unique sublists) as keys and their occurrence counts as values.\n    \"\"\"\n    # Convert sublists to tuples for hashability and count their occurrences using dict\n    count_dict = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple\n        tuple_sublist = tuple(sublist)\n        # Increment count in dictionary, utilizing get() method for default value\n        count_dict[tuple_sublist] = count_dict.get(tuple_sublist, 0) + 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts unique sublists in a list and returns their occurrence counts as a dictionary.\n    \n    :param lst: A list containing lists as its elements.\n    :return: Dictionary with tuples (unique sublists) as keys and their counts as values.\n    \"\"\"\n    # Initialize an empty dictionary to store the counts of unique sublists\n    sublist_counts = {}\n    \n    # Iterate over each sublist in the given list\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable for dictionary keys\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple_sublist is already in the dictionary, increment its count\n        if tuple_sublist in sublist_counts:\n            sublist_counts[tuple_sublist] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            sublist_counts[tuple_sublist] = 1\n    \n    # Return the dictionary containing the counts of unique sublists\n    return sublist_counts", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 77.55474452554745, "dps_norm": 76.875, "pass@1": 42.0, "profiled": [{"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if all elements in the list are the same (i.e., only one distinct element exists).\n    \n    :param numbers: List of numbers\n    :return: Boolean indicating whether only one distinct element exists\n    \"\"\"\n    # If the list is empty, it technically has no distinct elements, but this might depend on the interpretation.\n    # For this solution, we'll consider an empty list as not meeting the \"only one distinct element\" criteria.\n    if not numbers:\n        return False\n    \n    # Use a set to find distinct elements. If the length of the set is 1, all elements in the list were the same.\n    # This approach assumes the list only contains hashable types (which numbers do).\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if all elements in a list are the same.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    # If the list is empty, consider it as having \"only one distinct element\" for this context\n    if len(numbers) == 0:\n        return True\n    \n    # Use set() to get distinct elements. A set with one element means all were the same.\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if all elements in the list are the same.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        return True  # Or you can raise an exception depending on your use case\n    \n    # Compare the set length (which removes duplicates) to the original list length\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if a list of numbers contains only one distinct element.\n    \n    Parameters:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # If the list is empty or contains only one element, it meets the condition by default\n    if len(numbers) <= 1:\n        return True\n    \n    # Use a set to find distinct elements; if the length of the set is 1, all elements in the list were the same\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if all elements in a given list are the same (i.e., there's only one distinct element).\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # If the list is empty, consider it as having one distinct element (None or Void, in a broad sense)\n    if len(numbers) == 0:\n        return True\n    \n    # Use set() to get distinct elements and compare the count to the original list's length\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if all elements in a list are the same (i.e., only one distinct element).\n\n    Args:\n        input_list (list): The input list to be checked.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if not input_list:\n        raise ValueError(\"Input list is empty\")\n\n    # Use set to find distinct elements; if only one is found, return True\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if a list of numbers contains only one distinct element.\n    \n    Args:\n    - numbers (list): A list of numbers (int or float).\n    \n    Returns:\n    - bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Check if all elements in the list are numbers\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise TypeError(\"All elements in the list must be numbers.\")\n    \n    # If the list is empty or contains one element, it has 'one distinct element' by default\n    if len(numbers) <= 1:\n        return True\n    \n    # Use set() to find distinct elements. If the length of the set is 1, all elements were identical.\n    return len(set(numbers)) == 1", "matching_cluster_idx": 1}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if all elements in a list are identical (i.e., only one distinct element).\n\n    Args:\n        input_list (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if not input_list:\n        return True  # An empty list can be considered to have \"one distinct element\" in this context, or adjust based on your specific needs\n    \n    # Compare all elements to the first element in the list\n    return all(element == input_list[0] for element in input_list)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if all elements in the input list are the same (i.e., only one distinct element).\n\n    Args:\n        input_list (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # If the list is empty or contains only one element, it has only one distinct element by default\n    if len(input_list) <= 1:\n        return True\n    \n    # Compare all elements to the first one; if any differs, return False\n    first_element = input_list[0]\n    for element in input_list[1:]:\n        if element != first_element:\n            return False\n    \n    # If the loop completes without finding a different element, all elements are the same\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if all elements in the list are the same (i.e., only one distinct element).\n\n    Args:\n    - numbers (list): A list of numbers.\n\n    Returns:\n    - bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n\n    # Check if all elements in the list are of numeric type\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"All elements in the list must be numbers.\")\n\n    # If the list is empty, consider it as having no distinct elements\n    if len(numbers) == 0:\n        return True\n\n    # Use set() to find unique elements and compare the length to the original list\n    return len(set(numbers)) == 1", "matching_cluster_idx": 1}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if all elements in the input list are identical.\n\n    Args:\n    - input_list (list): A list of numbers.\n\n    Returns:\n    - bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if not input_list:\n        return True  # or raise ValueError(\"Input list is empty\") based on your requirement\n    \n    # Compare the set length (which automatically removes duplicates) to 1\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if all elements in a list are the same (i.e., only one distinct element exists).\n\n    Args:\n        input_list (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # If the list is empty, consider it as having one distinct element (vacuously true) or\n    # alternatively, you could raise an exception for this edge case if it suits your requirements\n    if not input_list:\n        return True  # or raise ValueError(\"Input list is empty\")\n    \n    # Compare the set size (which automatically removes duplicates) with the original list size\n    # If they are equal and greater than 0, all elements were the same\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Returns True if all elements in the list are the same, False otherwise.\n\n    :param lst: A list of numbers\n    :return: bool\n    \"\"\"\n    # Check if the list is empty\n    if not lst:\n        return True  # or raise ValueError(\"List is empty\") depending on your preference\n    \n    # Compare the list to a list containing the first element repeated\n    # If all elements are the same, these two lists will be equal\n    return lst == [lst[0]] * len(lst)", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if all elements in the list are identical (i.e., only one distinct element).\n\n    Args:\n        input_list (list): The list of numbers to check.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Remove duplicates by converting the list to a set and check its length\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if all elements in a list are the same.\n    \n    Args:\n        numbers (list): A list of numbers.\n    \n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        return True  # or raise ValueError(\"List is empty\"), depending on your requirement\n    \n    # Compare all elements to the first one\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if all elements in a list are identical (i.e., only one distinct element).\n\n    Args:\n        input_list (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if not input_list:\n        raise ValueError(\"Input list is empty\")\n    \n    # Compare the set length (which automatically removes duplicates) to 1\n    # If they're equal, all elements in the list were the same\n    return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if all elements in a list are identical (i.e., only one distinct element exists).\n\n    Args:\n        input_list (list): A list of numbers to be checked.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if the list is empty\n    if not input_list:\n        raise ValueError(\"Input list is empty\")\n    \n    # Compare the list with a list containing the first element repeated \n    # for the length of the original list\n    return input_list == [input_list[0]] * len(input_list)", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Returns True if all elements in the list are the same, False otherwise.\n    \n    Parameters:\n    lst (list): A list of numbers\n    \n    Returns:\n    bool: Whether the list contains only one distinct element\n    \"\"\"\n    # Check if the list is empty\n    if len(lst) == 0:\n        raise ValueError(\"List cannot be empty\")\n    \n    # Compare the set length to 1. A set in Python is an unordered collection of unique elements.\n    # If all elements in the list are the same, the set will contain only one element.\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    \"\"\"\n    Checks if all elements in a list are identical (i.e., there's only one distinct element).\n\n    Args:\n        input_list (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # If the list is empty or contains only one element, it technically has only one distinct element\n    if len(input_list) <= 1:\n        return True\n    \n    # Compare each element with the first one. If all are the same, the list has only one distinct element.\n    # This approach assumes that comparing the elements (e.g., numbers) is a simple operation.\n    return all(element == input_list[0] for element in input_list)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks if all elements in a list are the same (i.e., only one distinct element exists).\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Remove duplicates by converting the list to a set and compare sizes\n    return len(lst) != 0 and len(set(lst)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 55.0, "profiled": [{"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in `s`.\n    \"\"\"\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string (str): The input string to count digits from.\n\n    Returns:\n        int: The total count of digits found in the input string.\n    \"\"\"\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string (str): The string to count digits from.\n\n    Returns:\n        int: The total number of digits found in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n    - input_string (str): The string to count digits from.\n\n    Returns:\n    - int: The total count of digits found in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Parameters:\n    s (str): The input string to count digits from.\n    \n    Returns:\n    int: The total number of digits found in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string (str): The input string to count digits from.\n\n    Returns:\n        int: The total count of digits found in the input string.\n    \"\"\"\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n    input_string (str): The string to count digits from.\n\n    Returns:\n    int: The total count of digits found in the string.\n    \"\"\"\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string (str): The input string to count digits from.\n\n    Returns:\n        int: The total number of digits found in the string.\n    \"\"\"\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string (str): The string to count digits in.\n\n    Returns:\n        int: The number of digits found in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in input_string)", "matching_cluster_idx": 2}, {"solution": "import unittest\ndef number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string (str): The string to count digits from.\n\n    Returns:\n        int: The total number of digits found in the string.\n    \"\"\"\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given input string.\n    \n    Args:\n        input_string (str): The string to count digits from.\n    \n    Returns:\n        int: The total count of digits found in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string (str): The string to count digits from.\n\n    Returns:\n        int: The total count of digits found in the string.\n    \"\"\"\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n        input_string (str): The input string to count digits from.\n    \n    Returns:\n        int: The total count of digits found in the string.\n    \"\"\"\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate over each character in the input string\n    for char in input_string:\n        # Check if the character is a digit\n        if char.isdigit():\n            # If it's a digit, increment the counter\n            digit_count += 1\n    \n    # Return the total count of digits found\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n    input_string (str): The input string to count digits from.\n\n    Returns:\n    int: The total count of digits found in the input string.\n    \"\"\"\n    return sum(char.isdigit() for char in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_string (str): The string to count digits from.\n\n    Returns:\n        int: The total count of digits found in the string.\n    \"\"\"\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the total number of digits within a given string.\n\n    Args:\n    - input_string (str): The string to search for digits.\n\n    Returns:\n    - int: The total count of digits found in the input string.\n    \"\"\"\n    return sum(char.isdigit() for char in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the total number of digits in a given input string.\n\n    Args:\n    - input_string (str): The input string to count digits from.\n\n    Returns:\n    - int: The total count of digits found in the input string.\n    \"\"\"\n    return sum(char.isdigit() for char in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the total number of digits within a given string.\n\n    Args:\n        input_string (str): The string to count digits in.\n\n    Returns:\n        int: The total count of digits found in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string: str) -> int:\n    \"\"\"\n    Counts the total number of digits in a given string.\n\n    Args:\n        input_string (str): The input string to search for digits.\n\n    Returns:\n        int: The total count of digits found in the input string.\n    \"\"\"\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_str):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        input_str (str): The input string to count digits from.\n\n    Returns:\n        int: The total count of digits in the input string.\n    \"\"\"\n    return sum(char.isdigit() for char in input_str)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 88.3644859813084, "dps_norm": 84.16666666666667, "pass@1": 76.0, "profiled": [{"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generate all pairs of consecutive items in a list.\n\n    Args:\n        input_list (list): The input list from which to generate pairs.\n\n    Returns:\n        list: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    if not isinstance(input_list, list) or len(input_list) < 1:\n        return []  # Return empty list for invalid or empty inputs\n    \n    # Use list comprehension to create pairs, iterating over the indices\n    # that would allow us to access each element and the next one in the list\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generate all pairs of consecutive items in a list.\n\n    Args:\n        input_list (list): The input list from which to generate consecutive pairs.\n\n    Returns:\n        list: A list of tuples, each containing a pair of consecutive items from the input list.\n    \"\"\"\n    # Check if the input list has at least one element to avoid index errors\n    if len(input_list) < 1:\n        return []\n\n    # Initialize an empty list to store the pairs\n    consecutive_pairs = []\n\n    # Iterate over the indices of the input list, excluding the last one\n    for i in range(len(input_list) - 1):\n        # For each index, pair the element at this index with the next one\n        pair = (input_list[i], input_list[i + 1])\n        # Append the pair to the list of consecutive pairs\n        consecutive_pairs.append(pair)\n\n    # Return the list of all consecutive pairs found in the input list\n    return consecutive_pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generate all pairs of consecutive items in a given list.\n\n    Args:\n        input_list (list): The input list from which to generate consecutive pairs.\n\n    Returns:\n        list[tuple]: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    # Check if the list is empty or contains only one element\n    if len(input_list) < 2:\n        return []\n\n    # Use list comprehension to generate pairs of consecutive items\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, each containing a pair of consecutive items from the input list.\n    \n    :param input_list: The input list from which to generate consecutive pairs.\n    :return: List of tuples, each tuple containing two consecutive items.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(input_list, list):\n        raise ValueError(\"Input must be a list\")\n    \n    # Initialize an empty list to store the pairs\n    consecutive_pairs = []\n    \n    # Iterate over the indices of the input list, excluding the last one\n    for i in range(len(input_list) - 1):\n        # For each index, create a tuple with the current element and the next one\n        pair = (input_list[i], input_list[i + 1])\n        # Append this pair to the list of consecutive pairs\n        consecutive_pairs.append(pair)\n    \n    # Return the list of consecutive pairs\n    return consecutive_pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \n    Args:\n        input_list (list): The input list from which to generate consecutive pairs.\n    \n    Returns:\n        list: A list of tuples, each tuple containing a pair of consecutive items.\n    \"\"\"\n    # Check if the input list has less than 2 elements, in which case there are no pairs\n    if len(input_list) < 2:\n        return []\n    \n    # Use list comprehension to generate pairs of consecutive elements\n    # The zip function is used with the input list and the list sliced from the second element to the end\n    # This effectively pairs each element with the one following it\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \n    :param input_list: The list from which to generate consecutive pairs.\n    :return: A list of tuples, each tuple being a pair of consecutive items.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(input_list, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    # Handle edge cases where the list has less than 2 elements\n    if len(input_list) < 2:\n        return []\n    \n    # Use list comprehension with zip to generate pairs of consecutive items\n    # zip(input_list, input_list[1:]) pairs the first element with the second, \n    # the second with the third, and so on, until the second last with the last.\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \n    :param input_list: The list from which to generate consecutive pairs.\n    :return: A list of tuples, each tuple containing a pair of consecutive items.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Handle the edge case where the list has less than two elements\n    if len(input_list) < 2:\n        return []\n    \n    # Use list comprehension with zip to generate pairs of consecutive items\n    # The zip function stops when the shortest input iterable is exhausted, \n    # which is why we don't have to worry about index out of range errors.\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \n    Args:\n        input_list (list): The input list from which to generate consecutive pairs.\n    \n    Returns:\n        list: A list of tuples, each tuple being a pair of consecutive items.\n    \"\"\"\n    # Initialize an empty list to store the pairs\n    consecutive_pairs = []\n    \n    # Iterate over the indices of the input list, excluding the last one\n    for i in range(len(input_list) - 1):\n        # For each index, create a tuple with the current element and the next one, and append it to the result list\n        consecutive_pairs.append((input_list[i], input_list[i + 1]))\n    \n    # Return the list of consecutive pairs\n    return consecutive_pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n\n    :param input_list: The list from which to generate consecutive pairs.\n    :return: List of tuples, each tuple being a pair of consecutive items.\n    \"\"\"\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generate a list of tuples, each containing a pair of consecutive items from the input list.\n\n    Args:\n        input_list (list): The list from which to extract consecutive pairs.\n\n    Returns:\n        list: A list of tuples, where each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generate all pairs of consecutive items in a given list.\n\n    Args:\n        input_list (list): The input list from which to generate consecutive pairs.\n\n    Returns:\n        list: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    # Check if the input list has less than 2 elements, in which case there can't be any pairs\n    if len(input_list) < 2:\n        return []\n    \n    # Use list comprehension to generate pairs of consecutive elements\n    # The range for the loop is up to the second last element to avoid index out of range error\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generate all pairs of consecutive items in a given list.\n\n    Args:\n        input_list (list): The input list from which to generate pairs.\n\n    Returns:\n        list[tuple]: A list of tuples, where each tuple contains a pair of consecutive items.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list\")\n\n    # Use list comprehension with enumerate to generate pairs\n    # For each index and value in the list, pair the value with the next one if it exists\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generates all pairs of consecutive items in a given list.\n\n    Args:\n        input_list (list): The input list from which to generate pairs.\n\n    Returns:\n        list: A list of tuples, where each tuple is a pair of consecutive items.\n    \"\"\"\n    if len(input_list) < 2:\n        return []  # Edge case: lists with less than 2 elements have no pairs\n    \n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, each containing a pair of consecutive items from the input list.\n    \n    :param input_list: The list from which to extract consecutive item pairs.\n    :return: List of tuples, each tuple containing two consecutive items from the input list.\n    \"\"\"\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generate all pairs of consecutive items from the input list.\n\n    Args:\n        input_list (list): The input list to generate consecutive pairs from.\n\n    Returns:\n        list: A list of tuples, where each tuple contains a pair of consecutive items.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(input_list, list):\n        raise ValueError(\"Input must be a list\")\n\n    # Handle edge cases\n    if len(input_list) < 2:\n        return []\n\n    # Use list comprehension with zip to create pairs of consecutive items\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the input list.\n\n    :param input_list: The input list from which to generate consecutive pairs.\n    :return: A list of tuples, each tuple containing a pair of consecutive items.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(input_list, list):\n        raise ValueError(\"Input must be a list\")\n    \n    # Handle edge cases where list has less than 2 elements\n    if len(input_list) < 2:\n        return []\n    \n    # Use list comprehension to generate pairs of consecutive items\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generate all pairs of consecutive items in a given list.\n\n    Args:\n        input_list (list): The list from which to generate consecutive pairs.\n\n    Returns:\n        list: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    if len(input_list) < 2:\n        return []  # Edge case: Lists with fewer than 2 elements have no pairs.\n    \n    # Use list comprehension with zip to pair each element with the next.\n    # The zip function stops once the shortest input iterable is exhausted,\n    # which is perfect here since we slice the input list to offset by one.\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \n    :param input_list: The list from which to extract consecutive pairs.\n    :return: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Returns a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n\n    :param input_list: The input list to generate pairs from.\n    :return: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Generates a list of tuples, where each tuple contains a pair of consecutive items from the input list.\n\n    :param input_list: The input list from which to generate consecutive pairs.\n    :return: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # If the list has less than 2 elements, there are no pairs\n    if len(input_list) < 2:\n        return []\n    \n    # Use list comprehension with zip to pair each element with the next one\n    # The '*' operator is used with zip to unpack the list into separate arguments\n    # Since we want pairs including the last element and the one before it, we use \n    # input_list and input_list shifted by one element ([1:] and[:-1] respectively)\n    return list(zip(input_list, input_list[1:]))", "matching_cluster_idx": 5}]}, "Mbpp/775": {"dps": 62.48, "dps_norm": 42.14285714285714, "pass@1": 83.0, "profiled": [{"solution": "def odd_position(input_list):\n    \"\"\"\n    Checks if every odd index in the list contains an odd number.\n    \n    Args:\n        input_list (list): A list of integers.\n    \n    Returns:\n        bool: True if every odd index has an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list using enumerate to access both index and value\n    for index, value in enumerate(input_list):\n        # Check if the index is odd (using modulus operator)\n        if index % 2 != 0:  # Index is odd\n            # Check if the value at the odd index is not odd\n            if value % 2 == 0:  # Value is even\n                # If an odd index with an even value is found, return False\n                return False\n    # If the loop completes without finding any odd index with an even value, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every odd index contains odd numbers in a given list.\n\n    Args:\n        lst (list): The input list to check.\n\n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(\n        # Check if the number at an odd index (1-indexed, so we use `i % 2 != 0`) is odd (using `x % 2 != 0`)\n        (i % 2 != 0 and x % 2 != 0) or (i % 2 == 0)  \n        # Iterate over both index `i` and value `x` in the list\n        for i, x in enumerate(lst)\n    )", "matching_cluster_idx": 1}, {"solution": "def odd_position(input_list):\n    \"\"\"\n    Checks if every odd index in a given list contains odd numbers.\n    \n    Args:\n        input_list (list): List of integers.\n    \n    Returns:\n        bool: True if all odd indices have odd numbers, False otherwise.\n    \"\"\"\n    # Use enumerate to get both index and value while iterating\n    # Check if the index is odd (index % 2 != 0) and if the value at that index is not odd (value % 2 == 0)\n    # If such a condition is met for any pair, immediately return False\n    for index, value in enumerate(input_list):\n        if index % 2 != 0 and value % 2 == 0:  # Adjusted condition to correctly reflect the problem statement\n            return False\n    # If the loop completes without finding any even numbers at odd indices, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Verifies if all elements at odd indexes in the input list are odd numbers.\n    \n    Args:\n        numbers (list): A list of integers.\n    \n    Returns:\n        bool: True if all odd indexes hold odd numbers, False otherwise.\n    \"\"\"\n    return all(\n        # Check if the number is odd for every odd index (0-indexed, so odd indexes are where index % 2 != 0)\n        num % 2 != 0 \n        for idx, num in enumerate(numbers) \n        if idx % 2 != 0  # Filter for odd indexes\n    )", "matching_cluster_idx": 2}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Checks if every odd index in the list contains an odd number.\n    \n    Args:\n        numbers (list): A list of integers.\n    \n    Returns:\n        bool: True if all odd indexes have odd numbers, False otherwise.\n    \"\"\"\n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(numbers):\n        # Check if the index is odd (using the modulus operator)\n        if index % 2 != 0:\n            # If the index is odd, check if the value is not odd\n            if value % 2 == 0:\n                # If the value is not odd (i.e., it's even), return False\n                return False\n    # If the loop completes without finding any even numbers at odd indexes, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every odd index in the list contains an odd number.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd (using the modulus operator)\n        if index % 2 != 0:\n            # If the index is odd, check if the value is even (i.e., not odd)\n            if value % 2 == 0:\n                # If an odd index with an even value is found, return False\n                return False\n    # If the loop completes without finding any odd index with an even value, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(input_list):\n    \"\"\"\n    Verify if all elements at odd indices in the input list are odd numbers.\n\n    Args:\n        input_list (list): A list of integers.\n\n    Returns:\n        bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    # Iterate over the list using enumerate to access both index and value\n    for index, value in enumerate(input_list):\n        # Check if the index is odd (using the modulus operator)\n        if index % 2 != 0:\n            # If the index is odd, check if the value is not odd\n            if value % 2 == 0:  # Even value found at an odd index\n                return False\n    # If the loop completes without finding any even values at odd indices, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(input_list):\n    \"\"\"\n    Checks if every odd index in a given list contains odd numbers.\n    \n    Args:\n        input_list (list): List of integers.\n    \n    Returns:\n        bool: True if all odd indexes have odd numbers, False otherwise.\n    \"\"\"\n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(input_list):\n        # Check if the index is odd (using the modulus operator %)\n        if index % 2 != 0:  # If index is odd\n            # Check if the value at this odd index is not odd\n            if value % 2 == 0:  # If value is even\n                # Since an odd index has an even value, return False\n                return False\n    # If the loop completes without finding any odd index with an even value, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every odd index in a list contains odd numbers.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list using enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd (using modulus to find remainder of division by 2)\n        if index % 2 != 0:  # If index is odd\n            # Check if the value at this odd index is not odd\n            if value % 2 == 0:  # If value is even\n                return False  # Immediately return False as condition not met\n    # If loop completes without returning False, all odd indexes had odd values\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(input_list):\n    \"\"\"\n    Verify if all elements at odd indexes in the input list are odd numbers.\n\n    Args:\n        input_list (list): The input list to check.\n\n    Returns:\n        bool: True if all elements at odd indexes are odd, False otherwise.\n    \"\"\"\n    return all(\n        elem % 2 != 0  # Check if the element is odd\n        for idx, elem in enumerate(input_list)  # Iterate over list with indexes\n        if idx % 2 != 0  # Filter to only consider odd indexes\n    )", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every odd index in a list contains an odd number.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(\n        # Check if the number at each odd index (1-indexed, so 0-indexed means we check for 'odd' indices with is_odd=i%2!=0)\n        num % 2 != 0 \n        # Iterate over the list with enumerate to get both index and value\n        for i, num in enumerate(lst) \n        # Filter for odd indices (in 0-indexed terms, these are the even 'i' values)\n        if i % 2 != 0\n    )", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every odd index in the list contains an odd number.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd (using the modulus operator)\n        if index % 2 != 0:\n            # If the index is odd, check if the value is even (since the problem's expectation is reversed in description)\n            if value % 2 == 0:\n                # If an odd index with an even value is found, return False\n                return False\n    # If the loop completes without finding any odd index with an even value, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Checks if every odd index in the list contains an odd number.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(numbers):\n        # Check if the index is odd (using the modulus operator)\n        if index % 2 != 0:\n            # If the index is odd, check if the value is even\n            if value % 2 == 0:\n                # If an odd index with an even value is found, return False\n                return False\n    # If the loop completes without finding any odd index with an even value, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every odd index in the list contains an odd number.\n    \n    Args:\n        lst (list): The input list to check.\n    \n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd (using the modulus operator)\n        if index % 2 != 0:  # Index is odd (1-based index for humans, 0-based for Python)\n            # Check if the value at the odd index is not odd\n            if value % 2 == 0:  # Value is even\n                return False  # Immediately return False if condition not met\n    # If the loop completes without returning False, all odd indexes had odd values\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(input_list):\n    \"\"\"\n    Checks if every odd index in a given list contains odd numbers.\n    \n    Args:\n        input_list (list): A list of integers.\n    \n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(input_list):\n        # Check if the index is odd (using the modulus operator)\n        if index % 2 != 0:\n            # If the index is odd, check if the value at this index is not odd\n            if value % 2 == 0:\n                # If the value is even at an odd index, immediately return False\n                return False\n    # If the loop completes without finding any even numbers at odd indexes, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every odd index in a list contains an odd number.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if every odd index has an odd number, False otherwise.\n    \"\"\"\n    return all(\n        # Check if the number at an odd index (1-indexed, so 0-indexed is 'index') is odd\n        num % 2 != 0 \n        # Iterate over both index and value, but only consider odd indices (0-indexed)\n        for index, num in enumerate(lst) if index % 2 != 0\n    )", "matching_cluster_idx": 2}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Validate if all elements at odd indices in the list are odd numbers.\n    \n    :param numbers: List of integers\n    :return: Boolean indicating whether all odd indices contain odd numbers\n    \"\"\"\n    # Iterate over the list with enumerate to access both index and value\n    for index, value in enumerate(numbers):\n        # Check if the index is odd (using the modulus operator %)\n        if index % 2 != 0:\n            # If the index is odd, check if the value is even (since the problem statement is likely reversed)\n            if value % 2 == 0:\n                # If an odd index with an even value is found, return False\n                return False\n    # If the loop completes without finding any odd index with an even value, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Returns True if all elements at odd indexes (0-indexed) in the list are odd numbers.\n    \n    :param numbers: List of integers\n    :return: Boolean indicating whether all odd indexes contain odd numbers\n    \"\"\"\n    return all(\n        num % 2 != 0  # Check if the number is odd\n        for idx, num in enumerate(numbers)  # Iterate with index and value\n        if idx % 2 != 0  # Filter for odd indexes (0-indexed, so we check for != 0)\n    )", "matching_cluster_idx": 2}, {"solution": "def odd_position(input_list):\n    \"\"\"\n    Verify if all elements at odd indices in the input list are odd numbers.\n\n    Args:\n    - input_list (list): A list of integers.\n\n    Returns:\n    - bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    return all(\n        # Check if the element at each odd index (1-indexed, so we use idx % 2 != 0 for 0-indexed lists)\n        elem % 2 != 0 \n        for idx, elem in enumerate(input_list) \n        # Filter for odd indices\n        if idx % 2 != 0\n    )", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every odd index (0-based indexing) in a list contains an odd number.\n    \n    Args:\n    - lst (list): The input list to check.\n    \n    Returns:\n    - bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(  # Use all() to check if all elements in the iterable are true\n        num % 2 != 0  # Check if a number is odd\n        for idx, num in enumerate(lst)  # Iterate over list with index and value\n        if idx % 2 != 0  # Filter for odd indices (0-based)\n    )", "matching_cluster_idx": 2}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/781": {"dps": 83.2283464566929, "dps_norm": 39.0, "pass@1": 71.0, "profiled": [{"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks if the count of divisors for a given number is even.\n\n    Args:\n    - n (int): The number to check for divisor count parity.\n\n    Returns:\n    - bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If i is a divisor, increment the divisor count\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the count of divisors for number `n` is even.\n    \n    Parameters:\n    n (int): The number to check divisors for.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Check for divisors from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment divisor count\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Return True if divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the count of divisors for a number `n` is even.\n\n    Args:\n    - `n` (int): The input number to check.\n\n    Returns:\n    - `bool`: `True` if the number of divisors is even, `False` otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If i is a divisor, increment the divisor count\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the divisors of a number `n` and return True if the count is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if `i` is a divisor of `n`\n        if n % i == 0:\n            # If `i` is a divisor, increment the divisor count\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks if the count of divisors of a given number `n` is even.\n\n    Args:\n    - n (int): The number to check divisors for.\n\n    Returns:\n    - bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if `i` is a divisor of `n`\n        if n % i == 0:\n            # If `i` is a divisor, increment the divisor count\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors for a given number `n` is even.\n\n    Args:\n        n (int): The input number to check.\n\n    Returns:\n        bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize a counter for divisors\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if `i` is a divisor of `n`\n        if n % i == 0:\n            # Increment the divisor count if `i` is a divisor\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks whether the count of divisors for a given number is even.\n\n    Args:\n    n (int): The input number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count\n    divisor_count = 0\n    \n    # Iterate through all numbers up to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Check if the divisor count is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Counts the divisors of `n` and checks if the count is even.\n    \n    :param n: The number to check for divisor count parity.\n    :return: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if `i` is a divisor of `n`\n        if n % i == 0:\n            # If `i` is a divisor, increment the divisor count\n            divisor_count += 1\n    \n    # Check if the divisor count is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks if the count of divisors for a given number `n` is even.\n\n    Args:\n    - n (int): The number to check for divisor count parity.\n\n    Returns:\n    - bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize a counter for divisors\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to find divisors\n    for i in range(1, n + 1):\n        # Check if `i` is a divisor of `n`\n        if n % i == 0:\n            # If `i` is a divisor, increment the divisor count\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks whether the count of divisors for a given number `n` is even.\n\n    Args:\n        n (int): The input number to check.\n\n    Returns:\n        bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor counter\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment divisor count\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Return True if divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks whether the count of divisors for a given number `n` is even.\n\n    Args:\n    n (int): The number to check for divisor count parity.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to find divisors\n    for i in range(1, n + 1):\n        # Check if `i` is a divisor of `n`\n        if n % i == 0:\n            # If `i` is a divisor, increment the divisor count\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks whether the count of divisors for a given number `n` is even.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to find divisors\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment divisor count\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Check if the divisor count is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Returns True if the count of divisors for number `n` is even, False otherwise.\n    \n    :param n: The input number to check.\n    :return: Boolean indicating whether the divisor count is even.\n    \"\"\"\n    # Initialize count of divisors\n    count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment the count\n        if n % i == 0:\n            count += 1\n    \n    # Return True if the count is even, False if odd\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks if the count of divisors for a given number `n` is even.\n\n    Args:\n        n (int): The input number to check.\n\n    Returns:\n        bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # Check if `i` is a divisor of `n`\n        if n % i == 0:\n            # If `i` is a divisor, increment the divisor count\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Counts the divisors of `n` and checks if the count is even.\n    \n    :param n: The number to check for divisor count parity.\n    :return: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment the divisor count\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks whether the count of divisors for a given number `n` is even.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor counter\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to find divisors\n    for i in range(1, n + 1):\n        # Check if `i` is a divisor of `n`\n        if n % i == 0:\n            # If `i` is a divisor, increment the counter\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n: int) -> bool:\n    \"\"\"\n    Checks if the count of divisors for a given number is even.\n\n    Args:\n        n (int): The input number to check.\n\n    Returns:\n        bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize a counter for divisors\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to find divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Increment the divisor count\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the count of divisors for a given number `n` is even.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to find divisors\n    for i in range(1, n + 1):\n        # Check if `i` is a divisor of `n`\n        if n % i == 0:\n            # If `i` is a divisor, increment the divisor count\n            divisor_count += 1\n    \n    # Check if the divisor count is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors for a given number `n` is even.\n\n    Args:\n    n (int): The number to check divisors for.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize divisor count to 0\n    divisor_count = 0\n    \n    # Check for divisors from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment divisor count\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Return True if divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks if the count of divisors for a given number `n` is even.\n\n    Args:\n    - n (int): The number to check divisors for.\n\n    Returns:\n    - bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize a counter for divisors\n    divisor_count = 0\n    \n    # Iterate from 1 to n (inclusive) to check for divisors\n    for i in range(1, n + 1):\n        # If n is divisible by i, it's a divisor\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Return True if the divisor count is even, False otherwise\n    return divisor_count % 2 == 0", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 95.67164179104478, "dps_norm": 98.0, "pass@1": 64.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a given string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: The input string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function removes all whitespace characters from a given string.\n\n    Parameters:\n    input_string (str): The string from which to remove all whitespace.\n\n    Returns:\n    str: The input string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from a given string.\n\n    Args:\n    - input_string (str): The string to remove spaces from.\n\n    Returns:\n    - str: The input string without any whitespace characters.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from a given string.\n\n    Args:\n        input_string (str): The string from which whitespaces are to be removed.\n\n    Returns:\n        str: The input string without any whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a given string.\n\n    Args:\n        input_string (str): The string from which to remove whitespace.\n\n    Returns:\n        str: The input string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a string.\n\n    Args:\n        input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a given string.\n\n    Args:\n        input_string (str): The input string to process.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from a given string.\n    \n    Args:\n        input_str (str): The input string to be processed.\n    \n    Returns:\n        str: Input string with all whitespace characters removed.\n    \"\"\"\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n    \n    Args:\n        input_string (str): The string from which to remove whitespaces.\n    \n    Returns:\n        str: The input string without any whitespace characters.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    :param input_string: The string from which to remove whitespaces.\n    :return: Input string without any whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The string from which to remove all spaces.\n\n    Returns:\n        str: The input string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The input string from which to remove whitespaces.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n    - input_string (str): The string from which to remove all whitespaces.\n\n    Returns:\n    - str: Input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The string from which to remove all whitespaces.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "import unittest\ndef remove_all_spaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from a given string.\n\n    Args:\n    - input_string (str): The string from which to remove all spaces.\n\n    Returns:\n    - str: The input string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a given string.\n\n    Args:\n        input_string (str): The input string from which to remove whitespaces.\n\n    Returns:\n        str: The input string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a given string.\n\n    Args:\n        input_string (str): The string from which to remove all whitespace characters.\n\n    Returns:\n        str: The input string with all whitespace characters removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from a given string.\n\n    Args:\n        input_string (str): The string to process.\n\n    Returns:\n        str: The input string without any whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_str):\n    \"\"\"\n    Removes all whitespace characters from a given string.\n    \n    Parameters:\n    input_str (str): The input string to remove whitespaces from.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string: str) -> str:\n    \"\"\"\n    This function removes all whitespace characters from the input string.\n\n    Args:\n        input_string (str): The input string from which whitespaces are to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 90.06872852233677, "dps_norm": 92.0, "pass@1": 63.0, "profiled": [{"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        lists (list): A list of lists containing numerical elements.\n\n    Returns:\n        list: The sublist with the highest sum of elements.\n    \"\"\"\n    # Check if input list is empty\n    if not lists:\n        return []\n\n    # Use the built-in max function with a custom key to find the list with the highest sum\n    # The key argument specifies that the max function should use the sum of each sublist for comparison\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    \"\"\"\n    Returns the list with the highest sum of elements from a given list of lists.\n\n    Args:\n        lists_of_lists (list): A list containing multiple lists of numbers.\n\n    Returns:\n        list: The list with the highest sum of elements. If multiple lists have the same highest sum, \n              returns the first one encountered.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not lists_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # Initialize the maximum sum and the corresponding list with the first sublist's values\n    max_sum = sum(lists_of_lists[0])\n    max_sum_list = lists_of_lists[0]\n\n    # Iterate through the list of lists starting from the second sublist (index 1)\n    for sublist in lists_of_lists[1:]:\n        current_sum = sum(sublist)\n        # If the sum of the current sublist is greater than the max_sum found so far, update max_sum and max_sum_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = sublist\n\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    \"\"\"\n    Identifies and returns the list with the highest sum of elements within a list of lists.\n\n    Args:\n        lists_of_lists (list): A list containing multiple lists of integers.\n\n    Returns:\n        list: The sublist with the highest sum of elements.\n    \"\"\"\n    # Check if input list is empty\n    if not lists_of_lists:\n        return []\n\n    # Use the built-in max function with a key to find the list with the highest sum\n    # The key argument specifies that the max function should use the sum of each sublist for comparison\n    return max(lists_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list within a list of lists whose elements sum to the highest value.\n\n    Args:\n        lists (list of lists): A list containing multiple lists of numbers.\n\n    Returns:\n        list: The sublist with the highest sum of elements. If multiple sublists have the same highest sum, \n              returns the first one encountered.\n    \"\"\"\n    # Check if input list is empty\n    if not lists:\n        return []\n\n    # Use the built-in max function with a custom key to find the list with the highest sum\n    # The key function sums all elements in each sublist\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Parameters:\n    lists (list of lists): A list containing multiple lists of numbers.\n    \n    Returns:\n    list: The list from the input with the highest sum of its elements.\n    \"\"\"\n    # Check if input list is empty\n    if not lists:\n        return []\n    \n    # Use the built-in max function with a key to find the list with the highest sum\n    # The key is a lambda function that calculates the sum of each sublist\n    return max(lists, key=lambda sublist: sum(sublist))", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a given list of lists.\n\n    Args:\n    - lists (list of lists): A list containing multiple lists of numbers.\n\n    Returns:\n    - list: The sublist with the highest sum of elements.\n    \"\"\"\n    # Use the built-in max function with a custom key to find the sublist with the highest sum\n    # The key argument specifies that the max function should use the sum of each sublist for comparison\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        lists_of_lists (list): A list containing multiple lists of integers.\n\n    Returns:\n        list: The sublist with the highest sum of elements. If multiple sublists have the same highest sum, \n              the first one encountered is returned.\n\n    Raises:\n        ValueError: If the input is not a list of lists or if the sublist is not composed of integers.\n    \"\"\"\n    # Input validation\n    if not isinstance(lists_of_lists, list) or not all(isinstance(sublist, list) for sublist in lists_of_lists):\n        raise ValueError(\"Input must be a list of lists.\")\n    if not all(isinstance(element, (int, float)) for sublist in lists_of_lists for element in sublist):\n        raise ValueError(\"Sublists must only contain integers or floats.\")\n\n    # Find the list with the maximum sum\n    return max(lists_of_lists, key=sum)", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n        lists (list): A list of lists containing numerical elements.\n    \n    Returns:\n        list: The sublist with the highest sum of elements.\n    \"\"\"\n    if not lists:  # Check if input list is empty\n        return []\n    \n    # Use the built-in max function with a key argument to find the list with the highest sum\n    # The key argument specifies that the max function should use the sum of each sublist for comparison\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list within a list of lists that has the highest sum of elements.\n\n    Args:\n        lists (list): A list of lists containing numeric elements.\n\n    Returns:\n        list: The sublist with the highest sum of elements. If multiple sublists have the same highest sum, returns the first one encountered.\n    \"\"\"\n    # Check if input list is empty\n    if not lists:\n        return []\n\n    # Use the built-in max function with a key to find the sublist with the highest sum\n    # The key argument specifies that the max function should use the sum of each sublist for comparison\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    \"\"\"\n    Returns the list with the highest sum of elements from a list of lists.\n\n    Args:\n        lists_of_lists (list): A list containing multiple lists of integers.\n\n    Returns:\n        list: The list with the highest sum of elements. If multiple lists share the same highest sum, \n              the first one encountered is returned.\n    \"\"\"\n    # Check if input list is empty\n    if not lists_of_lists:\n        return []\n\n    # Use the built-in max function with a custom key to find the list with the highest sum\n    # The key function calculates the sum of each sublist\n    return max(lists_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list with the highest sum of elements from a list of lists.\n\n    :param lists: A list containing multiple lists of integers.\n    :return: The list with the highest sum of its elements.\n    \"\"\"\n    # Use the built-in max function with a custom key to find the list with the highest sum\n    # The key argument of max() specifies that the sum of each sublist should be used for comparison\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    \"\"\"\n    Returns the list with the highest sum of elements from a given list of lists.\n\n    :param lists_of_lists: A list containing multiple lists of numbers.\n    :return: The list with the highest sum of its elements.\n    \"\"\"\n    # Check if input list is empty\n    if not lists_of_lists:\n        return []\n\n    # Use the built-in max function with a key to find the list with the highest sum\n    # The key argument specifies that the max function should use the sum of each sublist for comparison\n    return max(lists_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    \"\"\"\n    Identifies the sublist with the highest sum of elements within a list of lists.\n\n    Args:\n        lists_of_lists (list): A list containing multiple lists of numbers.\n\n    Returns:\n        list: The sublist with the highest sum of elements. If multiple sublists have the same highest sum,\n              the first one encountered is returned.\n    \"\"\"\n    if not lists_of_lists:  # Check for empty input\n        return []\n\n    # Use the built-in max function with a custom key to find the sublist with the highest sum\n    # The key function calculates the sum of each sublist\n    return max(lists_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    \"\"\"\n    Returns the list within a list of lists that has the highest sum of elements.\n    \n    Args:\n        lists_of_lists (list): A list containing multiple lists of integers.\n    \n    Returns:\n        list: The list with the highest sum of elements. If multiple lists have the same highest sum, \n              the first one encountered is returned.\n    \"\"\"\n    if not lists_of_lists:  # Check if input list is empty\n        return []\n    \n    # Use built-in max function with a custom key to find the list with the highest sum\n    return max(lists_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Parameters:\n    lists (list of lists): A list containing multiple lists of integers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements. If multiple sublists have the same highest sum, \n          it returns the first one encountered.\n    \"\"\"\n    if not lists:  # Check if the input list is empty\n        return []\n    \n    # Use the built-in max function with a key to find the sublist with the highest sum\n    # The key function calculates the sum of each sublist\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list within a list of lists whose elements sum to the highest value.\n\n    Args:\n        lists (list of lists): A list containing multiple lists of numbers.\n\n    Returns:\n        list: The sublist with the highest sum of elements. If multiple sublists have the same highest sum, \n              returns the first one encountered.\n\n    Raises:\n        ValueError: If input 'lists' is not a list or if it contains non-list elements or if any sublist contains non-numeric elements.\n    \"\"\"\n    # Input validation\n    if not isinstance(lists, list):\n        raise ValueError(\"Input must be a list of lists.\")\n    for i, sublist in enumerate(lists):\n        if not isinstance(sublist, list):\n            raise ValueError(f\"Element at index {i} is not a list.\")\n        if not all(isinstance(x, (int, float)) for x in sublist):\n            raise ValueError(f\"Sublist at index {i} contains non-numeric elements.\")\n\n    # Find the sublist with the highest sum\n    if not lists:  # Check for empty list\n        return []\n    \n    return max(lists, key=sum)", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists with the highest sum of elements.\n\n    Args:\n    - **lists** (list of lists): A list containing multiple lists of numbers.\n\n    Returns:\n    - The list with the highest sum. If input list is empty, returns None.\n    \"\"\"\n    if not lists:  # Check if the input list is empty\n        return None\n\n    # Use max function with a custom key to find the list with the highest sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    \"\"\"\n    Returns the list within a list of lists whose elements sum to the highest value.\n\n    Args:\n        lists_of_lists (list): A list containing multiple lists of numbers.\n\n    Returns:\n        list: The sublist with the highest sum of elements.\n    \"\"\"\n    # Check if input list is empty\n    if not lists_of_lists:\n        return []\n\n    # Use the built-in max function with a custom key to find the list with the highest sum\n    # The key function calculates the sum of each sublist\n    return max(lists_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    \"\"\"\n    Returns the list within a list of lists that has the highest sum of elements.\n\n    Args:\n        lists_of_lists (list): A list containing multiple lists of numbers.\n\n    Returns:\n        list: The sublist with the highest sum of elements. If multiple sublists have the same highest sum, \n              returns the first one encountered (based on input order).\n    \"\"\"\n    # Use the built-in max function with a key argument to find the sublist with the max sum\n    # The key argument specifies that the max function should use the sum of each sublist for comparison\n    return max(lists_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        lists (list): A list of lists containing numeric elements.\n\n    Returns:\n        list: The sublist with the highest sum of elements.\n    \"\"\"\n    # Check if input list is empty\n    if not lists:\n        return []\n\n    # Use built-in max function with a key to find the list with the maximum sum\n    # The key argument of max specifies a function of one argument that is used to extract a comparison key from each element in the list\n    # Here, the key is sum, meaning the sum of each sublist is used for comparison\n    return max(lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 93.0701754385965, "dps_norm": 98.33333333333333, "pass@1": 77.0, "profiled": [{"solution": "def check_K(given_tuple, k):\n    \"\"\"\n    Checks if the given tuple contains the value k.\n\n    Args:\n    - given_tuple (tuple): The input tuple to be checked.\n    - k: The value to be searched within the tuple.\n\n    Returns:\n    - bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in given_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a given tuple 'tup' contains the element 'k'.\n\n    Args:\n        tup (tuple): The input tuple to search in.\n        k: The element to search for in the tuple.\n\n    Returns:\n        bool: True if 'k' is found in 'tup', False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a given tuple contains the value k.\n\n    Args:\n    - `tup` (tuple): The input tuple to search in.\n    - `k`: The value to search for in the tuple.\n\n    Returns:\n    - `bool`: True if `k` is found in `tup`, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if the given tuple contains the element 'k'.\n\n    Args:\n        input_tuple (tuple): The input tuple to search in.\n        k (any): The element to search for.\n\n    Returns:\n        bool: True if 'k' is found, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if the given tuple contains the element 'k'.\n\n    Args:\n        input_tuple (tuple): The input tuple to be searched.\n        k (any): The element to be searched for in the tuple.\n\n    Returns:\n        bool: True if 'k' is found in the tuple, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_to_check, k):\n    \"\"\"\n    Checks if the given tuple contains the element k.\n    \n    Args:\n        tuple_to_check (tuple): The input tuple to search in.\n        k: The element to search for in the tuple.\n    \n    Returns:\n        bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_to_check", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if the given tuple contains the value k.\n\n    Args:\n        tup (tuple): The input tuple.\n        k (any): The value to search for.\n\n    Returns:\n        bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if the element `k` is present in the given tuple `tup`.\n\n    Args:\n    - `tup` (tuple): The input tuple to be searched.\n    - `k` (any): The element to be searched for in the tuple.\n\n    Returns:\n    - `bool`: True if `k` is found in `tup`, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_to_check, target_k):\n    \"\"\"\n    Checks if the given tuple contains the target value k.\n\n    Args:\n        - tuple_to_check (tuple): The input tuple to search in.\n        - target_k (any): The target value to search for.\n\n    Returns:\n        - bool: True if target_k is found in the tuple, False otherwise.\n    \"\"\"\n    return target_k in tuple_to_check", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_to_check, target_K):\n    \"\"\"\n    Checks if the given tuple contains the target value K.\n    \n    Args:\n    - tuple_to_check (tuple): The input tuple to search in.\n    - target_K (any): The target value to search for.\n    \n    Returns:\n    - bool: True if target_K is found in tuple_to_check, False otherwise.\n    \"\"\"\n    return target_K in tuple_to_check", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    \"\"\"\n    Checks if the given tuple contains the value k.\n    \n    Args:\n        tpl (tuple): The input tuple.\n        k: The value to search for.\n    \n    Returns:\n        bool: True if k is found, False otherwise.\n    \"\"\"\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a given tuple contains the value k.\n\n    Args:\n        - tup (tuple): The input tuple to be searched.\n        - k: The value to be searched within the tuple.\n\n    Returns:\n        - bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Checks if an element `k` exists within a given tuple.\n\n    Args:\n        tuple_input (tuple): The input tuple to be checked.\n        k: The element to be searched within the tuple.\n\n    Returns:\n        bool: True if `k` is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a given tuple contains the element 'k'.\n\n    Args:\n        tup (tuple): The input tuple to be searched.\n        k (any): The element to be searched for in the tuple.\n\n    Returns:\n        bool: True if 'k' is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if element `k` exists within the given `tup`.\n\n    Args:\n    - tup (tuple): The input tuple to search in.\n    - k (any): The element to search for.\n\n    Returns:\n    - bool: True if `k` is found in `tup`, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if the element `k` is present in the `input_tuple`.\n\n    Args:\n        input_tuple (tuple): The input tuple to search in.\n        k (any): The element to search for.\n\n    Returns:\n        bool: True if `k` is found in `input_tuple`, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_to_check, target_k):\n    \"\"\"\n    Checks if a given tuple contains the specified target value k.\n    \n    Args:\n    - tuple_to_check (tuple): The tuple to be searched.\n    - target_k: The value to be searched for within the tuple.\n    \n    Returns:\n    - bool: True if target_k is found in the tuple, False otherwise.\n    \"\"\"\n    return target_k in tuple_to_check", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if the given tuples contain the value 'k' or not.\n\n    Args:\n        input_tuple (tuple): The input tuple to search in.\n        k (any): The value to search for.\n\n    Returns:\n        bool: True if 'k' is found in the tuple, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    \"\"\"\n    Checks if the given tuple contains the value k.\n\n    Args:\n        tpl (tuple): The input tuple to search within.\n        k (any): The value to search for in the tuple.\n\n    Returns:\n        bool: True if k is found in tpl, False otherwise.\n    \"\"\"\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if a given tuple contains the value 'k'.\n\n    Args:\n        tup (tuple): The input tuple to search in.\n        k (any): The value to search for in the tuple.\n\n    Returns:\n        bool: True if 'k' is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}]}}}
